<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机系统</title>
    <link href="/2023/08/22/SoftwareDevelopment/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/08/22/SoftwareDevelopment/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>计算机系统学习 <span id="more"></span></p><ol type="1"><li>L1 Cache 和 L2 Cache 都是每个 CPU 核心独有的，而 L3 Cache 是多个 CPU核心共享的。</li><li>MESI协议用来保证多核之间的缓存一致性 <ahref="https://xiaolincoding.com/os/1_hardware/cpu_mesi.html">CPU缓存一致性</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java</title>
    <link href="/2023/07/25/SoftwareDevelopment/Java/"/>
    <url>/2023/07/25/SoftwareDevelopment/Java/</url>
    
    <content type="html"><![CDATA[<p>Java基础学习</p><span id="more"></span><h3 id="代码块">代码块</h3><ol type="1"><li>静态代码块:<ol type="1"><li><strong>格式</strong>：static { }</li><li><strong>特点</strong>：类加载时自动执行，由于类只会加载一次，所以静态代码块也只会执行一次。</li><li><strong>作用</strong>：完成类的初始化，例如：对类变量的初始化赋值。</li></ol></li><li>实例代码块<ol type="1"><li><strong>格式</strong>：{ }<br /></li><li><strong>特点</strong>：每次创建对象时，执行实例代码块，并在构造器前执行。</li><li><strong>作用：</strong>和构造器一样，都是用来完成对象的初始化的，例如：对实例变量进行初始化赋值。</li></ol></li></ol><h3 id="单例设计模式">单例设计模式</h3><ol type="1"><li>保证一个类只有一个对象，防止内存占用</li><li>定义方法：把类的构造器私有；定义一个类变量存储类的一个对象；提供一个类方法返回对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">//2. 类变量存储唯一类对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    <br>    <span class="hljs-comment">//1. 私有构造器使得在外部无法构造类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">//3. 定义一个类方法返回对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> A <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多态">多态</h3><ol type="1"><li><p>在函数传参时可以直接定义为父类并传入各个子类，但此时无法调用各个类特有的方法。</p><p>为了解决该问题，可以在传入后强转类型到子类类型再处理。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果p接收的是子类对象</span><br><span class="hljs-keyword">if</span>(父类变量 instance 子类)&#123;<br>    <span class="hljs-comment">//则可以将p转换为子类类型</span><br>    子类 变量名 = (子类)父类变量;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="final">final</h3><ol type="1"><li>用法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">- <span class="hljs-keyword">final</span>修饰类：该类称为最终类，特点是不能被继承<br>- <span class="hljs-keyword">final</span>修饰方法：该方法称之为最终方法，特点是不能被重写。<br>- <span class="hljs-keyword">final</span>修饰变量：该变量只能被赋值一次。<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>被 static final 修饰的成员变量，称之为常量。</li></ol><h3 id="object">Object</h3><ol type="1"><li><p>可以通过重写toString()和equals()来自定义打印的信息和比较的规则</p></li><li><p>如果想实现拷贝，需要实现Cloneble接口</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 在使用时以如下方式调用 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;wo666&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[]&#123;<span class="hljs-number">99.0</span>,<span class="hljs-number">99.5</span>&#125;);<br><span class="hljs-comment">//调用方法克隆得到一个新对象</span><br>   <span class="hljs-type">User</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> (User) u1.clone();<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="日期旧">日期（旧）</h3><ol type="1"><li><p>使用Date类获取当前时间 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>System.out.println(d);<br></code></pre></td></tr></table></figure></p></li><li><p>将日期格式化</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;</span>);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> sdf.format(d);<br><br><span class="hljs-type">Date</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> sdf.parse(rs)<br></code></pre></td></tr></table></figure></p></li><li><p>Calendar</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>now.get(Calendar.YEAR)<span class="hljs-comment">// 获取年份信息</span><br>now.getTime()<span class="hljs-comment">// 获取Date对象</span><br>now.set(Calendar.MONTH, <span class="hljs-number">9</span>);<span class="hljs-comment">// 修改日期</span><br><br><span class="hljs-comment">//为某个信息增加或者减少多少</span><br>now.add(Calendar.DAY_OF_YEAR, <span class="hljs-number">100</span>);<br>now.add(Calendar.DAY_OF_YEAR, -<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="日期jdk8">日期（JDK8）</h3><ol type="1"><li><p>LocalDate 年月日</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld</span> <span class="hljs-operator">=</span> LocalDate.now();<span class="hljs-comment">// 2023-07-25</span><br>ld.getMonth();<span class="hljs-comment">// JULY</span><br>ld.withMonth(<span class="hljs-number">12</span>);<span class="hljs-comment">// 修改月份</span><br>ld.plusYears(<span class="hljs-number">2</span>);<span class="hljs-comment">// 添加年份</span><br>ld.minusYears(<span class="hljs-number">2</span>);<span class="hljs-comment">// 减小年份</span><br><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld8</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2099</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>);<span class="hljs-comment">// 创建LocalDate</span><br><span class="hljs-comment">//判断2个日期对象，是否相等，在前还是在后： equals isBefore isAfter</span><br>System.out.println(ld8.equals(ld9));<span class="hljs-comment">// true</span><br>System.out.println(ld8.isAfter(ld)); <span class="hljs-comment">// true</span><br>System.out.println(ld8.isBefore(ld)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></p></li><li><p>LocalTime 时 分 秒 纳秒</p><p>内置函数同LocalDate</p></li><li><p>LocalDateTime 年 月 日 时 分 秒 纳秒</p></li><li><p>DateTimeFormatter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);<br><br>formatter.format(LocalDateTime.now());<span class="hljs-comment">// 转化</span><br>LocalDateTime.parse(dateStr, formatter);<span class="hljs-comment">// 解析</span><br></code></pre></td></tr></table></figure></li><li><p>Period &amp; Duration</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2029</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2029</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>);<br><br><span class="hljs-comment">// 1、创建Period对象，封装两个日期对象。</span><br><span class="hljs-type">Period</span> <span class="hljs-variable">period</span> <span class="hljs-operator">=</span> Period.between(start, end);<br><br><span class="hljs-comment">// 2、通过period对象获取两个日期对象相差的信息。</span><br>System.out.println(period.getYears());<br>System.out.println(period.getMonths());<br>System.out.println(period.getDays());<br><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2025</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2025</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>);<br><span class="hljs-comment">// 1、得到Duration对象</span><br><span class="hljs-type">Duration</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> Duration.between(start, end);<br><br><span class="hljs-comment">// 2、获取两个时间对象间隔的信息</span><br>System.out.println(duration.toDays());<span class="hljs-comment">// 间隔多少天</span><br>System.out.println(duration.toHours());<span class="hljs-comment">// 间隔多少小时</span><br>System.out.println(duration.toMinutes());<span class="hljs-comment">// 间隔多少分</span><br>System.out.println(duration.toSeconds());<span class="hljs-comment">// 间隔多少秒</span><br>System.out.println(duration.toMillis());<span class="hljs-comment">// 间隔多少毫秒</span><br>System.out.println(duration.toNanos());<span class="hljs-comment">// 间隔多少纳秒</span><br></code></pre></td></tr></table></figure></p></li></ol><h3 id="任意类数组排序">任意类数组排序</h3><ol type="1"><li><p>方法一</p><p>首先对于类，需要实现Compareable接口</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;<br></code></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student s)</span> &#123;<br>    <span class="hljs-keyword">return</span> s.getChinese() - <span class="hljs-built_in">this</span>.getChinese();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>随后在使用时如下所示</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(students)<br></code></pre></td></tr></table></figure></p></li><li><p>方法二</p><p>在调用时实现比较函数</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(students, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> Double.compare(o1.getHeight(), o2.getHeight()); <span class="hljs-comment">// 升序</span><br>        <span class="hljs-comment">// return Double.compare(o2.getHeight(), o1.getHeight()); // 降序</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></p><p>Lambda写法</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(students, (Student o1, Student o2) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> Double.compare(o1.getHeight(), o2.getHeight()); <span class="hljs-comment">// 升序</span><br>&#125;);<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="异常">异常</h3><ol type="1"><li><p>自定义异常</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeIllegalException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<span class="hljs-comment">// 继承Exception类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AgeIllegalException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AgeIllegalException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>抛出异常</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>    <span class="hljs-keyword">if</span>(age &gt; <span class="hljs-number">0</span> &amp;&amp; age &lt; <span class="hljs-number">150</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;年龄被成功保存： &quot;</span> + age);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 用一个异常对象封装这个问题</span><br>        <span class="hljs-comment">// throw 抛出去这个异常对象</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AgeIllegalRuntimeException</span>(<span class="hljs-string">&quot;/age is illegal, your age is &quot;</span> + age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>捕获异常</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    saveAge2(<span class="hljs-number">225</span>);<br>    System.out.println(<span class="hljs-string">&quot;saveAge2底层执行是成功的！&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (AgeIllegalException e) &#123;<br>    e.printStackTrace();<br>    System.out.println(<span class="hljs-string">&quot;saveAge2底层执行是出现bug的！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="properties属性文件">Properties属性文件</h3><ol type="1"><li><p>格式</p><ol type="1"><li>属性文件后缀以<code>.properties</code>结尾</li><li>属性文件里面的每一行都是一个键值对，键和值中间用=隔开。比如:<code>admin=123456</code></li><li><code>#</code>表示这样是注释信息，是用来解释这一行配置是什么意思。</li><li>每一行末尾不要习惯性加分号，以及空格等字符；不然会把分号，空格会当做值的一部分。</li><li>键不能重复，值可以重复</li></ol></li><li><p>读取/写入</p><ol type="1"><li><p>读取</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;path&quot;</span>));<br>properties.getProperty(<span class="hljs-string">&quot;a&quot;</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>写入</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.setProperty(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;minmin&quot;</span>);<br>properties.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;path&quot;</span>), <span class="hljs-string">&quot;i saved many users!&quot;</span>);<br></code></pre></td></tr></table></figure></p></li></ol></li></ol><h3 id="logback日志">Logback日志</h3><ol type="1"><li><p>导入库</p><ol type="1"><li><p>在资料中找到<code>slftj-api.jar、logback-core.jar、logback-classes.jar</code>这三个jar包，复制一下</p></li><li><p>在当前模块下面新建一个lib文件夹，把刚刚复制的三个jar包都粘贴到此处</p></li><li><p>右键lib文件夹，点击<code>Add as Library</code></p></li><li><p>从资料中找到<code>logback.xml</code>配置文件，将此文件复制粘贴到src目录下（必须是src目录）</p></li></ol></li><li><p>在代码中使用</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;LogTest&quot;</span>);<span class="hljs-comment">// 创建Logger对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            LOGGER.info(<span class="hljs-string">&quot;除法准备执行&quot;</span>);<br>            div(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>);<br>            LOGGER.info(<span class="hljs-string">&quot;除法正常执行&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            LOGGER.error(<span class="hljs-string">&quot;除法异常&quot;</span>);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        LOGGER.debug(<span class="hljs-string">&quot;参数a=&quot;</span>+a+<span class="hljs-string">&quot;;参数b=&quot;</span>+b+<span class="hljs-string">&quot;;&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a/b;<br>        System.out.println(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="多线程">多线程</h3><ol type="1"><li><p><strong>继承Thread类</strong></p><ol type="1"><li><p>创建线程类</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<span class="hljs-comment">// 继承Thread类</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 描述线程执行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>在程序中使用</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<span class="hljs-comment">// 实例化</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        t.start();<span class="hljs-comment">// 运行，调用run方法</span><br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol></li><li><p><strong>实现Runable接口</strong></p><ol type="1"><li><p>实现接口</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 描述线程执行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>使用</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>       <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol></li><li><p><strong>Runable接口其他实现</strong></p><ol type="1"><li><p>匿名内部类</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>               <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>                   System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>+i);<br>               &#125;<br>           &#125;<br>       &#125;;<br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>简化</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure></p></li><li><p>进一步简化</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>+i);<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure></p></li></ol></li><li><p><strong>实现Callable接口</strong></p><p><strong>好处</strong>：可以返回线程执行结果</p><ol type="1"><li><p>实现接口</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">this</span>.n;i++)&#123;<br>            sum += i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> String.valueOf(sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>使用</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;String&gt; call = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-number">100</span>);<span class="hljs-comment">// 创建Callable类</span><br>FutureTask&lt;String&gt; f1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);<span class="hljs-comment">// 创建FutureTask类</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(f1).start();<span class="hljs-comment">// 运行</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> f1.get();<span class="hljs-comment">// 获取执行结果</span><br><br>System.out.println(res);<br></code></pre></td></tr></table></figure></p></li></ol></li><li><p>常用API</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/1668051403591.png" style="zoom:50%;" /></p></li></ol><h3 id="同步问题">同步问题</h3><ol type="1"><li><p>同步代码块</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱&quot;</span> + money + <span class="hljs-string">&quot;成功！&quot;</span>);<br>        <span class="hljs-built_in">this</span>.money -= money;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱：余额不足~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><ol type="1"><li>建议把共享资源作为锁对象, 不要将随便无关的对象当做锁对象</li><li>对于实例方法，建议使用this作为锁对象</li><li>对于静态方法，建议把类的字节码(类名.class)当做锁对象</li></ol></li><li><p>同步方法</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<span class="hljs-comment">// 在声明时声明synchronized</span><br>    <span class="hljs-comment">// 先搞清楚是谁来取钱？</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>    <span class="hljs-comment">// 1、判断余额是否足够</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱&quot;</span> + money + <span class="hljs-string">&quot;成功！&quot;</span>);<br>        <span class="hljs-built_in">this</span>.money -= money;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱：余额不足~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>Lock自定义锁</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">// 创建锁</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-comment">// 先搞清楚是谁来取钱？</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        <span class="hljs-keyword">try</span> &#123;<br>            lk.lock(); <span class="hljs-comment">// 加锁</span><br>            <span class="hljs-comment">// 1、判断余额是否足够</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>                System.out.println(name + <span class="hljs-string">&quot;来取钱&quot;</span> + money + <span class="hljs-string">&quot;成功！&quot;</span>);<br>                <span class="hljs-built_in">this</span>.money -= money;<br>                System.out.println(name + <span class="hljs-string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                System.out.println(name + <span class="hljs-string">&quot;来取钱：余额不足~&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">// 在finally里解锁，防止出现异常无法解锁</span><br>            lk.unlock(); <span class="hljs-comment">// 解锁</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="线程池">线程池</h3><ul><li><p>临时线程什么时候创建？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">新任务提交时，发现核心线程都在忙、任务队列满了、并且还可以创建临时线程，此时会创建临时线程。<br></code></pre></td></tr></table></figure></li><li><p>什么时候开始拒绝新的任务？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">核心线程和临时线程都在忙、任务队列也满了、新任务过来时才会开始拒绝任务。<br></code></pre></td></tr></table></figure></li></ul><ol type="1"><li>创建线程池</li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230726180918.png" /></p><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">3</span>,<span class="hljs-comment">//核心线程数有3个</span><br>    <span class="hljs-number">5</span>,  <span class="hljs-comment">//最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2</span><br>    <span class="hljs-number">8</span>,<span class="hljs-comment">//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。</span><br>    TimeUnit.SECONDS,<span class="hljs-comment">//时间单位（秒）</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">4</span>), <span class="hljs-comment">//任务阻塞队列，没有来得及执行的任务在，任务队列中等待</span><br>    Executors.defaultThreadFactory(), <span class="hljs-comment">//用于创建线程的工厂对象</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="hljs-comment">//拒绝策略</span><br>);<br></code></pre></td></tr></table></figure></code></pre><ol start="2" type="1"><li>执行Runnable对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 任务是干啥的？</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ==&gt; 输出666~~&quot;</span>);<br>        <span class="hljs-comment">//为了模拟线程一直在执行，这里睡久一点</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(Integer.MAX_VALUE);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>pool.execute(target); <span class="hljs-comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span><br>pool.execute(target); <br>pool.execute(target); <br><br>pool.shutdown();<span class="hljs-comment">// 等待线程全部执行结束后关闭</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>执行Callable对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCallable</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br><br>    <span class="hljs-comment">// 2、重写call方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 描述线程的任务，返回线程执行返回后的结果。</span><br>        <span class="hljs-comment">// 需求：求1-n的和返回。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Thread.currentThread().getName() + <span class="hljs-string">&quot;求出了1-&quot;</span> + n + <span class="hljs-string">&quot;的和是：&quot;</span> + sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">3</span>,<br>            <span class="hljs-number">5</span>,<br>            <span class="hljs-number">8</span>,<br>            TimeUnit.SECONDS, <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">4</span>),<br>            Executors.defaultThreadFactory(),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br><br>        <span class="hljs-comment">// 2、使用线程处理Callable任务。</span><br>        Future&lt;String&gt; f1 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">100</span>));<br>        Future&lt;String&gt; f2 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">200</span>));<br>        Future&lt;String&gt; f3 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">300</span>));<br>        Future&lt;String&gt; f4 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">400</span>));<br><br>        <span class="hljs-comment">// 3、执行完Callable任务后，需要获取返回结果。</span><br>        System.out.println(f1.get());<br>        System.out.println(f2.get());<br>        System.out.println(f3.get());<br>        System.out.println(f4.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230726201654.png" /></p><h3 id="网络通信">网络通信</h3><ol type="1"><li><p>InetAddress</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InetAddress</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> InetAddress.getLocalHost();<br>System.out.println(ip.getHostAddress());<span class="hljs-comment">// 获取IP地址</span><br>System.out.println(ip.getHostName());<span class="hljs-comment">// 获取机器名4</span><br><br><span class="hljs-type">InetAddress</span> <span class="hljs-variable">ip2</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;www.baidu.com&quot;</span>);<span class="hljs-comment">// 根据url获取ip</span><br>System.out.println(ip2.isReachable(<span class="hljs-number">5000</span>));<span class="hljs-comment">// 判断是否可达</span><br></code></pre></td></tr></table></figure></p></li><li><p>UDP通信</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-string">&quot;test&quot;</span>.getBytes();<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf,buf.length, InetAddress.getLocalHost(),<span class="hljs-number">6666</span>);<br><br>        socket.send(packet);<br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">6666</span>);<br><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">24</span>];<br><br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf,buf.length);<br><br>        socket.receive(packet);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> packet.getLength();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span> , len);<br>        System.out.println(rs);<br>        socket.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>TCP多线程通信</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReaderThread</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(is);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> dis.readUTF();<br>                    System.out.println(msg);<br><br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;有人下线了：&quot;</span> + socket.getRemoteSocketAddress());<br>                    dis.close();<br>                    socket.close();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;-----服务端启动成功-------&quot;</span>);<br>        <span class="hljs-comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8888</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br><br>            System.out.println(<span class="hljs-string">&quot;有人上线了：&quot;</span> + socket.getRemoteSocketAddress());<br><br>            <span class="hljs-comment">// 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderThread</span>(socket).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="junit测试">junit测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringUtil</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNumber</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;名字长度：&quot;</span>+name.length());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringUtilTest</span>&#123;<br>    <span class="hljs-meta">@Test</span><span class="hljs-comment">// 必须加注解</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetMaxIndex</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> StringUtil.getMaxIndex(<span class="hljs-literal">null</span>);<br>       System.out.println(index1);<br>        <br>       <span class="hljs-type">int</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> StringUtil.getMaxIndex(<span class="hljs-string">&quot;admin&quot;</span>);<br>       System.out.println(index2);<br>        <br>        <span class="hljs-comment">//断言机制：预测index2的结果,用来判断逻辑是否有问题</span><br>        Assert.assertEquals(<span class="hljs-string">&quot;方法内部有Bug&quot;</span>,<span class="hljs-number">4</span>,index2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230727215753.png" /></p><p>假设我想在每个测试方法中使用Socket对象，并且用完之后，需要把Socket关闭，上述注解就会起作用</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SSM学习</title>
    <link href="/2023/07/23/SoftwareDevelopment/SSM%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/07/23/SoftwareDevelopment/SSM%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>黑马SSM学习 <span id="more"></span></p><h2 id="spring">Spring</h2><h3 id="iocinversion-of-control控制反转"><strong>IoC</strong>（Inversionof Control）控制反转：</h3><ol type="1"><li><p>使用对象时由主动new产生对象转化为由IoC提供对象,目的是进行解耦</p></li><li><p>IoC容器负责对象的创建、初始化等一系列工作，被创建的对象称为<strong>Bean</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;bookDao&quot;</span> class=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建Ioc对象</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><span class="hljs-comment">// 取出Bean</span><br><span class="hljs-type">BookDao</span> <span class="hljs-variable">bookDao</span> <span class="hljs-operator">=</span> (BookDao) ctx.getBean(<span class="hljs-string">&quot;bookDao&quot;</span>);<br><span class="hljs-comment">// 调用函数进行操作</span><br>bookDao.save();<br></code></pre></td></tr></table></figure><h3 id="didependency-injection依赖注入"><strong>DI</strong>(DependencyInjection)依赖注入</h3><ol type="1"><li>在容器中建立bean与bean之间的依赖关系的整个过程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在service层为IoC容器提供set方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBookDao</span><span class="hljs-params">(BookDao bookDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bookDao = bookDao;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;bookService&quot;</span> class=<span class="hljs-string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;<br>   &lt;!--配置server与dao的关系--&gt;<br>   &lt;!--property标签表示配置当前bean的属性<br>   name属性表示配置哪一个具体的属性<br>   ref属性表示参照哪一个bean--&gt;<br>   &lt;property name=<span class="hljs-string">&quot;bookDao&quot;</span> ref=<span class="hljs-string">&quot;bookDao&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>建立之后在Service中可以直接不使用new创建DAO对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> BookDao bookDao;<br></code></pre></td></tr></table></figure><h3 id="bean">Bean</h3><ol type="1"><li>默认单例，即多次创建指向的都是同一个对象，可以通过scope属性更改</li><li>可以使用无参构造方法创建，即对bean对应的class中写一个无参构造函数（或者别写有参构造函数，默认会有一个无参构造函数）</li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端学习</title>
    <link href="/2023/07/15/SoftwareDevelopment/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/07/15/SoftwareDevelopment/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>前端开发学习 <span id="more"></span></p><h2 id="tips">Tips</h2><ol type="1"><li>连续的按钮重叠时可以在中间添加&lt;br&gt;分开各个按钮</li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Django</title>
    <link href="/2023/07/13/SoftwareDevelopment/Django/"/>
    <url>/2023/07/13/SoftwareDevelopment/Django/</url>
    
    <content type="html"><![CDATA[<p>Django学习 <span id="more"></span></p><ol type="1"><li><p>Django项目创建</p><p><ahref="https://www.acwing.com/activity/content/code/content/1969996/">工程课Django-2.1. 上课笔记 - AcWing</a></p></li><li><p>Pycharm连接服务器项目</p><p><ahref="https://blog.csdn.net/strawberry47/article/details/110440842">(141条消息)用pycharm跑服务器代码如何建立映射、如何设置自动更新、如何安装包_pycharm建立映射_strawberry47的博客-CSDN博客</a></p></li><li><p>访问静态文件：配置settings后，通过ip:port/static/images/../xxx.png访问</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux服务器工具</title>
    <link href="/2023/07/13/SoftwareDevelopment/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E5%85%B7/"/>
    <url>/2023/07/13/SoftwareDevelopment/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>tmux、vim用法 <span id="more"></span></p><h2 id="tmux">tmux</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs stata">功能：<br>    (1) 分屏。<br>    (2) 允许断开Terminal连接后，继续运行进程。<br>结构：<br>    一个tmux可以包含多个session，一个session可以包含多个<span class="hljs-keyword">window</span>，一个<span class="hljs-keyword">window</span>可以包含多个pane。<br>    实例：<br>        tmux:<br>            session 0:<br>                <span class="hljs-keyword">window</span> 0:<br>                    pane 0<br>                    pane 1<br>                    pane 2<br>                    ...<br>                <span class="hljs-keyword">window</span> 1<br>                <span class="hljs-keyword">window</span> 2<br>                ...<br>            session 1<br>            session 2<br>            ...<br>操作：<br>    (1) tmux：新建一个session，其中包含一个<span class="hljs-keyword">window</span>，<span class="hljs-keyword">window</span>中包含一个pane，pane里打开了一个<span class="hljs-keyword">shell</span>对话框。<br>    (2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。<br>    (3) 按下Ctrl + a后手指松开，然后按<span class="hljs-string">&quot;（注意是双引号&quot;</span>）：将当前pane上下平分成两个pane。<br>    (4) Ctrl + <span class="hljs-keyword">d</span>：关闭当前pane；如果当前<span class="hljs-keyword">window</span>的所有pane均已关闭，则自动关闭<span class="hljs-keyword">window</span>；如果当前session的所有<span class="hljs-keyword">window</span>均已关闭，则自动关闭session。<br>    (5) 鼠标点击可以选pane。<br>    (6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。<br>    (7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。<br>    (8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。<br>    (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。<br>    (10) 按下ctrl + a后手指松开，然后按<span class="hljs-keyword">d</span>：挂起当前session。<br>    (11) tmux a：打开之前挂起的session。<br>    (12) 按下ctrl + a后手指松开，然后按s：选择其它session。<br>        方向键 —— 上：选择上一项 session/<span class="hljs-keyword">window</span>/pane<br>        方向键 —— 下：选择下一项 session/<span class="hljs-keyword">window</span>/pane<br>        方向键 —— 右：展开当前项 session/<span class="hljs-keyword">window</span><br>        方向键 —— 左：闭合当前项 session/<span class="hljs-keyword">window</span><br>    (13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的<span class="hljs-keyword">window</span>。<br>    (14) 按下Ctrl + a后手指松开，然后按w：选择其他<span class="hljs-keyword">window</span>，操作方法与(12)完全相同。<br>    (15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。<br>    (16) 鼠标滚轮：翻阅当前pane内的内容。<br>    (17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持<span class="hljs-keyword">Mac</span>，不过该操作并不是必须的，因此影响不大）<br>    (18) tmux中复制/粘贴文本的通用方式：<br>        (1) 按下Ctrl + a后松开手指，然后按[<br>        (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板<br>        (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处<br></code></pre></td></tr></table></figure><h2 id="vim">vim</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs bash">功能：<br> (1) 命令行模式下的文本编辑器。<br> (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。<br> (3) 使用方式：vim filename<br>     如果已有该文件，则打开它。<br>     如果没有该文件，则打开个一个新的文件，并命名为filename<br>模式：<br> (1) 一般命令模式<br>     默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。<br> (2) 编辑模式<br>     在一般命令模式里按下i，会进入编辑模式。<br>     按下ESC会退出编辑模式，返回到一般命令模式。<br> (3) 命令行模式<br>     在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。<br>     可以查找、替换、保存、退出、配置编辑器等。<br>操作：<br> (1) i：进入编辑模式<br> (2) ESC：进入一般命令模式<br> (3) h 或 左箭头键：光标向左移动一个字符<br> (4) j 或 向下箭头：光标向下移动一个字符<br> (5) k 或 向上箭头：光标向上移动一个字符<br> (6) l 或 向右箭头：光标向右移动一个字符<br> (7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符<br> (8) 0 或 功能键[Home]：光标移动到本行开头<br> (9) $ 或 功能键[End]：光标移动到本行末尾<br> (10) G：光标移动到最后一行<br> (11) :n 或 nG：n为数字，光标移动到第n行<br> (12) gg：光标移动到第一行，相当于1G<br> (13) n&lt;Enter&gt;：n为数字，光标向下移动n行<br> (14) /word：向光标之下寻找第一个值为word的字符串。<br> (15) ?word：向光标之上寻找第一个值为word的字符串。<br> (16) n：重复前一个查找操作<br> (17) N：反向重复前一个查找操作<br> (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2<br> (19) :1,<span class="hljs-variable">$s</span>/word1/word2/g：将全文的word1替换为word2<br> (20) :1,<span class="hljs-variable">$s</span>/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。<br> (21) v：选中文本<br> (22) d：删除选中的文本<br> (23) <span class="hljs-built_in">dd</span>: 删除当前行<br> (24) y：复制选中的文本<br> (25) yy: 复制当前行<br> (26) p: 将复制的数据在光标的下一行/下一个位置粘贴<br> (27) u：撤销<br> (28) Ctrl + r：取消撤销<br> (29) 大于号 &gt;：将选中的文本整体向右缩进一次<br> (30) 小于号 &lt;：将选中的文本整体向左缩进一次<br> (31) :w 保存<br> (32) :w! 强制保存<br> (33) :q 退出<br> (34) :q! 强制退出<br> (35) :wq 保存并退出<br> (36) :<span class="hljs-built_in">set</span> <span class="hljs-built_in">paste</span> 设置成粘贴模式，取消代码自动缩进<br> (37) :<span class="hljs-built_in">set</span> nopaste 取消粘贴模式，开启代码自动缩进<br> (38) :<span class="hljs-built_in">set</span> nu 显示行号<br> (39) :<span class="hljs-built_in">set</span> nonu 隐藏行号<br> (40) gg=G：将全文代码格式化<br> (41) :noh 关闭查找关键词高亮<br> (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令<br>异常处理：<br> 每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。<br> 如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：<br>     (1) 找到正在打开该文件的程序，并退出<br>     (2) 直接删掉该swp文件即可<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>夏令营面试</title>
    <link href="/2023/06/24/School/%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%9D%A2%E8%AF%95/"/>
    <url>/2023/06/24/School/%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>夏令营面试 <span id="more"></span></p><h2 id="高数">高数</h2><ol type="1"><li><p><strong>函数</strong></p><p>对于一个给定的数集D，对于每个值x属于D，按照一定的法则f，有一个确定的值y与之对应，则称y为x的函数</p></li><li><p><strong>极限</strong></p><p>若函数f(x)在点<spanclass="math inline">\(x_0\)</span>的去心邻域中有定义，若存在常数A，对于任意给定的<spanclass="math inline">\(\varepsilon &gt;0\)</span>,总存在正数<spanclass="math inline">\(\sigma\)</span>,使得当<spanclass="math inline">\(0&lt;|x-x_0|&lt;\sigma\)</span>时，对应的函数值</p><p>f(x)都满足不等式<spanclass="math inline">\(|f(x)-A|&lt;\varepsilon\)</span>，则A称为f(x)当x-&gt;x0的极限</p></li><li><p><strong>拐点</strong></p><p>连续曲线的凹弧与凸弧的分界点称为该曲线的拐点</p><p>二阶导为0三阶导不为0</p></li><li><p><strong>罗尔定理</strong></p><p>f(x)满足在[a,b]上连续，在(a,b)可导，f(a)=f(b),则存在一点c，使得f'(c)=0</p></li><li><p><strong>拉格朗日中值定理</strong></p><p>f(x)满足在[a,b]上连续，在(a,b)可导，则有<spanclass="math inline">\(f(b)-f(a)=f&#39;(c)(b-a)\)</span></p></li><li><p><strong>柯西中值定理</strong></p><p>f(x),g(x)满足在[a,b]连续，(a,b)可导，则存在一点c属于(a,b),有<spanclass="math inline">\(\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f&#39;(c)}{g&#39;(c)}\)</span></p></li><li><p><strong>二元函数极限</strong></p><p>f(x,y)在(x0,y0)的去心领域内有定义，且(x,y)以任意方式趋向于(x0,y0)时，f(x,y)均趋向于A</p></li><li><p><strong>一元函数可微条件</strong></p><p>可导必可微，可微必可导</p><p>可导条件：函数在该点的 去心邻域 内有定义；左右导数存在且相同</p></li><li><p><strong>二元函数可微条件</strong></p><p>全增量减去线性增量比上根号下derta x的平方加dertay的平方的极限值若趋于0则可微</p></li><li><p><strong>方向导数</strong></p><p>在函数定义域内的点，对某一方向求导得到的导数</p><p><span class="math inline">\(\frac{\partial f}{\partiall}=\mathrm{grad}f\cdot\frac{\overline{l}}{\left|\overline{l}\right|}\)</span></p></li><li><p><strong>梯度</strong></p><p><span class="math inline">\(\text{grad}f=(\frac{\partial f}{\partialx},\frac{\partial f}{\partial y})\)</span></p></li><li><p><strong>散度</strong></p><p><span class="math inline">\(\operatorname{div}F:=\nabla\cdotF={\frac{\partial F_{x}}{\partial x}}+{\frac{\partial F_{y}}{\partialy}}+{\frac{\partial F_{z}}{\partial z}}\)</span></p></li></ol><h2 id="线代">线代</h2><ol type="1"><li><p><strong>线性相关</strong></p><p>对m个n维向量<spanclass="math inline">\(\alpha_1、\alpha_2,...,\alpha_m\)</span>，若存在一组不全为0的数<spanclass="math inline">\(k_1,k_2,...,k_m\)</span>，使得<spanclass="math inline">\(k_1\alpha_1+k_2\alpha_2+...+k_m\alpha_m=0\)</span>则称该向量组线性相关</p></li><li><p><strong>矩阵的秩</strong></p><p>矩阵的最高阶非零子式的阶数</p><p>矩阵A中有一个r阶子式Dr!=0且所有r+1阶子式值全等于0</p></li><li><p><strong>向量组的秩</strong></p><p>向量组的极大线性无关组中所含向量的个数r称为向量组的秩</p></li><li><p><strong>特征向量</strong></p><p>设A是n阶矩阵，<spanclass="math inline">\(\lambda\)</span>是一个数，若存在n维非零列向量x使得<spanclass="math inline">\(Ax=\lambda x\)</span>,则称<spanclass="math inline">\(\lambda\)</span>是A的特征值，x是A的对应于特征值<spanclass="math inline">\(\lambda\)</span>的特征向量</p></li><li><p><strong>矩阵的相似</strong></p><p>AB是两个n阶方阵，若存在P，使得<spanclass="math inline">\(P^{-1}AP=B\)</span>,则称A相似于B</p><p>相似的矩阵是同一个线性变换在不同基/坐标系下的的不同描述</p><p><span class="math inline">\(Bx =P^{-1}APx\)</span>,即先对x使用P变换到新的坐标系，然后使用A进行线性变换，然后再使用<spanclass="math inline">\(P^{-1}\)</span>回到当前坐标系</p></li><li><p><strong>矩阵的相似对角化</strong></p><p>对于A若有<spanclass="math inline">\(P^{-1}AP=B\)</span>,其中B是对角矩阵，则称A可相似对角化</p><p>A可以相似对角化的充要条件为A有n个线性无关的特征向量</p><p><strong>只有实对称矩阵能正交相似对角化</strong></p></li><li><p>实对称矩阵<strong>A</strong>的不同<ahref="https://baike.baidu.com/item/特征值/11034909?fromModule=lemma_inlink">特征值</a>对应的<ahref="https://baike.baidu.com/item/特征向量/8663983?fromModule=lemma_inlink">特征向量</a>是正交的。</p></li><li><p><strong>特征值对应的特征向量就是理想中想取得正确的坐标轴，而特征值就等于数据在旋转之后的坐标上对应维度上的方差。</strong></p></li><li><p><strong>正定矩阵</strong></p><p>若对于任意的x，均有<spanclass="math inline">\(x^TAx&gt;0\)</span>,则称A为正定矩阵</p><p>特征值都大于0</p></li><li><p><strong>向量范数</strong></p><ol type="1"><li>1-范数 ：<spanclass="math inline">\(||x||_1=\sum_{i=1}^m|x_i|\)</span>，向量元素绝对值之和</li><li>2-范数：<span class="math inline">\(||x||_1=\sqrt{\sum_{i=1}^mx_i^2}\)</span>，向量元素平方和开方</li><li>p-范数：<spanclass="math inline">\(||x||_p=(\sum_{i=1}^m|x_i|^p)^{\frac{1}{p}}\)</span>，到0点的闵可夫斯基距离</li><li><span class="math inline">\(\infty\)</span>-范数： <spanclass="math inline">\(||x||_{\infty}=\max\limits_{i}|x_i|\)</span></li></ol></li><li><p><strong>矩阵范数</strong></p><ol type="1"><li>1-范数：<spanclass="math inline">\(||A||_1=\max\limits_{j}\sum_{i=1}^m|a_{i,j}|\)</span>，列和范数，所有矩阵列向量绝对值之和的最大值</li><li>2-范数：<spanclass="math inline">\(||A||_2=\sqrt{\lambda_1}\)</span>, <spanclass="math inline">\(\lambda_1\)</span>表示<spanclass="math inline">\(A^TA\)</span>的最大特征数，称为谱范数</li><li><span class="math inline">\(\infty\)</span>-范数：<spanclass="math inline">\(||A||_{\infty}=\max\limits_{j}\sum\limits_{j=1}^{m}|a_{i,j}|\)</span>,行和范数，即所有矩阵行向量绝对值之和的最大值</li><li>F-范数：<spanclass="math inline">\(||A||_F=(\sum_{i=1}^m\sum_{j=1}^na_{i,j}^2)^{\frac{1}{2}}\)</span>,矩阵元素绝对值平方和再开方</li></ol></li><li><p><strong>线性方程组解的情况</strong></p><ol type="1"><li>无解：系数矩阵秩&lt;增广矩阵的秩</li><li>唯一解：系数矩阵的秩=增广矩阵的秩=列数n</li><li>无穷解：系数矩阵的秩=增广矩阵的秩&lt;列数n</li></ol></li><li><p><strong>合同矩阵</strong></p><p>若存在可逆矩阵C，使得<spanclass="math inline">\(C^TAC=B\)</span>则称矩阵A与B合同</p></li><li><p><strong>正交矩阵</strong></p><p>满足<span class="math inline">\(A^T=A^{-1}\)</span>的矩阵</p><p>行向量均正交的矩阵</p></li></ol><h2 id="概率论">概率论</h2><ol type="1"><li><p><strong>古典概型</strong></p><p>样本空间只有有限个样本点且每个样本点发生的可能性都一样</p></li><li><p><strong>几何概型</strong></p><p>样本空间是可度量的有界区域，每个样本点发生的可能性都相同</p></li><li><p><strong>条件概率</strong></p><p>在已知A发生的条件下，事件B发生的概率为条件概率，有<spanclass="math inline">\(P(B|A)=\frac{P(AB)}{P(A)}\)</span></p></li><li><p><strong>全概率公式</strong></p><p>把<span class="math inline">\(B_i\)</span>看作是事件<spanclass="math inline">\(A\)</span>发生的一种“可能途径”，<spanclass="math inline">\(P ( A ∣ B 1 )\)</span> 则是通过这种途径得到<spanclass="math inline">\(A\)</span>的可能性，而途径的选择是随机的，因此可以把<spanclass="math inline">\(P(A)\)</span>看作不同途径概率的和。</p><p><span class="math inline">\(P(A) =\sum_{i=1}^nP(B_i)P(A/B_i)\)</span></p></li><li><p><strong>贝叶斯公式</strong></p><p><spanclass="math inline">\(P(A_j|B)=\frac{P(A_j)P(B|A_j)}{\sum_{i-1}^{n}P(A_i)P(B|A_i)}\)</span></p><p>以手写数字识别为例：识别目标<spanclass="math inline">\(P(A_j|B)\)</span>代表在给定的图片(B)的基础上，是0/1/.../9的的概率，取其中的最大值作为预测结果即可</p><p>先验概率<spanclass="math inline">\(P(A_j)\)</span>即为每个数字的样本数量占比；类条件概率<spanclass="math inline">\(P(B|A_j)\)</span>为对于数字为j的所有样本，第1,2,...,28*28个特征中颜色为白色的概率相乘的值。</p><p>分母是事件B发生的全概率</p></li><li><p>常见的随机变量分布类型</p><ol type="1"><li><p><strong>0-1分布</strong>：<spanclass="math inline">\(P\{x=1\}=p,P\{x=0\}=1-p\)</span></p></li><li><p><strong>伯努利分布</strong>：n次0-1分布</p></li><li><p><strong>二项分布</strong>：<spanclass="math inline">\(P\{X=k\}=C_n^kp^k(1-p)^{n-k}\)</span>，在只有两个结果的n次独立伯努利实验中，所期望的结果出现次数的概率</p></li><li><p><strong>泊松分布</strong>：<spanclass="math inline">\(P\{X=k\}=\frac{\lambda^k}{k!}e^{-\lambda}\)</span>,称X服从参数为<spanclass="math inline">\(\lambda\)</span>的泊松分布</p><p>为了预测在固定时间间隔内发生<strong>指定数量</strong>事件的概率,常用于对小概率事件进行建模</p><p>例子：1.已知某家小杂货店，平均每周售出2个水果罐头。请问该店水果罐头的最佳库存量是多少2. 一个月内某条路上出现车祸的概率</p><p><ahref="https://zhuanlan.zhihu.com/p/146951852">如何深刻理解二项式分布到泊松分布？- 知乎 (zhihu.com)</a></p><p>参数 λ是单位时间(或单位面积)内随机事件的<strong>平均发生次数</strong>，满足线性相加（2倍单位时间内…服从 2λ分布）。</p></li><li><p><strong>几何分布</strong>：<spanclass="math inline">\(P\{X=k\}=(1-p)^{k-1}p\)</span>,即前k-1次都失败，第k次成功了</p></li><li><p><strong>超几何分布</strong>：<spanclass="math inline">\(P(X=k)=\frac{C_m^k\timesC_{N-m}^{n-k}}{C_N^n}\)</span></p><p>假设有限总体包含N个样本，其中质量合格的为m个，则剩余的N-m个为不合格样本，如果从该有限总体中抽取出n个样本，其中有k个是质量合格的概率</p></li><li><p><strong>均匀分布</strong>：U(a,b)：在一个区间内为定值，除了这个区间都是0</p></li><li><p><strong>指数分布</strong>：<spanclass="math inline">\(E(\lambda)=\lambda e^{-\lambdax},x&gt;0\)</span></p></li><li><p><strong>正态分布</strong>：<spanclass="math inline">\(f(x)=\frac{1}{\sqrt{2\pi}\sigma}\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)\)</span></p></li></ol></li><li><p><strong>边缘分布</strong>：多维随机变量中只包含其中部分变量的概率分布。如对(X,Y)分布只研究X的分布。</p></li><li><p><strong>期望</strong></p><p>对于离散型随机变量，若级数<spanclass="math inline">\(\sum^{\infty}_{i=1}x_ip_i\)</span>绝对收敛，则期望即为该值</p><p>对于连续型随机变量，若对xf(x)dx在负无穷到正无穷的积分绝对收敛，则数学期望为该值</p><p>数学期望称为概率平均值，是描述随机变量平均取值状况特征的指标</p></li><li><p><strong>方差</strong></p><p><spanclass="math inline">\(DX=E[(X-EX)^2]=E(X^2)-(EX)^2\)</span></p></li><li><p><strong>切比雪夫不等式</strong></p><p><span class="math inline">\(P(|X-\mu|\geqk)\leq\frac{\sigma^2}{k^2}或P(|X-\mu|&lt;k)\geq1-\frac{\sigma^2}{k^2}\)</span></p><p>方差越小，X的值越接近均值，说明方差是<strong>刻画随机变量与其期望值偏离程度的指标</strong></p></li><li><p><strong>协方差</strong></p><p>随机变量XY的协方差<spanclass="math inline">\(Cov(X,Y)=E[(X-EX)(Y-EY)]=E(XY)-EXEY\)</span></p><p>用于衡量两个变量的相关性</p></li><li><p><strong>皮尔逊相关系数</strong></p><p><spanclass="math inline">\(\frac{Cov(X,Y)}{\sqrt{DX}\sqrt{DY}}\)</span>,若值为0则不相关</p></li><li><p><strong>大数定理</strong></p><ol type="1"><li><p>当样本量足够大时，能用频率近似代替概率；能用样本均值近似代替总体均值。</p></li><li><p><strong>伯努利大数定理</strong>：</p><p>从定义概率的角度，<strong>揭示了概率与频率的关系</strong>，当N很大的时候，事件A发生的概率等于A发生的频率。</p><p><spanclass="math inline">\(\lim\limits_{n\to\infty}P\left\{\left|\frac{f_A}{n}-p\right|&lt;\epsilon\right\}=1\)</span></p></li><li><p><strong>切比雪夫大数定理</strong></p><p><strong>揭示了样本均值和真实期望的关系</strong></p><p><spanclass="math inline">\(\lim\limits_{n\to+\infty}P\left\{\left|\frac{1}{n}\sum_{i=1}^{n}X_i-\frac{1}{n}\sum_{i=1}^{n}\mu_i\right|&lt;\xi\right\}=1\)</span></p></li><li><p>辛钦大数定律</p><p><strong>揭示了算术平均值和数学期望的关系</strong></p><p><spanclass="math inline">\(\lim\limits_{n\to\infty}P\left\{\left|\frac{1}{n}\sum_{i=1}^{n}X_i-\frac{1}{n}\sum_{i=1}^{n}E\left(X_{\mathbb{i}}\right)\right|\leq\varepsilon\right\}=1\)</span></p></li></ol></li><li><p><strong>中心极限定理</strong></p><p>对于一系列独立同分布的离散随机变量来说，当样本量足够大时，样本均值的分布呈现正态分布</p><p>要求一系列离散随机变量独立同分布且存在均值方差</p><p>样本数量无穷大的时候，<strong>样本均值的分布</strong>呈现<strong>正态分布</strong>，其对原总体的分布不做任何要求，意味着无论总体是什么分布，其抽样样本的均值的频数的分布都随着抽样数的增多而趋于正态分布。</p></li><li><p><strong>事件的独立性</strong></p><p>某一事件发生的概率完全不受到其他事件的影响。 用公式表示就是<spanclass="math inline">\(P(A,B)=P(A)*P(B)\)</span></p></li><li><p><strong>马尔科夫链</strong></p><p>马尔可夫链描述的是随机变量的一个状态序列，在这个状态序列里未来信息只与当前信息有关，而与过去的信息无关。它有两个很重要的假设：</p><ol type="1"><li>t+1时刻的状态的概率分布只与t时刻有关</li><li>t到t+1时刻状态转移与t值无关</li></ol></li></ol><p><a href="https://www.zhihu.com/question/36214010">(90 封私信 / 68条消息) 二项分布、泊松分布和正态分布的区别及联系? - 知乎(zhihu.com)</a></p><h2 id="离散数学">离散数学</h2><ol type="1"><li><p>幂集</p><p>集合的全体子集</p></li><li><p>笛卡尔乘积</p><p>用两个集合AB中的元素组成有序对，以A的元素作为第一个分量，B的元素作为第二个分量。这些有序对的集合称为A和B的笛卡尔乘积</p></li><li><p>单射：任给x1,x2属于X,若x1!=x2,则f(x1)!=f(x2)</p></li><li><p>满射：任给y属于Y，存在x属于X使得f(x)=y</p></li><li><p>双射：同时满足单射和满射</p></li><li><p>自反：对任意x，有R(x,x)</p></li><li><p>反自反：对任意x，没有R(x,x)</p></li><li><p>对称：有R(x,y)则有R(y,x)</p></li><li><p>反对称：有R(x,y)则没有R(y,x)</p></li><li><p>传递：有R(x,y)和R(y,z)则有R(x,z)</p></li><li><p>相容关系: R是自反、对称的</p></li><li><p>等价关系：R是自反、对称、传递的</p><ol type="1"><li><p>等价类：对于所有属于集合A的元素x,<spanclass="math inline">\([x]_R\)</span>为所有满足xRy的y元素集合</p></li><li><p><strong>商集</strong>：设 R 是集合 A 上的等价关系，由 R确定的<strong>所有等价类</strong>组成的集合，称为集合 A 上关于 R的商集，记为 <strong>A/R，是集合 A 的一个划分。</strong></p></li></ol></li><li><p>偏序关系：R是自反、反对称、传递的</p></li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230626185200.png" /></p><ol type="1"><li><p>最大元：在都可比的情况下最大的，有可能有好几个极大元没有最大元</p></li><li><p>最小元：在都可比的情况下最小的</p></li><li><p>极大元：在可比的那条链中最大的</p></li><li><p>极小元：在可比的那条链中最小的</p></li><li><p>上界：两个集合AB,B包含于A，对于任意的B中的x，有A中的y，x&lt;=y,则y为B的上界</p></li><li><p>下界：两个集合AB,B包含于A，对于任意的B中的x，有A中的y，y&lt;=x,则y为B的下界</p></li><li><p>上确界：上界中最小的</p></li><li><p>下确界：下届中最小的</p></li><li><p>逆序关系：R是反自反、反对称、传递的</p></li><li><p>哈密顿图：能走出一条通过<strong>每个节点</strong>仅一次的回路</p></li><li><p>欧拉图：能走出一条通过<strong>每条边</strong>仅一次的回路</p></li><li><p>任意命题公式都可由仅含有 <span class="math inline">\(\{\lnot,\lor\}\)</span>或<span class="math inline">\(\{\lnot, \land\}\)</span>的命题公式来等价表示,这两个集合就是完备集</p></li><li><p>自反闭包：R 的<strong>自反闭包</strong> r（R）是包含 R的最小的、自反的关系集合</p></li><li><p>代数系统</p><ol type="1"><li>&lt;S,*&gt;,代表非空集合和运算</li><li>幺元e:对任意x属于S，e*x=x则为左幺元，x*e=x则为右幺元</li><li>零元0：对任意x属于S，0*x = 0则为左零元</li><li>逆元<span class="math inline">\(x^{-1}\)</span>：对x属于S，<spanclass="math inline">\(x^{-1}*x=e\)</span>则为左逆元</li><li>广群：S非空，*运算封闭</li><li>半群：S非空，*运算封闭可结合</li><li>群：S非空，*封闭可结合存在幺元，每个元素均存在s逆元</li><li>有限群：S为有限集的群</li><li>阿贝尔群：S非空，*运算可以交换的群</li><li>循环群：阿贝尔群，其内任意元素均可由a的幂组成，a称为生成元</li></ol></li></ol><h2 id="数据结构">数据结构</h2><h3 id="参数传递的方式">参数传递的方式</h3><ol type="1"><li>值传递：生成一个临时变量作为形参传递给函数</li><li>指针传递：直接把地址传过去</li><li>引用传递：在栈中开辟一个空间，空间里面存的是地址，对引用的操作都是间接寻址的过程</li></ol><h3 id="p问题np问题np完全问题">P问题、NP问题、NP完全问题</h3><ol type="1"><li>P问题：存在多项式时间算法的问题</li><li>NP问题：能在多项式时间内验证得出一个正确解的问题，也就是不好求解，但是能验证一个答案是否正确</li><li>NP完全问题：所有的NP问题都可以规约到他，只要解决了这个问题，所有的NP问题都能得到解决，他本身也是个NP问题</li><li>NP难问题：所有的NP问题都能约化到它，但是它不一定是一个NP问题。</li></ol><h3 id="稳定性">稳定性</h3><p>如果两个具有相同键的对象以相同的顺序出现在排序输出中，则排序算法是<strong>稳定的</strong>。</p><p>稳定性的好处：<strong>排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。</strong>基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。</p><p>稳定的排序算法：<strong>冒泡排序、插入排序、归并排序和基数排序</strong></p><p>不是稳定的排序算法：<strong>选择排序、快速排序、希尔排序、堆排序</strong></p><h3 id="改进冒泡排序">改进冒泡排序</h3><p>设置一标志性变量pos，用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位，故在进行下一趟排序时只要扫描到pos位置即可。</p><h3 id="改进快排">改进快排</h3><p>只对长度大于 k kk的子序列递归调用快速排序，让原序列基本有序，然后再对整个基本有序序列用插入排序算法排序</p><h3 id="判断图中是否有环">判断图中是否有环</h3><ol type="1"><li>拓扑排序</li><li>深搜出现重复结点</li></ol><h3 id="g数据1g内存如何排序">10G数据，1G内存如何排序</h3><p><strong>分别排序</strong>：根据内存1G，数据10G，我们将10G数据切分成10份，通过内存调用磁盘的方式，每1G进行排序，排序结束后，我们会得到10个有序的数据数组。<strong>归并</strong>：多路归并过程可以使用最小堆。内存中开辟一个大小为10的最小堆，和一个缓冲区（小于1G，不要太小）。取10份排序好的数据的首位进入最小堆。则最小的数位于堆顶，移除堆顶元素并写入缓冲区，然后从移除元素的元素所属数组中的下一位进入最小堆，在次移除堆顶进入缓冲区...直到缓冲区满，缓冲区回写磁盘，清空缓冲区，再次将数据置入最小堆...直到10份数据全部写完，然后将最小堆的元素按顺序回写磁盘即可。</p><h3 id="堆栈区别">堆栈区别</h3><ol type="1"><li>栈：存放函数的参数值、局部变量，由编译器自动分配释放。</li><li>堆 ：是由 new 分配的内存块，由应用程序控制，需要程序员手动利用delete 释放，如果没有，程序结束后，操作系统自动回收。</li></ol><h3 id="数组名数组首地址">数组名、数组首地址</h3><ol type="1"><li>&amp;array是整个数组的首地址，array是数组首元素的首地址</li><li>&amp;array加一之后移动一整个数组，array加一后移动一个数组元素</li></ol><h3 id="内存的分配方式">内存的分配方式</h3><ol type="1"><li>从静态存储区域分配，如全局变量</li><li>在栈上创建，函数内局部变量的存储单元都在栈上创建</li><li>从堆上分配，动态内存分配</li></ol><h3id="函数名函数指针函数的入口地址">函数名，函数指针，函数的入口地址</h3><ol type="1"><li>函数名：一个指向其函数入口指针常量</li><li>函数指针：向函数的指针变量</li><li>函数入口地址：</li></ol><h2 id="计组">计组</h2><h3 id="为什么要设计多级缓存">为什么要设计多级缓存</h3><ol type="1"><li>L1 Cache用的晶体管比较多，同样的制程都给L1会导</li><li>Cache容量上升后期对命中率的提升并不明显，边际效用递减</li><li>L1如果太大，始终频率就做不了太大，影响处理器处理速度</li></ol><h3 id="单周期和多周期cpu的区别">单周期和多周期CPU的区别</h3><p>一个程序的不同指令所需要的执行时间是不同的，所以如果按照单周期处理的话，无论什么指令我都按照最长的那条指令去处理，对CPU资源是有浪费的</p><h3 id="自旋锁和互斥锁">自旋锁和互斥锁</h3><ol type="1"><li>互斥锁加锁失败后，线程释放CPU,给其他线程</li><li>自旋锁加锁失败后，线程会忙等待，知道拿到锁</li><li>看起来自旋锁效率低，但是互斥锁会在加锁失败后让线程进入睡眠状态，资源释放后会唤醒该进程，这就导致了两次的上下文切换，如果程序较短效率就会比较低</li></ol><h2 id="计网">计网</h2><p><ahref="https://blog.csdn.net/weixin_42369760/article/details/100008786">(135条消息)网络中主机通信过程_网络中的主机通信流程_Cold_Johnsnow的博客-CSDN博客</a></p><h3 id="数据链路层流量控制的方式">数据链路层流量控制的方式</h3><ol type="1"><li><p><strong>停止-等待</strong></p><p>发送方每发一帧，都要等待接收方回应，如果没收到就一直等待</p></li><li><p><strong>滑动窗口</strong></p><p>发送方维持一组连续的允许发送的帧的序号，称为发送窗口：同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。发送窗口用来对发送方进行流量控制，发送窗口的大小W代表在还未收到对方确认信息的情况下发送方最多还可以发送多少个数据帧。同理，在接收端设置接收窗口是为了控制可以接收哪些数据帧和不可以接收哪些帧。在接收方，只有收到的数据帧的序号落入接收窗口内时，才允许将该数据帧收下。若接收到的数据帧落在接收窗口之外，则一律将其丢弃。</p></li><li><p><strong>后退N帧</strong></p><p>发送方可以连续发送帧，当接收方检测出失序的信息帧或者发送方之前发送的某个帧超时后，发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧，接收方只允许按顺序接收帧</p></li><li><p><strong>选择重传.</strong></p><p>先收下发送序号不连续但是在接收窗口的那些数据帧，等待所缺序号的数据帧收到后再一并交给主机</p></li></ol><h3 id="交换机能替代路由器吗">交换机能替代路由器吗</h3><ol type="1"><li>同构网络可以</li></ol><h2 id="操作系统">操作系统</h2><h3 id="进程和线程">进程和线程</h3><ol type="1"><li>进程是资源分配的基本单位，线程是调度的基本单位</li><li>在操作系统的发展过程中，为了提高CPU利用率提出了多道程序的并发执行，并发执行就涉及到了程序之间的切换，当一个程序去做IO了，我得能找到一个对象让他来执行，为了表示这个对象就提出了进程。但是进程的在上下文切换时的代价较大，为了进一步提高并行性，提出线程的概念。一个进程可以创建多个线程，线程只保留一些必要的堆栈，共享进程的内存空间。</li></ol><h2 id="编译原理">编译原理</h2><h3 id="程序的编译执行过程">程序的编译执行过程</h3><ol type="1"><li>预处理：处理头文件、宏定义、条件编译指令</li><li>编译：词法分析、语法分析、语义分析、中间代码生成、目标代码生成、目标代码优化</li><li>汇编：将编译产生的源码转化为object file</li><li>链接：将一些object file链接成一个可执行文件</li></ol><h3 id="文法句型句子语言">文法、句型、句子、语言</h3><ol type="1"><li>文法：文法是一个四元组(<spanclass="math inline">\(V_N,V_T,P,S\)</span>)，分别代表非终结符集、终结符集、产生式集合、开始符号</li><li>句型：由开始符号推导出的符号串</li><li>句子：只由终结符组成的句型</li><li>语言：所有句子的集合</li><li>等价文法：文法的语言相同</li></ol><h3 id="文法的四种类型">文法的四种类型</h3><ol type="1"><li>0型文法：所有文法</li><li>1型文法(上下文有关文法)：对于所有a-&gt;b,均有|b|&gt;=|a|</li><li>2型文法(上下文无关文法)：|b|&gt;=|a|且a为非终结符</li><li>3型文法(正规文法)：对任意a-&gt;b,都有A-&gt;w或A-&gt;wB</li></ol><h3 id="ll1文法">LL(1)文法</h3><ol type="1"><li>对于A的所有产生式，FIRST子集不能有交集</li><li>如果A能推出空，则所有非空产生式的FIRST子集和FOLLOW(A)不能有交集</li><li>消除左递归、提取左因子</li></ol><h2 id="数据库">数据库</h2><h3 id="范式">范式</h3><ol type="1"><li><strong>第一范式</strong>：所有属性不可再分，强调表的原子性</li><li><strong>第二范式</strong>：若某关系R属于第一范式，且每一个非主属性完全函数依赖于任何一个候选码，则关系R属于第二范式。<ol type="1"><li><strong>候选码</strong>：能唯一标识元组的属性或属性组</li><li><strong>主属性</strong>：所有候选码的属性称为主属性</li><li><strong>函数依赖</strong>：设R(U)是属性集U上的关系模式，X、Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称Y函数依赖于X或X函数确定Y。</li><li><strong>完全函数依赖</strong>：如果Y函数依赖于X，且对于X的任何一个真子集X’，都有Y不函数依赖于X’，则称Y对X完全函数依赖。</li><li><strong>部分函数依赖</strong>：如果Y函数依赖于X，但Y不完全函数依赖于X，则称Y对X部分函数依赖。</li><li>第二范式理解：每个表必须有一个（有且仅有一个）数据项作为关键字或主键（primarykey），其他数据项与关键字或者主键一一对应，即其他数据项完全依赖于关键字或主键</li></ol></li><li><strong>第三范式</strong>：非主属性既不传递依赖于码，也不部分依赖于码。<ol type="1"><li><strong>传递函数依赖</strong>：在R(U)中，若X函数依赖于Y，Y不函数依赖于X，Y函数依赖于Z。则称Z对X传递函数依赖</li></ol></li><li><strong>BCNF范式</strong>：关系模式R&lt;U,F&gt;中，若每一个决定因素都包含码，则R&lt;U,F&gt;属于BCFN。<ol type="1"><li>理解：<ol type="1"><li>所有非主属性对每一个码都是完全函数依赖；</li><li>所有主属性对每一个不包含它的码也是完全函数依赖；</li><li>没有任何属性完全函数依赖于非码的任何一组属性。</li></ol></li></ol></li></ol><h3 id="事务的四大特性acid">事务的四大特性ACID</h3><ol type="1"><li>原子性：要么都做要么都不做</li><li>一致性：事务必须使数据库从一个一致性状态变换到另一个一致性状态</li><li>隔离性：事务之间不互相干扰，多个并发事务之间互相隔离</li><li>持久性：一个事务一旦被提交，对数据的改变就是永久的</li></ol><h3 id="机器学习">机器学习</h3><h3 id="pca">PCA</h3><p>PCA (Principal ComponentAnalysis)是最常用的<strong>线性降维</strong>方法，它的目标是通过某种线性投影，将高维的数据映射到低维的空间中表示，并期望在所投影的维度上数据的<strong>方差最大</strong>，以此使用较少的数据维度，同时保留住较多的原数据点的特性。</p><h3 id="k-means">K-means</h3><p>聚类算法，事先确定常数 k代表着聚类类别数。首先随机选取k个初始点为质心，并通过计算每一个样本与质心之间的相似度（可以采用欧式距离），将样本点归到最相似的类中，接着重新计算每个类的质心（该类中所有点的平均值），重复这样的过程直到质心不再改变，最终就确定了每个样本所属的类别以及每个类的质心。</p><h3 id="牛顿法和梯度下降法">牛顿法和梯度下降法</h3><p>从本质上去看，牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。更通俗地说，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大（二阶导数信息）。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。（牛顿法目光更加长远，所以少走弯路；相对而言，梯度下降法只考虑了局部的最优，没有全局思想。）</p><p>从几何上说，牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230628102018.png" style="zoom:50%;" /></p><h2 id="项目">项目</h2><h3 id="yolov4">Yolov4</h3><ol type="1"><li><p>输入端</p><ol type="1"><li><strong>Mosaic数据增强</strong>：随机使用<strong>4张图片</strong>，随机缩放，再随机分布进行拼接，大大丰富了检测数据集，特别是随机缩放增加了很多小目标，让网络的鲁棒性更好。</li></ol></li><li><p>BackBone</p><ol type="1"><li><strong>CSPDarknet53</strong>：CSPNet的作者认为推理计算过高的问题是由于网络优化中的<strong>梯度信息重复</strong>导致的。因此采用CSP模块先将基础层的特征映射划分为两部分，然后通过跨阶段层次结构将它们合并，在减少了计算量的同时可以保证准确率。</li><li><strong>Dropblock</strong>：Dropout的方式会随机的删减丢弃一些信息，但<strong>Dropblock的研究者</strong>认为，卷积层对于这种随机丢弃并不敏感，因为卷积层通常是三层连用：<strong>卷积+激活+池化层</strong>，池化层本身就是对相邻单元起作用。而且即使随机丢弃，卷积层仍然可以从相邻的激活单元学习到<strong>相同的信息</strong>。因此，在全连接层上效果很好的Dropout在卷积层上<strong>效果并不好</strong>。</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625131008.png" style="zoom: 67%;" /></p><ol start="3" type="1"><li>Neck<ol type="1"><li><strong>SPP</strong>：使用k={1<em>1,5</em>5,9<em>9,13</em>13}的最大池化的方式，再将不同尺度的特征图进行Concat操作。比单纯的使用<strong>k*k最大池化</strong>的方式，更有效的增加主干特征的接收范围，显著的分离了最重要的上下文特征。</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625131645.png" style="zoom: 50%;" /></p><p>​ 2.<strong>FPN+PAN</strong>:FPN层自顶向下传达<strong>强语义特征</strong>，而特征金字塔则自底向上传达<strong>强定位特征</strong>，两两联手，从不同的主干层对不同的检测层进行参数聚合</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625132401.png" /></p><ol start="4" type="1"><li><p>输出端</p><ol type="1"><li><p>IOU_loss：1-交集/并集。当预测框和目标框不相交时无法衡量；当相交但相交的位置不同时无法衡量</p></li><li><p>GIOU_Loss</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625134108.png" style="zoom:50%;" /></p></li><li><p>DIOU_Loss</p><p><img src="https://pic1.zhimg.com/80/v2-029f094658e87f441bf30c80cb8d07d0_1440w.webp" alt="img" style="zoom:50%;" /></p></li><li><p>CIOU_Loss</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625134312.png" style="zoom:50%;" /></p></li><li><p><strong>DIOU_nms</strong>：Nms主要用于预测框的筛选</p></li></ol></li></ol><h3 id="yolov5">Yolov5</h3><ol type="1"><li><p>输入端</p><ol type="1"><li>Mosaic数据增强</li><li>自适应锚框计算</li><li>letterbox统一尺寸</li></ol></li><li><p>Backbone</p><ol type="1"><li><p>Focus结构：将<spanclass="math inline">\(608*608*3\)</span>切片为<spanclass="math inline">\(304*304*12\)</span>,再经过32个卷积核的卷积操作得到<spanclass="math inline">\(304*304*32\)</span>的特征图</p></li><li><p>CSP结构</p><p><img src="https://pic4.zhimg.com/80/v2-1da2f1a93c888dfe7c9002de56cff02b_1440w.webp" alt="img" style="zoom:50%;" /></p></li></ol></li><li><p>Neck</p><ol type="1"><li>FPN_PAN</li></ol></li><li><p>输出端</p><ol type="1"><li>CIOU_Loss</li><li>加权nms</li></ol></li></ol><h2 id="英文面">英文面</h2><h3 id="分钟自我介绍">2分钟自我介绍</h3><p>Good afternoon professors. I am honored to be here for thisinterview. Now i will give a brief introduction about myself. My name isChenLibiao and I am studying Computer Science at Beijing University ofTechnology.</p><p>First of all, for my in-class studies, you can see that I achievedhigh grade points and high ranking. And outside of class, I am alsoresponsible for tutoring advanced mathematics at our school, so I have astrong ability to communicate with others.</p><p>In terms of competitions, I have received some awards in many fieldssuch as mathematics, algorithms and data analysis So I think I havecomprehensive knowledge.</p><p>In terms of scientific research, under the guidance of my tutor, Ihave completed a paper on deep neural network as the first author andyou can see that paper in the middle of my materials. In addition tothat, I also have several other research projects so I believe that Ican complete high-level research work under the guidance of teachers andresearch team.</p><p>Beihang university has been my dream school for a long time. If Ihave the honor of being selected as an excellent camper, I will surelychoose Beihang University in September. Ok that's all, thanks forlistening</p><h3 id="项目介绍">项目介绍</h3><p>This project is about using deep neural networks for the diagnosis ofASD. ASD is a complex neurodevelopmental disorder that severely impactssocial abilities. In this project, we employed sliding windows andpearson rank correlation coefficient to collect dynamic functionalconnectivity (dFC) data and applied Kendall's rank correlationcoefficient to extract features. We then introduced self-attentionmechanism in our DNN architecture to efficiently extract high-orderspatial features across consecutive windows. By stacking multi-headself-attention layers with feed-forward neural networks, our modeleffectively extracts rich information in multiple dimensions andintegrates them together. We conducted systematic experiments on thelarge-sacle ABIDE dataset to validate the performance of our model.Moreover, our study revealed that the middle frontal gyrus and middletemporal gyrus exhibit significant alterations in ASD patients,highlighting their diagnostic value and potential relevance as targetsfor intervention. Our model provides an effective approach to assist inthe diagnosis of ASD.</p>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/06/23/School/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/06/23/School/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>计算机网络复习</p><span id="more"></span><h2 id="计算机网络体系结构">计算机网络体系结构</h2><ol type="1"><li><p>局域网基本都使用广播式通信技术，广域网中的无线、卫星通信也采用广播式通信</p></li><li><p>是否采用分组存储转发与路由选择机制是点对点网络与广播式网络的重要区别</p></li><li><p>计算机网络的组成</p><ol type="1"><li>按组成部分：硬件+软件+协议</li><li>按功能：通信子网（交换机、路由器等）+资源子网（计算机设备、软件）</li><li>按工作方式：边缘部分（主机）+核心部分（路由器等）</li></ol></li><li><p>计算机网络的交换技术</p><ol type="1"><li><p>电路交换网络</p><p>建立专用的通路用于传送数据，包括建立连接、传输数据、断开链接三个阶段。连接建立后则该线路被独占</p><p>数据直接传送、时延小；线路利用率低、不能充分利用线路容量、不便于进行差错控制</p></li><li><p>报文交换网络</p><p>用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文。<strong>整个报文</strong>传送到相邻结点，全部存储后再转发给下一个节点，又称为存储-转发网络。报文交换对报文的大小没有限制。</p><p>可以较为充分地利用线路容量；增大了资源开销、时延</p></li><li><p>分组交换网络</p><p>也称为包交换网络。将数据分成较短的<strong>固定长度</strong>的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包)，以存储-转发方式传输。</p><p>除具备报文交换网络的优点外，分组交换网络还具有自身的优点：缓冲易于管理；包的平均时延更小，网络占用的平均缓冲区更少；更易于标准化；更适合应用。现在的主流网络基本上都可视为分组交换网络。</p></li></ol></li><li><p>协议是控制两个或多个对等实体进行通信的规则的集合，是水平的；服务是指下层为紧邻的上层提供的功能调用，是垂直的</p></li><li><p>服务的分类</p><ol type="1"><li><p>面向连接服务与无连接服务</p><p>面向连接服务：连接建立、数据传输、连接释放</p></li><li><p>可靠服务和不可靠服务</p><p>可靠服务指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地</p></li><li><p>有应答服务和无应答服务</p><p>有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统内部自动实现，而不由用户实现。所发送的应答既可以是肯定应答，也可以是否定应答，通常在接收到的数据有错误时发送否定应答。</p></li></ol></li><li><p>OSI（开放系统互连参考模型）</p><p>低三层为通信子网，高三层为资源子网</p><ol type="1"><li>物理层：传输单位为比特，在物理媒体上为数据端设备透明地传输原始比特流</li><li>数据链路层：传输单位是帧，任务是将网络层传来的IP数据报组装成帧。有成帧、差错控制、流量控制和传输管理的功能</li><li>网络层：传输单位是数据报，关心的是通信子网的运行控制。主要任务是把网络层的协议数据单元从源端传送到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互连等</li><li>传输层：传输单位是报文段（TCP）或用户数据报（UDP），负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为<strong>端到端连接</strong>提供流量控制、差错控制、服务质量、数据传输管理等服务。高层使用传输层的服务而忽略通信子网的存在</li><li>会话层：允许不同主机上的各个进程之间进行会话。利用传输层端到端的服务为表示层实体或用户进程建立连接并传输数据</li><li>表示层：处理在两个通信系统中交换信息的表示方式，可以进行数据压缩、加密解密等</li><li>应用层：用户与网络的界面</li></ol></li><li><p>OSI和TCP/IP</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010617.png" style="zoom:50%;" /></p></li></ol><h2 id="物理层">物理层</h2><ol type="1"><li><p>数据报与虚电路</p><p><strong>分组交换</strong>根据其通信子网向端点系统提供的服务，可以分为面向连接的虚电路方式和无连接的数据报方式，这两种方式都由<strong>网络层</strong>提供</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010638.png" /></p></li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010654.png" /></p><p>​虚电路试图结合数据报方式和电路交换方式，每次建立虚电路时就确定一条固定线路，以后数据传输都从这条线路走，但是并不独占线路。</p><ol start="2" type="1"><li>中继器：将信号整形并放大再转发出去，消除信号的失真和衰减，扩大网络传输的距离</li><li>集线器：多端口的中继器</li></ol><h2 id="数据链路层">数据链路层</h2><h3 id="功能">功能</h3><ol type="1"><li>为网络提供服务：无确认的无连接服务、有确认的无连接服务、有确认的面向连接服务</li><li>链路管理：连接的建立、维持和释放</li><li>帧定界：确定开始结束位格式；帧同步：接收方能够从比特流中识别出开始结束标志</li><li>流量控制：防止发送方发送能力大于接收方接受能力而导致淹没现象</li><li>差错控制：检错码（奇偶校验码、循环冗余码），纠错编码（海明码）</li></ol><h3 id="流量控制的方式">流量控制的方式</h3><ol type="1"><li><p><strong>停止-等待</strong></p><p>发送方每发一帧，都要等待接收方回应，如果没收到就一直等待</p></li><li><p><strong>滑动窗口</strong></p><p>发送方维持一组连续的允许发送的帧的序号，称为发送窗口：同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。发送窗口用来对发送方进行流量控制，发送窗口的大小W代表在还未收到对方确认信息的情况下发送方最多还可以发送多少个数据帧。同理，在接收端设置接收窗口是为了控制可以接收哪些数据帧和不可以接收哪些帧。在接收方，只有收到的数据帧的序号落入接收窗口内时，才允许将该数据帧收下。若接收到的数据帧落在接收窗口之外，则一律将其丢弃。</p></li><li><p><strong>后退N帧</strong></p><p>发送方可以连续发送帧，当接收方检测出失序的信息帧或者发送方之前发送的某个帧超时后，发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧，接收方只允许按顺序接收帧</p></li><li><p><strong>选择重传.</strong></p><p>先收下发送序号不连续但是在接收窗口的那些数据帧，等待所缺序号的数据帧收到后再一并交给主机</p></li></ol><h3 id="介质访问控制">介质访问控制</h3><ol type="1"><li><p>信道划分介质访问控制</p><ol type="1"><li>频分多路复用：共享时间</li><li>时分多路复用：共享空间</li><li>波分多路复用：光的频分多路复用</li><li>码分多路复用：采用不同编码区分各路原始信号</li></ol></li><li><p>随机访问介质访问控制</p><p>不采用<strong>集中控制</strong>的方式解决发送信息的次序问题</p><ol type="1"><li><p>纯ALOHA协议：不检测直接发，如果没收到确认帧随机等一段时间后再发</p></li><li><p>时隙ALOHA协议：将时间划分为一段段等长的时隙，只能在每个时隙开始时才能发送一个帧</p></li><li><p>CSMA（载波监听多路访问）</p><ol type="1"><li>1-坚持CSMA：发送数据前监听信道，若空闲则发送，若不空闲则一直等待</li><li>非坚持CSMA：若不空闲则等待一个随机时间后再发送</li><li>p-坚持CSMA：如果空闲，则以p概率发送，以1-p概率下一个时隙再发送，如果忙则一直监听</li></ol></li><li><p>CSMA/CD：载波监听+碰撞检测。先听后发，边听边发，冲突停发，随机重发。适用于有线连接的半双工通信</p><p>CSMA/CD算法的归纳如下：①准备发送：适配器从网络层获得一个分组，封装成帧，放入适配器的缓存。②检测信道：若检测到信道空闲，它就开始发送这个帧。若检测到信道忙，它就持续检测直至信道上没有信号能量，然后开始发送这个帧。③在发送过程中，适配器仍持续检测信道。这里只有两种可能：发送成功：在争用期内一直未检测到碰撞，这个帧肯定能发送成功。发送失败：在争用期内检测到碰撞，此时立即停止发送，适配器执行指数退避算法，等待一段随机时间后返回到步骤②。若重传16次仍不能成功，则停止重传并向上报错。</p></li><li><p>CSMA/CA：载波监听+碰撞避免，适用于无线局域网（接收信号强度弱、存在隐蔽站，不能进行碰撞检测）</p><p>CSMA/CA算法的归纳如下：</p><ol type="1"><li>若站点最初有数据要发送（而不是发送不成功再进行重传)，且检测到信道空闲，在等待时间DIFS后，就发送整个数据帧。</li><li>否则，站点执行CSMA/CA退避算法，选取一个随机回退值。一旦检测到信道忙，退避计时器就保持不变。只要信道空闲，退避计时器就进行倒计时。</li><li>当退避计时器减到0时（这时信道只可能是空闲的），站点就发送整个帧并等待确认。</li><li>发送站若收到确认，就知道已发送的帧被目的站正确接收。这时如果要发送第二帧，就要从步骤2开始，执行CSMA/CA退避算法，随机选定一段退避时间。若发送站在规定时间（由重传计时器控制）内没有收到确认帧ACK,就必须重传该帧，再次使用CSMA/CA协议争用该信道，直到收到确认，或经过若干次重传失败后放弃发送。</li></ol></li></ol></li><li><p>轮询访问</p><p>主机在逻辑上形成环，令牌在环上移动，拿到令牌才能发送</p></li></ol><h3 id="局域网">局域网</h3><ol type="1"><li><p>局域网现在由以太网垄断，以太网采用无连接的工作方式，不对发送的数据帧编号，也不要求接收方发送确认，提供的是不可靠服务，对于差错的纠正由高层完成。</p></li><li><p>以太网发送的数据都是用曼彻斯特编码的信号，每个码元的中间出现一次电压转换，接收端利用这种电压转换方便地把位同步信号提取出来</p></li><li><p>计算机与外界局域网的连接是通过主机箱内插入的一块网络接口板[又称网络适配器(Adapter)或网络接口卡(NetworkInterfaceCard,NIC)]实现的。<strong>网卡</strong>上装有处理器和存储器，是工作在<strong>数据链路层</strong>的网络组件。<strong>网卡和局域网</strong>的通信是通过电缆或双绞线以串行方式进行的，而<strong>网卡和计算机</strong>的通信则是通过计算机主板上的/O总线以并行方式进行的。因此，网卡的重要功能就是进行数据的串并转换。网卡不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码及数据缓存功能等。</p></li><li><p>每一个网卡都有一个唯一的介质访问控制（MAC）地址</p></li><li><p>MAC帧，802.3帧格式用长度域替代了类型域</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010713.png" /></p></li><li><p>无线局域网分为有固定基础设施无线局域网和无固定基础设施移动自组织网络</p></li><li><p>通用虚拟局域网，可以把一个较大的局域网分割为一些较小的与地理位置无关的逻辑上的VLAN</p></li><li><p>VLAN在以太网帧中插入一个四字节的标识符，用来指明发送该帧的计算机属于哪个虚拟局域网</p></li></ol><h3 id="广域网">广域网</h3><ol type="1"><li>广域网中的一个重要问题是<strong>路由选择</strong>和<strong>分组转发</strong>。路由选择协议负责搜索分组从某个结点到目的结点的最佳传输路由，以便构造路由表，然后从路由表再构造出转发分组的转发表。分组是通过转发表进行转发的。</li></ol><p>2.PPP协议：点对点协议是使用串行线路通信的面向字节的协议，应用在直接连接的两个节点的链路上(找不到就广播)</p><h3 id="数据链路层设备">数据链路层设备</h3><ol type="1"><li><strong>网桥</strong>：两个以上以太网通过网桥连接后可以成为一个覆盖范围更广的以太网，原来每个以太网称为一个网段</li><li><strong>局域网交换机</strong>：多端口的网桥，每个端口都直接与单台主机或另一个交换机连接，通常都工作在全双工模式。具有自学习能力，能够方便的扩展以太网。</li></ol><h2 id="网络层">网络层</h2><h3 id="功能-1">功能</h3><h3id="异构网络互连用路由器进行网络互联和路由选择来将多个网络连接在一起"><strong>异构网络互连</strong>：用路由器进行网络互联和路由选择来将多个网络连接在一起</h3><ol start="2" type="1"><li><p><strong>路由与转发</strong>：路由器的两个功能：路由选择（确定哪一条道路）、分组转发（当一个分组到达时所采取的动作）</p><p>路由选择按照复杂的分布式算法动态改变所选择的路由，生成路由表；转发表通过路由表生成。</p></li><li><p><strong>软件定义网络（SDN）</strong>：分为数据平面和控制平面。采用集中式的控制平面和分布式的数据平面。路由器不需要路由选择软件，路由器之间不再需要交换路由信息。</p></li><li><p><strong>拥塞控制</strong>：因出现过量的分组而引起网络性能下降的现象称为拥塞</p></li></ol><h3 id="路由算法">路由算法</h3><ol type="1"><li><p>静态路由算法：人工指定</p></li><li><p>距离-向量路由算法(RIP)：</p><p>所有结点都定期地将他们的整个路由选择表传送给所有与之直接相邻的结点。当出现新的路由或者距离某个已有路由距离有更近路径时更新自身路由表。</p><p>RIP使用跳数来衡量到达目的网络的距离</p></li><li><p>链路状态路由算法（OSPF）：</p><p>要求每个参与该算法的结点都具有完全的网络拓扑信息，他们执行以下两项任务:(1)主动测试所有邻接结点的状态.(2)定期将链路状态传播给所有其他结点</p><p>当别的结点的状态报文发送来时，如果对自身状态有更新，则使用Dijkstra算法更新到各个目标节点的最短路径</p></li><li><p>层次路由</p><p>将互联网划分为许多较小的自治系统。每个自治系统内部决定采用何种路由选择协议（内部网关协议），自治系统之间采用相同协议（外部网关协议）。</p></li></ol><h3 id="ipv4">IPv4</h3><ol type="1"><li><p>早期IP地址</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/image-20230624125348468.png" style="zoom:67%;" /></p></li><li><p>网络地址转换（NAT）</p><ol type="1"><li><p>将专用网络地址转化为公用地址，从而对外隐藏内部管理的IP地址。</p></li><li><p>每个NAT路由器至少有一个有效的外部全球IP地址，本地地址的主机和外界通信时，NAT路由器使用NAT转换表进行本地IP地址和全球IP地址的转换。</p></li></ol></li><li><p>子网划分</p><p>从主机号借用若干比特作为子网号，不改变网络号，属于单位内部的事情，对外仍表现为没有划分的网络</p></li><li><p>子网掩码</p><ol type="1"><li><p>使用子网掩码表达对原网络中主机号的借位</p></li><li><p>子网掩码是一个与IP地址相对应的、长32bt的二进制串，它由一串1和跟随的一串0组成。其中，1对应于P地址中的网络号及子网号，而0对应于主机号。计算机只需将IP地址和其对应的子网掩码逐位“与”，就可得出相应子网的网络地址。</p></li><li><p>一台主机在设置IP地址信息的同时，必须设置子网掩码</p></li><li><p>同属于一个子网的所有主机及路由器的相应端口必须设置相同的子网掩码</p></li><li><p>路由器的路由表中所包含的主要内容有目的网络地址、子网掩码、下一跳地址</p></li></ol></li><li><p>无分类编址CIDR</p><ol type="1"><li>在变长子网掩码的基础上提出一种消除传统ABC类网络划分，并可以在软件支持下实现超网构造的一种IP地址划分方法</li><li>IP::={<网络前缀>,<主机号>}，其中网络前缀的长度不定，使用IP/前缀比特数的方式得到网络前缀</li><li>使用网络前缀都相同的连续IP地址组成“CIDR地址块”，一个CIDR地址块可以表示很多地址，这种地址的聚合称为路由聚合，或称构成超网。路由聚合使得路由表中的一个项目可以表示多个原来传统分类地址的路由，有利于减少路由器之间的信息的交换，从而提高网络性能</li><li>路由表中的每个项目由网络前缀和下一跳地址组成，在查找路由表时应该从匹配结果中选择具有最长网络前缀的路由</li></ol></li><li><p>网络层转发分组的过程</p><ol type="1"><li>从收到的IP分组的首部提取目的主机的P地址D(即目的地址)。</li><li>若查找到特定主机路由（目的地址为D),就按照这条路由的下一跳转发分组；否则从转发表中的下一条（即按前缀长度的顺序）开始检查，执行步骤3)。</li><li>将这一行的子网掩码与目的地址D进行按位与运算。若运算结果与本行的前缀匹配，则查找结束，按照“下一跳”指出的进行处理（或者直接交付本网络上的目的主机，或通过指定接口发送到下一跳路由器)。否则，若转发表还有下一行，则对下一行进行检查，重新执行步骤3)。否则，执行步骤4)。</li><li>若转发表中有一个默认路由，则把分组传送给默认路由；否则，报告转发分组出错。</li></ol></li><li><p>地址解析协议（ARP）</p><ol type="1"><li><p>实现IP地址到MAC地址的映射</p></li><li><p>每台主机都设有一个ARP高速缓存用来存放本局域网上各主机和路由器的IP地址到MAC地址的映射表，称为ARP表</p></li><li><p>工作原理</p><p>主机A向B发送IP数据报时，先在ARP高速缓存中查找有无B的IP地址，如果有就可以查出其对应的硬件地址，再将此硬件地址写入MAC帧通过局域网发过去。如果没有就使用MAC地址为FFFF-FF-FF-FF-FF的帧来封装并广播ARP请求分组，B收到后通过单播向A发送响应分组，包含B的IP与MAC地址的对应关系。</p></li><li><p>当主机想要发数据给另一个网络的主机时，本地主机查找路由器硬件地址并发送数据，由路由器完成后续操作</p></li></ol></li><li><p>动态主机配置协议（DHCP）</p><ol type="1"><li><p>是应用层协议，基于UDP，用于给主机动态的分配IP地址</p></li><li><p>DHCP的工作原理</p><p>使用客户/服务器模式。需要IP地址的主机在启动时就向DHCP服务器广播发送发现报文，这时该主机就成为DHCP客户。本地网络上所有主机都能收到此广播报文，但只有DHCP服务器才回答此广播报文。DHCP服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的P地址池中取一个地址分配给该计算机。DHCP服务器的回答报文称为提供报文。</p></li></ol></li><li><p>网际控制报文协议</p><p>为了提高IP数据报交付成功的机会，在网络层使用了网际控制报文协议(InternetControl MessageProtocol,ICMP)来让主机或路由器报告差错和异常情况。</p></li></ol><h3 id="ipv6">IPv6</h3><ol type="1"><li>解决IP地址耗尽的措施<ol type="1"><li>采用无类别编址CIDR，使IP地址分配更加合理</li><li>采用网络地址转换NAT节省全球IPI地址</li><li>采用更大地址空间的IPv6</li></ol></li></ol><h3 id="路由协议">路由协议</h3><ol type="1"><li><p>内部网关协议</p><ol type="1"><li><p>路由信息协议（RIP）</p><ol type="1"><li>基于距离向量的路由选择协议</li><li>直连路由器跳数为1，随后每多一个加1跳，大于15跳认为不可达</li><li>每个路由器和直接相连的路由器交换自身路由表，一段时间后每个路由器都将知道全部的路由器信息，称为RIP收敛</li><li>是应用层协议，使用UDP传送数据</li></ol></li><li><p>开放最短路径优先协议（OSPF）</p><ol type="1"><li><p>分布式链路状态路由算法的代表</p></li><li><p>采用洪泛法向本自治系统中所有路由器发送信息，信息为自己和相邻路由器的度量</p></li><li><p>只有当链路状态改变时才发送信息</p></li><li><p>是网络层协议，直接用IP数据报传送</p></li><li><p>所有路由器最终都能建立一个链路状态数据库，采用Dijkstra算法计算从自己到各目的网络的最优路径以构造自己的路由表</p></li></ol></li></ol></li><li><p>外部网关协议</p><ol type="1"><li>边界网关协议（BGP）<ol type="1"><li>采用路径向量路由选择协议，是应用层协议，基于TCP</li><li>每个自治系统选择一个或多个BGP发言人，发言人要与其他BGP发言人建立TCP连接并交换路由信息</li><li>找的是较好的路径，并非最佳路径</li></ol></li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010842.png" style="zoom: 50%;" /></p><h3 id="ip组播">IP组播</h3><ol type="1"><li>缘由：有的应用程序要把一个分组发送给多个目的地主机，只发送一次但是可以发送到多个主机</li><li>每个组都有一个地址，要给该组发送的计算机将使用这个地址作为分组的目标地址</li><li>仅应用于UDP，地址采用D类地址</li><li>使用因特网组管理协议（IGMP）使路由器知道组播组成员的信息</li></ol><h3 id="移动ip">移动IP</h3><ol type="1"><li>移动站在归属网络时，按传统的TCP/IP方式进行通信。</li><li>移动站漫游到外地网络时，向外地代理进行登记，以获得一个临时的转交地址。外地代理要向移动站的归属代理登记移动站的转交地址。</li><li>归属代理知道移动站的转交地址后，会构建一条通向转交地址的隧道，将截获的发送给移动站的P分组进行再封装，并通过隧道发送给被访网络的外地代理。</li><li>外地代理把收到的封装的数据报进行拆封，恢复成原始的P分组，然后发送给移动站，这样移动站在被访网络就能收到这些发送给它的P分组。</li><li>移动站在被访网络对外发送数据报时，仍然使用自己的永久地址作为数据报的源地址，此时显然无须通过A的归属代理来转发，而是直接通过被访网络的外部代理。</li><li>移动站移动到另一外地网络时，在新外地代理登记后，然后新外地代理将移动站的新转交地址告诉其归属代理。无论如何移动，移动站收到的数据报都是由归属代理转发的。</li><li>移动站回到归属网络时，移动站向归属代理注销转交地址。</li></ol><h2 id="传输层">传输层</h2><h3 id="服务">服务</h3><ol type="1"><li><p>功能</p><ol type="1"><li><p>为运行在不同主机上的<strong>进程</strong>之间提供逻辑通信</p></li><li><p>复用和分用：复用指发送方不同的应用进程都可使用同一个传输层协议传送数据；分用指接收方的传输层在剥去报文首部后能够把这些数据正确交付到目的应用进程</p></li><li><p>对收到的报文进行差错检测（首部和数据部分），网络层只检查IP数据报的首部</p></li><li><p>提供两种不同的传输协议（TCP和UDP）</p></li></ol></li><li><p>套接字Socket：IP地址：端口号,唯一标识一台主机上的一个进程</p></li></ol><h3 id="udp">UDP</h3><ol type="1"><li><p>UDP在IP数据报服务的基础上提供复用和分用以及差错检测服务</p></li><li><p>优点</p><ol type="1"><li>无需建立连接，因此不会引入建立连接的时延</li><li>无连接状态。不需要维护连接状态，也不跟走这些参数，因此一般可以支持更多的活动客户机</li><li>分组首部开销小，只有8B</li><li>没有拥塞控制，应用层能更好的控制要发送的数据和发送时间</li><li>支持一对一、一对多、多对一的通信</li></ol></li><li><p>面向报文，对应用层交下来的报文在添加首部后就向下交付给IP层，保留报文边界。报文是UDP数据报处理的最小单位。</p></li></ol><h3 id="tcp">TCP</h3><ol type="1"><li><p>每条TCP连接只能有两个端点，每一条TCP连接只能是点到点的</p></li><li><p>TCP面向字节流，应用程序和TCP的交互是大小不一的数据块，但TCP把应用程序交下来的数据仅视为一连串的无结构字节流</p></li><li><p>TCP连接的两端为套接字或插口</p></li><li><p>三次握手</p><p>连接建立前，服务器进程处于LISTEN(收听)状态，等待客户的连接请求。</p><ol type="1"><li>客户机的TCP首先向服务器的TCP发送连接请求报文段。这个特殊报文段的首部中的<strong>同步位SYN置1</strong>，同时选择一个初始序号<strong>seq=x</strong>。TCP规定，SYN报文段不能携带数据，但要消耗掉一个序号。这时，TCP客户进程进入SYN-SENT(同步已发送)状态。</li><li>服务器的TCP收到连接请求报文段后，如同意建立连接，则向客户机发回确认，<strong>并为该TCP连接分配缓存和变量</strong>，在确认报文段中，把<strong>SYN位和ACK位都置1</strong>，确认号是ack=x+1,同时也为自己选择一个初始序号seq=y。注意，确认报文段不能携带数据，但也要消耗掉一个序号。这时，TCP服务器进程进入SYN-RCVD(同步收到).状态。</li><li>当客户机收到确认报文段后，还要向服务器给出确认，<strong>并为该TCP连接分配缓存和变量</strong>。确认报文段的ACK位置1，确认号ack=y+l,序号seq=x+1。该报文段<strong>可以携带数据</strong>，若不携带数据则不消耗序号。这时，TCP客户进程进入ESTABLISHED'(已建立连接)状态。</li></ol><p>成功进行以上三步后，就建立了TCP连接，接下来就可以传送应用层数据。TCP提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据。另外，值得注意的是，服务器端的资源是在完成第二次握手时分配的，.而客户端的资源是在完成第三次握手时分配的，这就使得服务器易于受到SYN洪泛攻击。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010903.png" style="zoom: 50%;" /></p><ol start="5" type="1"><li>四次挥手<ol type="1"><li>客户机打算关闭连接时，向其TCP发送连接释放报文段，并停止发送数据，主动关闭TCP连接，该报文段的终止位FN置1，序号sq=u,它等于前面已传送过的数据的最后一个字节的序号加1，FN报文段即使不携带数据，也消耗掉一个序号。这时，TCP客户进程进入FNWAIT-1(终止等待1)状态。TCP是全双工的，即可以想象为一条TCP连接上有两条数据通路，发送FN的-一端不能再发送数据，即关闭了其中一条数据通路，但对方还可以发送数据。</li><li>服务器收到连接释放报文段后即发出确认，确认号ack=u+1,序号seq=v,等于它前面已传送过的数据的最后一个字节的序号加1。然后服务器进入CLOSE-WAIT(关闭等待)状态。此时，<strong>从客户机到服务器这个方向的连接就释放了</strong>，·T℃P连接处于半关闭状态。但服务器若发送数据，客户机仍要接收，即从服务器到客户机这个方向的连接并未关闭。</li><li>若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时，其发出FN=1的连接释放报文段。设该报文段的序号为w(在半关闭状态服务器可能又发送了一些数据)，还须重复上次已发送的确认号ck=u+1。这时服务器进入LAST-ACK(最后确认)状态。</li><li>客户机收到连接释放报文段后，必须发出确认。把确认报文段中的确认位ACK置1,确认号ack=w+1,序号seq=u+1。此时TCP连接还未释放，必须经过时间等待计时器设置的时间2MSL（最长报文段寿命)后，客户机才进入CLOSED(连接关闭)状态。</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010954.png" style="zoom:50%;" /></p><ol start="6" type="1"><li><p>TCP的可靠传输</p><ol type="1"><li>校验</li><li>序号：用来保证数据能够有序提交给应用层</li><li>确认：TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号</li><li>重传<ol type="1"><li>超时重传：计时器设置的重传时间到期但还未收到确认就重传</li><li>冗余ACK：基于上述“确认”，多次收到ACK中同样的序号则认为丢失，进行重传</li></ol></li></ol></li><li><p>TCP流量控制</p><ol type="1"><li>接收方根据自己接收缓存的大小动态调整发送发发送窗口大小，称为接收窗口rwnd</li><li>发送方根据其对当前网络拥塞程度的估计而确定的窗口值称为拥塞窗口cwnd</li><li>A的发送窗口取rwnd和cwnd的最小值</li></ol></li><li><p>TCP拥塞控制</p><ol type="1"><li>流量控制是防止发送的过快导致接收方无法接收；拥塞控制是防止网络链路压力过大。二者都对发送方的发送速率进行控制</li><li>慢开始和拥塞避免<ol type="1"><li>慢开始：连接建立时cwnd为1，此后每收到一个确认cwnd加一直到到达阈值，随后采用拥塞避免算法</li><li>拥塞避免：每经过一个往返时延RTT就把cwnd加一</li><li>网络拥塞的处理：当判断网络出现拥塞（未按时收到确认），把慢开始阈值设置为此时cwnd的一半并置cwnd为1</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625011022.png" style="zoom:50%;" /></p></li><li><p>快重传和快恢复</p><pre><code class="hljs">1. 快重传：当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。    2. 快恢复：当发送方连续收到三个冗余ACK时，把阈值设置为此时cwnd的一半并置cwnd为当前的阈值</code></pre><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625011039.png" style="zoom: 50%;" /></p></li></ol><h2 id="应用层">应用层</h2><h3 id="网络应用模型">网络应用模型</h3><ol type="1"><li>C/S模型</li><li>P2P模型：每个结点都同时具有下载、上传的功能</li></ol><h3 id="域名系统dns">域名系统（DNS）</h3><ol type="1"><li>域名服务器：因特网的域名系统被设计成一个联机分布式的数据库系统，采用C/S模型。每个域名服务器保存一个区内所有主机的域名到IP地址的映射，同时具有连向其他域名服务器的信息。</li><li>域名服务器是分层结构，分为根域名服务器、顶级域名服务器、授权域名服务器、本地域名服务器</li><li>域名解析过程：<ol type="1"><li>递归查询：本地域名服务器向根域名服务器查询一次，后面几次查询都递归的在其他几个域名服务器之间进行。</li><li>迭代查询：<ol type="1"><li>主机向本地域名服务器采用递归查询</li><li>如果查不到，向根域名服务器发起请求，根域名服务器告诉本地域名服务器去哪个顶级域名服务器查询，迭代上述过程直到找到目标服务器</li></ol></li></ol></li></ol><h3 id="文件传输协议ftp">文件传输协议（FTP）</h3><ol type="1"><li>FTP使用两个并行的TCP连接，一个是控制连接（带外传送）一个是数据连接。</li><li>数据连接分为两种：主动模式PORT和被动模式PASV。PORT是服务器连接到客户端的某个端口，PASV是客户端连接到服务器的某个端口。</li></ol><h3 id="电子邮件">电子邮件</h3><ol type="1"><li>发信人调用用户代理来撰写和编辑要发送的邮件。用户代理用SMTP把邮件传送给发送端邮件服务器。</li><li>发送端邮件服务器将邮件放入邮件缓存队列中，等待发送。</li><li>运行在发送端邮件服务器的SMTP客户进程，发现邮件缓存中有待发送的邮件，就向运行在接收端邮件服务器的SMTP服务器进程发起建立TCP连接。</li><li>TCP连接建立后，SMTP客户进程开始向远程SMTP服务器进程发送邮件。当所有待发送邮件发完后，SMTP就关闭所建立的TCP连接。</li><li>运行在接收端邮件服务器中的SMTP服务器进程收到邮件后，将邮件放入收信人的用户邮箱，等待收信人在方便时进行读取。</li><li>收信人打算收信时，调用用户代理，使用POP3(或IMAP)协议将自己的邮件从接收端邮件服务器的用户邮箱中取回（如果邮箱中有来信的话）。</li></ol><h3 id="万维网">万维网</h3><p>用户单击鼠标后所发生的事件按顺序如下（以访问清华大学的网站为例）：</p><ol type="1"><li>浏览器分析链接指向页面的URL(http://www.tsinghua.edu.cn/chn/index.htm)。</li><li>浏览器向DNS请求解析www.tsinghua.edu.cn的IP地址。</li><li>域名系统DNS解析出清华大学服务器的P地址。</li><li>浏览器与该服务器建立TCP连接（默认端口号为80）。</li><li>浏览器发出HTTP请求：GET/chn/index.htm。</li><li>服务器通过HTTP响应把文件index.htm发送给浏览器。</li><li>释放TCP连接。</li><li>浏览器解释文件index.htm,并将Web页显示给用户。</li></ol>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2023/06/22/School/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/06/22/School/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>数据结构复习</p><span id="more"></span><ol type="1"><li><p>数据的逻辑结构：线性结构（栈、队列）、非线性结构（树、图）</p></li><li><p>数据的存储结构：顺序存储、链式存储、索引存储、散列存储</p></li><li><p>满二叉树：就是都满了</p><p>完全二叉树：除了最后一层都满，最后一层从左到右排列</p><p>二叉排序树：左子树的值小于根节点的值，右子树的值大于根节点的值</p><p>平衡二叉树：任意节点左右子树的深度差不大于1</p></li><li><p>二叉树遍历</p><ol type="1"><li>先序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ol></li><li><p>树的遍历</p><ol type="1"><li>先根遍历：先访问根节点，再依次遍历每棵子树</li><li>后根遍历：先依次遍历每棵子树，再访问根节点</li></ol></li><li><p>在无向图中若任意两个顶点是联通的则称为连通图；在有向图中若任意两个顶点双向可达则称为强连接图</p></li><li><p>最小生成树</p><ol type="1"><li><p>Prim算法<span class="math inline">\(O(n^2)\)</span></p><p>初始时从图中任取一个点加入T集合，之后每次选择一个与集合T距离最近的顶点加入</p><p><img src="C:\Users\chenl\AppData\Roaming\Typora\typora-user-images\image-20230622205421669.png" alt="image-20230622205421669" style="zoom:67%;" /></p></li><li><p>Kruskal算法<span class="math inline">\(O(n^2)\)</span></p><p>将边按权值排序，不断选择权值最小的边，使用并查集判断如果边的两个端点ab已经在一类中了则跳过，否则加入</p><p><img src="C:\Users\chenl\AppData\Roaming\Typora\typora-user-images\image-20230622205745004.png" alt="image-20230622205745004" style="zoom: 67%;" /></p></li></ol></li><li><p>最短路径</p><ol type="1"><li><p>Dijkstra单源最短路<span class="math inline">\(O(n^2)\)</span></p><p>初始时把源点放入S，寻找距离原点最近的顶点并入，然后更新原点到所有点的距离，重复上述过程直到到达目标点</p></li><li><p>Floyd多源最短路<span class="math inline">\(O(n^3)\)</span></p><p>基于动态规划，初始时对于任意两个点，如果他们之间存在边则边权值作为最短路径，若不存在则置无穷。之后每次尝试加入一个顶点k，看看每两个点之间增加k后得到的距离是否更短，若更短则进行更新。</p></li></ol></li><li><p>二叉排序树的删除：</p><ol type="1"><li>叶子节点直接删</li><li>只有一个子树直接替代</li><li>左右子树都有，找右子树中序遍历第一个结点替代（即右子树中的最小值）</li></ol></li><li><p>平衡二叉树（AVL）：在二叉排序树基础上规定任意顶点左右子树高度差不超过1.插删如果破坏了平衡则对最近不平衡结点进行旋转</p></li><li><p>排序算法</p><ol type="1"><li>直接插入排序<spanclass="math inline">\(O(n^2)\)</span>：遍历数组，对于某个值，遍历他前面的有序序列找到插入的地方并插入</li><li>折半插入排序<spanclass="math inline">\(O(n^2)\)</span>：在上述基础上用二分法找插入位置<spanclass="math inline">\(O(n(logn+n))\)</span></li><li>冒泡排序<spanclass="math inline">\(O(n^2)\)</span>：遍历两边，若逆序则调整顺序</li><li>快排<span class="math inline">\(O(nlogn)\)</span>：最坏<spanclass="math inline">\(O(n^2)\)</span>，最好<spanclass="math inline">\(O(nlogn)\)</span>，是平均性能最优的算法</li><li>选择排序<spanclass="math inline">\(O(n^2)\)</span>：每次在后面序列中选一个最大的和前面的交换</li><li>堆排序<span class="math inline">\(O(nlogn)\)</span></li><li>归并排序<spanclass="math inline">\(O(nlogn)\)</span>：将序列不断二分直到只有一个或两个元素，然后进行排序，然后再原路合并回去，合并时采用双指针遍历一遍存入新数组即可，需要O(n)的空间</li><li>桶排序：划分多个范围相同的区间，每个子区间内部进行排序，然后再合并</li><li>基数排序$O(d(n+r))：d代表分配回收的趟数，n代表长度，r代表基数</li></ol></li></ol><p><img src="C:\Users\chenl\AppData\Roaming\Typora\typora-user-images\image-20230622221713048.png" alt="image-20230622221713048" style="zoom:67%;" /></p><ol start="12" type="1"><li><p>外部排序</p><p>主要思路为减少访存次数.常用归并排序.将外存上的文件划分为若干长度为l的子文件,依次读入内存使用内部排序算法进行排序并写回外存.随后逐渐进行归并操作.</p></li><li><p>查找算法</p><ol type="1"><li><p>顺序查找</p></li><li><p>二分查找</p></li><li><p>插值查找：<span class="math inline">\(mid = low + \frac{(key -a[low])*(high-low)}{a[high]-a[low]}\)</span>,时间复杂度O(lglgn)</p></li><li><p>二叉排序树</p></li><li><p>平衡二叉树</p></li><li><p>红黑树：平衡二叉树调整太多了，红黑树稍微放宽了限制</p></li><li><p>B树:除根节点的非叶节至少有m/2上取整棵子树，最多有m棵子树</p></li><li><p>B+树：叶节点包含了全部关键字，非叶节点的关键字也会出现在叶结点中，叶子节点按大小顺序链接起来</p><p>B+树有两种查找运算：一种从最小关键词开始查找，一种从根节点开始查找，查找到最底层cai'jie'shu</p></li><li><p>散列表</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件工程导论</title>
    <link href="/2023/06/07/School/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/07/School/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>软件工程导论期末复习 <span id="more"></span></p><h2 id="第一章-概述">第一章 概述</h2><ol type="1"><li><p>软件定义</p><ol type="1"><li>软件是计算机系统中与硬件相互依存的另一部分，它是包括<strong>程序</strong>，<strong>数据</strong>及其<strong>相关文档</strong>的完整集</li><li>一种具有<核心功能>，能够实现<目标>的<事物></li></ol></li><li><p>软件分类</p><p>系统软件、应用软件、支撑软件、可复用软件(标准函数库)</p></li><li><p>软件工程定义</p><ol type="1"><li>建立并使用完善的工程化原则 ,以较经济的手段获得能在实际机器上有效运行的可靠软件的一系列方法</li><li>软件工程是开发，运行 , 维护和修复软件的系统方法</li><li>"软件工程是：①把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程，也就是把工程应用于软件；②研究①中提到的途径。</li></ol></li><li><p>软件工程三个要素</p><p>过程、方法、工具</p></li></ol><h2 id="第二章-软件生存期模型">第二章 软件生存期模型</h2><h3 id="软件生存期">软件生存期</h3><ol type="1"><li><p>软件生存期由<strong>软件定义</strong>、<strong>软件开发</strong>和<strong>运行维护</strong>三个时期组成，每个时期会包含一系列活动（Activity）和任务（Task）</p><ol type="1"><li><p><strong>活动</strong>：实现某个目的而采取的步骤或执行的责任。可行性分析，软件需求分析，软件体系结构设计等</p></li><li><p><strong>任务</strong>：构成活动的基本元素，一项活动往往有若干任务构成。软件需求分析包含需求抽取，需求分析，需求撰写，需求</p><p>验证等</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607173237.png" style="zoom: 67%;" /></p></li></ol><h3 id="软件过程模型">软件过程模型</h3><h4 id="瀑布模型">瀑布模型</h4><ol type="1"><li><p>介绍</p><ol type="1"><li><p>各项活动按自上而下，相互衔接的固定次序，如同瀑布逐级下落</p></li><li><p>每个阶段必须完成规定的文档；每个阶段结束前完成文档审查</p></li><li><p>阶段间具有顺序性和依赖性</p></li><li><p>质量保证与推迟实现的观点</p></li></ol></li><li><p>优缺点</p><ol type="1"><li>强迫进行规范化、每个阶段都有文档、每个阶段都验证过</li><li>很有可能没法一遍过，不能真正满足用户需求（到后面阶段了发现前面设计的有问题)，不适用于大型软件开发</li></ol></li></ol><h4 id="快速原型模型">快速原型模型</h4><ol type="1"><li><p>介绍</p><p>先开发一个‘原型’软件，完成部分主要功能，展示给用户并征求意见，然后逐步完善，最终获得满意的软件产品</p></li><li><p>分类</p><p>抛弃式原型：为了引出需求方便客户看，之后抛弃</p><p>进化式原型：在这个基础上继续做出成品</p></li><li><p>优缺点</p><ol type="1"><li><p>有助于满足用户的真实需求；</p><p>开发过程的后续阶段不会因为发现规格说明文档的错误而进行较大的返工</p></li><li><p>（进化式原型）系统结构较差</p><p>给用户造成项目已经（接近）完成的错觉</p></li></ol></li></ol><h4 id="增量模型">增量模型</h4><ol type="1"><li><p>介绍</p><p>增量模型把软件产品分解成一系列的增量构件，在增量开发迭代中逐步加入</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607182914.png" style="zoom:67%;" /></p></li><li><p>优缺点</p><ol type="1"><li><p>能在较短时间内向用户提交可完成一些有用的工作产品</p><p>项目失败的风险较低</p><p>最重要的系统服务将接受最多的测试</p></li><li><p>增量构件的划分比较困难</p><p>难以将客户的需求映射到适当规模的增量上</p></li></ol></li></ol><h4 id="螺旋模型">螺旋模型</h4><ol type="1"><li><p>介绍</p><p>将瀑布模型与快速原型模型结合起来，并且加入两种模型均忽略了的<strong>风险分析</strong></p><p>包含四个阶段：制定计划；<strong>风险分析</strong>；开发与验证（实施工程）；评审（评价开发工作）</p></li><li><p>优缺点</p><ol type="1"><li><p>对可选方案和约束条件的强调，有利构件的重用和软件质量的提升</p><p>通过风险分析，最大程度地降低软件彻底失败的可能性</p></li><li><p>螺旋模型是风险驱动的，对软件开发人员要求高，必须具有丰富的风险评估经验和专门知识</p><p>通常只适用大型软件，过大的风险管理支出会影响客户的最终收益</p></li></ol></li></ol><h4 id="统一过程模型">统一过程模型</h4><ol type="1"><li><p>介绍</p><p>包含四个过程阶段和六个核心过程流</p><p>四个阶段：初始阶段、细化阶段、构造阶段、移交阶段</p><p>六个工作流：业务建模工作流、需求工作流、分析和设计工作流、实现工作流、测试工作流、部署工作流</p></li></ol><h2 id="第三章-软件需求工程">第三章 软件需求工程</h2><h3 id="需求分类">需求分类</h3><p>用户需求和软件需求</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607190026.png" style="zoom:67%;" /></p><h3 id="软件需求工程">软件需求工程</h3><p>需求工程通过工程化的过程，方法和工具实现软件需求的获取、分析、文档化、确认和管理。</p><p>前四个是需求开发，最后一个是需求管理</p><h4 id="需求开发">需求开发</h4><ol type="1"><li><p>需求获取</p><p>分析任务：获取系统干系人的原始需求，建立对待开发软件所要解决问题的初步理解，收集软件开发所需的领域知识</p><p>确定需求来源：系统干系人、现有文档、现有系统</p><p><strong>需求获取方法</strong></p><p>​ • 访谈：访谈后使用扎根理论（GroundedTheory）等方法对访谈结果进行<strong>定性</strong>分析</p><p>​ • 专题小组</p><p>​ •问卷调查：所收集数据用于<strong>定量</strong>分析，具有统计学意义</p><p>​ •民族志研究：彻底置身于研究对象的文化和日常生活中，以观察者的身份获取领域知识和用户需求</p><p>​ • 系统原型</p><p>​ • 文档学习</p><p>​ • 同类系统调研</p><p>​ • 用户评论挖掘</p></li><li><p>需求分析</p><ol type="1"><li>问题框架分析</li><li>目标建模分析</li><li>结构化分析：<strong>数据流图</strong>、实体关系图、状态转换图、数据字典等</li><li>面向对象分析：<strong>用例图</strong>、<strong>类图</strong>、时序图、协作图、状态图等</li></ol></li><li><p>文档化</p><p>需求规格说明：精确地阐述一个软件系统必须提供的功能和性能以及它所要考虑的限制条件</p><ol type="1"><li>只描述“做什么”而无须描述“怎么做”</li><li>确保需求是可验证的</li></ol></li><li><p>需求确认</p><ol type="1"><li>需求评审：针对<strong>需求文档</strong>的评审活动</li><li>需求原型：通过动画、界面原型等方式向利益相关者展示开发团队当前对于系统软件需求的理解，从而获取反馈</li></ol></li></ol><h4 id="需求管理">需求管理</h4><p>需求管理贯穿上述四个过程</p><ol type="1"><li><p><strong>需求跟踪管理</strong>：维护需求文档与前继和后续工作成果之间的对应关系，确保产品满足用户需求</p><p>向前追踪、向后追踪</p><p>辅助理解，变更管理，软件复用，项目管理</p></li><li><p><strong>需求优先级管理</strong>：保证重要的需求优先被实现</p><p>优先级分类（KANO）：基本需求、期望需求、兴奋性需求</p></li><li><p><strong>需求变更控制</strong>：对依据规范处理需求变更，防止需求变更失去控制而导致项目混乱</p><p>基本流程：分析评估、变更决策、变更实施、变更发布</p></li></ol><h2 id="第四章-结构化分析方法">第四章 结构化分析方法</h2><h3 id="介绍">介绍</h3><ol type="1"><li><p>定义</p><p>针对用户需求建立抽象的分析模型</p></li><li><p>核心思想</p><p>自顶向下，逐步求精</p></li></ol><h3 id="功能建模">功能建模</h3><h4 id="数据流图">数据流图</h4><ol type="1"><li><p>定义</p><p>从数据传递和加工的角度，以图形的方式刻画数据流从输入到输出的移动变换过程</p></li><li><p>组成</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607192455.png" style="zoom: 67%;" /></p><ol start="3" type="1"><li><p>分层</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607192705.png" style="zoom: 67%;" /></p></li><li><p>例题</p></li></ol><p>​ PPT4 13~14面</p><h3 id="数据建模">数据建模</h3><h4 id="实体关系图">实体关系图</h4><ol type="1"><li>组成</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607193003.png" style="zoom:67%;" /></p><ol start="2" type="1"><li><p>关系类型</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607193927.png" style="zoom:67%;" /></p></li><li><p>例题</p><p>PPT4 p18</p></li></ol><h3 id="行为建模">行为建模</h3><h4 id="状态转换图">状态转换图</h4><ol type="1"><li><p>组成</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607194146.png" /></p></li></ol><h3 id="数据字典">数据字典</h3><ol type="1"><li><p>定义</p><p>对于分析模型中出现的所有数据对象给出准确的定义,三种分析模型的“粘合剂”</p></li><li><p>数据结构定义式</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607194547.png" style="zoom:67%;" /></p></li><li><p>例题</p><p>PPT4 p25~p27</p></li></ol><h2 id="第五章-软件设计">第五章 软件设计</h2><h3 id="软件设计任务和过程">软件设计任务和过程</h3><ol type="1"><li><p>软件设计的目标</p><ol type="1"><li><p>满足所有分析模型中涵盖的需求</p></li><li><p>从实现的角度展示软件在数据、功能、行为等方面的全景图</p></li><li><p>具有可读性，能够被软件开发人员准确地理解性</p></li></ol></li><li><p>软件设计的阶段</p><ol type="1"><li>从工程管理角度: 概要设计阶段和详细设计阶段</li><li>从设计目标维度: 体系结构设计、数据设计、接口设计和过程设计</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607195829.png" style="zoom:67%;" /></p></li><li><p>软件设计的任务</p><ol type="1"><li>体系结构设计: 定义软件系统的各主要成份以及它们之间的关系</li><li>数据设计: 确定数据的组织、彼此的关联、存取方式以及处理方法</li><li>接口设计：在用户和目标系统之间（界面设计）、目标系统内部各模块间（内部接口）、目标系统和其他系统之间（外部接口）构建有效地交流媒介</li><li>过程设计：描述各模块的实现算法</li></ol></li></ol><h3 id="软件设计原则">软件设计原则</h3><ol type="1"><li><p>分而治之</p><ol type="1"><li><p>解决大型复杂问题时通常采用的策略</p></li><li><p>不是越小越好</p></li></ol></li><li><p>模块独立性</p><ol type="1"><li><p>软件系统中每个模块只涉及软件要求的具体的子功能，而和软件系统中其他的模块的接口是简单的</p></li><li><p>独立性比较强的模块应是<strong>高内聚</strong>，<strong>低耦合</strong>的模块</p></li><li><p>两个准则:</p><ol type="1"><li><p>耦合性</p><p>模块之间耦合性越强，功能独立性越差，这样形成的模块结构界面不好</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607200555.png" style="zoom: 80%;" /></p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607200405.png" style="zoom: 67%;" /></p><ol start="2" type="1"><li><p>内聚性</p><p>模块内聚性越强，功能独立性越好，对于形成的模块结构有比较好的作用</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607202734.png" style="zoom:67%;" /></p></li><li><p>信息隐藏: 与正确使用无关的细节信息都应当被隐藏</p></li><li><p>复用性设计: 将复用的思想用于软件开发，称为软件复用</p></li><li><p>灵活性设计:保证软件灵活性设计的关键是<strong>抽象</strong></p></li></ol></li></ol></li></ol><h3 id="软件体系结构">软件体系结构</h3><ol type="1"><li><p>定义</p><p>系统在某种环境下的一组最基本的概念和属性，包括了元素、关系以及设计和演化的原则</p></li><li><p>分类</p><ol type="1"><li>管道和过滤器</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607201341.png" style="zoom: 67%;" /></p><ol start="2" type="1"><li>主程序-子进程体系结构</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607201413.png" style="zoom: 67%;" /></p><ol start="3" type="1"><li>分层体系结构</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607201821.png" style="zoom:67%;" /></p><ol start="4" type="1"><li>客户机/服务器体系结构<ol type="1"><li>瘦客户机模型:所有的应用处理和数据管理都在服务器上执行，客户机只负责表示部分</li><li>胖客户机模型:服务只负责对数据的管理，客户机实现应用逻辑和与用户的交互</li></ol></li></ol><p>### 用户界面设计</p></li><li><p>基于分层框架的设计方法</p><p>逐层进行设计，每一个层关注界面设计的一个特定方面</p></li></ol><p>​ 功能层、架构层、导航层、形式层、细节层</p><ol start="2" type="1"><li><p>界面布局模式</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607202301.png" /></p></li></ol><h2 id="第六章-面向对象方法概述">第六章 面向对象方法概述</h2><h3 id="面向对象">面向对象</h3><ol type="1"><li><p>对象</p><p>系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位，由一组<strong>属性</strong>和对这组属性进行操作的一组<strong>服务</strong>组成</p></li><li><p>类图</p><ol type="1"><li><p>概念类图</p><p>描述<strong>现实世界</strong>的实体与概念，重点反映现实世界问题域，与具体实现技术无关</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607203650.png" style="zoom: 50%;" /></p></li><li><p>分析类图</p><p>与系统实现相关的对象的抽象，由系统设计师绘制，其作用是描述系统的架构结构、指导程序员编码(实体类，边界类，控制类)</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607203712.png" style="zoom: 50%;" /></p></li><li><p>实现类图</p><p>真正考虑程序实现，揭示<strong>软件开发细节</strong></p></li></ol></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607203759.png" style="zoom:50%;" /></p><h3 id="uml">UML</h3><ol type="1"><li>特点<ol type="1"><li>统一标准</li><li>面向对象</li><li>可视化,表达能力强</li><li>独立于过程: UML是系统建模的语言，不依赖特定的开发过程</li><li>容易掌握使用</li><li>与编程语言紧密关联: 可以根据 UML所建立的系统模型自动产生Java、C++等代码框架</li></ol></li></ol><h2 id="第八章-软件构建">第八章 软件构建</h2><ol type="1"><li><p>交互方式</p><p>命令式编程: 做什么,怎么做</p><p>声明式编程:做什么,机器决定怎么做(如数据库查询语言,正则表达式等)</p></li><li><p>逻辑组织</p><p>• 结构化编程</p><p>• 面向对象编程</p><p>• 函数式编程: 结果唯一取决于输入参数</p><p>• 逻辑编程: 事实+规则=结果</p></li></ol><h2 id="第九章-软件测试">第九章 软件测试</h2><p>软件测试是使用人工和自动手段来运行或检测某个系统的过程，其目的在于检验系统是否满足规定的需求并找出与预期结果之间的差别.</p><h3 id="软件测试阶段">软件测试阶段</h3><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607205503.png" style="zoom:67%;" /></p><h4 id="单元测试">单元测试</h4><ol type="1"><li>测试模块接口保证被测程序单元的信息能够正常地流入和流出</li><li>走遍控制结构中的所有独立路径（基本路径）以确保模块中的所有语句至少执行一次</li><li>对所有的错误处理进行测试</li></ol><h4 id="集成测试">集成测试</h4><ol type="1"><li><p><strong>大爆炸集成测试</strong>指在软件开发过程中，先编写各个模块的代码，然后将这些代码一次性地集成到整个系统中进行测试的方法。这种方法的优点是适用于紧急项目和初步设计差异不大的项目，但缺点是容易发现问题，难以定位问题。</p></li><li><p><strong>自顶向下集成测试</strong>指从软件系统的最高层开始，逐步添加和测试下层的模块或组件，直到整个系统被完整集成并测试的方法。这种方法的优点是能够更早地发现整体性问题，但缺点是对底层模块进行测试时需要模拟上层模块的行为。</p></li><li><p><strong>自底向上集成测试</strong>指从底层的模块或组件开始，逐步添加和测试上层的模块或组件，直到整个系统被完整集成并测试的方法。这种方法的优点是对底层模块进行测试比较彻底，但缺点是对于整体性问题可能会晚于自顶向下集成测试发现。</p></li></ol><h4 id="系统测试">系统测试</h4><p>基于软件需求说明书的黑盒测试</p><p>分类: 功能测试, 性能测试(负载测试,压力测试)</p><h4 id="验收测试">验收测试</h4><p>确保软件准备就绪，让最终用户将其用于执行软件的既定功能和任务，测试其需求是否被满足</p><ol type="1"><li>α测试：由一个用户在受控环境下进行的测试</li><li>β测试：由软件的多个用户在实际使用环境下进行的测试</li></ol><h4 id="回归测试">回归测试</h4><p>错误被修正后或软件功能、环境发生变化后进行的重新测试</p><h3 id="主要软件测试技术">主要软件测试技术</h3><h4 id="白盒测试">白盒测试</h4><h5 id="基本路径测试法">基本路径测试法</h5><ol type="1"><li><p>语句覆盖</p><p>使得每个可执行<strong>语句</strong>至少要执行一次</p></li><li><p>判定覆盖(分支覆盖)</p><p>使得程序中每个判断的<strong>取真分支</strong>和<strong>取假分支</strong>至少经历一次</p></li><li><p>条件覆盖</p></li></ol><p>​使得程序中每个判断的每个<strong>条件</strong>的可能取值至少执行一次</p><ol start="4" type="1"><li><p>判定/条件覆盖</p><p>同时满足判定覆盖和条件覆盖的要求</p></li><li><p>条件组合覆盖</p><p>求出判定中所有条件的各种可能组合值</p></li></ol><h5 id="程序控制流图">程序控制流图</h5><p>​ 例题: PPT9 P60</p><h4 id="黑盒测试">黑盒测试</h4><h5 id="等价类划分法">等价类划分法</h5><ol type="1"><li><p>定义</p><p>等价类是某个输入域的子集，在该子集中每个输入数据的作用是等效的</p></li><li><p>分类</p><ol type="1"><li>有效等价类: 可以检查程序是否实现了规格说明中所规定的功能和性能</li><li>无效等价类: 用于检查程序能否妥善处理异常输入数据</li></ol></li><li><p>例题</p><p>PPT9 P78</p></li></ol><h5 id="边界值分析法">边界值分析法</h5><p>确定边界情况(输入或输出等价类的边界).选取正好等于、刚刚大于或刚刚小于边界值作为测试数</p><h4 id="静态测试">静态测试</h4><p>不通过执行被测软件而进行测试的技术</p><h4 id="组合测试">组合测试</h4><p>对部分参数的所有取值组合进行验证，即可有效地发现软件的缺陷——降低测试复杂度</p><p>被测试软件能够抽象为一个受到多个因素（参数）影响的系统，且该因素应当是离散且有限的</p>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式操作系统</title>
    <link href="/2023/05/27/School/%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/05/27/School/%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>分布式操作系统期末复习 <span id="more"></span></p><h3 id="名词">名词</h3><ol type="1"><li>autonomous 自治的，自己管理自己</li><li>Concurrency 并发</li><li>Coordination 协调</li><li>Transparency 透明</li><li>Trade-off 权衡</li><li>latency 延迟</li><li>Homogeneous 同构</li><li>Heterogeneous 异构</li><li>Tightly-coupled 紧耦合</li><li>Paradigm 范式</li><li>Tiered Architecture 分层架构</li><li>synchronous 同步</li><li>asynchronous 异步</li><li>Transient Communication 暂时通信</li><li>Persistent Communication 持久通信</li><li>router 路由</li><li>relay 中继</li><li>Primitives 原语</li><li>Message Brokers 消息代理</li><li>Decoupling 解耦</li><li>Processor allocation 处理器分配</li><li>Deterministic Algorithm 确定性算法</li><li>Heuristic Algorithm 启发式算法</li><li>replica 副本</li><li>Mounting 挂载</li><li>recursive name resolution 递归名称解析</li><li>clock skew 时钟偏移</li><li>concurrent 并发</li><li>Mutual Exclusion 互斥</li><li>critical region 临界区</li><li>Transaction 事务</li><li>cascaded aborts 级联终止</li></ol><h3 id="第一章">第一章</h3><ol type="1"><li><p>分布式操作系统定义</p><p>分布式系统是独立计算机的集合，在其用户看来是一个单一的连贯系统。</p><p>由位于<strong>联网</strong>计算机上的<strong>硬件或软件</strong>组件组成的任何系统，这些组件通过<strong>消息传递</strong>来通信和协调它们的操作。</p></li><li><p>特性</p><ol type="1"><li>Hidden ：Hide the difference and the communication among all kindsof computers</li><li>Consistent and Uniform<br /></li><li>Scalability：伸缩性，即使坏了一部分整个系统也不会瘫痪（允许某些功能不可用了）</li><li>Concurrency ：Coordination among different concurrently executingprograms that share resource</li><li>No Global Clock ：</li></ol></li><li><p>目标</p><ol type="1"><li><p>Making Resources Accessible</p></li><li><p>Distribution Transparency 看起来只有一个电脑</p></li><li><p>Openness</p><p>Mechanism : (How to do it)It need cache</p><p>Policy : (What will be done)Size? • Consistency? • Always or only onesession? • Can user control?</p></li><li><p>Scalability</p></li></ol></li></ol><h3 id="第二章-communication">第二章 Communication</h3><ol type="1"><li><p>UDP offers no guarantee of delivery 不可靠的传输 No setup costs不需要建立连接，额外花销小</p></li><li><p>RPC(Remote Procedure Call)</p><p>Problems:</p><ol type="1"><li>Call by Value：异构的计算机对于相同的字符串的解读不同</li><li>Call by Reference：<ol type="1"><li>For array: copy/restore把整个数组发过去，搞完之后再发回本机修改</li><li>For ordinary pointer 接收机器拿着指针回来找</li></ol></li><li>How to Create Stub：Interface Definition Language(IDL)使用统一接口</li></ol></li><li><p>RMI（Remote Method Invocation）</p><p>Client:Proxy</p><p>Server:Skleton</p><p>RMI and RPC are same theoretically.</p></li><li><p>同步通信收发都是堵塞的，异步通信发是非堵塞的收都可以</p></li><li><p>Transient communication:A message is not stored in communicationsystem 瞬时通信不存储信息</p><ol type="1"><li>Sockets Interface<ol type="1"><li>TCP/UDP</li><li>IP Multicast: IP multicast is available only via UDP</li></ol></li><li>MPI(Message Passing Interface standard)</li></ol></li><li><p>Persistent Communication:A message is stored in communicationsystem until it is sent to receiver 持久通信</p><ol type="1"><li>Message Queue Model 保证一定送达但是不保证时间长短<ol type="1"><li>router：进行接收转发</li><li>relay：接收之后进行处理 Relay can build a scalable message-queuingsystem</li><li>Application of Message Queue System<ol type="1"><li>Asynchronization 异步</li><li>Decoupling of application 解耦</li><li>Flow Cutting 流切割</li></ol></li></ol></li></ol></li><li><p>Stream Oriented Communication</p><ol type="1"><li><p>Continuous representation media: Temporal relationship betweendata items is IMPORTANT to explain the meaning of data.</p></li><li><p>Discrete representation media: Temporal relationship between dataitems is NOT IMPORTANT to explain the meaning of data</p></li><li><p>Transmission types</p><ol type="1"><li><p>Asynchronous transmission mode</p><p>Data items are transmitted one by one. No time restriction ontransmission.</p></li><li><p>Synchronous transmission mode</p><p>Every data item has a maximum end-to-end delay defined for each unitin a data stream.</p></li><li><p>Isochronous transmission mode</p><p>Data item must be transmitted on time.</p></li></ol></li><li><p>Interleaving frames 交错帧，减小数据包丢失的影响</p></li><li><p>QoSNegotiation是一种网络协议，用于协商和确定网络中各种流量的优先级、带宽、延迟等服务质量参数。</p></li></ol></li></ol><h3 id="第三章">第三章</h3><ol type="1"><li><p>Server Classification</p><ol type="1"><li>Iterative Server：Server is responsible for dealing with request andreturn the result to client</li><li>Concurrent Server：Server doesn’t deal with request from client. Itsends the request to a thread or a process,then wait for nextrequest</li></ol></li><li><p><strong>Out-of-band</strong> data ： data that is to be processedby the server before any other data from thatclient.优先级很高，需要及时处理</p></li><li><p>Stateless Server：Don’t save any information about client</p><p>Server with state：Maintain information about client</p></li><li><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230606232439.png" style="zoom:50%;" /></p></li><li><p>Code Migration</p><ol type="1"><li><p>Process migration ：An entire process was moved from one machineto another.</p><ol type="1"><li><p>Weak Mobility: Only migrate code segment and some initializationdata</p></li><li><p>Strong Mobility: Migrate the code segment and the executingsegment</p></li></ol></li><li><p>Resource Migration:</p><ol type="1"><li>Process-Resource Binding: ID,Value,Type</li><li>Resource-Machine Binding: Unattached Resource,FastenedResource,Fixed Resource</li></ol></li></ol></li><li><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607005703.png" style="zoom:50%;" /></p></li><li><p>Processor Allocation Algorithm</p><ol type="1"><li>Deterministic Algorithm：Know all information about allprocesses</li><li>Heuristic Algorithm：The load of a system is unpredictable.</li></ol></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607010738.png" style="zoom:50%;" /></p><h3 id="第四章">第四章</h3><ol type="1"><li>Flat Naming</li><li>Struct Naming<ol type="1"><li>Iterative NameResolution:迭代名称解析：每一层都给服务器发，然后服务器返回下一层地址</li><li>Recursive NameResolution：递归名称解析：主机只发一次，服务器之间进行通讯完成工作</li></ol></li><li>Attribute-Based Naming：To describe an entity in terms of(attribute,value) pairs</li></ol><h3 id="第五章">第五章</h3><ol type="1"><li><p>物理时钟</p><ol type="1"><li>Cristian Algorithm<ol type="1"><li>如果有一个有WWV接收器的机器，其他机器都可以向这个机器请求时间</li><li>Time is not allowed to runbackward.如果一个机器的时间在同步时钟之后，时间回溯是不被允许的</li></ol></li><li>Berkeley Algorithm<ol type="1"><li>Time server polls the time of every machine</li><li>Average the results and tell the time to other machine</li></ol></li><li>Averaging Algorithm<ol type="1"><li>Every machine broadcast its time to others in every timeinterval</li><li>After broadcasting,machine collect time response from other machinesin an interval S</li><li>Average all the time values，Discard m highest and m lowest</li><li>Try to add an estimated time delay to correct the time</li></ol></li><li>应用: Network Time Protoc ol (NTP)</li></ol></li><li><p>逻辑时钟</p><ol type="1"><li><p>为什么不用物理时钟</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607101629.png" style="zoom: 50%;" /></p></li><li><p>Lamport’s Logical Clocks</p><pre><code class="hljs">1. If a and b are two events in a **same process**,and a happens before b,then a→b is true    2. If a is a **sending** event of a message in a process,b is receiving event of this message in another process,then a→b is true    3. If a→b is not true,b→ a is not true,a and b is concurrent 并发</code></pre><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607104453.png" style="zoom:50%;" /></p></li></ol></li><li><p>Vector Clocks</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607104716.png" style="zoom:50%;" /></p><ol start="4" type="1"><li><p>Election Algorithm</p><ol type="1"><li>Bully Algorithm</li></ol><p>进程P发现协调员(coordinator)无法工作，发起一个选举，给所有比自己PID大的进程Q发消息，要是应答了则P放弃，Q继续上述过程，直到只剩一个，成为新的协调员</p><ol start="2" type="1"><li><p>Ring Algorithm</p><p>逻辑上的环，每个进程知道自己的后继进程。转一圈之后选PID最大的当新协调员。</p></li></ol></li><li><p>Mutual Exclusion</p><ol type="1"><li><p>Centralized Algorithm</p><p>P是协调者，Q想进去要问P，能进就可以，不能进Q就进等待队列。里面的进程出来之后授权队列头进程</p></li><li><p>Distributed Algorithm</p><p>P想进去，发请求给所有进程Q，要是Q不想进去就发ok回来，要是Q就在里面就不回应，要是Q也想进去就比较时间戳，要是比自己早就回ok</p></li><li><p>Token Ring Algorithm</p><p>一个令牌在环里绕，拿到令牌的可以进去。</p><p>这个算法不是一个fair algorithm，前面俩都是fair algorithm</p></li></ol></li><li><p>Distributed Transaction</p><p>A transaction can • Protect shared resource from concurrent accesses• Permit a process read and write several data items as if it is readand written by a single atomic operation</p><ol type="1"><li><p>Characteristics</p><ol type="1"><li><p>Atomic • A transaction cannot be separated.</p></li><li><p>Consistent • A transaction cannot spoil the consistent item ofsystem.</p></li><li><p>Isolated • Concurrent transaction cannot affect eachother.</p></li><li><p>Durable • Once a transaction is committed,the change will bepermanent.</p></li><li><p>RollBack</p></li><li><p>Private Workspace: Give a private workspace to a transaction whenit begins</p><p>All data are read and written in the private workspace until thetransaction is committed or failed</p></li></ol></li><li><p>Writeahead Log</p><ol type="1"><li><p>Before a file is updated,a record is written in a log</p></li><li><p>Only after write the log successfully,the change can be committedto the file</p><ol start="2" type="1"><li>Serial Equivalence</li></ol></li></ol></li><li><p>Several transactions can be executed at the same time but thefinal result is the same as the situation that all transactions areexecuted one by one</p></li><li><p>Two Concurrent Control Methods</p><ol type="1"><li><p>Pessimistic approaches 不允许可能出现的问题</p><p>Timestamp Ordering</p><ol type="1"><li>A transaction’s request to <strong>write</strong> an object is validonly if that object was last read and written by earliertransactions</li><li>A transaction’s request to <strong>read</strong> an object is validonly if that object was last written by earlier transactions</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607153228.png" style="zoom:50%;" /></p></li><li><p>Optimistic approaches 可以有问题，回滚就行了</p></li></ol></li></ol></li></ol><h3 id="第六章">第六章</h3><ol type="1"><li><p>Replication 副本</p><ol type="1"><li><p>为什么需要副本</p><p>• Reliability</p><p>• Performance</p><p>• Fault tolerance</p></li><li><p>CAP</p><ol type="1"><li>Partition Tolerance 分区容错性<ol type="1"><li>Every subnetwork is called a partition</li><li>The system still work when communication fail</li></ol></li><li>Consistency 一致性<ol type="1"><li>All replica in the system should be consist</li></ol></li><li>Availability 可用性<ol type="1"><li>All nodes in the system can be used when user need it</li></ol></li><li>上述三个不能bingcun<ol type="1"><li>如果想有P，那肯定得有预留的副本，那么一致性和全可用性就不可能实现</li><li>如果想有CA,那P肯定不能实现</li></ol></li></ol></li><li><p>一致性</p><ol type="1"><li>Strict Consistency<ol type="1"><li>Any read operation on data item x can return back the result of lastwrite on x.</li><li>Depend on absolute global time</li></ol></li><li>Sequential Consistency<ol type="1"><li>The result of all process’s read and write operation are the same asif they are executed according to a specific order.</li><li>一个进程内部执行顺序一致就行，俩进程谁先谁后无所谓？</li></ol></li><li>Linearizability<ol type="1"><li>every operation has a timestamp,and satisfies followingcondition</li><li>时间在前的先发生</li></ol></li><li>Causal Consistency<ol type="1"><li>Writes that are potentially causally related must be seen by allprocesses in the same order.</li><li>得分析前面的潜在因果关系，要是俩写操作判断不出来谁前谁后，那读的时候谁前谁后都可以</li></ol></li></ol></li><li><p>修改的传播方法</p><ol type="1"><li><p>Only propagate a notification of an update</p><p>告诉别人我已经改了，别再用那个旧的了</p></li><li><p>Transfer data from one copy to another</p><p>把改了的数据发给别人</p></li><li><p>Propagate the update to other copies</p><p>告诉别人我怎么改的</p></li></ol></li><li><p>传染病模型</p><ol type="1"><li><p>传统的方法是P一个人告诉其他所有人更新消息，传染病模型是P告诉Q之后，PQ一起告诉别人</p></li><li><p>Anti-Entropy Model 反熵模型</p><p>A server P select another server Q randomly and exchangeupdates</p></li><li><p>Gossiping Model 八卦模型</p><p>P拿到更新之后随机再告诉别人要更新</p></li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软工课设</title>
    <link href="/2023/05/17/School/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE/"/>
    <url>/2023/05/17/School/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE/</url>
    
    <content type="html"><![CDATA[<p>软工课设后端开发 <span id="more"></span></p><ol type="1"><li>getAllProductByAdmin</li></ol>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高数下串讲</title>
    <link href="/2023/05/17/School/%E9%AB%98%E6%95%B0%E4%B8%8B%E4%B8%B2%E8%AE%B2/"/>
    <url>/2023/05/17/School/%E9%AB%98%E6%95%B0%E4%B8%8B%E4%B8%B2%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>朋辈讲师高数下串讲 <span id="more"></span></p><h3 id="多元函数微分">多元函数微分</h3><ol type="1"><li>偏导定义</li><li>判断是否可微 P161</li><li>判断偏导是否连续 P161，P165例1.11.2</li><li>复合函数求偏导 P166 例1.11.3</li><li>隐函数公式证明 P162</li><li>无条件极值、条件极值、拉格朗日乘数法 P165 P168 P169</li><li>例1.11.8</li></ol><h3 id="二重积分">二重积分</h3><ol type="1"><li><p>对称性P176，注例，P178例1.12.2</p></li><li><p>交换积分次序 P180 例1.12.8</p></li><li><p>直角坐标和极坐标的转换 P179 例1.12.5</p></li></ol><h3 id="section"></h3>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基础-小作业</title>
    <link href="/2023/05/07/School/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E5%B0%8F%E4%BD%9C%E4%B8%9A/"/>
    <url>/2023/05/07/School/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E5%B0%8F%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<p>基于华为云平台使用机器学习算法进行鸢尾花数据集分类 <span id="more"></span></p><h3 id="实验环境搭建">实验环境搭建</h3><ol type="1"><li><p>首先访问华为云的modelarts平台：https://console.huaweicloud.com/modelarts/，在左侧找到<strong>开发环境</strong>，选择Notebook并点击创建，如下图所示。</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230508124116.png" /></p></li><li><p>随后在创建界面指定名称，设置自动停止可以保证不会忘记关闭服务器而造成损失，镜像根据需求选择即可。其他默认，点击<strong>立即创建</strong>并提交，等待创建完成即可。</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230508124205.png" /></p></li><li><p>点击<strong>打开</strong>，即可进入服务器操作页面</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230508124525.png" /></p></li><li><p>左上角蓝色箭头可以上传文件到服务器，右侧可以选择交互的平台，本次选择Notebook。打开后即可进入代码编写阶段。</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230508124636.png" /></p></li></ol><h3 id="核心代码">核心代码</h3><p>本文使用<strong>sklearn</strong>实现若干模型对鸢尾花数据集的分类。由于本次实验选择的数据集为鸢尾花的前两类，他们之间是线性可分的，因此理想情况下分类准确率应为100%.</p><ol type="1"><li><p>头文件导入</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.rcParams[<span class="hljs-string">&quot;font.sans-serif&quot;</span>]=[<span class="hljs-string">&quot;SimHei&quot;</span>] <span class="hljs-comment">#设置字体</span><br>plt.rcParams[<span class="hljs-string">&quot;axes.unicode_minus&quot;</span>]=<span class="hljs-literal">False</span> <span class="hljs-comment">#该语句解决图像中的“-”负号的乱码问题</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br></code></pre></td></tr></table></figure></p></li><li><p>数据预处理</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">data = pd.read_csv(<span class="hljs-string">&quot;iris.data&quot;</span>,header=<span class="hljs-literal">None</span>)[:<span class="hljs-number">100</span>]<br>x = data.iloc[:,:<span class="hljs-number">4</span>]<br>y = []<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data.iloc[:<span class="hljs-number">100</span>,<span class="hljs-number">4</span>]:<br>    <span class="hljs-keyword">if</span> item == <span class="hljs-string">&#x27;Iris-setosa&#x27;</span>:<br>        y.append(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">else</span>:<br>        y.append(<span class="hljs-number">1</span>)<br>X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>线性模型</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><br>model = LogisticRegression()<br><br>model.fit(X_train, y_train)<br><br>y_pred = model.predict(X_test)<br><br>accuracy = accuracy_score(y_test, y_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy: &#123;:.2f&#125;%&quot;</span>.<span class="hljs-built_in">format</span>(accuracy * <span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure></p></li><li><p>决策树</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier<br>model = DecisionTreeClassifier()<br><br>model.fit(X_train, y_train)<br><br>y_pred = model.predict(X_test)<br><br>accuracy = accuracy_score(y_test, y_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy: &#123;:.2f&#125;%&quot;</span>.<span class="hljs-built_in">format</span>(accuracy * <span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure></p></li><li><p>其他</p><p>由于sklearn的模型接口一致，除model的定义不同外其他均一致，因此后续只给出头文件以及model定义</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 支持向量机</span><br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC<br>model = SVC()<br><br><span class="hljs-comment"># 贝叶斯</span><br><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB<br>model = GaussianNB()<br><br><span class="hljs-comment"># 神经网络</span><br><span class="hljs-keyword">from</span> sklearn.neural_network <span class="hljs-keyword">import</span> MLPClassifier<br>model = MLPClassifier(hidden_layer_sizes=(<span class="hljs-number">10</span>,), max_iter=<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment"># 集成学习（以随机森林为例）</span><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br>model = RandomForestClassifier()<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="结果和总结">结果和总结</h3><ol type="1"><li>实验结果</li></ol><p>​通过在华为云平台的Notebook运行，所有分类的准确率均为100%，符合预期。</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/result.png" /></p><ol start="2" type="1"><li><p>总结</p><p>通过本次实验，我深入了解了华为云平台具有创建方便、使用方式简洁、资源充足、不占有本机资源等优点，并通过实际操作熟悉了其使用方法，使我能够更加便捷地进行机器学习和数据处理等任务。</p><p>在本次实验中，我们采用了鸢尾花数据集进行二分类任务，通过理论学习和实践操作的结合，我掌握了机器学习中数据预处理、模型训练和评估等基本流程，提升了我的数据分析和模型建立能力。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛打印</title>
    <link href="/2023/05/04/Algorithm/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%B0/"/>
    <url>/2023/05/04/Algorithm/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%B0/</url>
    
    <content type="html"><![CDATA[<p>经典的算法题 <span id="more"></span></p><h3 id="背包问题">背包问题</h3><p>给定 N 个正整数 A1,A2,…，从中选出若干个数，使它们的和为M，求有多少种选择方案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[<span class="hljs-number">110</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">110</span>][<span class="hljs-number">10010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(a[i]&lt;=j) dp[i][j] = dp[i][j] + dp[i<span class="hljs-number">-1</span>][j-a[i]];<span class="hljs-comment">// 两个方案加起来</span><br>        &#125;<br>    &#125;<br>    <br>    cout&lt;&lt;dp[n][m];<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="判断闰年">判断闰年</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(x%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;x%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span> || x%<span class="hljs-number">400</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="蛇形数组">蛇形数组</h3><p>注意算a[20,20]要满足j&gt;=20 &amp;&amp; i-j+1 &gt;=20,i要算到40多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">300</span>][<span class="hljs-number">300</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> reverse = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">50</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(reverse)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++) &#123;<br>                a[j][i - j + <span class="hljs-number">1</span>] = cnt++;<br>                cout&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;i-j+<span class="hljs-number">1</span>&lt;&lt;endl;<br>            &#125;<br>            reverse = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++) &#123;<br>                a[i - j + <span class="hljs-number">1</span>][j] = cnt++;<br>                cout&lt;&lt;i-j+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;endl;<br>            &#125;<br>            reverse = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;a[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="正方形内的z字数组">正方形内的Z字数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> a[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            cin &gt;&gt; a[i][j];<br><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(x != n || y != n)&#123;<br>        <span class="hljs-keyword">if</span>(x &lt; n &amp;&amp; y &lt; n)<br>            cout &lt;&lt; a[x][y] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">if</span>(flag) x--, y++;<br>        <span class="hljs-keyword">else</span> x++, y--;<br><br>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>) &#123;<br>            x = <span class="hljs-number">0</span>;<br>            flag = !flag;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(y &lt; <span class="hljs-number">0</span>)&#123;<br>            y = <span class="hljs-number">0</span>;<br>            flag = !flag;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维涂色差分">二维涂色差分</h3><p>给定两个点(x1,y1),(x2,y2)，对其中间的格子进行涂色，问最后有多少个格子被涂色</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> map[N][N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;<br>        x1++;<span class="hljs-comment">// 注意区分点和格子</span><br>        y1++;<br>        map[x1][y1] ++;<br>        map[x1][y2+<span class="hljs-number">1</span>] --;<br>        map[x2+<span class="hljs-number">1</span>][y1] --;<br>        map[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]++;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;N;j++)&#123;<br>            map[i][j] = map[i<span class="hljs-number">-1</span>][j] + map[i][j<span class="hljs-number">-1</span>] - map[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + map[i][j];<br>            <span class="hljs-keyword">if</span>(map[i][j] &gt; <span class="hljs-number">0</span>) res++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串子串查找">字符串子串查找</h3><p>给出一个字符串和多行文字，在这些文字中找到字符串出现的那些行。你的程序还需支持大小写敏感选项：当选项打开时，表示同一个字母的大写和小写看作不同的字符；当选项关闭时，表示同一个字母的大写和小写看作相同的字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function">string <span class="hljs-title">to_lower</span><span class="hljs-params">(string s)</span></span>&#123;<br>    string temp = s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temp.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(temp[i]&gt;=<span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; temp[i]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>) temp[i] = temp[i] -<span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-string">&#x27;a&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string refer;<br>    cin&gt;&gt;refer;<br>    <span class="hljs-type">int</span> sign;<br>    cin&gt;&gt;sign;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">if</span>(!sign) refer = <span class="hljs-built_in">to_lower</span>(refer);<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        string s;<br>        cin&gt;&gt;s;<br>        string temp = s;<br>        <span class="hljs-keyword">if</span>(!sign) temp = <span class="hljs-built_in">to_lower</span>(s);<br><br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">find</span>(refer)!=string::npos)&#123;<br>            cout&lt;&lt;s&lt;&lt;endl;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统复习</title>
    <link href="/2023/05/03/School/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/05/03/School/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>操作系统基础知识复习 <span id="more"></span></p><h2 id="计算机系统概述">计算机系统概述</h2><ol type="1"><li><p>计算机自下而上的四个部分：硬件、操作系统、应用程序、用户。</p></li><li><p>操作系统定义：指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。</p></li><li><p>操作系统的四个特征:<strong>并发</strong>、<strong>共享</strong>、虚拟、异步(P2)。前两者必须实现。</p></li><li><p>操作系统为用户提供了两种接口：命令接口和程序接口。前者分为联机命令接口（交互式命令接口，在终端一问一答）和脱机命令接口（批处理系统，用户无法干预过程）。后者由一组系统调用组成。</p></li><li><p>操作系统发展历程</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230503155929.png" style="zoom:67%;" /></p></li><li><p>计算机通过硬件完成操作系统由用户态到核心态的转换。</p></li><li><p>操作系统主要的四种结构</p><ol type="1"><li><p>分层法：自底向上逐层验证</p><ol type="1"><li>优点：便于系统的调试和验证，简化了系统的设计和实现；易扩充和易维护</li><li>缺点：合理定义各层比较困难；效率差（需要穿越多层）</li></ol></li><li><p>模块化：按功能分为若干个模块，向外提供接口</p><ol type="1"><li>优点：提高操作系统的正确性、可解释性和可维护性；增强了操作系统的可适应性；加速了操作系统的开发过程</li><li>缺点：接口规定难以满足对接口的实际需求；无法可靠的决定开发顺序</li></ol></li><li><p>宏内核：将系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为用户程序提供高性能的系统服务。</p></li><li><p>微内核：将内核中最基本的功能保留在内核，将不需要在和心态执行的功能移到用户态执行</p><p>操作系统中绝大部分功能都放在微内核外的一组服务器（进程）中实现，只有微内核运行在内核态，是C/S模式。</p><p>优点：扩展性和灵活性；可靠性和安全性；可移植性；分布式计算</p></li></ol></li><li><p>操作系统的<strong>引导过程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625005915.png" style="zoom: 50%;" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625005955.png" /></p></li></ol><h2 id="进程与线程">进程与线程</h2><h3 id="进程与线程-1">进程与线程</h3><ol type="1"><li><p>进程的组成：PCB、程序段、数据段</p></li><li><p>进程的<strong>创建过程</strong>（原语）</p><ol type="1"><li>为新进程分配一个唯一的进程标识号，并申请一个空白PCB(PCB是有限的)。若PCB申请失败，则创建失败。</li><li>为进程分配其运行所需的资源，如内存、文件、I/O设备和CPU时间等（在PCB中体现)。这些资源或从操作系统获得，或仅从其父进程获得。如果资源不足（如内存），则并不是创建失败，而是处于创建态，等待内存资源。</li><li>初始化PCB,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</li><li>若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。</li></ol></li><li><p>进程的<strong>终止过程</strong>（原语）</p><ol type="1"><li>根据被终止进程的标识符，检索出该进程的PCB,从中读出该进程的状态。</li><li>若被终止进程处于运行状态，立即终止该进程的执行，将处理机资源分配给其他进程。</li><li>若该进程还有子孙进程，则应将其所有子孙进程终止。</li><li>将该进程所拥有的全部资源，.或归还给其父进程，或归还给操作系统。</li><li>将该PCB从所在队列（链表）中删除。</li></ol></li><li><p><strong>进程的通信</strong>包含三种：共享存储、消息传递（直接通信、间接通信）、管道通信</p></li><li><p>为什么<strong>引入进程</strong></p><p>在多道程序同时运行的背景下，进程之间需要共享系统资源，因此会导致各程序在执行过程中出现相互制约的关系，程序的执行会表现出间断性的特征。这些特征都是在程序的执行过程中发生的，是动态的过程，而传统的程序本身是一组指令的集合，是一个静态的概念，无法描述程序在内存中的执行情况，即我们无法从程序的字面上看出它何时执行、何时停顿，也无法看出它与其他执行程序的关系，因此，程序这个静态概念己不能如实反映程序并发执行过程的特征。为了深刻描述程序动态执行过程的性质乃至更好地支持和管理多道程序的并发执行，人们引入了进程的概念。</p></li></ol><h3 id="处理机调度">处理机调度</h3><ol type="1"><li><p>调度的层次</p><ol type="1"><li><p>高级调度（作业调度）</p><p>按照一定原则从外存上处于后备队列的作业中挑选一个分配资源建立相应进程使他们获得竞争处理机的权利。是内存与辅存之间的调度</p></li><li><p>中级调度（内存调度）</p><p>为了提高内存利用率和系统吞吐量，将暂时不能运行的进程调至外存等待，将状态改为挂起态。当运行条件具备且内存有空闲时再调入内存</p></li><li><p>低级调度（进程调度）</p><p>从就绪队列中选择一个进程执行</p></li></ol></li><li><p>评价指标</p><ol type="1"><li>CPU利用率：有效工作时间/总时间</li><li>系统吞吐量：单位时间CPU完成作业的数量</li><li>周转时间：作业完成时间-作业提交时间</li><li>等待时间：进程处于等处理机的时间之和</li><li>响应时间：从用户提交请求到系统首次响应所用的时间</li></ol></li><li><p>上下文切换过程</p><ol type="1"><li>挂起一个进程，保存CPU上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>跳转到新进程PCB中的程序计数器所指向的位置执行。</li><li>恢复处理机上下文。</li></ol></li></ol><h3 id="同步与互斥">同步与互斥</h3><ol type="1"><li><p>等待时间：等待CPU的时间；周转时间：作业完成时间-作业提交时间；响应比：<spanclass="math inline">\(\frac{等待时间+要求服务时间}{要求服务时间}\)</span></p></li><li><p>同步与互斥</p><ol type="1"><li><p>同步：同步是指多个进程或线程之间的协作，按照一定的顺序执行，保证数据的正确性和一致性。通常使用信号量、事件等机制实现。</p></li><li><p>互斥：互斥是指多个进程或线程之间的竞争，保证同一时间只有一个进程或线程能够访问共享资源，避免数据的竞争和冲突。通常使用互斥锁、读写锁等机制实现。</p></li><li><p>区别：同步和互斥都是为了保证多个进程或线程之间的正确性和一致性，但它们侧重点不同。同步主要关注不同进程或线程之间的协作和顺序执行，而互斥则主要关注共享资源的竞争和访问控制。同时，同步可以用于实现互斥，但互斥不能实现同步。</p></li></ol></li></ol><h3 id="死锁">死锁</h3><ol type="1"><li><p>死锁产生的必要条件</p><ol type="1"><li>互斥:对资源进行排他性使用</li><li>不剥夺:进程的资源在未使用完之前,不能被其他进程夺走</li><li>请求并保持:进程已经保持了至少一个资源,但又提出了新的资源请求,而该资源已被其他进程占有</li><li>循环等待:存在一个资源的循环等待链</li></ol></li><li><p>死锁预防</p><ol type="1"><li>破坏互斥条件:比如打印机,肯定不可行</li><li>破坏不剥夺条件:确实可以,但是会增加系统开销,可以用于易于保存和恢复的资源比如CPU的寄存器和内存资源</li><li>破坏请求并保持条件:进程在运行前申请所有需要的资源,如果资源不足就等待,资源足够后一次性分配.</li><li>破坏循环等待条件:采用顺序资源分配法,给每个资源一个编号,每个进程必须按照编号递增的顺序请求资源,同类资源一次申请完.</li></ol></li><li><p>死锁避免</p><ol type="1"><li><p>银行家算法</p><p>要求每个进程给出最大的资源请求量MAX,已知每个进程的现在资源占有量ALLO.对于一个新的资源请求NEW,首先检查NEW+ALLO是否大于MAX,若大于则不予分配.然后检查如果分配了,系统是否还是安全状态(找到一个安全序列),如果是就可以进行分配.</p></li></ol></li><li><p>死锁检测和<strong>解除</strong></p><ol type="1"><li>资源剥夺法:挂起某些死锁进程并抢占他的资源,将这些资源分配给其他死锁进程.</li><li>撤销进程法:撤销部分或者全部死锁进程并剥夺资源</li><li>进程回退法:让一个/多个进程回退到足以回避死锁的地步</li></ol></li></ol><h2 id="内存管理">内存管理</h2><h3 id="内存管理概念">内存管理概念</h3><ol type="1"><li><p>交换与覆盖：覆盖是在同一个程序或者进程中进行的，交换是在不同进程之间进行的。</p></li><li><p>连续分配管理方式</p><ol type="1"><li>单一连续分配：内存分为系统区和用户区，用户区中只有一道用户程序</li><li>固定分区分配：分区大小可以相同也可以不同，会产生内部碎片</li><li>动态分区分配：分配策略：首次适应、邻近适应、最佳适应、最坏适应，会产生外部碎片</li></ol></li><li><p>基本分页存储管理</p><ol type="1"><li><p>系统为每个进程建立一个页表，他记录页面在内存中对应的物理块号</p></li><li><p>基本地址变换</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010241.png" style="zoom:67%;" /></p></li><li><p>快表（TLB）：由页号+块号组成，是高速缓冲存储器</p><p>基本的分页存储需要先到页表查找对应的物理块号然后再去访存，需要经过两次访存。快表根据局部性原理将最近访问过的页面存储起来，直接建立页号+块号的结构，可以快速定位到物理块号</p></li></ol></li><li><p>基本分段存储管理</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230504213228.png" /></p><p>段的共享是通过两个作业的段表中相应表项指向被共享的段的统一物理副本实现的</p></li><li><p>段页式管理</p><ol type="1"><li><p>分页存储能够有效提高内存利用率，分段存储能够反映程序的逻辑结构并有利于段的共享和保护</p></li><li><p>系统为贝格进程建立一张段表，每个分段有一张页表。段表表项至少包含段号、页表长度和页表始址，页表表项至少包括页号和块号</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010326.png" style="zoom: 50%;" /></p></li></ol></li></ol><h3 id="虚拟内存管理">虚拟内存管理</h3><ol type="1"><li><p>基于局部性原理，在程序装入时，仅须将程序当前要运行的少数页面或段先装入内存，而将其余部分暂留在外存，便可启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存容量大得多的存储器，称为虚拟存储器。</p></li><li><p>程序局部性原理</p><ol type="1"><li>时间局部性：由于程序中存在大量的循环操作，程序中的某条指令一旦执行，不久后该指令可能再次执行；某数据被访问过，不久后该数据可能再次被访问。</li><li>空间局部性：一旦程序访问了某个存储单元，不久后其附近的存储单元也会被访问，即程序在一段时间内所访问的地址可能集中在一定的范围之内，因为指令通常是顺序存放、执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li><li>时间局部性通过将近来使用的指令和数据保存到高速缓存中，并使用高速缓存的层次结构实现。空间局部性通常使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上建立了“内存-外存”的两级存储器结构，利用局部性原理实现高速缓存。</li></ol></li><li><p>置换算法</p><ol type="1"><li>最佳置换算法（OPT）：淘汰最长时间内不再被访问的页面</li><li>先进先出算法(FIFO)：淘汰最早进入内存的页面</li><li>最近最久未使用算法（LRU）：淘汰最近最长时间未访问过的页面</li><li><strong>Belady异常</strong>：分配的物理块数增大但缺页率不减反增。只有FIFO有这种现象</li></ol></li></ol><h2 id="文件管理">文件管理</h2><ol type="1"><li><p>文件系统的<strong>逻辑结构</strong>分为无结构文件（流式文件）和有结构文件</p></li><li><p>文件分配磁盘块方式（物理结构）</p><ol type="1"><li><p>连续分配</p></li><li><p>链接分配</p><ol type="1"><li>隐式链接：目录项中含有文件的第一块的指针和最后一块的指针。每个盘块都含有指向下一个盘块的指针</li><li>显式链接：把指针显式的放在一张表中</li></ol></li><li><p>索引分配：设置索引块记录所有分配的块</p></li><li><p>混合索引分配</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010348.png" style="zoom:50%;" /></p></li></ol></li><li><p>虚拟文件系统（VFS）</p><p>为用户提供了文件系统操作的统一接口，屏蔽了不同文件系统带来的差异和操作细节。</p></li></ol><h2 id="输入输出管理">输入/输出管理</h2><ol type="1"><li>设备可以分为块设备和字符设备</li><li>I/O接口指设备控制器，组成如下</li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010408.png" style="zoom:67%;" /></p><ol start="3" type="1"><li>I/O端口指设备控制器中可被CPU直接访问的寄存器，主要包括数据寄存器、状态寄存器、控制寄存器</li><li>端口可以独立编址采用特殊内核指令，也可以统一编址使用内存空间</li><li>I/O控制分为程序直接控制、中断驱动、DMA，参考计组</li><li>I/O软件层次结构<ol type="1"><li>用户层I/O软件：实现与用户交互的接口，用户可直接调用在用户层提供的库函数</li><li>设备独立性软件：使得应用程序独立于具体使用的物理设备</li><li>设备驱动程序：与硬件直接相关，负责具体实现系统对设备发出的操作指令</li><li>中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完毕后再恢复中断现场返回中断程序</li></ol></li><li>设备独立性：用户在编程序时使用的设备与实际设备无关，一个程序应独立于分配给他的某类设备的具体设备，即在用户程序中只指明I/O使用的设备类型即可</li><li>在磁盘上进行一次读写的时间由寻道时间、延迟时间和传输时间决定。<ol type="1"><li>寻道时间：将磁头移动到指定磁道所需要的时间（时间最长）</li><li>延迟时间：磁头定位到某一磁道的扇区所需要的时间</li><li>传输时间：从磁盘读出或向磁盘写入数据所需要的时间</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法提高课</title>
    <link href="/2023/04/27/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%8F%90%E9%AB%98%E8%AF%BE/"/>
    <url>/2023/04/27/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%8F%90%E9%AB%98%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<p>算法提高课的DP题 <span id="more"></span></p><h3 id="最长上升子序列">最长上升子序列</h3><ol type="1"><li><p><a href="https://www.acwing.com/problem/content/484/">482.合唱队形 - AcWing题库</a></p></li><li><p><a href="https://www.acwing.com/problem/content/1014/">1012.友好城市 - AcWing题库</a></p></li></ol><h3 id="背包">背包</h3><ol type="1"><li><ahref="https://www.acwing.com/problem/content/description/280/">278.数字组合 - AcWing题库</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/2023/04/24/School/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/2023/04/24/School/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>编译原理易错知识点 <span id="more"></span></p><h3 id="文法">文法</h3><ol type="1"><li><p>符号串真前缀、真后缀、真子串要求<strong>非空</strong>且不等于原串</p></li><li><p>终结符与非终结符的交集为空集</p></li><li><p>开始符号S至少必须在某个产生式的左部出现一次</p></li><li><p>高级程序设计语言的语法可以用2型文法描述</p></li><li><p>高级程序设计语言的词法可以用3型文法描述</p></li><li><p>使用<strong>正规式</strong>、<strong>正规文法</strong>描述高级程序设计语言的单词结构</p></li></ol><h4 id="正规式">正规式</h4><ol type="1"><li><p>正规文法是3型文法，左线性表示为A-&gt;w或A-&gt;Bw;右线性表示为A-&gt;w或A-&gt;wB</p></li><li><p><span class="math display">\[A=r_1^*=\varepsilon | r_1^+=\varepsilon|r_1r_1^*=\varepsilon|r_1A\]</span></p><p><span class="math display">\[A=r_1^+=r_1r_1^*=r_1(\varepsilon|r_1^+)=r_1|r_1r_1^+=r_1|r_1A\]</span></p><p><span class="math display">\[A=r_1^*r_2=(\varepsilon|r_1^+)r_2=r_2|r_1^+r_2=r_2|r_1r_1^*r_2=r_2|r_1A\]</span></p></li></ol><h3 id="语法">语法</h3><ol type="1"><li>对于LL(1)文法，A的候选式中最多允许1个可以推导出<spanclass="math inline">\(\varepsilon\)</span></li><li>规范规约要求推导过程是对句柄进行规约，也叫最左规约</li><li>算符优先文法：对于一个算符文法，a==b，a&lt;b,a&gt;b至多只有一个成立</li><li>算符优先分析不是一种严格的规范规约，规约对象不是句柄</li><li><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230511115528.png" style="zoom:50%;" /></li><li>素短语：句型中至少含有一个终结符且不含其他素短语的短语</li><li>消除左递归只在自顶向下分析使用，自底向上不需要</li><li>上下文无关文法并不是都能用LR(0)方法进行分析</li><li>对于SLR(1)分析，A-&gt;a.只将Follow（A）集合中的字符进行规约，别的要么移进要么<strong>空着</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2023/04/24/School/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2023/04/24/School/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>计组复习 <span id="more"></span></p><h3 id="计算机系统概述">计算机系统概述</h3><ol type="1"><li>冯诺依曼提出计算机硬件系统由<strong>运算器、存储器、寄存器、输入设备、输出设备</strong>组成，指令和数据以同等地位存储，都以二进制表示，以<strong>运算器</strong>为核心</li><li>冯诺依曼机基本工作方式是控制流驱动，提出的“存储程序”的基本思想是：将事先编制好的程序和原始数据送入主存后才能执行，一旦程序被启动执行，就无须操作人员的干预，计算机会自动逐条执行指令，直至程序执行结束。</li></ol><h3 id="数据的表示和计算">数据的表示和计算</h3><ol type="1"><li><p><strong>大端方式</strong>按从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节存放在前面；<strong>小端方式</strong>按从最低有效字节到最高有效字节的顺序存储数据，即最低有效字节存放在前面。</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010547.png" style="zoom:50%;" /></p></li><li><p>IEEE754的短浮点数由1位符号位、8位阶码、23位尾数组成，其中阶码采用移码，偏移量为127，尾数采用原码表示</p><p>真值表示为<spanclass="math inline">\((-1)^S*1.M*2^{(E-127)}\)</span></p></li></ol><p>### 存储系统</p><ol type="1"><li><p>CPU可以与Cache和主存交换信息。<strong>主存和Cache</strong>之间的数据调动是由硬件自动完成的，<strong>主存和辅存</strong>之间的数据调动是由硬件和操作系统共同完成的(虚拟存储技术)。</p></li><li><p>静态随机存储器（SRAM）：速度快、不需要刷新、用于高速缓存</p><p>动态随机存储器（DRAM）：速度慢，需要刷新，用于内存</p></li><li><p><strong>高位交叉编址</strong>中高位地址表示体号，低位地址表示体内地址。每次存完一个存储体后才存下一个，并行性差</p><p>低位交叉编址中低位地址表示体号，每次存某一个存储体，下次就存下一个存储体，并行性好</p></li><li><p>主存容量的扩展：</p><ol type="1"><li><strong>位扩展</strong>改变字长，将多个存储芯片的地址端、片选端、读写控制端相应并联，数据端分别引出。</li><li>字扩展增加存储体字的数量，不改变字长，通过片选信号进行选择。</li></ol></li><li><p>Cache和主存的映射</p><ol type="1"><li><p>直接映射</p><p>Cache行号=主存块号 mod Cache总行数</p><p>即主存的第<spanclass="math inline">\(1、2^{c}+1、2^{c+1}+1\)</span>块均映射到第0行。当产生冲突时无条件进行置换</p><p>主存块号的低c位正好是要装入的Cache行号，因此给每个Cache行设置一个长为m-c的标记，就可以知道是哪块主存在cache中了</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010509.png" style="zoom: 50%;" /></p></li><li><p>全相联映射</p><p>主存中的每一块可以装入Cache的任意位置。但是需要一行一行的查找</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230629133704.png" style="zoom:50%;" /></p></li><li><p>组相联映射</p><p>组间直接映射，组内全相联映射</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230629133750.png" style="zoom:50%;" /></p></li></ol></li><li><p>Cache写策略</p><ol type="1"><li>写命中<ol type="1"><li>全写法：把数据同时写入Cache和主存</li><li>回写法：只把数据写入Cache同时标记脏页，当块被换出时若为脏页才写回主存</li></ol></li><li>写不命中<ol type="1"><li>写分配法：加载主存的块到Cache中，然后更新Cache块，常与回写法搭配</li><li>非写分配法：只写入主存，不进行调块，常与全写法搭配</li></ol></li></ol></li></ol><h3 id="指令系统">指令系统</h3><ol type="1"><li><p>数据寻址方式</p><ol type="1"><li><p>隐含寻址：在指令中隐含特定操作数的地址</p></li><li><p>立即数寻址：本身就是操作数</p></li><li><p>直接寻址：指令中的地址是主存中真实的地址</p></li><li><p>间接寻址：指令中的地址是数据所在地址的地址，在此基础上可以进行多级寻址</p></li><li><p>寄存器寻址：给出操作数所在的寄存器编号</p></li><li><p>寄存器间接寻址：指向的寄存器给出操作数所在的地址</p></li><li><p>相对寻址：在PC基础上添加一个偏移量</p></li><li><p>基址寻址：基址寄存器BX加上一个偏移量</p><p>基址寄存器面向操作系统，其内容由操作系统或管理程序确定</p></li><li><p>变址寻址：变址寄存器IX加上一个偏移量</p><p>变址寄存器面向用户，可由用户改变</p></li><li><p>堆栈寻址：通过堆栈指针SP寻址</p></li></ol></li><li><p>复杂指令系统：CISC</p><p>精简指令系统：RISC</p></li></ol><h3 id="中央处理器">中央处理器</h3><ol type="1"><li><p>CPU全周期：取指、译码、执行、访存、写回</p></li><li><p>异常和中断</p><ol type="1"><li>异常：故障（除0、缺页等）、自陷（单步调试）、终止（硬件故障）</li><li>中断：可屏蔽中断、不可屏蔽中断</li><li>响应过程<ol type="1"><li>关中断：防止在保存断点和程序状态时被打断</li><li>保存断点和程序状态</li><li>识别异常和中断并转到相应的处理程序</li></ol></li></ol></li><li><p>数据旁路：在流水线设计中不等待ALU写入寄存器同时下一个读寄存器，而是直接把结果输出到ALU的输入</p></li></ol><h3 id="总线">总线</h3><ol type="1"><li>特点<ol type="1"><li>分时：同一时刻只允许有一个部件向总线发送消息</li><li>共享：总线上可以挂接多个部件，各个部件之间互相交换的信息可以通过这个线路进行分时共享，多个部件可以同时从总线上接收相同的消息</li></ol></li></ol><h3 id="问答题">问答题</h3><ol type="1"><li><p>指令和数据均存放在内存中，计算机如何区分他们是指令还是数据</p><p>从时间上讲，取指令发生在取指阶段，取数据发生在执行阶段。从空间上讲，从内存读出的指令流流向控制器（指令寄存器），从内存读出的数据流流向运算器（通用寄存器）。</p></li><li><p>组合逻辑电路和时序逻辑电路有什么区别？组合逻辑电路是具有一组输出和一组输入的非记忆性逻辑电路，它的基本特点是任何时刻的输出信号状态仅取决于该时刻各个输入信号状态的组合，而与电路在输入信号作用前的状态无关。组合电路不含存储信号的记忆单元，输出与输入之间无反馈通路，信号是单向传输的。时序逻辑电路中任意时刻的输出信号不仅和当时的输入信号有关，而且与电路原来的状态有关，这是时序逻辑电路在逻辑功能上的特点。因而时序逻辑电路必然包含存储记忆单元。</p><p>此外，组合逻辑电路没有统一的时钟控制，而时序逻辑电路则必须在时钟节拍下工作。</p></li><li><p>引入总线结构有什么好处？ ①简化了系统结构，便于系统设计制造。②大大减少了连线数目，便于布线，减小体积，提高系统的可靠性。③便于接口设计，所有与总线连接的设备均采用类似的接口。④便于系统的扩充、更新与灵活配置，易于实现系统的模块化。⑤便于设备的软件设计，所有接口的软件对不同的接口地址进行操作。⑥便于故障诊断和维修，同时也能降低成本。</p></li><li><p>计算机系统的五层层次结构</p><p>微程序机器层、传统机器语言层、操作系统层、汇编语言层、高级语言层</p><p>其中后三层称为虚拟机</p></li><li><p>机器字长、指令字长、存储字长</p><p>机器字长：计算机能直接处理的二进制数据位数，为内部寄存器字长等长</p><p>指令字长：一条指令的二进制位数</p><p>存储字长：一个存储单元所能存储的二进制的位数</p><p>三者都必须是字节的整数倍，彼此之间没有直接的制约关系</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线性代数</title>
    <link href="/2023/04/12/School/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <url>/2023/04/12/School/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>线性代数基础知识复习 <span id="more"></span></p><h3 id="矩阵与方程组">矩阵与方程组</h3><ol type="1"><li><p><strong>超定方程组</strong>：方程个数大于未知数个数</p></li><li><p><strong>亚定方程组</strong>：方程个数小于未知数个数</p></li><li><p><strong>首变量</strong>：增广矩阵每一行第一个非零元对应的变量</p></li><li><p><strong>自由变量</strong>：化简过程中跳过的列对应的变量</p></li><li><p><strong>行最简式</strong>：矩阵是行阶梯形的且每一行的第一个非零元是该列唯一的非零元</p><figure><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230412123644.png"alt="行最简式子" /><figcaption aria-hidden="true">行最简式子</figcaption></figure></li><li><p><strong>齐次方程组</strong>：线性方程组右侧全为0</p></li><li><p><strong>奇异</strong>：一个<span class="math inline">\(n\timesn\)</span>的矩阵若不存在乘法逆元。矩阵A是奇异的当且仅当其行列式为0</p></li><li><p>若A是非奇异的，则<spanclass="math inline">\(Ax=0\)</span>仅有平凡解0，A与I行等价</p><p>证明：假设存在<span class="math inline">\(\barx\)</span>是一个非零解，则有<span class="math inline">\(\bar x=I\barx=(A^{-1}A)\bar x=A^{-1}A\bar x=A^{-1}0=0\)</span>.矛盾，得证。</p></li><li><p><strong>LU分解</strong>：将矩阵A分解为一个单位下三角矩阵L和一个严格上三角矩阵U的乘积的过程。</p><p>如果一个<span class="math inline">\(n\timesn\)</span>的矩阵能够仅利用行运算3化简为严格上三角形的，则A有一个LU分解</p></li><li><p>给定<spanclass="math inline">\(R^n\)</span>中的两个向量x,y.则<spanclass="math inline">\(x^Ty\)</span>为标量积或者<strong>内积</strong>，<spanclass="math inline">\(xy^T\)</span>为<strong>外积</strong></p></li><li><p>矩阵求导<ahref="https://zhuanlan.zhihu.com/p/273729929">矩阵求导公式的数学推导（矩阵求导——基础篇）- 知乎 (zhihu.com)</a></p></li></ol><h3 id="行列式">行列式</h3><ol type="1"><li><p><spanclass="math inline">\(a_{ij}\)</span>的<strong>余子式</strong><spanclass="math inline">\(A{ij}=(-1)^{i+j}|M_{ij}|\)</span>,<spanclass="math inline">\(|A|\)</span>可以表示为任意行或列的余子式展开</p><ol type="1"><li>若A为三角形方阵，则A的行列式等于A的对角线元素的乘积。可以用递归证明。</li><li>若A有一行或一列包含的元素值全为0，则|A|为0.</li></ol></li><li><p>交换矩阵的两行或两列会改变行列式的符号</p></li><li><p>某行的倍数加到另一行上不会改变矩阵的行列式</p></li><li><p>可以通过将行列式转化为三角形求值，若最后一行全为0则行列式值为0，否则为对角线元素的乘积</p></li><li><p><strong>伴随矩阵</strong>：将原矩阵的元素用它们的余子式替换，然后将结果矩阵转置。<spanclass="math inline">\(A^{-1}=\frac{adj(A)}{|A|}\)</span></p></li></ol><p>​ <span class="math inline">\(A(adj(A))=det(A)I\)</span>,则有<spanclass="math inline">\(A\frac{adj(A)}{det(A)} =I\)</span>,即可推出上述表达式</p><ol start="6" type="1"><li><p><strong>克拉默法则</strong>:若A为非奇异矩阵，<spanclass="math inline">\(Ax=b\)</span>，则有<spanclass="math inline">\(x_i=\frac{det(A_i)}{det(A)}\)</span>,其中<spanclass="math inline">\(A_i\)</span>为将矩阵A中第i列用b替换得到的矩阵。<span class="math display">\[x=A^{-1}b=\frac{1}{det(A)}adj(A)b\]</span></p><p><span class="math display">\[x_i=\frac{b_1A_{1i}+b_2A_{2i}+...+b_nA_{ni}}{det(A)}=\frac{det(A_i)}{det(A)}\]</span></p></li></ol><h3 id="正交性">正交性</h3><ol type="1"><li><p><strong>最小二乘法</strong>原理：<ahref="https://zhuanlan.zhihu.com/p/38128785">最小二乘法（least sqauremethod） - 知乎 (zhihu.com)</a></p></li><li><p>$x^Ty = | x | | y | cos$ 用余弦定理证明</p></li><li><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230423122641.png" /></p><p>已知<span class="math inline">\(x\)</span>,<spanclass="math inline">\(y\)</span>,则有</p></li></ol><p><span class="math display">\[\alpha=\left \| x \right \|cos\theta=\frac{\left \| x \right \| \left \|y \right \|  cos\theta}{\left \| y \right \|}=x^Ty\]</span></p><p><span class="math display">\[p=\alpha u=\alpha\frac{1}{\left \| y \right \|}y=\frac{x^Ty}{y^Ty}y\]</span></p><ol start="4" type="1"><li>求过一个定点<span class="math inline">\(p\)</span>且与已知向量<spanclass="math inline">\(l\)</span>垂直的平面：对于任意点x,应有<spanclass="math inline">\(\overrightarrow{xp}·l=0\)</span>，即可求得x表达式</li><li>求给定三个点确定的平面：先求得两个向量，然后根据叉乘求出法向量，然后任取一个给定点按4中方式计算即可</li><li>施密特正交化过程：<ahref="https://zhuanlan.zhihu.com/p/136627868">如何理解施密特（Schmidt）正交化- 知乎 (zhihu.com)</a></li></ol><h3 id="特征值">特征值</h3><ol type="1"><li>一个矩阵A是可对角化的，当且仅当A有n个线性无关的特征向量</li></ol>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux总结</title>
    <link href="/2023/04/09/School/Linux_School/Linux%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/09/School/Linux_School/Linux%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 <span id="more"></span></p><h3 id="第一章-基础知识">第一章 基础知识</h3><ol type="1"><li><p>Linux五个子系统的关系（关系图见1-3）</p><p>·进程调度与内存管理之间的关系：这两个子系统互相依赖。在多道程序环境下，程序要运行必须为之创建进程，而创建进程的第一件事，就是要将程序和数据装入内存。</p><p>·进程间通信与内存管理的关系：进程间通信子系统要依赖内存管理支持共享内存通信机制，这种机制允许两个进程除了拥有自己的私有内存，还可存取共同的内存区域。</p><p>·虚拟文件系统与网络接口之间的关系：虚拟文件系统利用网络接口支持网络文件系统(NFS)，也利用内存管理支持RAMDISK设备。</p><p>· 内存管理与虚拟文件系统之间的关系：内存管理利用虚拟文件系统支持交换，交换进程(swapd)定期地由调度程序调度，这也是内存管理依赖于进程调度的唯一原因。当一个进程存取的内存映射被换出时，内存管理向文件系统发出请求，同时，挂起当前正在运行的进程。</p></li><li><p>华为的OpenEuler操作系统是基于Linux内核的开源操作系统</p></li><li><p>GNU与Linux</p><p>Linux与GNU有很大关系。实际上，通常所说的Linux操作系统其实是由Linux内核和GNU操作系统（包括shell、工具集、库等）共同组成的。Linux操作系统的内核由LinusTorvalds在1991年发起开发，而GNU则在此之前就开始了基础软件和工具的开发。LinusTorvalds将GNU的类Unix系统和他的内核结合起来，形成了我们今天所说的Linux操作系统。</p></li></ol><h3 id="第二章-进程">第二章 进程</h3><ol type="1"><li><p>Linux2.4与2.6在进程堆栈上的区别</p><p>使用thread_info代替了task_struct</p><p>在2.6版本中，内存管理存在SLUB、SLAB等多种机制，可以更加灵活地管理内存。而在2.4版本中，则只支持较为简单的伙伴系统（BuddySystem）来管理内存</p></li></ol><p>​</p><h3 id="第五章">第五章</h3><ol type="1"><li><p>hw_interrupt_type结构中的域都是函数指针，它们指向了一些用来操作中断服务例程的函数，采用的是<strong>面向对象</strong>的方法</p></li><li><p>为什么引入下半部，下半部的组织</p><p>下半部通常使用软中断（Softirq）实现，在内核中被组织为一组可重入的函数队列，并伴随着一个标志位，表示是否有下半部需要处理。当某个中断处理程序需要执行下半部任务时，它只需要将任务添加到下半部队列中，然后向内核中断处理程序返回。当CPU空闲时，内核会检查下半部队列是否有任务需要执行，并按照优先级顺序逐个执行。这种机制使得中断处理程序可以更快地退出，从而提高系统的吞吐量和响应速度。</p></li></ol><h3 id="第六章">第六章</h3><ol type="1"><li><p>为什么要划分VMA</p><p>Linux2.4 将用户地址空间划分成多个 VMA区域的主要原因是为了实现虚拟内存管理机制，即将虚拟地址映射到物理地址，从而提升系统的内存利用率和安全性。由于每个VMA区域都有不同的访问权限和属性，可以灵活地为不同的代码和数据分配合适的内存空间，从而避免了其中一个区域出现问题影响整个系统的情况。</p></li><li><p>以write()为例,VFS是如何与EXT2结合的</p><p>以 ext2 文件系统为例，当应用程序执行 write() 系统调用时，内核会首先在VFS 层进行处理。VFS 会查找并获得要写入文件的 inode结构，并将其缓存到本地内存中，以便之后高效地访问。VFS 层还会根据 inode的地址，找到对应的靠近磁盘缓存中的 buffer_head数据结构，建立起文件系统中每个块和缓存的映射关系，进而实现读写请求与具体物理设备之间的转换。</p><p>接下来，VFS 会将写入数据的请求传递给 ext2文件系统，以处理这个文件系统的特定细节，如块的分配、解析目录等。ext2文件系统首先检查写入数据的可用空间是否足够，如果空间不足，需要进行扩展块的分配和逻辑分区的重分配等操作。如果数据空间足够，则会将数据写入相应的块中，并更新inode结构和超级块等元数据信息。更新元数据时，需要确保在出现断电等异常情况时，文件系统仍然可以保持一致性，并使用日志文件（journal）来记录必要的元数据信息，以备后续恢复。</p><p>最后，当 ext2 文件系统完成数据写入操作后，VFS层会返回相应的结果给应用程序，并清除 inode缓存等临时数据，以便之后更高效地进行访问。整个过程中，VFS层扮演了一个统一接口的角色，将 Linux系统与具体文件系统解耦，并实现了文件读写等基本操作的抽象，从而方便了内核的开发工作</p></li><li><p>什么是设备文件？什么是设备驱动程序？</p><p>在 Linux2.4中，设备文件是一种特殊的文件类型，它用于与系统中的各种物理或虚拟设备进行交互。设备文件一般存储在/dev目录下，其中包括了很多常用设备（如硬盘、显示器、键盘等）的设备文件。</p><p>设备文件可以分为两种类型：块设备文件和字符设备文件。块设备文件通常用于访问磁盘等存储设备，而字符设备文件则用于访问串口、键盘鼠标等非存储类设备。</p><p>而设备驱动程序是指控制设备功能的软件程序，通过设备驱动程序可以控制设备的输入、输出、中断处理等操作。设备驱动程序一般是由操作系统内核或者用户态应用程序所提供的。</p><p>在 Linux2.4中，设备驱动程序通常被编译为模块的形式，称为内核模块。这些模块可以动态地加载到内核中，从而实现对特定设备的控制和管理。当设备文件被打开时，内核将自动使用与该设备相关的设备驱动程序，以实现对设备的操作。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件系统</title>
    <link href="/2023/04/06/School/Linux_School/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/04/06/School/Linux_School/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 第七章.文件系统 <span id="more"></span></p><h3 id="文件系统的特征">文件系统的特征</h3><ol type="1"><li>Linux文件是无结构的字符流式文件</li><li>外部设备也被看作文件</li></ol><h3 id="虚拟文件系统vfs">虚拟文件系统VFS</h3><ol type="1"><li>虚拟文件系统VFS是面向对象的设计</li><li>向上提供给用户接口，向下要求各文件系统分别实现各接口</li><li>四种通用文件模型：超级块对象、索引节点对象、文件对象、目录项对象</li></ol><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230406212830.png" /></p><p>进程和文件系统之间数据结构的关系</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux中断处理</title>
    <link href="/2023/04/05/School/Linux_School/Linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
    <url>/2023/04/05/School/Linux_School/Linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 第五章.中断处理 <span id="more"></span></p><h3 id="快中断与慢中断">快中断与慢中断</h3><ol type="1"><li><p>在中断响应时，OS规定要关闭中断允许位，直到中断处理程序中调用了开中断指令STI为止</p></li><li><p>快中断对应上半部处理程序，慢中断对应下半部处理程序</p></li><li><p>处理慢中断前：需保存所有寄存器的内容,而快中断处理仅要保存部分被修改的寄存器</p></li><li><p>慢中断处理时不屏蔽其它中断信号（开中断）,而快中断处理时会屏蔽所有其它中断（关中断）</p></li><li><p>慢中断处理完毕后，通常不立即返回被中断的进程，而是进入调度程序重新调度，调度结果未必是被中断的原进程运行(是抢先式调度)。快中断处理完毕后，通常恢复现场返回被中断的进程继续执行(是非抢先式调度)。</p></li><li><p>可以将上半部看做是一个用来实现“登记中断”功能的函数，即当一个中断发生时，它就把中断例程的下半部分挂接到该设备的下半部分执行队列中，然后不再做其他事情</p></li></ol><h3 id="中断请求队列">中断请求队列</h3><ol type="1"><li>hw_interrupt_type结构中的域都是函数指针，它们指向了一些用来操作中断服务例程的函数，采用的是<strong>面向对象</strong>的方法。</li><li>几个重要数据结构之间的关系</li><li><img src=https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230405163958.png width="80%"></li></ol><h3 id="中断的注册与安装">中断的注册与安装</h3><ol type="1"><li>中断服务例程在安装之前，需先用函数<strong>request_irq()</strong>进程注册，以向系统申请一个中断描述符结构空间和一个中断号。</li><li>调用函数<strong>setup_irq()</strong>把中断服务例程安装到中断请求队列中。该函数的主要作用是为中断服务例程分配一个irqaction结构，并把指针handler指向中断服务例程的函数。</li><li>在中断结束之后，关闭申请中断的设备时，调用<strong>free_irq()</strong>释放所申请的中断号。</li><li><strong>do_IRQ()</strong>负责处理所有的外部设备中断.在do_IRQ的末尾，调用<strong>iqr_exit()</strong>,它的一项重要工作中就使启动中断的下半部分</li></ol><h3 id="linux的时间系统">Linux的时间系统</h3><ol type="1"><li>Jiffies是一个全局变量，用于存放自系统启动以来产生的总的节拍数。给全局变量jiffies加1这项工作是紧急的，因此它由上半部来完成；而其余各项，则因它们不那么紧急，由下半部分完成</li><li>上半部函数：timer_interrupt() 下半部函数：timer_bh()</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统调用</title>
    <link href="/2023/04/05/School/Linux_School/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2023/04/05/School/Linux_School/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 第四章.系统调用 <span id="more"></span></p><h3 id="系统调用功能">系统调用功能</h3><ol type="1"><li>Linux利用i386体系结构的软件中断实现系统调用，即调用了int$0x80汇编指令。</li><li>系统调用处理程序的入口是system_call()</li></ol><h3 id="系统调用和中断处理的区别">系统调用和中断处理的区别</h3><p>中断必须完成当前指令后才进入中断，而系统调用可以在一条指令中进行</p><h3 id="系统调用的参数传递">系统调用的参数传递</h3><ol type="1"><li>系统调用使用寄存器来传递参数.要传递的参数有：系统调用号、系统调用所需的参数</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树状数组&amp;线段树</title>
    <link href="/2023/04/03/Algorithm/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2023/04/03/Algorithm/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>Acwing蓝桥杯树状数组和线段树内容 <span id="more"></span></p><h3 id="树状数组">树状数组</h3><p>可以实现在增加某个位置一个值的情况下快速求前缀和,时间复杂度O(logn)</p><p>例题：<ahref="https://www.acwing.com/problem/content/description/1267/">1265.数星星 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> a[N],tr[N];<br><span class="hljs-type">int</span> n,m;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;-x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i)) tr[i] += y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i&gt;=<span class="hljs-number">1</span>;i-=<span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-comment">// 初始化操作</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">add</span>(i,a[i]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> k,x,y;<br>        cin&gt;&gt;k&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-built_in">query</span>(y) - <span class="hljs-built_in">query</span>(x<span class="hljs-number">-1</span>)&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(x,y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线段树">线段树</h3><h4 id="求动态区间和">求动态区间和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> l,r;<br>    <span class="hljs-type">int</span> val;<br>&#125;node[<span class="hljs-number">4</span>*N];<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    node[u].val = node[<span class="hljs-number">2</span>*u].val + node[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) node[u] = &#123;l,r,a[l]&#125;;<br>    <span class="hljs-keyword">else</span>&#123;<br>        node[u] = &#123;l,r&#125;;<br>        <span class="hljs-type">int</span> mid = l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u,l,mid);<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>        <span class="hljs-built_in">pushup</span>(u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(node[u].l &gt;= l &amp;&amp; node[u].r &lt;= r) <span class="hljs-keyword">return</span> node[u].val;<br>    <span class="hljs-type">int</span> mid = node[u].l + node[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l&lt;=mid) sum += <span class="hljs-built_in">query</span>(<span class="hljs-number">2</span>*u,l,r);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) sum += <span class="hljs-built_in">query</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>,l,r);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(node[u].l == node[u].r) node[u].val += y;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> mid = node[u].l + node[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(x&lt;=mid) <span class="hljs-built_in">modify</span>(<span class="hljs-number">2</span>*u,x,y);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>,x,y);<br>        <span class="hljs-built_in">pushup</span>(u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> k,x,y;<br>        cin&gt;&gt;k&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,x,y)&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,x,y);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求区间最大值">求区间最大值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> l,r;<br>    <span class="hljs-type">int</span> val;<br>&#125;node[<span class="hljs-number">4</span>*N];<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    node[u].val = <span class="hljs-built_in">max</span>(node[<span class="hljs-number">2</span>*u].val, node[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) node[u] = &#123;l,r,a[l]&#125;;<br>    <span class="hljs-keyword">else</span>&#123;<br>        node[u] = &#123;l,r&#125;;<br>        <span class="hljs-type">int</span> mid = l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u,l,mid);<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>        <span class="hljs-built_in">pushup</span>(u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(node[u].l &gt;= l &amp;&amp; node[u].r &lt;= r) <span class="hljs-keyword">return</span> node[u].val;<br>    <span class="hljs-type">int</span> mid = node[u].l + node[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l&lt;=mid) sum = <span class="hljs-built_in">query</span>(<span class="hljs-number">2</span>*u,l,r);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) sum = <span class="hljs-built_in">max</span>(sum,<span class="hljs-built_in">query</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>,l,r));<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    <br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>        <span class="hljs-comment">// printf(&quot;%d\n&quot;,query(1,x,y));</span><br>        cout&lt;&lt;<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,x,y)&lt;&lt;endl;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>硬件课设</title>
    <link href="/2023/04/02/School/%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/"/>
    <url>/2023/04/02/School/%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/</url>
    
    <content type="html"><![CDATA[<p>记录硬件课设学习过程 <span id="more"></span></p><h3 id="实验一-pl端设计">实验一 PL端设计</h3><ol type="1"><li>新建工程，编写好.v文件</li><li>Synthesis -&gt; Run Synthesis 检查是否具有语法错误</li><li>新建simulation sources，编写仿真文件</li><li>将仿真文件右键设置为top文件，Simulation -&gt; Run Simulation进行仿真</li><li>I/O Ports 设置引脚</li><li>Program and Debug -&gt; Generate Bitstream 产生字节流</li><li>Open Hardware Manager 将程序烧到电路板</li></ol><h3 id="实验二-ps端设计">实验二 PS端设计</h3><ol type="1"><li><p>新建工程，IP Integrator -&gt; Create Block Design</p></li><li><p>查找zynq，选择第一个</p></li><li><p>双击芯片，添加预配置文件</p></li><li><p>MIO Configuration -&gt; I/O Peripherals -&gt; GPIO -&gt; EMIOGPIO (Width) 打勾，选择引脚数量</p></li><li><p>将GPIO_0 DDR FIXED_IO三个引脚右键Make External引出</p></li><li><p>点击Validate Design 审查是否具有错误</p><figure><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/image-20230402143111433.png"alt="审查错误" /><figcaption aria-hidden="true">审查错误</figcaption></figure></li><li><p>右键IP文件选择Generate Output Product, 点击Generate</p><figure><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230402143328.png"alt="生成输出" /><figcaption aria-hidden="true">生成输出</figcaption></figure></li><li><p>右键IP文件点击Create HDL Wrapper进行封装</p></li><li><p>Run Synthesis</p></li><li><p>Add Source -&gt; Add or create constraints新建约束文件并填写</p></li><li><p>Generate Bitstream</p></li><li><p>File-&gt;Export-&gt;Export Hardware-&gt;Includebitstream</p></li><li><p>Launch SDK</p></li><li><p>在SDK中File-&gt;New-&gt;Application Project-&gt;Next-&gt;emptyProject</p></li><li><p>bsp文件夹/system.mss中有一些测试示例，选择gpiops的ImportExamples</p></li><li><p>修改文件逻辑</p></li><li><p>在Vivado中Open Target 连接电路板</p></li><li><p>在SDK中Run as -&gt; Launch on Hardware(System Debugger)烧到电路板上</p></li></ol><h3 id="实验三-ps-pl已有ip">实验三 PS + PL已有IP</h3><ol type="1"><li><p>同实验二的1~3，然后打开AXI总线并在Interrupts勾选FabricInterrupts,展开后在PL-PS InterruptPorts勾选IRQ_F2P[15:0]开启中断</p></li><li><p>添加另一个IP查找GPIO，添加后双击勾选Enable DualChannel开启双使能通道</p></li><li><p>对于两个GPIO宽度都设置为4(LED和按键都是占4个引脚)</p></li><li><p>勾选Enable Interrupt，点击确定</p></li><li><p>引出DDR FIXED_IO GPIO DPIO2</p></li><li><p>点击页面上方的自动连接将IP和ZYNQ连接起来，然后手动将ZYNQ和IP的中断接口连起来</p></li><li><p>同实验二6~12</p></li><li><p>File-&gt;new-&gt;Board Support Package 全默认即可</p></li><li><p>system.mss中勾选gpio的前两个示例代码</p></li><li><p>同实验二后续</p></li></ol><h3 id="实验四-ps-pl自定义ip">实验四 PS + PL自定义IP</h3><ol type="1"><li><p>新建工程编准备好.v文件</p></li><li><p>Tools-&gt;Create and Package New IP-&gt;Create a new AXI4peripheral-&gt;Edit IP</p></li><li><p>添加资源，将需要封装为IP的文件（记作A）引入进来</p></li><li><p>将文件中的module声明复制到自动产生文件（记作B）的末尾 userlogic处，同时指定端口的连接</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230402200933.png" /></p></li><li><p>在Users to add portshere处添加IP的输入输出，注意reg要改为wire</p></li></ol><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230402200643.png" /></p><ol start="6" type="1"><li><p>在top层两处添加端口</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230402201224.png" /></p></li></ol><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230402201255.png" /></p><ol start="7" type="1"><li>Run Synthesis</li><li>在Package IP - AXI_SMG-&gt;File Groups页面点击Merge changes fromFile Grops Wizard,在下面一个页面进行同样的操作</li><li>点击最下面Review and Package完成IP打包</li><li>新建项目，IP Integrator-&gt;Create Block Design打开IP设计界面</li><li>在Project-&gt;Project Setting中的IP页面中添加IP的路径</li><li>预配值Zynq，勾选AXI总线（默认已勾选）</li><li>引出DDR FIXED_IO led_out a_g key_in四个引脚，然后点击自动连接</li><li>同实验三后续</li></ol><h3 id="正点原子">正点原子</h3><ol type="1"><li>嵌入式开发流程</li></ol><p><img src= https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230417123616.png width="50%"></p><ol start="2" type="1"><li>GPIO是一个外设，用来对器件的引脚作观测(input)以及控制(output)。</li><li>MIO(MultiuseI/O),将来自PS外设X和静态存储器接口的访问多路复用到PS的引脚上。</li></ol><h3 id="oled">OLED</h3><ol type="1"><li>引脚：<ol type="1"><li><p>SDA:C17</p></li><li><p>SCLK:D15</p></li><li><p>CS:C15</p></li><li><p>GPIO[0]:D16(DC)</p></li><li><p>GPIO[1]:F17(RES)</p></li></ol></li></ol><h3 id="pm2.5">PM2.5</h3><p>TX u4</p><p>RX v4</p><p>GPIO y4</p><h3 id="asr">ASR</h3><p>UART0_TX Y13</p><p>UART0_RX Y14</p><h3 id="顶层">顶层</h3><h4 id="oled-1">OLED</h4><ol type="1"><li><p>SDA:C17</p></li><li><p>SCLK:D15</p></li><li><p>CS:C15</p></li><li><p>GPIO[0]:D16(DC)</p></li><li><p>GPIO[1]:F17(RES)</p></li></ol><h4 id="asr-1">ASR</h4><ol type="1"><li><p>RX:R15</p><p>"小植"：0x01</p><p>“温湿度”：0x32(50)</p><p>"空气"：0x33(51)</p><p>"甲醛"：0x34(52)</p></li></ol><h4 id="pm">PM</h4><ol type="1"><li>RX:W13</li></ol><h4 id="jq">JQ</h4><ol type="1"><li>RX:V14</li></ol><h4 id="tts">TTS</h4><ol type="1"><li>TX:T16</li></ol><h3 id="dht11">DHT11</h3><ol type="1"><li>dht11_data:AB21</li></ol>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程调度</title>
    <link href="/2023/04/01/School/Linux_School/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <url>/2023/04/01/School/Linux_School/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 第二章.进程调度 <span id="more"></span></p><h4 id="进程调度策略">进程调度策略</h4><ol type="1"><li><p>分为普通进程和实时进程，普通进程的优先级动态变化，实时进程的优先级刚开始就设置好并固定。</p></li><li><p>普通进程采用动态优先级策略，SCHED_OTHER;实时进程采用SCHED_FIFO或者SCHED_RR</p></li><li><p>如果一个进程是实时进程，则其子孙进程也是实时进程</p></li></ol><h4 id="进程调度依据">进程调度依据</h4><ol type="1"><li>依据weight值选择最大的运行<ol type="1"><li>对于普通进程，weight值首先赋值为剩余的时钟数，若上次也是在当前CPU上运行的则weight增加一个常量，若不需要切换内存则weight再加1，然后还受人为控制的nice的影响(weight+=20-nice)</li><li>对于实时进程，weight=1000+rt_priority</li></ol></li><li>在一个单独时期里，每个进程有一个指定时间片，用完就会被抢占，没用完可以多次调度运行</li><li>所有进程用完其时间片，一个时期才结束</li><li>创建新进程时，子进程继承父进程的一半剩余时间片。子进程结束运行时，剩余时间片也将归还给父进程</li></ol><h3 id="进程调度时机">进程调度时机</h3><p>分为被动调度和主动调度</p><ol type="1"><li><p>被动调度：</p><ol type="1"><li>适用情况<ol type="1"><li>当前进程用完CPU时间片</li><li>一个进程被唤醒且优先级高于当前进程</li></ol></li><li>调度时机<ol type="1"><li>调用sched_setscheduler()或sched_yield()系统调用时</li><li>进程用户态进程前</li><li>系统调用执行结束，控制由核心态返回用户态前</li></ol></li></ol></li><li><p>主动调度</p><p>当进程所需资源无法满足而必须立即阻塞时，直接调度schedule()</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搜索与图论</title>
    <link href="/2023/03/30/Algorithm/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
    <url>/2023/03/30/Algorithm/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>树、图 <span id="more"></span></p><h3 id="dfs回溯">DFS(回溯)</h3><p>深度优先搜索，和回溯同模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> select[])</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(满足某条件)&#123;<br>        result.<span class="hljs-built_in">push_back</span>(a);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:select[])&#123;<br>        做出选择;<br>        <span class="hljs-built_in">DFS</span>(a,select);<br>        撤销选择;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓扑排序">拓扑排序</h3><p>本质为宽搜，通过结点的入度判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,M=N*<span class="hljs-number">2</span>;<br><br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx;<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">int</span> n,m;<br>vector&lt;<span class="hljs-type">int</span>&gt;res;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">add</span>(a,b);<br>        d[b] ++;<br>    &#125;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(d[i] == <span class="hljs-number">0</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(i);<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br>            <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=h[t];j!=<span class="hljs-number">-1</span>;j=ne[j])&#123;<br>                <span class="hljs-type">int</span> k = e[j];<br>                d[k]--;<br>                <span class="hljs-keyword">if</span>(d[k] == <span class="hljs-number">0</span>)&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(k);<br>                    q.<span class="hljs-built_in">push</span>(k);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()!=n) cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : res)&#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/image-20230331164952535.png"alt="最短路算法" /><figcaption aria-hidden="true">最短路算法</figcaption></figure><h3 id="dijkstra">Dijkstra</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> st[N];<br><br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;cnt&lt;n<span class="hljs-number">-1</span>;cnt++)&#123;<br><span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!st[i] &amp;&amp; (t == <span class="hljs-number">-1</span> || d[t]&gt;d[i])) t = i;<br>&#125;<br>st[t] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>    d[j] = <span class="hljs-built_in">min</span>(d[j],d[t] + g[t][j]);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">if</span>(d[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> d[n]; <br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>g[a][b] = <span class="hljs-built_in">min</span>(g[a][b],c);<br>&#125;<br><br>cout&lt;&lt;<span class="hljs-built_in">dijkstra</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化的dijkstra">堆优化的Dijkstra</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N],e[N],ne[N],w[N],idx;<br><span class="hljs-type">int</span> st[N];<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; q;<span class="hljs-comment">// 距离并不用于更新，而用于排序</span><br>    <br>q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-keyword">auto</span> mint = q.<span class="hljs-built_in">top</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-type">int</span> t = mint.second;<br>        <span class="hljs-keyword">if</span>(t == n) <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 能快一些</span><br><span class="hljs-keyword">if</span>(st[t]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 可能存在重边</span><br>st[t] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br><span class="hljs-type">int</span> j = e[i];<br><span class="hljs-keyword">if</span>(d[j] &gt; d[t] + w[i]) &#123;<br>d[j] = d[t] + w[i];<br>q.<span class="hljs-built_in">push</span>(&#123;d[j],j&#125;);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(d[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> d[n]; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>e[idx] = b;<br>w[idx] = c;<br>ne[idx] = h[a];<br>h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-built_in">add</span>(a,b,c);<br>&#125;<br><br>cout&lt;&lt;<span class="hljs-built_in">dijkstra</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="belman_fold">belman_fold</h3><p>用于求路径包含不大于k条边且可能包含负权边的单源最短路径</p><p>例题：<ahref="https://ac.nowcoder.com/acm/contest/52244/F?&amp;headNav=acm">F-坐火车_2023年中国高校计算机大赛-团队程序设计天梯赛（GPLT）上海理工大学校内选拔赛（同步赛)(nowcoder.com)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br><span class="hljs-type">int</span> a,b,w;<br><br>&#125;edge[N];<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> d[N],backup[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br><br><span class="hljs-built_in">memcpy</span>(backup,d,<span class="hljs-keyword">sizeof</span> d);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>    <span class="hljs-type">int</span> a = edge[j].a;<br>    <span class="hljs-type">int</span> b = edge[j].b;<br>    <span class="hljs-type">int</span> w = edge[j].w;<br>    <br>d[b] = <span class="hljs-built_in">min</span>(d[b],backup[a] + w);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> d[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>edge[i] = &#123;a,b,c&#125;;<br>&#125;<br><br><span class="hljs-type">int</span> res = <span class="hljs-built_in">bellman_ford</span>();<br><span class="hljs-keyword">if</span>(res &gt; <span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;res;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="spfa">SPFA</h3><p>存在负权边的单源最短路算法，大多数情况下优于dijkstra</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> h[N],w[N],e[N],ne[N],idx;<br><span class="hljs-type">int</span> d[N],used[N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>e[idx] = b;<br>w[idx] = c;<br>ne[idx] = h[a];<br>h[a] = idx++; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>used[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>used[t] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br><span class="hljs-type">int</span> j = e[i];<br><span class="hljs-keyword">if</span>(d[j] &gt; d[t] + w[i])&#123;<br>d[j] = d[t] + w[i];<br><span class="hljs-keyword">if</span>(!used[j])&#123;<br>q.<span class="hljs-built_in">push</span>(j); <br>used[j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> d[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-built_in">add</span>(a,b,c);<br>&#125;<br><br><span class="hljs-built_in">spfa</span>();<br><span class="hljs-keyword">if</span>(d[n] &gt; <span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;d[n];<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="spfa判断负环">SPFA判断负环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> h[N],w[N],e[N],ne[N],idx;<br><span class="hljs-type">int</span> d[N],used[N],cnt[N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>e[idx] = b;<br>w[idx] = c;<br>ne[idx] = h[a];<br>h[a] = idx++; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">// 不一定从1开始，要全加进去</span><br>    used[i] = <span class="hljs-number">1</span>;<br>    q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>used[t] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br><span class="hljs-type">int</span> j = e[i];<br><span class="hljs-keyword">if</span>(d[j] &gt; d[t] + w[i])&#123;<br>d[j] = d[t] + w[i];<br>cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 如果边数为n，则有n+1个点，则必有一个点经过了两次，则必存在负环（若正环则不会走）</span><br><span class="hljs-keyword">if</span>(cnt[j]&gt;=n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(!used[j])&#123;<br>q.<span class="hljs-built_in">push</span>(j); <br>used[j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-built_in">add</span>(a,b,c);<br>&#125;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>()) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="floyd">Floyd</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> g[N][N];<br><br><span class="hljs-type">int</span> n,m,k;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                g[i][j] = <span class="hljs-built_in">min</span>(g[i][j],g[i][k] + g[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(i==j) g[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> g[i][j] = INF;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b],c);<br>    &#125;<br>    <br>    <span class="hljs-built_in">floyd</span>();<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(g[a][b] &gt; <span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;g[a][b]&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="prim">Prim</h3><p>求最小生成树</p><p>注意不事先将1号点放进去所以要特判多处i=0的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> d[N],used[N];<br><br><br><span class="hljs-type">int</span> n,m;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!used[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || d[t] &gt; d[j])) t = j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &amp;&amp; d[t] == INF) <span class="hljs-keyword">return</span> INF;<br>        <br>        <span class="hljs-keyword">if</span>(i) res += d[t];<br>        used[t] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>            <span class="hljs-keyword">if</span>(!used[k])&#123;<br>                d[k] = <span class="hljs-built_in">min</span>(d[k],g[t][k]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b] = g[b][a] = <span class="hljs-built_in">min</span>(g[a][b],c);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">prim</span>();<br>    <span class="hljs-keyword">if</span>(res == INF) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="kruskal">Kruskal</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> p[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>    <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Edge &amp;e)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> w &lt; e.w;<br>    &#125;<br>&#125;edge[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,res=<span class="hljs-number">0</span>;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        edge[i] = &#123;a,b,c&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(edge,edge+m);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        p[i] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a = edge[i].a;<br>        <span class="hljs-type">int</span> b = edge[i].b;<br>        <span class="hljs-type">int</span> w = edge[i].w;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a) != <span class="hljs-built_in">find</span>(b))&#123;<br>            res += w;<br>            p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>            cnt++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(cnt != n<span class="hljs-number">-1</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程管理</title>
    <link href="/2023/03/30/School/Linux_School/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2023/03/30/School/Linux_School/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 第三章.进程管理 <span id="more"></span></p><h4 id="进程的类别">进程的类别</h4><ol type="1"><li><p>TASK_RUNNING: 正在运行/就绪</p></li><li><p>TASK_TRACED: 供调试使用</p></li><li><p>TASK_INTERRUPTIBLE: 可被信号或中断唤醒进入就绪队列（）</p></li><li><p>TASK_UNINTERRUPTIBLE：等待资源不可被其他进程中断，例如在等待打印机资源，则在获得之前不可进入就绪状态</p></li><li><p>TASK_STOPPED: 被调试暂停，或收到SIGSTOP信号</p></li><li><p>TASK_ZOMBIE:正在终止（已经释放内存、文件等资源，但是父进程还未收到通知，描述符未释放）</p></li><li><p>TASK_DEAD:已退出且不需要父进程回收的进程的状态</p></li></ol><p><img src=https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/image-20230330143205241.png width="80%"></p><h4 id="进程的系统堆栈">进程的系统堆栈</h4><ol type="1"><li><p>Linux2.4的PCB于所属进程的内核堆栈放在一起，为每个进程分配8KB大小的内存区域。</p></li><li><p>进程描述符task_struct位于8k低端，内核堆栈位于8k高端</p></li></ol><p><img src=https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/image-20230331205455782.png width="80%"></p><ol start="3" type="1"><li>操作系统可以使用current宏通过esp指针获得PCB的指针，具体方式为将低13位清零得到起始空间地址</li></ol><p>current = (struct task_struct*) STACK_POINTE &amp; 0xFFFE000</p><h4 id="进程的链表结构">进程的链表结构</h4><ol type="1"><li><p>Linux进程通过双向链表连接。</p></li><li><p>对于TASK_RUNNING状态的进程，引入运行队列(runningqueue)，使用list_head实现，本质为双链表</p></li><li><p>对于非TASK_RUNNING状态的进程，引入等待队列，其可以细分很多种分别维护，本质为双循环链表</p></li><li><p>为了快速定位进程，以PID为关键字建立了哈希表，可以通过PID快速找到进程</p></li></ol><h4 id="进程控制">进程控制</h4><ol type="1"><li><p>sys_fork() sys_vfork() sys_clone()均可创建新进程</p></li><li><p>对于sys_fork()，除了代码段外父子进程不共享任何东西</p></li><li><p>对于sys_clone(),有选择地对父进程进行赋值，如果不提供标志则和fork()一样。</p></li><li><p>对于sys_vfork(),子进程能够共享父进程的内存地址空间，使用复制指针的方法使子进程与父进程资源实现共享。父进程在子进程运行时会被堵塞，保证子进程先运行。出现COW后就基本不再用了。</p></li><li><p>wait()wait_pid()用于检测子进程是否终止。如果子进程仍在运行则父进程堵塞，如果子进程终止则返回子进程的终止状态，如果没有子进程则出错返回</p></li><li><p>exit()释放大部分进程占用的资源，终止进程。进程进入ZOMBIE状态后内核调用exit_notify()通知父进程调用wait()判断子进程状态并通过release()回收子进程的task_struct，#### 进程与线程</p></li><li><p>进程是资源分配的基本单位，线程是处理器调度的独立单位，但是在Linux中弱化了这样的关系，不明确区分进程线程。</p></li><li><p>Linux认为线程是一组共享资源的进程</p></li><li><p>clone()可以创建内核支持的用户线程，对内核可见且由内核调度</p></li><li><p>pthread_create()由基于POSIX标准的线程库创建的用户线程</p></li><li><p>对于多线程进程，组内所有线程的tgid都相等且等于父进程的pid</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法中的数学</title>
    <link href="/2023/03/22/Algorithm/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    <url>/2023/03/22/Algorithm/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>算法竞赛中常用的数学知识 <span id="more"></span></p><h3 id="判断质数">判断质数</h3><p>若d能够整除n，则<spanclass="math inline">\(\frac{n}{d}\)</span>也能整除n，因此只需要枚举到<spanclass="math inline">\(d\leq\frac{n}{d}\)</span>即可，时间复杂度<spanclass="math inline">\(O(\sqrt{n})\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_Prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=x/i;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分解质因数">分解质因数</h3><p>定义：不考虑排列顺序的情况下，每个正整数都能够以唯一的方式表示成它的质因数的乘积。<span class="math inline">\(n=p_1^{a_1} * p_2^{a_2}*p_3^{a_3}.....p_n^{a_n}\)</span></p><p>其中<span class="math inline">\(p_i\)</span>为质数</p><p>大于根号n的质因数最多只有一个，因为如果有两个，他们的乘积就大于n了。因此只需要判断到x/i即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<span class="hljs-comment">// 满足此条件的一定是质数</span><br>        &#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, s ++ ;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="埃筛质数">埃筛质数</h3><p>思路为从前往后枚举，将所有当前值的倍数筛掉即可，时间复杂度约为<spanclass="math inline">\(O(n)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> used[N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!used[i])&#123;<br>            cnt++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+i;j&lt;=n;j+=i)&#123;<br>                used[j] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125; <br>    &#125;    <br>    <br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin&gt;&gt;n;<br>    cout&lt;&lt;<span class="hljs-built_in">work</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线性筛质数">线性筛质数</h3><p>没懂，比埃筛效率高</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求所有约数">求所有约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=x/i;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span>(i!=x/i) res.<span class="hljs-built_in">push_back</span>(x/i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求约数个数约数之和">求约数个数&amp;约数之和</h3><p>假设$x=p_1<sup>{<em>{1}}p_2^{</em>{2}}...p_n</sup>{_{n}} $,则</p><p>约数个数为<spanclass="math inline">\((\alpha_1+1)(\alpha_2+1)...(\alpha_n+1)\)</span>，因为每个约数都可以表示为<spanclass="math inline">\(p_1^{\beta_{1}}p_2^{\beta_{2}}...p_n^{\beta_{n}}\)</span>,则所有个数即为所有<spanclass="math inline">\(\beta\)</span>的组合数</p><p>约数之和为<spanclass="math inline">\((P_1^0+P_1^1+...P_1^{\alpha_1})(P_2^0+P_2^1+...P_2^{\alpha_2})...(P_n^0+P_n^1+...P_n^{\alpha_n})\)</span>，因为这些展开即是上述的各个组合</p><p><a href="https://www.acwing.com/problem/content/872/">870. 约数个数 -AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; primes;<br><br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                x /= i;<br>                primes[i] ++ ;<br>            &#125;<br><br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) primes[x] ++ ;<br>    &#125;<br><br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : primes) res = res * (p.second + <span class="hljs-number">1</span>) % mod;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/873/">871. 约数之和 -AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;primes;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=x/i;i++)&#123;<br>            <span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>)&#123;<br>                x/=i;<br>                primes[i]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) primes[x]++;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:primes)&#123;<br>        <span class="hljs-type">int</span> a = t.first;<br>        <span class="hljs-type">int</span> b = t.second;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> temp = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(b--) temp = (a*temp+<span class="hljs-number">1</span>)%mod;<br>        res = res*temp%mod;<br>    &#125;<br>    <br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大公约数">最大公约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最小公倍数">最小公倍数</h3><p>在#include&lt;algorithm&gt;后可以使用__gcd(a,b)求最小公倍数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a*b/<span class="hljs-built_in">gcd</span>(a,b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="欧拉函数">欧拉函数</h3><p><span class="math inline">\(1-N\)</span>中与<spanclass="math inline">\(N\)</span>互质的数的个数称为欧拉函数</p><p>若<spanclass="math inline">\(N=P_1^{a_1}P_2^{a_2}...P_m^{a_m}\)</span>,则<spanclass="math inline">\(f(N)=N*\frac{p_1-1}{p1}*\frac{p_2-1}{p2}*...*\frac{p_m-1}{pm}\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res = res / i * (i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) res = res / x * (x - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>筛法求欧拉函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">int</span> euler[N];           <span class="hljs-comment">// 存储每个数的欧拉函数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_eulers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    euler[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            primes[cnt ++ ] = i;<br>            euler[i] = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> t = primes[j] * i;<br>            st[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>)<br>            &#123;<br>                euler[t] = euler[i] * primes[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            euler[t] = euler[i] * (primes[j] - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速幂">快速幂</h3><p>求 m^k mod p，时间复杂度 O(logk)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k)&#123;<br>        <span class="hljs-keyword">if</span>(k&amp;<span class="hljs-number">1</span>)&#123;<br>            res = (LL) res*a%p;<br>        &#125;<br>        k&gt;&gt;=<span class="hljs-number">1</span>;<br>        a=(LL)a*a%p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求组合数">求组合数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j ++ )<br>            <span class="hljs-keyword">if</span> (!j) c[i][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % mod;<br></code></pre></td></tr></table></figure><h3 id="龟速乘">龟速乘</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LL <span class="hljs-title">qadd</span><span class="hljs-params">(LL a, LL b, LL p)</span></span>&#123;<br>    LL res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res = (res+a)%p;<br>        a = (a+a) % p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯题集</title>
    <link href="/2023/03/22/Algorithm/LanQiao/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E9%9B%86/"/>
    <url>/2023/03/22/Algorithm/LanQiao/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>蓝桥杯好题 <span id="more"></span></p><h3 id="回溯">回溯</h3><p><ahref="https://www.acwing.com/activity/content/problem/content/1551/">1209带分数</a></p><h3 id="卡尔可夫链式问题">卡尔可夫链式问题</h3><h5 id="砖块---acwing题库"><ahref="https://www.acwing.com/problem/content/3780/">3777. 砖块 -AcWing题库</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string s;<br><span class="hljs-type">int</span> n,t;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(string &amp;temp, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(temp[x] == <span class="hljs-string">&#x27;W&#x27;</span>) temp[x] = <span class="hljs-string">&#x27;B&#x27;</span>;<br>    <span class="hljs-keyword">else</span> temp[x] = <span class="hljs-string">&#x27;W&#x27;</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;<br>    string temp = s;<br>    vector&lt;<span class="hljs-type">int</span>&gt;res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(temp[i] != c)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">update</span>(temp,i);<br>            <span class="hljs-built_in">update</span>(temp,i+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(temp[n<span class="hljs-number">-1</span>] != c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    cout&lt;&lt;res.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!res.<span class="hljs-built_in">empty</span>())&#123;<br>        cout&lt;&lt;res.<span class="hljs-built_in">back</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        res.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        cin&gt;&gt;n;<br>        cin&gt;&gt;s;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">check</span>(<span class="hljs-string">&#x27;W&#x27;</span>) &amp;&amp; !<span class="hljs-built_in">check</span>(<span class="hljs-string">&#x27;B&#x27;</span>)) cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="费解的开关---acwing题库"><ahref="https://www.acwing.com/problem/content/97/">95. 费解的开关 -AcWing题库</a></h5><h5 id="翻硬币---acwing题库"><ahref="https://www.acwing.com/problem/content/1210/">1208. 翻硬币 -AcWing题库</a></h5><h3 id="博弈论">博弈论</h3><p><ahref="https://www.lanqiao.cn/problems/2061/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;difficulty=30&amp;tags=2022">灭鼠先锋</a></p><h3 id="前缀和">前缀和</h3><p><ahref="https://www.lanqiao.cn/problems/2109/learning/?page=2&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;difficulty=30&amp;tags=2022">统计子矩阵</a></p><p>70</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">510</span>][<span class="hljs-number">510</span>],s[<span class="hljs-number">510</span>][<span class="hljs-number">510</span>];<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            s[i][j] = s[i<span class="hljs-number">-1</span>][j] + s[i][j<span class="hljs-number">-1</span>] - s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;x++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;y&lt;=m;y++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y;j&lt;=m;j++)&#123;<br>                    <span class="hljs-type">int</span> x1 = i - x + <span class="hljs-number">1</span>;<br>                    <span class="hljs-type">int</span> y1 = j - y + <span class="hljs-number">1</span>;<br>                    <span class="hljs-type">int</span> sum = s[i][j] - s[x1<span class="hljs-number">-1</span>][j] - s[i][y1<span class="hljs-number">-1</span>] + s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>];<br>                    <span class="hljs-keyword">if</span>(sum &lt;= k) ans++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>100</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">501</span>;<br><span class="hljs-type">int</span> a[maxn][maxn];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 请在此输入您的代码</span><br><span class="hljs-type">int</span> n,m,k;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i++)<br>&#123;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br> &#123;<br>   cin &gt;&gt; a[i][j];<br>   <span class="hljs-comment">//为了后面计算方便，维护纵向前缀和</span><br>   <span class="hljs-comment">//a[i][j]表示前i行第j列之和</span><br>   a[i][j] += a[i<span class="hljs-number">-1</span>][j];<br> &#125;<br>&#125;<br><span class="hljs-comment">//遍历上边界和下边界</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<span class="hljs-comment">//遍历上边界</span><br>&#123;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ii = i; ii &lt;= n; ii++)<span class="hljs-comment">//遍历下边界</span><br> &#123;<br>   <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1</span>;<span class="hljs-comment">//滑动窗口的左右端点</span><br>   <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-comment">//区间前缀和：[l,r]区间的累计和</span><br>   <span class="hljs-keyword">for</span>(r = <span class="hljs-number">1</span>; r &lt;= m; r++)<span class="hljs-comment">//遍历右端点，根据区间和调整左端点</span><br>   &#123;<br>     sum += a[ii][r] - a[i<span class="hljs-number">-1</span>][r];<span class="hljs-comment">//加上右端点处的和</span><br>     <span class="hljs-keyword">while</span>(sum &gt; k)<span class="hljs-comment">//区间和了，左端点右移，区间变小</span><br>     &#123;<br>       sum -= a[ii][l] - a[i<span class="hljs-number">-1</span>][l];<span class="hljs-comment">//减去移出去的左端点处的和</span><br>       l++;<br>     &#125;<br>     ans += r - l + <span class="hljs-number">1</span>;<span class="hljs-comment">//方法数就是找到的区间大小累加</span><br>   &#125;<br> &#125;<br>&#125;<br>cout &lt;&lt; ans &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分应用">二分应用</h3><p><ahref="https://www.acwing.com/problem/content/description/732/">730.机器人跳跃问题 - AcWing题库</a></p><p><a href="https://www.acwing.com/problem/content/1229/">1227. 分巧克力- AcWing题库</a></p><h3 id="空间换时间">空间换时间</h3><p><a href="https://www.acwing.com/problem/content/1223/">1221. 四平方和- AcWing题库</a></p><h3 id="填空">填空</h3><p><ahref="https://www.lanqiao.cn/problems/598/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tags=2022,省赛">冒泡排序次数</a></p><p><ahref="https://www.lanqiao.cn/problems/597/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tags=2022,省赛">跑步锻炼</a></p><p><ahref="https://www.lanqiao.cn/problems/1463/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tags=2022,省赛">货物摆放</a></p><p><ahref="https://www.lanqiao.cn/problems/646/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tags=2022,省赛">等差素数列</a></p><h3 id="动态规划">动态规划</h3><p><a href="https://www.acwing.com/problem/content/1214/">1212. 地宫取宝- AcWing题库</a></p><h3 id="深搜">深搜</h3><p><ahref="https://www.lanqiao.cn/problems/506/learning/?problem_list_id=1&amp;page=1&amp;sort=students_count">作物杂交- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2010</span>;<br><br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q[N];<br><span class="hljs-type">int</span> w[N],have[N],f[N];<br><span class="hljs-type">int</span> n,m,k,t;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;q[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-type">int</span> need1 = q[u][i].first;<br>    <span class="hljs-type">int</span> need2 = q[u][i].second;<br>    <span class="hljs-keyword">if</span>(!have[need1]) <span class="hljs-built_in">dfs</span>(need1);<br>    <span class="hljs-keyword">if</span>(!have[need2]) <span class="hljs-built_in">dfs</span>(need2);<br>    <span class="hljs-keyword">if</span>(have[need1] &amp;&amp; have[need2])&#123;<br>      have[u] = <span class="hljs-number">1</span>;<br>      f[u] = <span class="hljs-built_in">min</span>(f[u],<span class="hljs-built_in">max</span>(f[need1],f[need2]) + <span class="hljs-built_in">max</span>(w[need1], w[need2]));<br>      <span class="hljs-comment">// return f[u];</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> f[u];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> f);<br>  cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;t;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<br>    cin&gt;&gt;w[i];<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>    <span class="hljs-type">int</span> x;<br>    cin&gt;&gt;x;<br>    have[x] = <span class="hljs-number">1</span>;<br>    f[x] = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>    <span class="hljs-type">int</span> a,b,c;<br>    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>    q[c].<span class="hljs-built_in">push_back</span>(&#123;a,b&#125;);<br>  &#125;<br><br>  cout&lt;&lt;<span class="hljs-built_in">dfs</span>(t);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图论">图论</h3><p><a href="https://www.acwing.com/problem/content/1490/">1488. 最短距离- AcWing题库</a></p><h3 id="模拟">模拟</h3><p><a href="https://www.acwing.com/problem/content/3212/">3209. 集合竞价- AcWing题库</a></p>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯小知识</title>
    <link href="/2023/03/20/Algorithm/LanQiao/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/03/20/Algorithm/LanQiao/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>总结蓝桥杯常见的小考点 <span id="more"></span></p><h3 id="判断闰年">判断闰年</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(x%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;x%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span> || x%<span class="hljs-number">400</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="蛇形数组">蛇形数组</h3><p>注意算a[20,20]要满足j&gt;=20 &amp;&amp; i-j+1 &gt;=20,i要算到40多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">300</span>][<span class="hljs-number">300</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> reverse = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">50</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(reverse)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++) &#123;<br>                a[j][i - j + <span class="hljs-number">1</span>] = cnt++;<br>                cout&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;i-j+<span class="hljs-number">1</span>&lt;&lt;endl;<br>            &#125;<br>            reverse = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++) &#123;<br>                a[i - j + <span class="hljs-number">1</span>][j] = cnt++;<br>                cout&lt;&lt;i-j+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;endl;<br>            &#125;<br>            reverse = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;a[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSP 重点</title>
    <link href="/2023/03/14/Algorithm/CCF-CSP/CSP-%E9%87%8D%E7%82%B9/"/>
    <url>/2023/03/14/Algorithm/CCF-CSP/CSP-%E9%87%8D%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 重要题目 <span id="more"></span></p><h3 id="买菜---acwing题库"><ahref="https://www.acwing.com/problem/content/3266/">3263. 买菜 -AcWing题库</a></h3><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230528104827.png" style="zoom: 80%;" /></p><p>两组区间求相交的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2010</span>;<br><br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; a[N],b[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;p,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p.second &lt; q.first || q.second &lt; p.first) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(p.second,q.second) - <span class="hljs-built_in">max</span>(p.first,q.first);<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i].first&gt;&gt;a[i].second;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;b[i].first&gt;&gt;b[i].second;<br>    &#125;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            sum += <span class="hljs-built_in">get</span>(a[i],b[j]);<br>        &#125;<br>    &#125;<br><br>    cout&lt;&lt;sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出行计划---acwing题库">[4455. 出行计划 - AcWing题库</h3><p><a href="https://www.acwing.com/problem/content/4458/"></a></p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230528104748.png" style="zoom:67%;" /></p><p>很隐蔽的差分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,k;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> t,c;<br>        cin&gt;&gt;t&gt;&gt;c;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,t-k-c+<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> r = t-k;<br>        <span class="hljs-keyword">if</span>(r &gt; <span class="hljs-number">0</span>)&#123;<br>            a[l]++;<br>            a[r+<span class="hljs-number">1</span>]--;<br>        &#125;<br>    <br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++) a[i] = a[i] + a[i<span class="hljs-number">-1</span>];<br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        cout&lt;&lt;a[x]&lt;&lt;endl;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="化学方程式---acwing题库"><ahref="https://www.acwing.com/problem/content/description/3287/">3284.化学方程式 - AcWing题库</a></h3><p>String处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> unordered_map&lt;string, <span class="hljs-type">int</span>&gt; MPSI;<br><br><span class="hljs-function">MPSI <span class="hljs-title">dfs</span><span class="hljs-params">(string&amp; str, <span class="hljs-type">int</span>&amp; u)</span></span><br><span class="hljs-function"></span>&#123;<br>    MPSI res;<br>    <span class="hljs-keyword">while</span> (u &lt; str.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">if</span> (str[u] == <span class="hljs-string">&#x27;(&#x27;</span>)<br>        &#123;<br>            u ++ ;  <span class="hljs-comment">// 过滤掉 &#x27;(&#x27;</span><br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(str, u);<br>            u ++ ;  <span class="hljs-comment">// 过滤掉 &#x27;)&#x27;</span><br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>, k = u;<br>            <span class="hljs-keyword">while</span> (k &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(str[k])) k ++ ;<br>            <span class="hljs-keyword">if</span> (k &gt; u)<br>            &#123;<br>                cnt = <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(u, k - u));<br>                u = k;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: t)<br>                res[c.x] += c.y * cnt;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[u] == <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> k = u + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (k &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; str[k] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; str[k] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) k ++ ;<br>            <span class="hljs-keyword">auto</span> key = str.<span class="hljs-built_in">substr</span>(u, k - u);<br>            u = k;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (k &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(str[k])) k ++ ;<br>            <span class="hljs-keyword">if</span> (k &gt; u)<br>            &#123;<br>                cnt = <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(u, k - u));<br>                u = k;<br>            &#125;<br>            res[key] += cnt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">MPSI <span class="hljs-title">work</span><span class="hljs-params">(string str)</span></span><br><span class="hljs-function"></span>&#123;<br>    MPSI res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; str[j] != <span class="hljs-string">&#x27;+&#x27;</span>) j ++ ;<br>        <span class="hljs-keyword">auto</span> item = str.<span class="hljs-built_in">substr</span>(i, j - i);<br>        i = j;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (k &lt; item.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(item[k])) k ++ ;<br>        <span class="hljs-keyword">if</span> (k) cnt = <span class="hljs-built_in">stoi</span>(item.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k));<br>        <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(item, k);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: t)<br>            res[c.x] += c.y * cnt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        string str;<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> k = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;=&#x27;</span>);<br>        <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">work</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k)), right = <span class="hljs-built_in">work</span>(str.<span class="hljs-built_in">substr</span>(k + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">if</span> (left == right) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Y&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;N&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/3212/">3209. 集合竞价- AcWing题库</a></p><p>模拟</p><p><ahref="https://www.acwing.com/problem/content/description/3222/">3219.模板生成系统 - AcWing题库</a></p><p>字符串处理</p><h3 id="日期模拟题">日期模拟题</h3><p>现在，给你 a,b,c 和 y1,y2，希望你输出从公元 y1 年到公元 y2年间的每年的 a月的第 b 个星期 c 的日期。已知 18501年 1 月 1日是星期二。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//日期题套路，12个月，开13个位置，第0个为占位符</span><br><span class="hljs-type">int</span> months[<span class="hljs-number">13</span>] = &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span><br>&#125;;<br><br><span class="hljs-comment">//判断某一年是否是闰年的函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">is_leap</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span> || (year % <span class="hljs-number">4</span>  == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//求某月有多少天的函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_days</span><span class="hljs-params">(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(month == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> months[month] + <span class="hljs-built_in">is_leap</span>(year); <span class="hljs-comment">//如果是2月的话返回天数和是否是闰年，如果是闰年2月份+1天</span><br>    <span class="hljs-keyword">return</span> months[month]; <span class="hljs-comment">//不是2月份则直接返回天数即可</span><br>&#125;<br><br><span class="hljs-comment">//星期一到星期日用0~6表示</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b, c, y1, y2;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; y1 &gt;&gt; y2;<br><br>    <span class="hljs-type">int</span> days = <span class="hljs-number">0</span>; <span class="hljs-comment">//表示过了多少天</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> year = <span class="hljs-number">1850</span>; year &lt;= y2; year ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> month = <span class="hljs-number">1</span>; month &lt;= <span class="hljs-number">12</span>; month ++ )<br>        &#123;<br>            <span class="hljs-keyword">if</span>(year &gt;= y1 &amp;&amp; month == a)<br>            &#123;<br>                <span class="hljs-type">int</span> w = (<span class="hljs-number">1</span> + days) % <span class="hljs-number">7</span>; <span class="hljs-comment">//先算一下这个月的1月1号是星期几,1850年1月1日是星期二，下标为1</span><br>                <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">//统计一下当前是枚举到的第几个星期c</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d = <span class="hljs-number">1</span>; d &lt;= <span class="hljs-built_in">get_days</span>(year, month); d ++ ) <span class="hljs-comment">//枚举一下这个月的所有天</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span>(w == c - <span class="hljs-number">1</span>) <span class="hljs-comment">//星期的下标从0开始，所以要-1，如星期七的下标是6</span><br>                    cnt ++ ;<span class="hljs-comment">//星期c的个数++</span><br>                    <span class="hljs-keyword">if</span>(cnt == b) <span class="hljs-comment">//如果星期c的个数等于b的话，满足条件，输出</span><br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d/%02d/%02d\n&quot;</span>, year, month, d);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    w = (w + <span class="hljs-number">1</span>) % <span class="hljs-number">7</span>; <span class="hljs-comment">//每过一天，星期需要往后错一位</span><br>                &#125;<br>                <span class="hljs-keyword">if</span>(cnt &lt; b) <span class="hljs-comment">//枚举完这个月后，如果星期c出现的次数小于b，说明没有第b个星期c，输出none</span><br>                &#123;<br>                    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;none&quot;</span>);<br>                &#125;<br>            &#125;<br>            days += <span class="hljs-built_in">get_days</span>(year, month); <span class="hljs-comment">//这个月过完之后加上这个月过的天数</span><br>        &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛-Python</title>
    <link href="/2023/03/14/Algorithm/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B-Python/"/>
    <url>/2023/03/14/Algorithm/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B-Python/</url>
    
    <content type="html"><![CDATA[<p>讲解在算法竞赛中python的常见用法 <span id="more"></span></p><h3 id="标准输入">标准输入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输入样例：</span><br><span class="hljs-number">11</span><br><span class="hljs-number">9</span> <span class="hljs-number">10</span><br><span class="hljs-number">10</span> <span class="hljs-number">10</span><br><span class="hljs-number">11</span> <span class="hljs-number">10</span><br><span class="hljs-number">12</span> <span class="hljs-number">10</span><br><span class="hljs-number">13</span> <span class="hljs-number">10</span><br><span class="hljs-number">11</span> <span class="hljs-number">9</span><br><span class="hljs-number">11</span> <span class="hljs-number">8</span><br><span class="hljs-number">12</span> <span class="hljs-number">9</span><br><span class="hljs-number">10</span> <span class="hljs-number">9</span><br><span class="hljs-number">10</span> <span class="hljs-number">11</span><br><span class="hljs-number">12</span> <span class="hljs-number">11</span><br><br><span class="hljs-comment"># 代码</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>points = []<br>res = [<span class="hljs-number">0</span>]*<span class="hljs-number">5</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    s = <span class="hljs-built_in">input</span>()<br>    x,y = [<span class="hljs-built_in">int</span>(m) <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> s.split()]<br></code></pre></td></tr></table></figure><h3 id="多输入但不知道多少">多输入但不知道多少</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        a,b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().strip().split())<br>    <span class="hljs-keyword">except</span> EOFError:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSP 20</title>
    <link href="/2023/03/13/Algorithm/CCF-CSP/CSP-20/"/>
    <url>/2023/03/13/Algorithm/CCF-CSP/CSP-20/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 第20届 <span id="more"></span></p><h3 id="称检测点查询"><ahref="https://www.acwing.com/problem/content/3295/">1.称检测点查询</a></h3><p>pair模板的小根堆 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,px,py;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; q;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;px&gt;&gt;py;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-type">int</span> d = (px-x)*(px-x) + (py-y)*(py-y);<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(d,i));<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>        cout&lt;&lt;q.<span class="hljs-built_in">top</span>().second&lt;&lt;endl;<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>c++重载运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,px,py;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> d;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point&amp; t) <span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">if</span>(d!=t.d) <span class="hljs-keyword">return</span> d&lt;t.d;<br>        <span class="hljs-keyword">return</span> id &lt; t.id;<br>    &#125;<br>&#125;q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (px-x)*(px-x) + (py-y)*(py-y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;px&gt;&gt;py;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        q[i] = &#123;x,y,<span class="hljs-built_in">distance</span>(x,y),i+<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(q,q+n);<br>    <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>        cout&lt;&lt;q[i].id&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="风险人群筛查"><ahref="https://www.acwing.com/problem/content/3296/">2.风险人群筛查</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,k,t,xl,yd,xr,yu;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> res[<span class="hljs-number">2</span>];<br>    cin&gt;&gt;n&gt;&gt;k&gt;&gt;t&gt;&gt;xl&gt;&gt;yd&gt;&gt;xr&gt;&gt;yu;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> max_cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;t;j++)&#123;<br>            <span class="hljs-type">int</span> x,y;<br>            cin&gt;&gt;x&gt;&gt;y;<br>            <span class="hljs-keyword">if</span>(x&gt;=xl &amp;&amp; x&lt;=xr &amp;&amp; y&gt;=yd &amp;&amp; y&lt;=yu)&#123;<br>                cnt++;<br>                <span class="hljs-keyword">if</span>(cnt &gt; max_cnt)&#123;<br>                    max_cnt = cnt;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(cnt &gt; max_cnt)&#123;<br>                    max_cnt = cnt;<br>                &#125;<br>                cnt = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(max_cnt) res[<span class="hljs-number">0</span>]++;<br>        <span class="hljs-keyword">if</span>(max_cnt&gt;=k) res[<span class="hljs-number">1</span>]++;<br>    &#125;<br>    <br>    cout&lt;&lt;res[<span class="hljs-number">0</span>]&lt;&lt;endl&lt;&lt;res[<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL,排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSP 22</title>
    <link href="/2023/03/11/Algorithm/CCF-CSP/CSP-22/"/>
    <url>/2023/03/11/Algorithm/CCF-CSP/CSP-22/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 第22届 <span id="more"></span></p><h3 id="灰度直方图"><ahref="https://www.acwing.com/problem/content/3414/">1.灰度直方图</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">256</span>;<br><br><span class="hljs-type">int</span> h[N];<br><span class="hljs-type">int</span> n,m,l;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;l;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            h[x] ++ ;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<br>        cout&lt;&lt;h[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻域均值"><ahref="https://www.acwing.com/problem/content/3415/">2.邻域均值</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">610</span>;<br><span class="hljs-type">int</span> n,l,r,t;<br><span class="hljs-type">int</span> res;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> sum[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;l,&amp;r,&amp;t);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>        &#125;·<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            sum[i][j] = sum[i<span class="hljs-number">-1</span>][j] + sum[i][j<span class="hljs-number">-1</span>] - sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-type">int</span> left,right,top,bottom;<br>            left = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,i-r);<br>            right = <span class="hljs-built_in">min</span>(n,i+r);<br>            top = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,j-r);<br>            bottom = <span class="hljs-built_in">min</span>(n,j+r);<br>            <span class="hljs-type">int</span> nums = (right-left+<span class="hljs-number">1</span>)*(bottom-top+<span class="hljs-number">1</span>);<br>            <span class="hljs-type">float</span> avg = sum[bottom][right] - sum[top<span class="hljs-number">-1</span>][right] - sum[bottom][left<span class="hljs-number">-1</span>] + sum[top<span class="hljs-number">-1</span>][left<span class="hljs-number">-1</span>];<br>            avg /= nums;<br>            <span class="hljs-keyword">if</span>(avg &lt;= t) res++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二维前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSP 23</title>
    <link href="/2023/03/11/Algorithm/CCF-CSP/CSP-23/"/>
    <url>/2023/03/11/Algorithm/CCF-CSP/CSP-23/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 202212 第23届题目 <span id="more"></span></p><h3 id="收集卡牌"><ahref="https://www.acwing.com/problem/content/4012/">4. 收集卡牌</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">17</span>,M = <span class="hljs-number">1</span>&lt;&lt;N;<span class="hljs-comment">// M代表状态数</span><br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">double</span> p[N];<br><span class="hljs-type">double</span> f[M][N*<span class="hljs-number">5</span>+<span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> state,<span class="hljs-type">int</span> coins,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">double</span>&amp; v = f[state][coins];<br>    <span class="hljs-keyword">if</span>(v&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> v;<br>    <span class="hljs-keyword">if</span>(coins &gt;= m*r) <span class="hljs-keyword">return</span> v = <span class="hljs-number">0</span>;<br>    <br>    v = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(state&gt;&gt;i&amp;<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">// 判断第i位是否为1</span><br>            v += p[i]*(<span class="hljs-built_in">dp</span>(state,coins+<span class="hljs-number">1</span>,r) + <span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            v += p[i]*(<span class="hljs-built_in">dp</span>(state | (<span class="hljs-number">1</span>&lt;&lt;i),coins,r<span class="hljs-number">-1</span>) + <span class="hljs-number">1</span>);<span class="hljs-comment">// 把第i位赋值为1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;p[i]);<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.10lf\n&quot;</span>, <span class="hljs-built_in">dp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n));<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制状态表示</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSP 201312</title>
    <link href="/2023/03/08/Algorithm/CCF-CSP/CSP-0/"/>
    <url>/2023/03/08/Algorithm/CCF-CSP/CSP-0/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 201312 第0届题目 <span id="more"></span></p><h3 id="最大的矩形"><ahref="https://www.acwing.com/problem/content/3197/">3.最大的矩形</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;h[i];<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i - l &gt;= <span class="hljs-number">0</span> &amp;&amp; h[i-l] &gt;= h[i]) l++;<br>        <span class="hljs-keyword">while</span>(i+r&lt;n&amp;&amp;h[i+r]&gt;=h[i]) r++;<br>        res = <span class="hljs-built_in">max</span>(res,h[i]*(l+r<span class="hljs-number">-1</span>));<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有趣的数"><ahref="https://www.acwing.com/problem/content/3198/">4. 有趣的数</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// c&#123;n-1&#125;&#123;k&#125;(k-1)(n-k-1)</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> c[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!j) c[i][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> c[i][j] = (c[i<span class="hljs-number">-1</span>][j] + c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) % N;<br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n<span class="hljs-number">-2</span>;i++)&#123;<br>        sum = (sum + c[n<span class="hljs-number">-1</span>][i]*(i<span class="hljs-number">-1</span>)*(n-i<span class="hljs-number">-1</span>))%N;<br>    &#125;<br>    <br>    cout&lt;&lt;sum;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划(中) 线性DP</title>
    <link href="/2023/02/25/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%AD-%E7%BA%BF%E6%80%A7DP/"/>
    <url>/2023/02/25/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%AD-%E7%BA%BF%E6%80%A7DP/</url>
    
    <content type="html"><![CDATA[<p>动态规划中的线性DP</p><span id="more"></span><h3 id="数字三角形">数字三角形</h3><h5 id="自上而下">自上而下</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">1</span>) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + a[i][j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == i) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][j]) + a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">-1e7</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        res = <span class="hljs-built_in">max</span>(res,dp[n][i]);<br>    &#125;<br><br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="自下而上">自下而上</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j],dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]) + a[i][j];<br>        &#125;<br>    &#125;<br><br>    cout&lt;&lt;dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长上升子序列">最长上升子序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(N,<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[i]&gt;a[j]) dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=n;i++) res = <span class="hljs-built_in">max</span>(res,dp[i]);<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSP 27</title>
    <link href="/2023/02/24/Algorithm/CCF-CSP/CSP-27/"/>
    <url>/2023/02/24/Algorithm/CCF-CSP/CSP-27/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 202212 第27届题目 <span id="more"></span></p><h3 id="如此编码">如此编码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N],c[N],l[N],b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    c[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        c[i] = c[i<span class="hljs-number">-1</span>]*a[i];<br>        l[i] = m%c[i];<br>        l[i] = l[i] - l[i<span class="hljs-number">-1</span>];<br>        b[i] = l[i]/c[i<span class="hljs-number">-1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="何以包邮">何以包邮</h3><h5 id="回溯暴搜">回溯暴搜</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">40</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">100000</span>];<br><span class="hljs-type">int</span> res = <span class="hljs-number">1e9</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> sum)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i==n)&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt;=m)&#123;<br>            res = <span class="hljs-built_in">min</span>(res,sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,sum);<br>    <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,sum+a[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dp">DP</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">40</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">100000</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        sum += a[i];<br>    &#125;<br><br>    <span class="hljs-type">int</span> target = sum - m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=target;j&gt;=a[i];j--)&#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-a[i]]+a[i]);<br>        &#125;<br>    &#125;<br><br>    cout&lt;&lt;sum - dp[target];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSP 28</title>
    <link href="/2023/02/24/Algorithm/CCF-CSP/CSP-28/"/>
    <url>/2023/02/24/Algorithm/CCF-CSP/CSP-28/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 202212 第28届题目 <span id="more"></span></p><h3 id="训练计划"><ahref="http://118.190.20.162/view.page?gpid=T159">2.训练计划</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N],p[N],l[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;p[i];<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">min</span><span class="hljs-params">(m+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]!=<span class="hljs-number">0</span>) min[i] = min[a[i]] + p[a[i]];<br>    &#125;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">max</span>(m+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        max[i] = n - p[i] + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> early = <span class="hljs-number">10</span> - max[i] + <span class="hljs-number">1</span> + l[i];<br>            l[a[i]] = l[a[i]]&gt;early?l[a[i]]:early;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        max[i] -= l[i];<br>        <span class="hljs-keyword">if</span>(max[i]&lt;<span class="hljs-number">0</span>) sign = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cout&lt;&lt;min[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(sign)&#123;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            cout&lt;&lt;max[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常用STL</title>
    <link href="/2023/02/23/Algorithm/%E5%B8%B8%E7%94%A8STL/"/>
    <url>/2023/02/23/Algorithm/%E5%B8%B8%E7%94%A8STL/</url>
    
    <content type="html"><![CDATA[<p>介绍常用的STL <span id="more"></span></p><h3 id="vector">vector</h3><p>变长数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">// 初始化</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(M,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N));<span class="hljs-comment">// 二维vector初始化</span><br>a.<span class="hljs-built_in">size</span>();<br>a.<span class="hljs-built_in">empty</span>();<br>a.<span class="hljs-built_in">front</span>();<br>a.<span class="hljs-built_in">back</span>();<br>a.<span class="hljs-built_in">push_back</span>();<br>a.<span class="hljs-built_in">pop_back</span>();<br><br>vec.<span class="hljs-built_in">erase</span>(a.<span class="hljs-built_in">begin</span>()+i); <span class="hljs-comment">// 删除</span><br></code></pre></td></tr></table></figure><h3 id="pair">pair</h3><p>二元组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br>pair&lt;<span class="hljs-type">int</span>,string&gt; a;<br>a.first; a.second;<br>a = (<span class="hljs-number">20</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>pair&lt;<span class="hljs-type">int</span>,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; b;<span class="hljs-comment">// 三元组</span><br><br><span class="hljs-comment">//按照第一个元素进行排序:</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;a[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;b)</span></span>&#123;<span class="hljs-comment">// 从大到小排序</span><br>    <span class="hljs-keyword">return</span> a.first &gt; b.first;<br>&#125;<br><span class="hljs-built_in">sort</span>(a,a+<span class="hljs-number">10</span>,cmp);<br><span class="hljs-comment">// pair模板的unordered_set</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair_hash</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function">    <span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;T1,T2&gt; <span class="hljs-type">const</span> &amp; pair)</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-type">size_t</span> h1 = <span class="hljs-built_in">hash</span>&lt;T1&gt;()(pair.first);<br>        <span class="hljs-type">size_t</span> h2 = <span class="hljs-built_in">hash</span>&lt;T2&gt;()(pair.second);<br>        <span class="hljs-keyword">return</span> h1^h2;<br>    &#125;<br>&#125;;<br><br>unordered_set&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,pair_hash&gt; pset;<br></code></pre></td></tr></table></figure><h3 id="string">string</h3><p>字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">string a = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>cout&lt;&lt; a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">// &quot;bc&quot; 代表起始下标为1，长度为2的子串</span><br>a.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;cd&quot;</span>) <span class="hljs-comment">// O(n^2)复杂度,如果没找到返回string::npos</span><br>a.<span class="hljs-built_in">replace</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// 将字符串从2开始后面2位替换为空串</span><br><span class="hljs-built_in">stoi</span>(<span class="hljs-string">&quot;123&quot;</span>)<span class="hljs-comment">// string转int</span><br><span class="hljs-built_in">stof</span>(<span class="hljs-string">&quot;1.23&quot;</span>)<span class="hljs-comment">// string转float</span><br><span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">char</span> *ptr = <span class="hljs-built_in">strstr</span>(s,<span class="hljs-string">&quot;cd&quot;</span>);<br>cout&lt;&lt; ptr - s;<span class="hljs-comment">// O(n)复杂度查找子串返回起始位置，需要用#include&lt;cstring&gt;</span><br><span class="hljs-built_in">to_string</span>(<span class="hljs-type">int</span>)<span class="hljs-comment">// int转string</span><br><br></code></pre></td></tr></table></figure><h3 id="queue">queue</h3><p>队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>();<span class="hljs-comment">// 向队尾插入</span><br>q.<span class="hljs-built_in">front</span>();<span class="hljs-comment">// 返回队头元素</span><br>q.<span class="hljs-built_in">back</span>();<span class="hljs-comment">// 返回队尾元素</span><br>q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 弹出对头元素，无返回值</span><br></code></pre></td></tr></table></figure><h3 id="priority_queue">priority_queue</h3><p>优先队列（堆）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">//默认大根堆</span><br><br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap;<span class="hljs-comment">//小根堆定义</span><br><br>q.<span class="hljs-built_in">push</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>q.<span class="hljs-built_in">top</span>();<br><br><span class="hljs-comment">// 使用pair模板</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII<br>priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;<span class="hljs-comment">// 按pair第一个元素排序</span><br>q.<span class="hljs-built_in">push</span>(&#123;d,i&#125;);<span class="hljs-comment">// 插入</span><br><br></code></pre></td></tr></table></figure><p>### deque</p><p>双端队列,效率低，慎用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;<span class="hljs-type">int</span>&gt; d;<br>d.<span class="hljs-built_in">front</span>();<br>d.<span class="hljs-built_in">back</span>();<br>d.<span class="hljs-built_in">push_back</span>();d.<span class="hljs-built_in">pop_back</span>()<br>d.<span class="hljs-built_in">push_front</span>();d.<span class="hljs-built_in">pop_front</span>();<br></code></pre></td></tr></table></figure><h3 id="setmultiset">set/multiset</h3><p>集合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>&gt; s;<br>s.<span class="hljs-built_in">insert</span>();<br>s.<span class="hljs-built_in">find</span>();<br>s.<span class="hljs-built_in">count</span>();<br>s.<span class="hljs-built_in">erase</span>();<span class="hljs-comment">// 删除所有对应的值</span><br>s.<span class="hljs-built_in">lower_bound</span>();<span class="hljs-comment">//大于等于x的最小的数</span><br>s.<span class="hljs-built_in">upper_bound</span>();<span class="hljs-comment">//大于x的最小的数</span><br></code></pre></td></tr></table></figure><h3 id="mapmultimap">map/multimap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">map &lt;string,<span class="hljs-type">int</span>&gt; m;<br>m.<span class="hljs-built_in">insert</span>();<span class="hljs-comment">// 插入的是pair</span><br>a[<span class="hljs-string">&quot;test&quot;</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 插入操作</span><br>m.<span class="hljs-built_in">find</span>();<br>cout&lt;&lt;a[<span class="hljs-string">&quot;test&quot;</span>];<span class="hljs-comment">// 时间复杂度O(logn)</span><br>m.<span class="hljs-built_in">earse</span>();<br></code></pre></td></tr></table></figure><h3id="unordered_setunordered_mapunordermap_multisetunordered_multimap">unordered_set/unordered_map/unordermap_multiset/unordered_multimap</h3><p>和上面操作类似，但是不支持lower_bound()和upper_bound()，但是增插改查时间复杂度为O(1).</p><p>两个同类型之间可以直接判等！</p><h3 id="bitset">bitset</h3><p>压位,每个只占一位。可以认为是bool数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">bitset&lt;10000&gt; s;<br>s.<span class="hljs-built_in">count</span>();<span class="hljs-comment">// 返回有几个1</span><br>s.<span class="hljs-built_in">set</span>(k,v);<span class="hljs-comment">// 将第k位变成v，v的取值[&#x27;true&#x27;,&#x27;false&#x27;]</span><br>s.<span class="hljs-built_in">set</span>();<span class="hljs-comment">// 所有值置1</span><br>s.<span class="hljs-built_in">reset</span>();<span class="hljs-comment">// 所有值置0</span><br>s.<span class="hljs-built_in">flip</span>();<span class="hljs-comment">// 等价于~，全部取反</span><br>s.<span class="hljs-built_in">flip</span>(k);<span class="hljs-comment">// 第k位取反S</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python数据处理小知识</title>
    <link href="/2023/02/13/Python/python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/02/13/Python/python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>日常使用pandas、numpy等数据处理库遇到的问题 <span id="more"></span></p><h3id="将两个dataframe在竖直方向上合并">将两个DataFrame在竖直方向上合并</h3><p>当读取多个源文件，并希望将多个表合并为一个表时，使用类似于以下的结构</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"> entire_data = pd.read_csv(<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>    data = pd.read_csv(<span class="hljs-string">&quot;&quot;</span>)<br>entire_data = pd.concat([entire_data,data])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>小知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础数据结构实现(下)</title>
    <link href="/2023/02/12/Algorithm/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0(%E4%B8%8B)/"/>
    <url>/2023/02/12/Algorithm/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0(%E4%B8%8B)/</url>
    
    <content type="html"><![CDATA[<p>介绍Trie树、并查集、堆、散列表 <span id="more"></span></p><h3 id="trie树">Trie树</h3><p>用于大量字符串的存储与查找.</p><p>同时也可以存储整数的二进制表示，相关题目见<ahref="https://www.acwing.com/problem/content/145/">143. 最大异或对 -AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[N][<span class="hljs-number">26</span>];<span class="hljs-comment">// 对每个节点，都可能有26个后继结点</span><br><span class="hljs-type">int</span> cnt[N];<span class="hljs-comment">// 记录以指定结点结尾的字符串有几个</span><br><span class="hljs-type">int</span> index;<span class="hljs-comment">// 节点下标索引</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string s)</span></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> i : s)&#123;<br>        <span class="hljs-type">int</span> u = i - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!a[p][u]) a[p][u] = ++index;<br>        p = a[p][u];<br>    &#125;<br>    cnt[p] ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string s)</span></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> i : s)&#123;<br>        inc<span class="hljs-number">&#x27;</span>ct u = i - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!a[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = a[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并查集">并查集</h3><p>初始有<spanclass="math inline">\(N\)</span>个独立的集合，并查集可以方便的合并集合并且查找任意两个元素是否属于同一集合。</p><p>原题链接：<a href="https://www.acwing.com/problem/content/838/">836.合并集合 - AcWing题库</a></p><p>并查集的思路为对每个集合维护一个树，并记录每个结点的父节点（根节点的父节点为自身）。合并两个元素<spanclass="math inline">\(x、y\)</span>所在的集合即令其中一个集合的根节点的父节点为另一个集合的根节点,即<spanclass="math inline">\(p(find(x)) = find(y)\)</span>.其中<spanclass="math inline">\(find()\)</span>为查找指定节点的父节点。查找两个元素是否属于同一集合即判断是否有<spanclass="math inline">\(p[x] == p[y]\)</span>。</p><p>xxxxxxxxxx25 1const int N = 1e5+10;2int a[N];3int head = 0;4int tail= 0;5​6int main(){7    int m;8    cin&gt;&gt;m;9    string s;10    intx;11    while(m--){12        cin&gt;&gt;s;13        if(s == "push"){14           cin&gt;&gt;x;15            a[tail++] = x;16       }else if(s =="pop"){17            head++;18       }else if(s == "empty"){19           if(head == tail) cout&lt;&lt;"YES"&lt;&lt;endl;20            elsecout&lt;&lt;"NO"&lt;&lt;endl;21       }else if(s == "query"){22           cout&lt;&lt;a[head-1]&lt;&lt;endl;23       }24   }25}c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> p[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<span class="hljs-comment">// 同时完成了查找根节点与路径压缩</span><br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        a[i] = i;<br>    &#125;<br>    <span class="hljs-type">char</span> op;<br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;M&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x) != <span class="hljs-built_in">find</span>(y)) a[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>((y));<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y)) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆">堆</h3><p>维护一个二叉树，父结点总是比两个子节点大，则根节点即为最大值。所有操作的核心是向上&amp;向下整理。</p><p>数组下标从1开始，则对于结点<spanclass="math inline">\(i\)</span>,左孩子为<spanclass="math inline">\(2*i\)</span>,右孩子为<spanclass="math inline">\(2*i+1\)</span>,父节点为<spanclass="math inline">\(i/2\)</span>.注意判断父子结点是否在合法范围内。</p><h5 id="向下整理">向下整理</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> temp = x;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*x &lt;= n &amp;&amp; a[<span class="hljs-number">2</span>*x] &lt; a[x]) x = <span class="hljs-number">2</span>*x;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span> &lt;= n &amp;&amp; a[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>] &lt; a[x]) x = <span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(temp != x)&#123;<br>        <span class="hljs-built_in">swap</span>(a[x],a[temp]);<br>        <span class="hljs-built_in">down</span>(x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="向上整理">向上整理</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x/<span class="hljs-number">2</span> &amp;&amp; a[x/<span class="hljs-number">2</span>]&gt;a[x])&#123;<br>        <span class="hljs-built_in">swap</span>(a[x],a[x/<span class="hljs-number">2</span>]);<br>        <span class="hljs-built_in">up</span>(x/<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插入一个数">插入一个数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在数组尾部插入，并向上整理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    a[++cnt] = x;<br>    <span class="hljs-built_in">up</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="取出最大值">取出最大值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_max</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-built_in">swap</span>(a[<span class="hljs-number">1</span>],a[cnt--]);<br>    <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> a[cnt+<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈希表">哈希表</h3><p>只实现开放寻址法，拉链法采用头插法链表。</p><p>对于插入操作在1e5数量级的，数组应该开2e5,同时质数遇到的冲突较少，因此设置<spanclass="math inline">\(N\)</span>=2e5+3.其次设置空位标识符<spanclass="math inline">\(null\)</span>=0x3f3f3f3f.这个数大于1e9.</p><h6 id="初始化">初始化</h6><p>memset按字节赋值，因此对每个字节赋值为0x3f.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> a);<br></code></pre></td></tr></table></figure><h6 id="常见操作">常见操作</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> t = ((x%N)+N)%N;<span class="hljs-comment">// 保证结果为正数</span><br><span class="hljs-keyword">while</span>(a[t] != nulll &amp;&amp; a[t] != x)&#123;<br>    t++;<br>    <span class="hljs-keyword">if</span>(t == N) temp = <span class="hljs-number">0</span>;<span class="hljs-comment">// 循环数组</span><br>&#125;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    a[<span class="hljs-built_in">find</span>(x)] = x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a[<span class="hljs-built_in">find</span>(x)] == null) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符哈希">字符哈希</h3><p>对字符串进行哈希.</p><p>文字讲解：<ahref="https://www.acwing.com/blog/content/15289/">【新手向】字符串哈希详解 - AcWing</a></p><p><a href="https://www.acwing.com/problem/content/843/">841. 字符串哈希- AcWing题库</a></p><p>对于长度为<span class="math inline">\(n\)</span>的字符串<spanclass="math inline">\(S\)</span>,对应哈希值为<spanclass="math inline">\((\sum S_i*P^{(n-i)})*Q\)</span>.出于经验，<spanclass="math inline">\(P=131\)</span>,<spanclass="math inline">\(Q=2^{64}\)</span>. 此时采用unsigned long long作为数组可以通过自然溢出实现取模运算。</p><p>初始定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br>ULL h[N]; <span class="hljs-comment">// 存储字符串每个前缀的哈希值 </span><br>ULL p[N]; <span class="hljs-comment">// 存储展开式中的权值 ( p^0, p^1 , p^2, p^3 ... ) </span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>获得字符串的所有前缀编码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++ )&#123;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i]; <span class="hljs-comment">// 计算字符串每个 前缀 的哈希值 </span><br>    p[i] = p[i - <span class="hljs-number">1</span>] * P; <span class="hljs-comment">// 计算展开式中的各个权值 ( p^0, p^1 , p^2, p^3 ... ) </span><br> &#125;<br></code></pre></td></tr></table></figure><p>则区间[l,r]对应的字符串哈希值为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l<span class="hljs-number">-1</span>]*P[r-l+<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>比较两个字符串是否相等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>( <span class="hljs-built_in">get</span>( l1, r1 ) == <span class="hljs-built_in">get</span>( l2, r2 ) ) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>); <br><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="kmp">KMP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span><br>求模式串的Next数组：<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    ne[i] = j;<br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    <span class="hljs-keyword">if</span> (j == m)<br>    &#123;<br>        j = ne[j];<br>        <span class="hljs-comment">// 匹配成功后的逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单调栈、滑动窗口</title>
    <link href="/2023/02/12/Algorithm/%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2023/02/12/Algorithm/%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>单调栈、单调队列问题 <span id="more"></span></p><h3 id="单调栈">单调栈</h3><p>给定长度为N的整数数列，输出每个数左边第一个比他小的数，若不存在则输出-1</p><p>原题链接：<a href="https://www.acwing.com/problem/content/832/">830.单调栈 - AcWing题库</a></p><p>思路：常规思路为从第i个数向前遍历找到第一个更小的数。但对于a[i]与a[i-1],若a[i-1]&gt;a[i],则a[i-1]永远不可能作为i及以后数的答案，因此可以维护一个栈，若将进栈元素小于栈顶元素，则将栈顶元素出栈。最后得到的栈为值单调上升栈，第i个数的答案即为当前栈的栈顶元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n;<br>    stack&lt;<span class="hljs-type">int</span>&gt;st;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>()) st.<span class="hljs-built_in">push</span>(x),cout&lt;&lt;<span class="hljs-string">&quot;-1 &quot;</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() &gt;= x) st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>()) cout&lt;&lt;<span class="hljs-string">&quot;-1 &quot;</span>;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;st.<span class="hljs-built_in">top</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            st.<span class="hljs-built_in">push</span>(x);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口">滑动窗口</h3><p>给定长度为n的数组和窗口长度k，步长为1，求每个窗口的最大值与最小值。</p><p>原题链接：<ahref="https://www.acwing.com/problem/content/description/156/">154.滑动窗口 - AcWing题库</a></p><p>思路：常规思路为遍历窗口内所有数找出最大最小值。以最小值为例，滑动窗口思路为若a[i]&lt;a[i-1]，则a[i-1]不可能作为答案输出，因此维护一个双端均可出队的队列，若即将入队元素小于队尾元素，则将队尾元素舍去，即在队列中保证单调递增。同时为了去除离开窗口的元素，令上述队列存储元素下标，若队尾元素下标小于i-k+1则对应元素已离开窗口，舍弃即可。每个窗口的答案即为队尾元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-type">int</span> head = <span class="hljs-number">0</span>,tail = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,k,x;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(q[head]&lt;i-k+<span class="hljs-number">1</span>) head++;<br>        <span class="hljs-keyword">while</span>(head&lt;=tail &amp;&amp; a[q[tail]] &gt;= a[i]) tail--;<br>        q[++tail] = i;<br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout&lt;&lt;a[q[head]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    head = <span class="hljs-number">0</span>;tail = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(q[head]&lt;i-k+<span class="hljs-number">1</span>) head++;<br>        <span class="hljs-keyword">while</span>(head&lt;=tail &amp;&amp; a[q[tail]] &lt;= a[i]) tail--;<br>        q[++tail] = i;<br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout&lt;&lt;a[q[head]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础数据结构实现(上)</title>
    <link href="/2023/02/09/Algorithm/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/"/>
    <url>/2023/02/09/Algorithm/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<p>包含数组模拟单项链表、双向链表、栈、队列 <span id="more"></span></p><h3 id="单向链表">单向链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[N];<span class="hljs-comment">// 存储节点值</span><br><span class="hljs-type">int</span> ne[N];<span class="hljs-comment">// 存储当前节点的下一节点下标</span><br><span class="hljs-type">int</span> index;<span class="hljs-comment">// 当前用到的数组下标</span><br><span class="hljs-type">int</span> head;<span class="hljs-comment">// 头结点下标</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>index = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_head</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    a[index] = x;<br>    ne[index] = head;<br>    head = index;<br>    index ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_k</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">// 在第k个插入的数后面插入一个数</span><br>    a[index] = x;<br>    ne[index] = ne[k];<br>    ne[k] = index;<br>    index ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del_k</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//删除第k个插入的数后面的数</span><br>    <span class="hljs-keyword">if</span>(!k) head = ne[head];<br>    ne[k] = ne[ne[k]];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_all</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head;i!=<span class="hljs-number">-1</span>;i = ne[i])&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> m;<br>    cin&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">char</span> op;<br>        cin&gt;&gt;op;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;H&#x27;</span>)&#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">add_to_head</span>(x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;D&#x27;</span>)&#123;<br>            <span class="hljs-type">int</span> k;<br>            cin&gt;&gt;k;<br>            <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) head = ne[head];<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">del_k</span>(k<span class="hljs-number">-1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> k,x;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-built_in">insert_k</span>(k<span class="hljs-number">-1</span>,x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head;i!=<span class="hljs-number">-1</span>;i = ne[i])&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双向链表">双向链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[N],ne[N],be[N];<br><span class="hljs-type">int</span> index,l_head,r_head;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    l_head = <span class="hljs-number">-1</span>;<br>    r_head = <span class="hljs-number">-1</span>;<br>    index = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_left_head</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">// 在左侧头部插入</span><br>    a[index] = x;<br>    ne[index] = l_head;<br>    be[index] = <span class="hljs-number">-1</span>;<br>    be[l_head] = index;<br>    l_head = index;<br>    <span class="hljs-keyword">if</span>(r_head == <span class="hljs-number">-1</span>) r_head = index;<br>    index ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_right_head</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">// 在右侧头部插入</span><br>    a[index] = x;<br>    ne[index] = <span class="hljs-number">-1</span>;<br>    be[index] = r_head;<br>    ne[r_head] = index;<br>    r_head = index;<br>    <span class="hljs-keyword">if</span>(l_head == <span class="hljs-number">-1</span>) l_head = index;<br>    index ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del_k</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">// 删除第k个插入的数</span><br>    <span class="hljs-keyword">if</span>(k == l_head &amp;&amp; l_head == r_head)&#123;<br>        l_head = r_head = <span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k == l_head &amp;&amp; k!=r_head)&#123;<br>        l_head = ne[l_head];<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k != l_head &amp;&amp; k == r_head)&#123;<br>        r_head = be[r_head];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        be[ne[k]] = be[k];<br>        ne[be[k]] = ne[k];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_left_k</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">// 在第k个插入的数左侧插入</span><br>    <span class="hljs-keyword">if</span>(k == l_head) &#123;<span class="hljs-built_in">insert_left_head</span>(x);<span class="hljs-keyword">return</span>;&#125;<br>    a[index] = x;<br>    ne[index] = k;<br>    be[index] = be[k];<br>    ne[be[k]] = index;<br>    be[k] = index;<br>    index++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_right_k</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">// 在第k个插入的数右侧插入</span><br>    <span class="hljs-keyword">if</span>(k == r_head) &#123;<span class="hljs-built_in">insert_right_head</span>(x);<span class="hljs-keyword">return</span>;&#125;<br>    a[index] = x;<br>    ne[index] = ne[k];<br>    be[index] = k;<br>    be[ne[k]] = index;<br>    ne[k] = index;<br>    index++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    cin&gt;&gt;m;<br>    <span class="hljs-type">int</span> k,x;<br>    string s;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;s;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;L&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">insert_left_head</span>(x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;R&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">insert_right_head</span>(x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;D&quot;</span>)&#123;<br>            cin&gt;&gt;k;<br>            <span class="hljs-built_in">del_k</span>(k<span class="hljs-number">-1</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;IL&quot;</span>)&#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-built_in">insert_left_k</span>(k<span class="hljs-number">-1</span>,x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;IR&quot;</span>)&#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-built_in">insert_right_k</span>(k<span class="hljs-number">-1</span>,x);<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l_head;i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>            cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈">栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> top = <span class="hljs-number">-1</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    cin&gt;&gt;m;<br>    string s;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;s;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;push&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            a[++top] = x;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;pop&quot;</span>)&#123;<br>            top--;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;empty&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(top == <span class="hljs-number">-1</span>) cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;query&quot;</span>)&#123;<br>            cout&lt;&lt;a[top]&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="队列">队列</h3><p>注意数组中左边的是head，右边的是tail。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> head = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tail = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    cin&gt;&gt;m;<br>    string s;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;s;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;push&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            a[tail++] = x;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;pop&quot;</span>)&#123;<br>            head++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;empty&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head == tail) cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;query&quot;</span>)&#123;<br>            cout&lt;&lt;a[head<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法基础课题集</title>
    <link href="/2023/02/04/Algorithm/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E9%A2%98%E9%9B%86/"/>
    <url>/2023/02/04/Algorithm/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>Acwing算法基础课中不熟练题目 <span id="more"></span></p><h3 id="两个数组的目标和">两个数组的目标和</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/802/">800.数组元素的目标和 - AcWing题库</a></p><p>思路：对于双指针要找到两个指针单调的方向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],b[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,x;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) cin&gt;&gt;b[i];<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=m<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]+b[j]==x)&#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;j;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]+b[j]&gt;x) j--;<br>        <span class="hljs-keyword">else</span> i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="离散化">离散化</h3><p>原题链接：<ahref="https://www.acwing.com/problem/content/description/804/">802.区间和 - AcWing题库</a></p><p>思路：将大范围(-1e9~1e9)但是稀疏(只有1e5的数字非0)的向量进行压缩.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> a[N],s[N];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; add;<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; query;<br>vector&lt;<span class="hljs-type">int</span>&gt; all_index;<span class="hljs-comment">// 存储所有需要占据索引的操作（某位置加、两点之间的和），注意需要排序+去重</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">// 二分查找离散化前的值x在离散化后的索引</span><br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=all_index.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> mid = l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(all_index[mid]&gt;=x) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x,c;<br>        cin&gt;&gt;x&gt;&gt;c;<br>        add.<span class="hljs-built_in">push_back</span>(&#123;x,c&#125;);<br>        all_index.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin&gt;&gt;l&gt;&gt;r;<br>        query.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>        all_index.<span class="hljs-built_in">push_back</span>(l);<br>        all_index.<span class="hljs-built_in">push_back</span>(r);<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(all_index.<span class="hljs-built_in">begin</span>(), all_index.<span class="hljs-built_in">end</span>());<br>    all_index.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(all_index.<span class="hljs-built_in">begin</span>(), all_index.<span class="hljs-built_in">end</span>()), all_index.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : add)&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(i.first);<br>        a[x] += i.second;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=all_index.<span class="hljs-built_in">size</span>();i++) s[i] = s[i<span class="hljs-number">-1</span>] + a[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : query)&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">find</span>(i.first);<br>        <span class="hljs-type">int</span> r = <span class="hljs-built_in">find</span>(i.second);<br>        cout&lt;&lt;s[r] - s[l<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="走迷宫bfs">走迷宫(BFS)</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/846/">844.走迷宫 - AcWing题库</a></p><h5 id="做法1">做法1</h5><p>个人做法,采用哈希集合存储已途径的点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> a[N][N];<br><br># unordered_set不能以pair作为模板，需要自己定义相关规则<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair_hash</span><br>&#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(pair&lt;T1, T2&gt; <span class="hljs-type">const</span> &amp;pair)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">size_t</span> h1 = <span class="hljs-built_in">hash</span>&lt;T1&gt;()(pair.first); <span class="hljs-comment">//用默认的 hash 处理 pair 中的第一个数据 X1</span><br>        <span class="hljs-type">size_t</span> h2 = <span class="hljs-built_in">hash</span>&lt;T2&gt;()(pair.second);<span class="hljs-comment">//用默认的 hash 处理 pair 中的第二个数据 X2</span><br>        <span class="hljs-keyword">return</span> h1 ^ h2;<br>    &#125;<br>&#125;;<br># 定义方式<br>unordered_set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, pair_hash&gt; map;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>    q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        ans++;<br>        <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br>            <span class="hljs-keyword">auto</span> temp = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> x = temp.first;<br>            <span class="hljs-type">int</span> y = temp.second;<br>            <span class="hljs-keyword">if</span>(x == n - <span class="hljs-number">1</span> &amp;&amp; y == m - <span class="hljs-number">1</span>) cout&lt;&lt;ans;<br>            <span class="hljs-keyword">if</span>(x+<span class="hljs-number">1</span>&lt;n &amp;&amp; !a[x+<span class="hljs-number">1</span>][y] &amp;&amp; !map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x+<span class="hljs-number">1</span>,y)))&#123;<br>                q.<span class="hljs-built_in">emplace</span>(x+<span class="hljs-number">1</span>,y);<br>                map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x+<span class="hljs-number">1</span>,y));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(x<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; !a[x<span class="hljs-number">-1</span>][y] &amp;&amp; !map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x<span class="hljs-number">-1</span>,y)))&#123;<br>                q.<span class="hljs-built_in">emplace</span>(x<span class="hljs-number">-1</span>,y);<br>                map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x<span class="hljs-number">-1</span>,y));<br><br>            &#125;<br>            <span class="hljs-keyword">if</span>(y+<span class="hljs-number">1</span>&lt;m &amp;&amp; !a[x][y+<span class="hljs-number">1</span>] &amp;&amp; !map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x,y+<span class="hljs-number">1</span>)))&#123;<br>                q.<span class="hljs-built_in">emplace</span>(x,y+<span class="hljs-number">1</span>);<br>                map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x,y+<span class="hljs-number">1</span>));<br><br>            &#125;<br>            <span class="hljs-keyword">if</span>(y<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; !a[x][y<span class="hljs-number">-1</span>] &amp;&amp; !map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x,y<span class="hljs-number">-1</span>)))&#123;<br>                q.<span class="hljs-built_in">emplace</span>(x,y<span class="hljs-number">-1</span>);<br>                map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x,y<span class="hljs-number">-1</span>));<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化做法如下,适用于所有在二维空间进行移动的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>    q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        ans++;<br>        <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br>            <span class="hljs-keyword">auto</span> temp = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> x = temp.first;<br>            <span class="hljs-type">int</span> y = temp.second;<br>            <span class="hljs-keyword">if</span>(x == n - <span class="hljs-number">1</span> &amp;&amp; y == m - <span class="hljs-number">1</span>) cout&lt;&lt;ans;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;u&lt;<span class="hljs-number">4</span>;u++)&#123;<br>                <span class="hljs-type">int</span> xx = x+dx[u];<br>                <span class="hljs-type">int</span> yy = y+dy[u];<br>                <span class="hljs-keyword">if</span>(xx&lt;n&amp;&amp;xx&gt;=<span class="hljs-number">0</span>&amp;&amp;yy&lt;m&amp;&amp;yy&gt;=<span class="hljs-number">0</span>&amp;&amp;!a[xx][yy]&amp;&amp;!map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(xx,yy)))&#123;<br>                    q.<span class="hljs-built_in">emplace</span>(xx,yy);<br>                    map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(xx,yy));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="做法2">做法2</h5><p>采用d数组记录到达每个点的最短距离，核心思路和做法1相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>    q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br>            <span class="hljs-keyword">auto</span> temp = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> x = temp.first;<br>            <span class="hljs-type">int</span> y = temp.second;<br>            <span class="hljs-keyword">if</span>(x == n - <span class="hljs-number">1</span> &amp;&amp; y == m - <span class="hljs-number">1</span>) cout&lt;&lt;d[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;<span class="hljs-number">4</span>;u++)&#123;<br>            <span class="hljs-type">int</span> xx = x+dx[u];<br>                <span class="hljs-type">int</span> yy = y+dy[u];<br>                <span class="hljs-keyword">if</span>(xx&lt;n&amp;&amp;xx&gt;=<span class="hljs-number">0</span>&amp;&amp;yy&lt;m&amp;&amp;yy&gt;=<span class="hljs-number">0</span>&amp;&amp;!a[xx][yy]&amp;&amp;!d[xx][yy])&#123;<br>                    q.<span class="hljs-built_in">emplace</span>(xx,yy);<br>                    d[xx][yy] = d[x][y] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列">最长公共子序列</h3><p>给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B的子序列的字符串长度最长是多少。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">char</span> a[N],b[N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;a+<span class="hljs-number">1</span>&gt;&gt;b+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>            <span class="hljs-keyword">if</span>(a[i] == b[j])&#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2023/02/03/Algorithm/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <url>/2023/02/03/Algorithm/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>前缀和与差分</p><span id="more"></span><h3 id="一维前缀和">一维前缀和</h3><p>主要作用：可以快速求出大量[l,r]之间所有数的和。注意两个数组都是从1开始。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i] = b[i<span class="hljs-number">-1</span>] +a[i];<br>cout&lt;&lt;b[r] - b[l<span class="hljs-number">-1</span>];<span class="hljs-comment">// 输出[l,r]之间所有数的和</span><br></code></pre></td></tr></table></figure><h3 id="二维前缀和">二维前缀和</h3><p>作用同一维前缀和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            s[i][j] = s[i<span class="hljs-number">-1</span>][j] + s[i][j<span class="hljs-number">-1</span>] - s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<span class="hljs-comment">// 计算前缀和</span><br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[x2][y2] - s[x1<span class="hljs-number">-1</span>][y2] - s[x2][y1<span class="hljs-number">-1</span>] + s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]);<span class="hljs-comment">// 计算矩形内所有数的和</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="一维差分">一维差分</h3><p>主要作用:对于在[l,r]区间内所有数加上c这类题目较快.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> m,n;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i] = a[i] - a[i<span class="hljs-number">-1</span>];<span class="hljs-comment">// 求差分</span><br><span class="hljs-keyword">while</span>(m--)&#123;<br>    <span class="hljs-type">int</span> l,r,c;<br>    cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>    b[r+<span class="hljs-number">1</span>] -= c;<br>    b[l] += c;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) a[i] = a[i<span class="hljs-number">-1</span>] + b[i]; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br></code></pre></td></tr></table></figure><h3 id="二维差分">二维差分</h3><p>作用同上.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> a[N][N],b[N][N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span>&#123;<span class="hljs-comment">//插入的规则,用图辅助理解</span><br>    b[x1][y1] += c;<br>    b[x1][y2+<span class="hljs-number">1</span>] -=c;<br>    b[x2+<span class="hljs-number">1</span>][y1] -=c;<br>    b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] +=c;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,q;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">insert</span>(i,j,i,j,a[i][j]);<span class="hljs-comment">//相当于对每个1*1的矩阵插入一个数</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2,c;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;<br>        <span class="hljs-built_in">insert</span>(x1,y1,x2,y2,c);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            a[i][j] = a[i<span class="hljs-number">-1</span>][j] + a[i][j<span class="hljs-number">-1</span>] - a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + b[i][j];<span class="hljs-comment">// 求前缀和</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/4458/">4455. 出行计划- AcWing题库</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高精度计算</title>
    <link href="/2023/02/03/Algorithm/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/"/>
    <url>/2023/02/03/Algorithm/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>高精度加法、减法、乘法、除法 <span id="more"></span></p><h3 id="高精度加法">高精度加法</h3><p>基本思路和列竖式相同，对于两个大数，使用string读入，在vector中倒排。对于两个vector的加法有c[i]= a[i] + b[i] +t.其中t是上一位的进位。计算完毕后，若t为1说明最高位有进位，再补上一个1即可。在输出时要记得反相输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span>(i &lt; a.<span class="hljs-built_in">size</span>() || i &lt; b.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>()) t += a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>()) t += b[i];<br>        result.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) result.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-type">int</span>&gt;aa,bb;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) aa.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//记得字符转化为对应数字要-&#x27;0&#x27;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) bb.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">add</span>(a,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>();i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        cout&lt;&lt;c[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度减法">高精度减法</h3><p>思路和高精度加法类似，以string读入，用vector倒排。对于减法，有c[i] =(a[i] - b[i] - t + 10) %10.在读数据时要注意判断a和b的大小。如果b大于a则需要先print出'-'然后再输b-a的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()!=b.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &gt; b.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-type">int</span> i=a,<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]!=b[i])&#123;<br>            <span class="hljs-keyword">return</span> a[i] &gt; b[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;result;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++)&#123;<br>        t = a[i] - t;<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>()) t = t - b[i];<br>        result.<span class="hljs-built_in">push_back</span>((t+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(result.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; result.back == <span class="hljs-number">0</span>) result.<span class="hljs-built_in">pop_back</span>();<br>   <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt;aa,bb;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) aa.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//记得字符转化为对应数字要-&#x27;0&#x27;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) bb.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">compare</span>(a,b))&#123;<br>        <span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">sub</span>(a,b);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-built_in">print</span>(c[i]);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>        <span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">sub</span>(b,a);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-built_in">print</span>(c[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="高精度乘法">高精度乘法</h3><p>对于大数A和小数b，结果的第i位可表示为c[i] =(a[i]<em>b+t)/10,其中t为第i-1位的进位。对第i+1位的进位t=(a[i]</em>b+t)%10.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>() || t;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>()) t = t + a[i]*b;<br>        result.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(result.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; result.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) result.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度除法">高精度除法</h3><p>思路可以正着做，记余数为r，则c[i] = (r*10+a[i])/b,r=r%b.为了在输入输出方面和加减乘保持一致，除法在形式上也采用倒排。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;r)</span></span>&#123;<br>    r = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt;result;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        r = r*<span class="hljs-number">10</span>+a[i];<br>        result.<span class="hljs-built_in">push_back</span>(r/b)<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(),result.<span class="hljs-built_in">end</span>());<br>   <span class="hljs-keyword">while</span>(result.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; result.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) result.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分算法</title>
    <link href="/2023/01/15/Algorithm/%E4%BA%8C%E5%88%86/"/>
    <url>/2023/01/15/Algorithm/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>整数二分、浮点数二分及例题 <span id="more"></span></p><h3 id="整数二分">整数二分</h3><p>整数二分有两种情况，取决于check()函数的逻辑。</p><p>第一种情况，假设check()函数判断的是“右侧是否满足”，则如果满足，说明mid处于右侧区间，则边界点应处于[l,mid]，因此更新r=mid；如果不满足，说明mid处于左侧区间且mid点本身并不是边界点，则边界点应处于(mid+1,r],因此更新l= mid + 1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<span class="hljs-comment">// 以整个数列为例</span><br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>    <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>&#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但考虑如下情况：若l = r - 1,此时mid = (l + r) &gt;&gt; 1 = (2l + 1)&gt;&gt; 1 =l,若此时check()返回true，执行l=mid，会导致l、r均未得到更新，程序陷入死循环，因此此时应赋值mid= (l + r + 1) &gt;&gt; 1.</p><p><strong>简便记法</strong>：出现mid - 1 的时候使用该情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例题</strong>：<ahref="https://www.acwing.com/problem/content/description/791/">789.数的范围 - AcWing题库</a></p><h3 id="浮点数二分">浮点数二分</h3><p>和整数二分类似，但无需考虑mid的取整问题。其中的eps代表精度，经验来看若题目要求保留n位小数则eps精度为n+2即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-type">double</span> l,<span class="hljs-type">double</span> r)</span></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br>    <span class="hljs-keyword">while</span>(r-l&gt;eps)&#123;<br>        <span class="hljs-type">double</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例题</strong>：<ahref="https://www.acwing.com/problem/content/792/">790. 数的三次方根 -AcWing题库</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2023/01/14/Algorithm/%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/01/14/Algorithm/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>快排、归并排序 <span id="more"></span></p><h3 id="快排">快排</h3><p>维护左右两个指针，左边指针向右走直到遇到大于x的值停下，右边指针向左走直到遇到小于x的值停下，随后两个指针指向的值进行交换。</p><p>快排是不稳定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> x=q[l],i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i&lt;j)&#123;<br><span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i]&lt;x);<br><span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j]&gt;x);<br><span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(q[i],q[j]);<br>&#125;<br><span class="hljs-built_in">quick_sort</span>(q,l,j);<br><span class="hljs-built_in">quick_sort</span>(q,j+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure><p>先对两侧的子序列排序，再对两个有序子序列进行合并，合并思路为双指针。</p><p>归并排序是稳定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">merge_sort</span>(q,l,mid);<br><span class="hljs-built_in">merge_sort</span>(q,mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;<br><span class="hljs-keyword">if</span>(q[i]&lt;q[j]) temp[k++] = q[i++];<br><span class="hljs-keyword">else</span> temp[k++] = q[j++];<br>&#125;<br><span class="hljs-keyword">while</span>(i&lt;=mid) temp[k++] = q[i++];<br><span class="hljs-keyword">while</span>(j&lt;=r) temp[k++] = q[j++];<br><span class="hljs-keyword">for</span>(i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++)&#123;<br>q[i] = temp[j];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2023/01/14/School/%E6%9C%8B%E8%BE%88%E7%AD%94%E7%96%91/"/>
    <url>/2023/01/14/School/%E6%9C%8B%E8%BE%88%E7%AD%94%E7%96%91/</url>
    
    <content type="html"><![CDATA[<p>朋辈讲师企业微信答疑 <span id="more"></span> 想必你清楚如何通过if-else 或者switch-case将0-9输出，主要问题在于如何将整数从高到低处理</p><p>如果直接按整数读入，会发现很难从高位到低位获得每个数字，自然很难处理</p><p>但如果是一个字符串，我们似乎就可以通过索引获得0~n的数字</p><p>如果学过c++，string自然是最好的选择，</p><p>如果只是学了c，可以通过下面的代码依次读入每个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> f[<span class="hljs-number">10</span>][<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&quot;ling&quot;</span>,<span class="hljs-string">&quot;yi&quot;</span>,<span class="hljs-string">&quot;er&quot;</span>,<span class="hljs-string">&quot;san&quot;</span>,<span class="hljs-string">&quot;si&quot;</span>,<span class="hljs-string">&quot;wu&quot;</span>,<span class="hljs-string">&quot;liu&quot;</span>,<span class="hljs-string">&quot;qi&quot;</span>,<span class="hljs-string">&quot;ba&quot;</span>,<span class="hljs-string">&quot;jiu&quot;</span>&#125;;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">do</span>&#123;<br>        c = getchar();<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fu&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,f[<span class="hljs-type">int</span>(c-<span class="hljs-string">&#x27;0&#x27;</span>)]);<span class="hljs-comment">// 注意ASCII码到实际整数的转化</span><br>        &#125;<br><br>    &#125;<span class="hljs-keyword">while</span>(c!=<span class="hljs-string">&#x27;\n&#x27;</span>);<br></code></pre></td></tr></table></figure><p>print的东西可以改为if-else或者switch-case，不再赘述了。</p><p>下面给出一个递归解决的方法~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><br><span class="hljs-type">char</span> f[<span class="hljs-number">10</span>][<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&quot;ling&quot;</span>,<span class="hljs-string">&quot;yi&quot;</span>,<span class="hljs-string">&quot;er&quot;</span>,<span class="hljs-string">&quot;san&quot;</span>,<span class="hljs-string">&quot;si&quot;</span>,<span class="hljs-string">&quot;wu&quot;</span>,<span class="hljs-string">&quot;liu&quot;</span>,<span class="hljs-string">&quot;qi&quot;</span>,<span class="hljs-string">&quot;ba&quot;</span>,<span class="hljs-string">&quot;jiu&quot;</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">high_to_low</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">10</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, f[<span class="hljs-built_in">high_to_low</span>(x/<span class="hljs-number">10</span>)]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> x%<span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fu&quot;</span>);<br>        x = -x;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,f[<span class="hljs-built_in">high_to_low</span>(x)]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>) <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));   <span class="hljs-comment">// 写法有些小问题</span><br>    <span class="hljs-type">int</span> a=<span class="hljs-built_in">rand</span>()%<span class="hljs-number">100</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//随机数字a</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a);<br>    <span class="hljs-type">int</span> d,b,n,i;<span class="hljs-comment">//输入数字b,n      // 没理解错的话n是最大的猜测次数吧，用int存储即可，n[100]代表有100个int</span><br>    d=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;b,&amp;n);    <span class="hljs-comment">// 确定题目是先读入b再读入n吗？</span><br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123; <span class="hljs-comment">// [0,n)是n个数，[0,n]是n+1个数了</span><br>        <span class="hljs-keyword">if</span>(b&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">// 每次读入b都要判断正负，原代码只判断了第一个b的正负</span><br>            <span class="hljs-keyword">if</span> (b &gt; a)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Too big\n&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b &lt; a)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Too small\n&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == a)&#123;   <span class="hljs-comment">//等真的的猜出来再判断输出什么</span><br>                <span class="hljs-keyword">if</span>(d==<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Bingo!\n&quot;</span>); <span class="hljs-comment">// 判等是两个=</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;<span class="hljs-number">1</span>&amp;&amp;d&lt;=<span class="hljs-number">3</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Lucky You!\n&quot;</span>);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;<span class="hljs-number">3</span>&amp;&amp;d&lt;=n)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Good Guess!\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果最后一次没猜对会先显示too small/big然后显示game over，</span><br>            <span class="hljs-comment">// 这个地方要按照题意，如果只需要输出game over 要把下面的if放在循环的开始</span><br>            <span class="hljs-keyword">if</span>(d&gt;=n)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Game Over\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            d++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Game Over\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10000</span>];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&lt;=m;i++)&#123;<br>        cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;       <span class="hljs-comment">// 获得i这个数的所有约数</span><br>            <span class="hljs-keyword">if</span>(i%j==<span class="hljs-number">0</span>) a[cnt++] = j;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt;j++)&#123;     <span class="hljs-comment">// 把约数都加起来</span><br>            sum += a[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum == i)&#123;       <span class="hljs-comment">// 要是加起来等于i，说明符合条件</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d = &quot;</span>,i);  <span class="hljs-comment">// 先把开头print出来</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt;j++)&#123;     <span class="hljs-comment">// 循环打印约数</span><br>                <span class="hljs-keyword">if</span>(j!=cnt<span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d + &quot;</span>,a[j]);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[j]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><span class="math display">\[d(e^{i\theta })=ie^{i\theta}d\theta=i(cos\theta+isin\theta)d\theta\]</span></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于脑功能连接矩阵的Kendall特征提取实现</title>
    <link href="/2023/01/11/DeepLearning/%E5%9F%BA%E4%BA%8E%E8%84%91%E5%8A%9F%E8%83%BD%E8%BF%9E%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84Kendall%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/01/11/DeepLearning/%E5%9F%BA%E4%BA%8E%E8%84%91%E5%8A%9F%E8%83%BD%E8%BF%9E%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84Kendall%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>基于脑功能连接矩阵的Kendall特征提取实现 <span id="more"></span>原论文如下图所示</p><div data-align="center"><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230111170705.png" width="  "></div><p>基本思路为将样本分为患病组和未患病组，对于患病组的每一个样本的每一个特征，将其和未患病组的每一个样本的对应特征进行相减运算，若结果为正则记为一组concordant，若结果为负则记为一组discordant,对于每一个特征，总的concordant数记为nc,总的discordant数记为nd，随后使用abs((nc-nd)/(m*n))代表每一个特征的Kendall系数，用该系数进行排序即可。</p><p>程序最基础的代码结构如下，我们使用上Pearson矩阵上三角展开后（1，6670）的数据当作每个样本的输入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> fc <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6670</span>):<br>nc = <span class="hljs-number">0</span><br>nd = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> file_asd <span class="hljs-keyword">in</span> files_asd:<br>ref = pd.read_csv(file_asd,header=<span class="hljs-literal">False</span>)[fc]<br>        <span class="hljs-keyword">for</span> file_hc <span class="hljs-keyword">in</span> files_hc:<br>        comp = pd.read_csv(file_hc,header=<span class="hljs-literal">False</span>)[fc]<br>        <span class="hljs-keyword">if</span> ref - comp &gt; <span class="hljs-number">0</span>:<br>        nc += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>        nd += <span class="hljs-number">1</span><br>tau[fc] = <span class="hljs-built_in">abs</span>(nc - nd)/(m*n)<br></code></pre></td></tr></table></figure><p>上述代码是对原论文思路的直接实现，逻辑清晰，但是由于大量的IO以及运算，效率十分低下。因此做如下改进：</p><p>为了避免大量重复IO，将所有数据提前读入内存中,后续根据索引直接取数即可,同时为了提高这一步的读取效率，将csv文件改为pkl文件在这一步带来了上千倍的速度提升。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">all_asd_data = []<br>all_hc_data = []<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files_asd:<br>    all_asd_data.append(pd.read_pickle(file))<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files_hc:<br>    all_hc_data.append(pd.read_pickle(file))<br>all_asd_data = pd.DataFrame(np.array(all_asd_data).reshape(<span class="hljs-built_in">len</span>(all_asd_data), -<span class="hljs-number">1</span>))<br>all_hc_data = pd.DataFrame(np.array(all_hc_data).reshape(<span class="hljs-built_in">len</span>(all_hc_data), -<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>即使如此，由于原运算架构采用三层for循环，三层的循环次数分别为6670、306、368，时间复杂度太高，并行度太差，该程序需要<strong>五个多小时</strong>才能完全跑完。后续在并行度上继续改进：</p><p>首先想到对于未患病组可以不逐个计算，取出所有未患病样本的第fc列，将该array直接减去ref的值，随后统计其中大于0的个数加到nc上，小于0的个数加到nd上即可。这样的改进可以让程序在<strong>10分钟</strong>内完成全部运算。</p><p>更进一步的，我们可以不区分fc，对于全部未患病样本all_hc_data，直接减去每一个患病样本（即利用广播机制将（368，6670）减去（1，6670）），随后以列进行统计大于0的数量，得到（1，6670）的数组，直接加到nc数组上即可，nd数组同理操作。这样程序只有一层for循环，在<strong>5秒</strong>内即可完成全部运算，代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(all_asd_data)),desc=<span class="hljs-string">&quot;running&quot;</span>,file=sys.stdout):<br>    ref = <span class="hljs-built_in">list</span>(all_asd_data.iloc[i, :])<br>    bool_res = all_hc_data - ref &gt; <span class="hljs-number">0</span><br>    total_true = np.array(np.<span class="hljs-built_in">sum</span>(bool_res, axis=<span class="hljs-number">0</span>))<br>    nc += total_true<br>    nd += <span class="hljs-built_in">len</span>(all_hc_data) - total_true<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6670</span>):<br>    tau_t = (nc[i] - nd[i])/(m*n)<br>    tau = pd.DataFrame(np.insert(tau.values, <span class="hljs-built_in">len</span>(tau.index), values=[<span class="hljs-built_in">int</span>(i), <span class="hljs-built_in">abs</span>(tau_t)], axis=<span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><p>完整代码如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python">root_path = <span class="hljs-string">&quot;../../raw_data/rois_aal_pkl_pearson_static_expand/&quot;</span><br>files = os.listdir(root_path)<br>files.sort()<br><br>label_temp = pd.read_csv(<span class="hljs-string">&quot;label_674.csv&quot;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> CheckOrder(files, label_temp):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;error&quot;</span>)<br>    exit()<br>label_temp = label_temp.group_1.values<br><br>m = <span class="hljs-built_in">sum</span>(label_temp)  <span class="hljs-comment"># 患病人数</span><br>n = <span class="hljs-built_in">len</span>(label_temp) - m  <span class="hljs-comment"># 未患病人数</span><br><br>files_asd = []<br>files_hc = []<br><span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(label_temp):<br>    <span class="hljs-keyword">if</span> item == <span class="hljs-number">1</span>:<br>        files_asd.append(root_path + files[i])<br>    <span class="hljs-keyword">else</span>:<br>        files_hc.append(root_path + files[i])<br><br><span class="hljs-comment"># 预加载所有数据，避免频繁IO</span><br>all_asd_data = []<br>all_hc_data = []<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files_asd:<br>    all_asd_data.append(pd.read_pickle(file))<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files_hc:<br>    all_hc_data.append(pd.read_pickle(file))<br>all_asd_data = pd.DataFrame(np.array(all_asd_data).reshape(<span class="hljs-built_in">len</span>(all_asd_data), -<span class="hljs-number">1</span>))<br>all_hc_data = pd.DataFrame(np.array(all_hc_data).reshape(<span class="hljs-built_in">len</span>(all_hc_data), -<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(all_asd_data.shape, all_hc_data.shape)<br><br>tau = pd.DataFrame(columns=[<span class="hljs-string">&#x27;ROI&#x27;</span>, <span class="hljs-string">&#x27;tau&#x27;</span>])<br>nc = np.zeros((<span class="hljs-number">6670</span>,), dtype=<span class="hljs-built_in">int</span>)<br>nd = np.zeros((<span class="hljs-number">6670</span>,), dtype=<span class="hljs-built_in">int</span>)<br><br><span class="hljs-comment"># 利用广播机制批量运算</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(all_asd_data)),desc=<span class="hljs-string">&quot;running&quot;</span>,file=sys.stdout):<br>    ref = <span class="hljs-built_in">list</span>(all_asd_data.iloc[i, :])<br>    bool_res = all_hc_data - ref &gt; <span class="hljs-number">0</span><br>    total_true = np.array(np.<span class="hljs-built_in">sum</span>(bool_res, axis=<span class="hljs-number">0</span>))<br>    nc += total_true<br>    nd += <span class="hljs-built_in">len</span>(all_hc_data) - total_true<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6670</span>):<br>    tau_t = (nc[i] - nd[i])/(m*n)<br>    tau = pd.DataFrame(np.insert(tau.values, <span class="hljs-built_in">len</span>(tau.index), values=[<span class="hljs-built_in">int</span>(i), <span class="hljs-built_in">abs</span>(tau_t)], axis=<span class="hljs-number">0</span>))<br><br>tau.columns = [<span class="hljs-string">&#x27;ROI&#x27;</span>, <span class="hljs-string">&#x27;tau&#x27;</span>]<br>tau = tau.sort_values(by=<span class="hljs-string">&#x27;tau&#x27;</span>, ascending=<span class="hljs-literal">False</span>)<br>tau = tau.reset_index(drop=<span class="hljs-literal">True</span>)<br>tau.to_csv(<span class="hljs-string">&quot;sort.csv&quot;</span>,index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微软官方开源工具PowerToys</title>
    <link href="/2023/01/10/Tools/%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7PowerToys/"/>
    <url>/2023/01/10/Tools/%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7PowerToys/</url>
    
    <content type="html"><![CDATA[<p>具有窗口置顶、查看文件被什么进程占用、批量重命名文件、alt+space全盘检索、OCR等实用功能<span id="more"></span></p><p>Github地址：<ahref="https://github.com/microsoft/PowerToys">microsoft/PowerToys:Windows system utilities to maximize productivity (github.com)</a></p><p>所有功能见文末。下面记录一些感兴趣工具的使用方法</p><h4 id="始终置顶">始终置顶</h4><p>​ 快捷键：win+ctrl+T,固定所选的窗口，使其始终位于所有窗口的顶部</p><h4 id="文件locksmith">文件Locksmith</h4><p>​在文件资源管理器中选择一个或多个文件，右键选择<strong>使用此文件的进程</strong>即可展示出所有使用中的进程并提供了结束进程的选项。十分实用！再也不用担心因为进程占用删不掉文件夹。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBed/20230110190258.png"alt="Locksmith" /><figcaption aria-hidden="true">Locksmith</figcaption></figure><h4 id="文件资源管理器加载项">文件资源管理器加载项</h4><p>在文件资源管理器中选择视图中的<strong>预览窗格</strong>，可以在文件资源管理器右侧预览md、pdf、svg等文件格式。</p><p>感觉不如quicklook好，但内嵌在资源管理器中看起来还不错。</p><h4 id="powerrename">PowerRename</h4><p>选定多个文件右键选择PowerRename，会弹出独立窗口，可以使用正则表达式来搜索文件进行批量重命名。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBed/20230110191047.png"alt="PowerRename" /><figcaption aria-hidden="true">PowerRename</figcaption></figure><h4 id="powertoys-run">PowerToys Run</h4><p>按下alt+space进行搜索，似乎有wox团队参加，和wox功能十分类似但看起来更简洁、美观。</p><p>在设置-&gt;隐私和安全性-&gt;搜索Windows中可以选择建立索引的目录范围以及索引存放的位置。</p><p>图中提示警告是因为还没编制完索引，编制完之后便可正常实用。</p><p>但wox支持拼音首字母检索，PowerToys Run似乎并不支持。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBed/20230110191344.png" /></p><h4 id="ocr文本提取器">OCR文本提取器</h4><p>快捷键：win+shift+T</p><p>自动复制到剪切板，很方便。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBed/20230110184744.png"alt="PowerToys" /><figcaption aria-hidden="true">PowerToys</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决批处理程序中文乱码问题</title>
    <link href="/2023/01/07/Tools/%E8%A7%A3%E5%86%B3%E6%89%B9%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/01/07/Tools/%E8%A7%A3%E5%86%B3%E6%89%B9%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>通过修改cmd编码格式解决批处理程序中文乱码问题 <span id="more"></span></p><p>参考链接：<ahref="https://blog.csdn.net/qq_43553082/article/details/125902114?spm=1001.2014.3001.5501">如何修改cmd的编码格式即当前活动代码页编号（比如修改为utf-8、GBK2312）_Interfrog的博客-CSDN博客_cmd编码</a></p>]]></content>
    
    
    <categories>
      
      <category>小知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pake自动化脚本</title>
    <link href="/2023/01/07/Tools/pake%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/"/>
    <url>/2023/01/07/Tools/pake%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>基于rust打包网页应用 <span id="more"></span></p><p>本文使用开源项目工具Pake：<ahref="https://github.com/tw93/Pake">tw93/Pake: 🤱🏻 Simply make any webpage a desktop application using Rust. 🤱🏻 很简单的用 Rust打包网页生成很小的桌面 App (github.com)</a></p><p>在使用前需要先安装VS相关tool以及rust，随后使用npm安装pake包，教程参见上述链接</p><p>下表给出使用命令行安装的常用命令：</p><table><tr><th align="center">参数</th><th align="center">说明</th><th align="center">用法</th></tr><tr><td align="center">url</td><td>打包的网页链接,必须提供</td><td>pake &amp;lt url &amp;gt</td></tr><tr><td align="center">name</td><td>应用名称</td><td>--name &amp;lt value &amp;gt</td></tr><tr><td align="center">icon</td><td>应用图标，支持本地/远程文件,Windows必须为.ico,MacOS必须为.icns,Linux必须为.png</td><td>--icon &amp;lt path &amp;gt</td><p>在本人使用过程中发现必须在nodejs/node_global/node_modules/pake-cli目录下以管理员方式打开才可以使用，十分不便，因此编写批处理程序简化操作。</p><p>在bat中获取管理员权限有多种方法，代码参考链接：<ahref="https://blog.csdn.net/oShuangYue12/article/details/106055253">bat以管理员运行</a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">setlocal<br><span class="hljs-built_in">set</span> uac=~uac_permission_tmp_%random%<br>md <span class="hljs-string">&quot;%SystemRoot%\system32\%uac%&quot;</span> 2&gt;nul<br><span class="hljs-keyword">if</span> %errorlevel%==0 ( rd <span class="hljs-string">&quot;%SystemRoot%\system32\%uac%&quot;</span> &gt;nul 2&gt;nul ) <span class="hljs-keyword">else</span> (<br>    <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> uac = CreateObject^(<span class="hljs-string">&quot;Shell.Application&quot;</span>^)&gt;<span class="hljs-string">&quot;%temp%\%uac%.vbs&quot;</span><br>    <span class="hljs-built_in">echo</span> uac.ShellExecute <span class="hljs-string">&quot;%~s0&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;runas&quot;</span>,1 &gt;&gt;<span class="hljs-string">&quot;%temp%\%uac%.vbs&quot;</span><br>    <span class="hljs-built_in">echo</span> WScript.Quit &gt;&gt;<span class="hljs-string">&quot;%temp%\%uac%.vbs&quot;</span><br>    <span class="hljs-string">&quot;%temp%\%uac%.vbs&quot;</span> /f<br>    del /f /q <span class="hljs-string">&quot;%temp%\%uac%.vbs&quot;</span> &amp; <span class="hljs-built_in">exit</span> )<br>endlocal<br></code></pre></td></tr></table></figure> 随后给出需要的三个参数即可 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /d D:\nodejs\node_global\node_modules\pake-cli<br><span class="hljs-built_in">set</span> /p url=please input the url: <br><span class="hljs-built_in">set</span> /p title=please input the title: <br><span class="hljs-built_in">set</span> /p ico=please input the ico path: <br>pake %url% --name %title% --icon %ico%<br>pause<br></code></pre></td></tr></table></figure></p><p>由于pake-cli文件夹权限较高，未找到直接打开其中msi文件的方法，为了简化安装流程，给出打开文件夹的脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br>start explorer <span class="hljs-string">&quot;D:\nodejs\node_global\node_modules\pake-cli&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo自动化脚本</title>
    <link href="/2023/01/06/Tools/hexo%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/"/>
    <url>/2023/01/06/Tools/hexo%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>Windows一键完成新建博客、提交next更新、启动本地service<span id="more"></span></p><h4 id="新建博客">新建博客</h4><p>创建.bat文件，cd后路径改为blog根目录</p><p><span class="citation" data-cites="echo">@echo</span> off会取消后续命令的显示</p><p>pause会使命令执行完之后不关闭脚本界面，以便查看是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br> <span class="hljs-built_in">cd</span> /d D:\Blog\GreaterChen.github.io\myblog<br> call hexo new <span class="hljs-string">&quot;new post&quot;</span><br> pause<br></code></pre></td></tr></table></figure><h4 id="自动提交">自动提交</h4><p>思路同上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">cd</span> /d  D:\Blog\GreaterChen.github.io\myblog<br>call hexo clean<br>call hexo g<br>call hexo d<br>pause<br></code></pre></td></tr></table></figure><h4 id="启动本地service">启动本地service</h4><p>思路同上 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">cd</span> /d  D:\Blog\GreaterChen.github.io\myblog<br>call hexo s<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Typora下载激活</title>
    <link href="/2023/01/06/Tools/Typore%E4%B8%8B%E8%BD%BD%E6%BF%80%E6%B4%BB/"/>
    <url>/2023/01/06/Tools/Typore%E4%B8%8B%E8%BD%BD%E6%BF%80%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<p>Typora最新版本激活</p><span id="more"></span><h2 id="typora">Typora</h2><ul><li>参考网址：<ahref="https://www.cnblogs.com/hackettt/p/16335288.html">typora下载和破解（仅供学习）- hackettt - 博客园 (cnblogs.com)</a></li></ul><p>​ 评价：版本较低（1.0）</p><ul><li>参考网址：<ahref="https://www.bilibili.com/video/BV1HG4y1171i/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&amp;vd_source=1455a4be36d2913a951945519501ede2">Typora激活，任意版本，最新版也可以，巨简单_哔哩哔哩_bilibili</a></li></ul><p>​ 下载地址：https://wweb.lanzoum.com/iOTy30jxhfxi</p><p>​ 使用方法：把解压出的文件放到typora根目录即可</p><p>​ 评价：任意版本，使用方便</p>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
