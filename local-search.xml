<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>八股-计算机网络</title>
    <link href="/2024/04/17/SoftwareDevelopment/%E5%85%AB%E8%82%A1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/04/17/SoftwareDevelopment/%E5%85%AB%E8%82%A1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>计算机网络学习</p><span id="more"></span><h3 id="网络分层模型">网络分层模型</h3><p>现在被提起最多的网络模型主要有两个，一个是国际标准化组织提出的OSI7层网络模型，一个是目前被广泛使用的TCP/IP四层网络模型。</p><h4 id="osi七层模型">OSI七层模型</h4><p>OSI七层网络模型自底向上分为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层，由于它比较复杂而且不实用，而且有些功能在多个层中重复出现，所以并没有被广泛使用。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417152617.png" /></p><h4 id="tcpip四层模型">TCP/IP四层模型</h4><p>自底向上分为网络接口层、网络层、传输层、应用层。</p><ol type="1"><li>应用层：主要提供两个终端设备上的<strong>应用程序</strong>之间信息交换的服务，它定义了信息交换的格式。应用层的协议比较丰富，而且和我们日常使用息息相关，比如浏览网页的HTTP，HTTPS，文件传输的FTP，解析域名的DNS等等。</li><li>传输层：传输层的主要任务就是负责向两台终端设备进程之间的通信<strong>提供通用的数据传输服务</strong>。协议主要包括TCP和UDP。</li><li>网络层：负责在若干设备组成的互联网上根据IP地址对数据包进行转发和路由。包含的协议有IP网际协议、ARP地址解析协议、NAT网络地址转换协议等等</li><li>网络接口层：将网络层交下来的 IP数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</li></ol><h4 id="为什么要分层">为什么要分层</h4><ol type="1"><li>各层之间相互独立，不需要关心其他层是如何实现的，只需要知道如何调用下层提供好的接口即可</li><li>提高整体灵活性，每一层都可以使用最适合的技术实现，只需要确保功能和接口不改变即可。符合高内聚低耦合的设计原则</li></ol><h3 id="网址处理流程">网址处理流程</h3><h4 id="域名解析工作流程">域名解析工作流程</h4><ol type="1"><li><p>首先查看浏览器缓存、操作系统缓存，hosts文件，如果有直接使用</p></li><li><p>客户端首先会发出一个 DNS 请求（UDP），并发给本地 DNS服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。</p><p>当客户端发出DNS查询时，它通常使用UDP协议发送到目标DNS服务器的端口53，当DNS响应数据超过512字节（UDP限制）时，会使用TCP来传输。</p></li><li><p>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到，则它直接返回IP 地址。如果没有，本地 DNS 会去问它的根域名服务器</p></li><li><p>根 DNS 收到来自本地 DNS的请求后，找到顶级域名服务器地址返回</p></li><li><p>本地DNS收到顶级域名服务器地址后再次发送请求</p></li><li><p>顶级域名服务器给出权威DNS服务器地址</p></li><li><p>本地DNS向权威DNS服务器发送请求</p></li><li><p>权威DNS查询后将IP返回</p></li></ol><h4 id="tcp">TCP</h4><h5 id="请求头结构">请求头结构</h5><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417162244.png" style="zoom:80%;" /></p><ol type="1"><li>首先，<strong>源端口号</strong>和<strong>目标端口</strong>号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</li></ol><p>​端口号如何获取？许多网络服务有默认端口号比如HTTP是80，HTTPS是443；其他的需要在URL中明确指出端口号。</p><ol start="2" type="1"><li>接下来有包的<strong>序</strong>号，这个是为了解决包乱序的问题。</li><li><strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。</li><li><strong>状态位</strong>。例如 <code>SYN</code>是发起一个连接，<code>ACK</code> 是回复，<code>RST</code>是重新连接，<code>FIN</code> 是结束连接等。TCP是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</li><li><strong>窗口大小</strong>。TCP要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力</li></ol><h5 id="分割数据">分割数据</h5><p>如果 HTTP 请求消息比较长，超过了 <code>MSS</code> 的长度，这时 TCP就需要把 HTTP的数据拆解成一块块的数据发送，而不是一次性发送所有数据。数据会被以<code>MSS</code>的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上TCP 头信息，然后交给 IP 模块来发送数据。</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417162623.png" style="zoom:67%;" /></p><h4 id="ip">IP</h4><h5 id="ip报文头部格式">IP报文头部格式</h5><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417162744.png" style="zoom:50%;" /></p><ol type="1"><li><p>在 IP 协议里面需要有<strong>源地址 IP</strong> 和<strong>目标地址 IP</strong></p></li><li><p>因为 HTTP 是经过 TCP 传输的，所以在 IP包头的<strong>协议号</strong>，要填写为<code>06</code>（十六进制），表示协议为 TCP。</p></li></ol><h4 id="mac">MAC</h4><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC地址等信息。</p><p>发送方MAC地址在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到MAC 头部就可以了。</p><p>接收方MAC地址需要ARP协议获取。如果对方和自己处于同一个子网中，ARP协议会在以太网中以<strong>广播</strong>的形式询问MAC地址，目标主机即可返回MAC地址。如果对方和自己不处于同一个子网，ARP协议广播获得默认路由的MAC地址并发送，由路由找到目标子网（路由器之间的传输也需要MAC地址）。</p><h3 id="http">HTTP</h3><h4 id="消息头常见字段">消息头常见字段</h4><ol type="1"><li>Host：指定请求将发送到的服务器的域名和端口号</li><li>Content-Length：表明了请求体的大小，解决粘包</li><li>Connection：用于客户端要求服务器使用「HTTP长连接」机制，以便其他请求复用。</li><li>Content-type：用于服务器回应时，告诉客户端，本次数据是什么格式。</li></ol><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417173130.png" style="zoom: 33%;" /></p><h4 id="常见状态码">常见状态码</h4><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417170858.png" style="zoom: 50%;" /></p><ol type="1"><li>200 OK 表示一切正常</li><li>204 No Content 没有响应体body数据</li><li>206 Partial Content应用于分块下载或断点续传，表示body数据是资源的一部分</li><li>301 Moved Permanently表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问</li><li>302 Found 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL来访问</li><li>304 Not Modified不具有跳转的含义，表示资源未修改，告诉客户端可以继续使用缓存资源，用于缓存控制</li><li>400 Bad request 表示客户端请求的报文有错误</li><li>403 Forbidden 表示服务器禁止访问资源，并不是客户端的请求出错</li><li>404 Not Found表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端</li><li>500 Internal Server Error 表示服务器发生错误</li><li>501 Not Implemented 表示客户端请求的功能还不支持</li><li>502 Bad Gateway服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误</li><li>503 Service Unavailable 表示服务器当前很忙，暂时无法响应客户端</li></ol><h4 id="粘包问题">粘包问题</h4><p>HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP传输协议，就会存在一个“粘包”的问题，即可能一个请求会分散在好几个TCP包中，也有可能好几个请求的内容出现在一个TCP包中。</p><p><strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过Content-Length 字段作为 HTTP body的边界，这两个方式都是为了解决“粘包”的问题</strong>。</p><h4 id="http缓存">HTTP缓存</h4><h5 id="强制缓存">强制缓存</h5><p>只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边，响应头中Cache-Control存储一个相对时间用来判断是否过期。</p><h5 id="协商缓存">协商缓存</h5><p><strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><p>第一种：请求头部中的 <code>If-Modified-Since</code>字段与响应头部中的 <code>Last-Modified</code>字段实现，这两个字段的意思是：</p><ul><li>响应头部中的<code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li><li>请求头部中的<code>If-Modified-Since</code>：当资源过期了，发现响应头中具有Last-Modified 声明，则再次发起请求的时候带上 Last-Modified的时间，服务器收到请求后发现有 If-Modified-Since则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304走缓存。</li></ul><p>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的<code>ETag</code> 字段，这两个字段的意思是：</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的<code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag的值。服务器收到请求后进行比对，如果资源没有变化返回304，如果资源变化了返回 200。</li></ul><h4 id="https">HTTPS</h4><p>HTTPS 解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS安全协议，使得报文能够加密传输。</p><h5 id="混合加密">混合加密</h5><p>HTTPS采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><h5 id="摘要算法数字签名">摘要算法+数字签名</h5><p>用摘要算法（哈希函数）来计算出内容的哈希值，也就是内容的「指纹」，这个哈希值是唯一的，且无法通过哈希值推导出内容,保证消息的完整性。</p><p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 +哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。那为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决。</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li></ul><p>非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p><h5 id="数字证书">数字证书</h5><p>CA（数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417180053.png" style="zoom:67%;" /></p><h5 id="建立连接">建立连接</h5><p>基于 RSA 算法的 TLS 握手过程需要四次通信。</p><ol type="1"><li><p>首先，由客户端向服务器发起加密通信请求，也就是<code>ClientHello</code> 请求。</p><p>在这一步，客户端主要向服务器发送以下信息：</p><p>（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</p><p>（2）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。</p><p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p></li><li><p>服务器收到客户端请求后，向客户端发出响应，也就是<code>SeverHello</code>。服务器回应的内容有如下内容：</p><p>（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p><p>（2）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</p><p>（3）确认的密码套件列表，如 RSA 加密算法。</p><p>（4）服务器的数字证书。</p></li><li><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p></li></ol><p>​（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</p><p>​（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>​（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、ServerRandom、pre-masterkey），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><ol start="4" type="1"><li><p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）经过公钥加密后的信息之后，使用私钥解密，然后通过协商的加密算法，计算出本次通信的「会话秘钥」。</p><p>然后，向客户端发送最后的信息：</p><p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p></li></ol><p>基于 RSA 算法的 HTTPS存在「前向安全」的问题：如果服务端的私钥泄漏了，过去被第三方截获的所有TLS 通讯密文都会被破解。</p><p>为了解决这个问题，后面就出现了 ECDHE密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法。</p><h5 id="数字证书签发和验证流程">数字证书签发和验证流程</h5><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417180919.png" /></p><h4 id="http演变">HTTP演变</h4><h5 id="http1.1">HTTP1.1</h5><p>改进：</p><ul><li>使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li><li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p>不足：</p><ul><li>请求 /响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩<code>Body</code> 的部分；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应。</li></ul><h5 id="http2">HTTP2</h5><p>改进：</p><ul><li>头部压缩：如果同时发出多个请求，头是一样或相似的，HPACK会消除重复部分（在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了）</li><li>二进制格式：头信息和数据体都采用二进制格式，在HTTP1.1里面采用纯文本（ASCII编码）格式</li><li>并发传输：1 个 TCP 连接包含多个 Stream，<strong>针对不同的 HTTP请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream，也就是 HTTP/2 可以并行交错地发送请求和响应</strong>。</li><li>服务器主动推送资源：客户端和服务器<strong>双方都可以建立Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream必须是奇数号，而服务器建立的 Stream 必须是偶数号。</li></ul><p>不足：</p><p>HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给HTTP 应用，那么当「前 1个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2队头阻塞问题</p><h5 id="http3">HTTP3</h5><ol type="1"><li>无队头堵塞：<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。HTTP/2只要某个流中的数据包丢失了，其他流也会因此受影响。</li><li>更快的建立连接：UDP和TLS1.3合并到一起，只需要1个RTT即可连接</li><li>连接迁移：不使用源地址端口号、目标地址端口号进行连接，而是采用连接ID标记，这样4G切换WIFI就不会产生卡顿</li></ol><h3 id="tcp-1">TCP</h3><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417162244.png" style="zoom: 50%;" /></p><h4 id="三次握手">三次握手</h4><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417190236.png" style="zoom:50%;" /></p><h5 id="流程">流程</h5><ol type="1"><li>一开始，客户端和服务端都处于 <code>CLOSE</code>状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li><li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为<code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于<code>SYN-SENT</code> 状态。</li><li>服务端收到客户端的 <code>SYN</code>报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入<code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code>标志位置为<code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于<code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文TCP 首部 <code>ACK</code> 标志位置为 <code>1</code>，其次「确认应答号」字段填入 <code>server_isn + 1</code>，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于<code>ESTABLISHED</code> 状态。</li><li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code>状态。</li></ol><h5 id="为什么是三次">为什么是三次？</h5><p>假设是两次，那么服务端收到SYN报文之后发送应答报文，然后就应该一直处于establish状态</p><ol type="1"><li><p>防止旧的重复连接初始化造成混乱</p><p>客户端先发送了 SYN（seq = 90）报文，然后客户端宕机了，而且这个 SYN报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了SYN（seq =100）报文。如果seq=90的报文先到达，那么服务器会发送第二次握手应答，客户端发现并不是自己想要的acknum（101），那么就会发送RST报文终止连接。</p><p>如果是两次握手连接，seq=90的报文到达之后服务器就会建立连接并且可以发送数据，直到收到客户端的RST报文才会停止。因此<strong>服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。</strong></p></li><li><p>同步双方初始序列号</p><p>所以当客户端发送携带「初始序列号」的 <code>SYN</code>报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p></li><li><p>避免资源浪费</p><p>如果客户端发送的 <code>SYN</code> 报文在网络中阻塞了，重复发送多次<code>SYN</code>报文，那么服务端在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p></li></ol><h5id="为什么每次建立连接初始化的序列号都不一样">为什么每次建立连接初始化的序列号都不一样</h5><ol type="1"><li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li></ol><p>​ RFC793 提到初始化序列号 ISN 随机生成算法：ISN = M + F(localhost,localport, remotehost, remoteport)。</p><ul><li><p>M是一个计时器，这个计时器每隔 4 微秒加1。</p></li><li><p>F 是一个 Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值，要保证 hash算法不能被外部轻易推算得出</p><p>如果序列号回绕的时间极短，我们就会再次面临之前延迟的报文抵达后序列号依然有效的问题。</p><p>为了解决这个问题，就需要有 TCP 时间戳。tcp_timestamps参数是默认开启的，开启了 tcp_timestamps 参数，TCP头部就会使用时间戳选项，它有两个好处，<strong>一个是便于精确计算 RTT，另一个是能防止序列号回绕（PAWS）</strong>。</p></li></ul><h5 id="握手报文丢失">握手报文丢失</h5><ol type="1"><li><p>第一次握手丢失</p><p>如果客户端迟迟收不到服务端的 SYN-ACK报文（第二次握手），就会触发「超时重传」机制，重传 SYN报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</p></li><li><p>第二次握手丢失</p><p>如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传SYN 报文</strong>。</p><p>如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传SYN-ACK 报文</strong>。</p></li><li><p>第三次握手丢失</p><p>服务端超时重传</p></li></ol><h5 id="syn攻击">SYN攻击</h5><p>开启 syncookies 功能就可以在不使用 SYN半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。</p><ul><li>当 「 SYN 队列」满之后，后续服务端收到 SYN包，不会丢弃，而是根据算法，计算出一个 <code>cookie</code> 值；</li><li>将 cookie值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端；</li><li>服务端接收到客户端的应答报文时，服务端会检查这个 ACK包的合法性。如果合法，将该连接对象放入到「 Accept 队列」。</li><li>最后应用程序通过调用 <code>accpet()</code> 接口，从「 Accept队列」取出的连接。</li></ul><h4 id="四次挥手">四次挥手</h4><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417213104.png" style="zoom:50%;" /></p><h5 id="三次挥手">三次挥手？</h5><p>当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启TCP_QUICKACK（默认情况就是没有开启，没有开启TCP_QUICKACK，等于就是在使用 TCP延迟确认机制）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p><h5 id="time_wait">TIME_WAIT</h5><ul><li><p>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</p><p>如果发送第四次挥手之后客户端直接关闭，服务端在关闭连接之前发送的<code>SEQ = 301</code>报文，被网络延迟了。接着，服务端以相同的四元组重新打开了新连接，前面被延迟的<code>SEQ = 301</code>这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。</p></li><li><p>保证「被动关闭连接」的一方，能被正确的关闭；</p><p>2MSL时间保证了如果第四次挥手报文丢失，服务端能够超时重传</p></li></ul><h4 id="重传">重传</h4><ol type="1"><li><p>超时重传</p><p>TCP 会在以下两种情况发生超时重传：</p><ul><li>数据包丢失</li><li>确认应答丢失</li></ul></li><li><p>快速重传</p><p>客户端连续三次发现ACK的是2，就会直接重传2号报文</p></li><li><p>SACK方法</p><p>需要在 TCP 头部「选项」字段里加一个 <code>SACK</code>的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417214625.png" /></p></li><li><p>DSACK</p></li></ol><p>​ <strong>使用了 SACK来告诉「发送方」有哪些数据被重复接收了。</strong></p><ul><li>「接收方」发给「发送方」的两个 ACK确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）</li><li><strong>于是「接收方」发现数据是重复收到的，于是回了一个 SACK =3000~3500</strong>，告诉「发送方」 3000~3500 的数据早已被接收了，因为ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个SACK 就代表着 <code>D-SACK</code>。</li><li>这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK确认报文丢了。</li></ul><h4 id="滑动窗口">滑动窗口</h4><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p><p><strong>累计应答</strong>：ACK600丢失了但是收到了ACK700，说明ACK600一定丢失了（不然ACK700这个报文就应该是ACK600）</p><h4 id="流量控制">流量控制</h4><ol type="1"><li>客户端发送 140 字节数据后，可用窗口变为 220 （360 - 140）。</li><li>服务端收到 140字节数据，<strong>但是服务端非常繁忙，应用进程只读取了 40 个字节，还有100 字节占用着缓冲区，于是接收窗口收缩到了 260 （360 -100）</strong>，最后发送确认信息时，将窗口大小通告给客户端。</li><li>客户端收到确认和窗口通告报文后，发送窗口<strong>减少为260</strong>。</li><li>客户端发送 180 字节数据，此时可用窗口减少到 80。</li><li>服务端收到 180 字节数据，<strong>但是应用程序没有读取任何数据，这180 字节直接就留在了缓冲区，于是接收窗口收缩到了 80 （260 -180）</strong>，并在发送确认信息时，通过窗口大小给客户端。</li><li>客户端收到确认和窗口通告报文后，发送窗口减少为 80。</li><li>客户端发送 80 字节数据后，可用窗口耗尽。</li><li>服务端收到 80 字节数据，<strong>但是应用程序依然没有读取任何数据，这80 字节留在了缓冲区，于是接收窗口收缩到了0</strong>，并在发送确认信息时，通过窗口大小给客户端。</li><li>客户端收到确认和窗口通告报文后，发送窗口减少为 0</li></ol><p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP连接一方收到对方的零窗口通知，就启动持续计时器。</strong>如果持续计时器超时，就会发送<strong>窗口探测( Window probe )报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><p><strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。</p><ol type="1"><li><p>让接收方不通告小窗口给发送方</p></li><li><p>让发送方避免发送小数据</p></li></ol><h4 id="拥塞控制">拥塞控制</h4><h5 id="慢启动">慢启动</h5><p>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加1，直到到达阈值（ssthresh）</p><h5 id="拥塞避免">拥塞避免</h5><p>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</p><h5 id="发生超时重传">发生超时重传</h5><ul><li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li><li><code>cwnd</code> 重置为 初值，进行慢启动</li></ul><h5 id="发生快速重传">发生快速重传</h5><ul><li><code>cwnd = cwnd/2</code> ;</li><li><code>ssthresh = cwnd</code>;</li><li>进入快速恢复算法</li></ul><h5 id="快速恢复">快速恢复</h5><p>快速恢复算法是认为，你还能收到 3 个重复 ACK说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p><ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><p><strong>为什么收到新的数据后，cwnd 设置回了 ssthresh ？</strong></p><p>首先，快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd来减缓拥塞，所以必然会出现 cwnd从大到小的改变。其次，过程2（cwnd逐渐加1）的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的</p><h4 id="tcp快速连接">TCP快速连接</h4><ul><li>在第一次建立连接的时候，服务端在第二次握手产生一个<code>Cookie</code> （已加密）并通过 SYN、ACK包一起发给客户端，于是客户端就会缓存这个<code>Cookie</code>，所以第一次发起 HTTP Get 请求的时候，还是需要 2 个RTT 的时延；</li><li>在下次请求的时候，客户端在 SYN 包带上 <code>Cookie</code>发给服务端，就提前可以跳过三次握手的过程，因为 <code>Cookie</code>中维护了一些信息，服务端可以从 <code>Cookie</code> 获取 TCP相关的信息，这时发起的 HTTP GET 请求就只需要 1 个 RTT 的时延；</li></ul><h3 id="ip-1">IP</h3><h4 id="ip地址分类">IP地址分类</h4><h5 id="初始分类">初始分类</h5><p>互联网诞生之初，IP地址显得很充裕，于是计算机科学家们设计了<strong>分类地址</strong>。IP地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。其中对于A、B、C 类主要分为两个部分，分别是<strong>网络号和主机号</strong>。</p><ul><li>主机号全为 1 指定某个网络下的所有主机，用于广播</li><li>主机号全为 0 指定某个网络</li></ul><p>缺点：</p><ol type="1"><li><strong>同一网络下没有地址层次</strong>，比如一个公司里用了 B类地址，但是可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种IP分类是没有地址层次划分的功能，所以这就<strong>缺少地址的灵活性</strong>。</li><li><strong>不能很好的与现实网络匹配</strong>。多的太多，少的太少</li></ol><h5 id="cidr">CIDR</h5><p>表示形式 <code>a.b.c.d/x</code>，其中 <code>/x</code> 表示前 x位属于<strong>网络号</strong>， x 的范围是 <code>0 ~ 32</code>，这就使得IP 地址更加具有灵活性。</p><p><strong>子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址</strong>。</p><p>假设对 C 类地址进行子网划分，网络地址 192.168.1.0，使用子网掩码255.255.255.192 对其进行子网划分。</p><p>C 类地址中前 24 位是网络号，最后 8位是主机号，根据子网掩码可知<strong>从 8 位主机号中借用 2位作为子网号</strong>。</p><h4 id="dhcp">DHCP</h4><p>电脑通常都是通过 DHCP 动态获取 IP 地址，大大省去了配 IP信息繁琐的过程。</p><ul><li>客户端首先发起 <strong>DHCP 发现报文（DHCP DISCOVER）</strong> 的 IP数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是UDP <strong>广播</strong>通信，其使用的广播目的地址是255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。客户端将该 IP数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</li><li>DHCP 服务器收到 DHCP 发现报文时，用 <strong>DHCP 提供报文（DHCPOFFER）</strong> 向客户端做出响应。该报文仍然使用 IP 广播地址255.255.255.255，该报文信息携带服务器提供可租约的 IP地址、子网掩码、默认网关、DNS 服务器以及 <strong>IP地址租用期</strong>。</li><li>客户端收到一个或多个服务器的 DHCP提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP请求报文（DHCP REQUEST</strong>进行响应，回显配置的参数。</li><li>最后，服务端用 <strong>DHCP ACK 报文</strong>对 DHCP请求报文进行响应，应答所要求的参数。</li></ul><h4 id="nat">NAT</h4><p>把 IP 地址 + 端口号一起进行转换。外部无法主动与 NAT内部服务器建立连接，因为 NAPT 转换表没有转换记录。</p><p>解决的方法主要有两种方法。</p><p><em>第一种就是<strong>改用 IPv6</strong></em></p><p>IPv6 可用范围非常大，以至于每台设备都可以配置一个公有 IP地址，就不搞那么多花里胡哨的地址转换了，但是 IPv6普及速度还需要一些时间。</p><p><em>第二种 <strong>NAT 穿透技术</strong></em></p><p>NAT 穿越技术拥有这样的功能，它能够让网络应用程序主动发现自己位于 NAT设备之后，并且会主动获得 NAT 设备的公有IP，并为自己建立端口映射条目，注意这些都是NAT设备后的应用程序自动完成的。</p><p>也就是说，在 NAT穿透技术中，NAT设备后的应用程序处于主动地位，它已经明确地知道 NAT设备要修改它外发的数据包，于是它主动配合 NAT设备的操作，主动地建立好映射，这样就不像以前由 NAT设备来建立映射了。</p><p>说人话，就是客户端主动从 NAT 设备获取公有 IP地址，然后自己建立端口映射条目，然后用这个条目对外通信，就不需要 NAT设备来进行转换了。</p><h4 id="icmp">ICMP</h4><p><code>ICMP</code> 主要的功能包括：<strong>确认 IP包是否成功送达目标地址、报告发送过程中 IP包被废弃的原因和改善网络设置等。</strong></p><p>ICMP 大致可以分为两大类：</p><ul><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li></ul><h4 id="igmp">IGMP</h4><p>在前面我们知道了组播地址，也就是 D类地址，既然是组播，那就说明是只有一组的主机能收到数据包，不在一组的主机不能收到数组包，怎么管理是否是在一组呢？那么，就需要<code>IGMP</code> 协议了。</p><p><strong>GMP是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间</strong>。</p><ul><li>IGMP报文向路由器申请加入和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除非主机通过IGMP 加入到组播组，主机申请加入到组播组时，路由器就会记录 IGMP路由器表，路由器后续就会转发组播包到对应的主机了。</li></ul><h4 id="ping的工作原理">ping的工作原理</h4><p>ping 命令执行的时候，源主机首先会构建一个 <strong>ICMP回送请求消息</strong>数据包。</p><p>ICMP 数据包内包含多个字段，最重要的是两个：</p><ul><li>第一个是<strong>类型</strong>，对于回送请求消息而言该字段为<code>8</code>；</li><li>另外一个是<strong>序号</strong>，主要用于区分连续 ping的时候发出的多个数据包。</li></ul><p>主机 <code>B</code> 会构建一个 <strong>ICMP回送响应消息</strong>数据包，回送响应数据包的<strong>类型</strong>字段为<code>0</code>，<strong>序号</strong>为接收到的请求数据包中的序号，然后再发送出去给主机A。</p><p>在规定的时候间内，源主机如果没有接到 ICMP的应答包，则说明目标主机不可达；如果接收到了 ICMP回送响应消息，则说明目标主机可达。此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是ICMP 数据包的时间延迟。</p><h4 id="localhost-127.0.0.1-0.0.0.0">localhost 127.0.0.1 0.0.0.0</h4><ul><li><code>127.0.0.1</code>是<strong>回环地址</strong>。<code>localhost</code>是<strong>域名</strong>，但默认等于<code>127.0.0.1</code>。</li><li>如果此时 <code>listen</code> 的是本机的 <code>0.0.0.0</code> ,那么它表示本机上的<strong>所有IPV4地址</strong>。</li><li><code>ping</code> 回环地址和 <code>ping</code>本机地址，是一样的，走的是<strong>lo0"假网卡"</strong>，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前<strong>狠狠拐了个弯</strong>，将数据插入到一个<strong>链表</strong>后就<strong>软中断</strong>通知<strong>ksoftirqd</strong>来进行<strong>收数据</strong>的逻辑，<strong>压根就不出网络</strong>。所以断网了也能<code>ping</code> 通回环地址。</li><li>如果服务器 <code>listen</code> 的是<code>0.0.0.0</code>，那么此时用<code>127.0.0.1</code>和本机地址<strong>都可以</strong>访问到服务。</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>八股-JVM</title>
    <link href="/2024/04/16/SoftwareDevelopment/%E5%85%AB%E8%82%A1-JVM/"/>
    <url>/2024/04/16/SoftwareDevelopment/%E5%85%AB%E8%82%A1-JVM/</url>
    
    <content type="html"><![CDATA[<p>JVM学习</p><span id="more"></span><h3 id="运行时数据区域">运行时数据区域</h3><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240416213839.png" style="zoom: 80%;" /></p><p><strong>线程私有的：</strong></p><ul><li><p>程序计数器</p></li><li><p>虚拟机栈</p><p>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。</p></li><li><p>本地方法栈</p><p>Java通过JNI调用本地的非Java代码</p></li></ul><p><strong>线程共享的：</strong></p><ul><li><p>堆</p></li><li><p>方法区</p><p>当虚拟机要使用一个类时，它需要读取并解析 Class文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的<strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p></li><li><p>直接内存 (非运行时数据区的一部分)</p><p>使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在Java 堆和 Native 堆之间来回复制数据。</p></li></ul><h4 id="为什么用元空间代替永久代">为什么用元空间代替永久代</h4><ol type="1"><li>整个永久代有一个 JVM本身设置的固定大小上限，无法进行调整（也就是受到 JVM内存的限制），而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li></ol><h4 id="java堆中创建对象的过程">Java堆中创建对象的过程</h4><ol type="1"><li><p><strong>类加载检查</strong></p><p>虚拟机遇到一条 new指令时，首先将去检查这个指令的参数是否能在方法区中的常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p></li><li><p><strong>分配内存</strong></p><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从Java 堆中划分出来。<strong>分配方式</strong>有<strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong>两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p>指针碰撞：</p><ul><li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li><li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul><p>空闲列表：</p><ul><li>适用场合：堆内存不规整的情况下。</li><li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul></li><li><p><strong>初始化零值</strong></p><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p></li><li><p><strong>设置对象头</strong></p><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong>另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p></li><li><p><strong>执行init方法</strong></p><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code>方法还没有执行，所有的字段都还为零。所以一般来说，执行 new指令之后会接着执行 <code>&lt;init&gt;</code>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p></li></ol><h4 id="对象的内存布局">对象的内存布局</h4><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong></p><h3 id="java垃圾回收">Java垃圾回收</h3><h4 id="堆的基本结构">堆的基本结构</h4><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol type="1"><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>JDK8之后永久代被元空间取代且移动到直接内存，并不存在于堆中</p><h4 id="内存泄漏途径">内存泄漏途径</h4><ol type="1"><li>静态集合类</li><li>单例模式</li><li>连接（IO）未释放</li><li>ThreadLocal使用不当</li></ol><h4 id="内存分配和回收原则">内存分配和回收原则</h4><ol type="1"><li><p><strong>对象优先在Eden区分配</strong>。当 Eden区没有足够空间进行分配时，虚拟机将发起一次 Minor GC（新生代收集）。GC期间虚拟机又发现 <code>allocation1</code> 无法存入 Survivor空间，所以只好通过 <strong>分配担保机制</strong>把新生代的对象提前转移到老年代中去。</p></li><li><p>大对象直接进入老年代</p></li><li><p>长期存活对象进入老年代</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为1)。对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1岁，当它的年龄增加到一定程度（默认为 15岁），就会被晋升到老年代中。</p></li></ol><h4 id="空间分配担保">空间分配担保</h4><p>在发生 Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看<code>-XX:HandlePromotionFailure</code>参数的设置值是否允许担保失败(Handle PromotionFailure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者<code>-XX: HandlePromotionFailure</code>设置不允许冒险，那这时就要改为进行一次 Full GC。</p><h4 id="死亡对象判断方法">死亡对象判断方法</h4><ol type="1"><li><p>引用计数法：无法解决两个对象相互引用问题</p></li><li><p>可达性分析</p><p>通过一系列的称为 <strong>“GC Roots”</strong>的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p><strong>GC Roots</strong>：</p><p>​ 虚拟机栈(栈帧中的局部变量表)中引用的对象</p><p>​ 本地方法栈(Native 方法)中引用的对象</p><p>​ 方法区中类静态属性引用的对象</p><p>​ 方法区中常量引用的对象</p><p>​ 所有被同步锁持有的对象</p><p>​ JNI（Java Native Interface）引用的对象</p></li></ol><h4 id="引用类型">引用类型</h4><ol type="1"><li><p>强引用</p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。</p></li><li><p>软引用</p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。<strong>软引用可用来实现内存敏感的高速缓存</strong>。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p></li><li><p>弱引用</p><p>只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p></li><li><p>虚引用</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p></li></ol><h4 id="如何判断一个类是无用的类">如何判断一个类是无用的类</h4><ol type="1"><li><p>该类所有的实例都已经被回收，也就是 Java堆中不存在该类的任何实例。</p></li><li><p>加载该类的 <code>ClassLoader</code> 已经被回收。</p></li><li><p>该类对应的 <code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ol><h4 id="垃圾收集算法">垃圾收集算法</h4><ol type="1"><li><p>标记-清除算法：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。效率不高且标记清除后会产生大量不连续的内存碎片。</p></li><li><p>复制算法：将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p></li><li><p>标记-整理算法：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p></li><li><p>分代收集算法：据对象存活周期的不同将内存分为几块。一般将 Java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p></li><li><p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p></li></ol><h4 id="minor-gcyoung-gc">Minor GC/Young GC</h4><p>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</p><p>新创建的对象优先在新生代 Eden 区进行分配,如果 Eden区没有足够的空间时,就会触发 Young GC 来清理新生代。</p><h4 id="full-gc">Full GC</h4><ol type="1"><li><strong>YoungGC 之前检查老年代</strong>:在要进行 Young GC的时候,发现老年代可用的连续内存空间 &lt; 新生代历次Yo u n g G C后升入老年代的对象总和的平均大小 ,说明本次 Young GC后可能升入老年代的对象大小,可能超过了老年代当前可用内存空间, 那就会触发Full GC。</li><li><strong>Yo u n g G C 之后老年代空间不足</strong>:执行 Young GC之后有一批对象需要放入老年代,此时老年代就是没有足够的内存空间存放这些对象了,此时必须立即触发一次 Full GC</li><li><strong>老年代空间不足</strong>,老年代内存使用率过高,达到一定比例,也会触发 Full GC。</li><li><strong>空间分配担保失败( Promotion Failure)</strong>,新生代的 To区放不下从 Eden 和 From 拷贝过来对象,或者新生代对象 GC年龄到达阈值需要晋升这两种情况, 老年代如果放不下的话都会触发 FullGC。</li><li><strong>方法区内存空间不足</strong>:如果方法区由永久代实现,永久代空间不足 Full GC。</li><li>System.gc()等命令触发: System.gc()、jmap -dump 等命令会触发 fullgc。</li></ol><h4 id="垃圾收集器">垃圾收集器</h4><ol type="1"><li><p>Serial收集器</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong>它的<strong>“单线程”</strong>的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（<strong>"Stop The World"</strong> ），直到它收集结束。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240416222237.png" /></p></li><li><p>ParNew收集器</p><p><imgsrc="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240416222532.png" /></p></li><li><p>Parallel Sacvenge收集器</p><p>JDK1.8默认收集器</p><figure><imgsrc="https://oss.javaguide.cn/github/javaguide/java/jvm/parallel-scavenge-garbage-collector.png"alt="Parallel Old收集器运行示意图" /><figcaption aria-hidden="true">Parallel Old收集器运行示意图</figcaption></figure></li><li><p>CMS收集器</p><p><strong>MS（Concurrent MarkSweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root相连的对象，速度很快 ；</p><p><strong>并发标记：</strong> 同时开启 GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p><p><strong>重新标记：</strong>重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p><p><strong>并发清除：</strong> 开启用户线程，同时 GC线程开始对未标记的区域做清扫。</p><p>缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul></li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240416225857.png" /></p><ol start="5" type="1"><li><p>G1收集器</p><p>JDK9之后的默认收集器</p><p><strong>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region划分内存空间以及有优先级的区域回收方式，保证了 G1收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）</p><p><imgsrc="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240416230340.png" /></p></li></ol><h3 id="双亲委派">双亲委派</h3><h4 id="实现方式">实现方式</h4><p>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</p><p>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器<code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器<code>BootstrapClassLoader</code> 中。</p><p>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的<code>findClass()</code> 方法来加载类）。</p><p>如果子类加载器也无法加载这个类，那么它会抛出一个<code>ClassNotFoundException</code> 异常。</p><h4 id="好处">好处</h4><p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了Java 的核心 API 不被篡改。</p><p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为<code>java.lang.Object</code>类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code>类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code>类，而不是你写的 <code>Object</code> 类。这是因为<code>AppClassLoader</code> 在加载你的 <code>Object</code>类时，会委托给 <code>ExtClassLoader</code> 去加载，而<code>ExtClassLoader</code> 又会委托给<code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code>发现自己已经加载过了 <code>Object</code>类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>八股-Java并发编程</title>
    <link href="/2024/04/16/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/04/16/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>Java并发编程学习</p><span id="more"></span><h3 id="进程和线程">进程和线程</h3><p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区(JDK1.8之后的元空间)</strong>资源，但是每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和 <strong>本地方法栈</strong>。</p><h4id="虚拟机栈和本地方法栈为什么是私有的">虚拟机栈和本地方法栈为什么是私有的?</h4><ul><li><strong>虚拟机栈：</strong> 每个 Java方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><h4 id="线程安全">线程安全</h4><p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。</p><ul><li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li><li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li></ul><h4 id="线程生命周期和状态">线程生命周期和状态</h4><p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</p><p>RUNNABLE: 运行状态，线程被调用了<code>start()</code>等待运行的状态。</p><p>BLOCKED：阻塞状态，需要等待锁释放。</p><p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像WAITING 那样一直等待。</p><p>TERMINATED：终止状态，表示该线程已经运行完毕。</p><h4 id="线程死锁">线程死锁</h4><p>互斥条件：该资源任意一个时刻只由一个线程占用。</p><p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p><p>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</p><h4 id="预防死锁">预防死锁</h4><p>互斥条件：原则性问题，不可通过这种方法解决</p><p>请求与保持条件：一次性申请所有需要的资源</p><p>不剥夺条件:占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源</p><p>循环等待条件:按序申请资源</p><h4 id="wait和sleep">wait()和sleep()</h4><ol type="1"><li><p><strong><code>sleep()</code> 方法没有释放锁，而<code>wait()</code> 方法释放了锁</strong> 。</p></li><li><p><code>wait()</code>通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</p></li><li><p><code>wait()</code>方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的<code>notify()</code>或者 <code>notifyAll()</code>方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用<code>wait(long timeout)</code> 超时后线程会自动苏醒。</p></li><li><p><code>sleep()</code> 是 <code>Thread</code>类的静态本地方法，<code>wait()</code> 则是 <code>Object</code>类的本地方法。<code>wait()</code>是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入WAITING状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p></li></ol><h4 id="可以直接调用-thread-类的-run-方法吗">可以直接调用 Thread 类的run 方法吗？</h4><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用<code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<code>start()</code> 会执行线程的相应准备工作，然后自动执行<code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行<code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结：调用 <code>start()</code>方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code>方法的话不会以多线程的方式执行。</strong></p><h3 id="单例模式">单例模式</h3><p>如果我们将一个变量使用 <code>volatile</code> 修饰，这就指示编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p><strong>在 Java 中，<code>volatile</code>关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM的指令重排序。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>uniqueInstance</code> 采用 <code>volatile</code>关键字修饰也是很有必要的，<code>uniqueInstance = new Singleton();</code>这段代码其实是分为三步执行：</p><ol type="1"><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现<code>uniqueInstance</code> 不为空，因此返回<code>uniqueInstance</code>，但此时 <code>uniqueInstance</code>还未被初始化。</p><p><strong><code>volatile</code>关键字能保证变量的可见性，但不能保证对变量的操作是原子性的</strong></p><h3 id="锁">锁</h3><h4 id="synchronized锁">synchronized锁</h4><ol type="1"><li>修饰实例方法：锁定对象实例</li><li>修饰静态方法：锁定类</li><li>修饰代码块：锁定括号里指定的对象/类</li></ol><h4 id="锁升级">锁升级</h4><p>在 Java 6 之后， <code>synchronized</code>引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让<code>synchronized</code> 锁的效率提升了很多（JDK18中，偏向锁已经被彻底废弃，前面已经提到过了）。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h4 id="reentrantlock">ReentrantLock</h4><p><code>ReentrantLock</code>更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能</p><h4 id="公平锁和非公平锁">公平锁和非公平锁</h4><p><strong>公平锁</strong> :锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p><p><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</p><h4id="synchronized和reentrantlock关系">Synchronized和ReentrantLock关系</h4><ol type="1"><li>二者都是可重入锁</li><li><code>synchronized</code> 是依赖于 JVM实现的，<code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）</li><li>ReentrantLock有一些新特性<ol type="1"><li>等待可中断：在等待锁的线程可以选择放弃等待，改为处理其他事情。<code>synchronized</code>就属于是不可中断锁</li><li>可实现公平锁：可以指定是公平锁还是非公平锁，而<code>synchronized</code>只能是非公平锁</li><li>可实现选择性通知（锁可以绑定多个条件）:<code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ol></li></ol><h4 id="condition">Condition</h4><p><code>Condition</code>是 JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。</strong></p><p><strong>在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由JVM选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong>，这个功能非常重要，而且是 <code>Condition</code>接口默认提供的。而<code>synchronized</code>关键字就相当于整个<code>Lock</code>对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而<code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p><h3 id="threadlocal">ThreadLocal</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的,<strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值</strong></p><p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为key ，Object 对象为 value 的键值对</strong></p><h4 id="内存泄漏">内存泄漏</h4><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code>的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code>没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value不会被清理掉。</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的Entry。假如我们不做任何措施的话，value 永远无法被 GC回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code>实现中已经考虑了这种情况，在调用<code>set()</code>、<code>get()</code>、<code>remove()</code>方法的时候，会清理掉 key 为 null 的记录。</p><h3 id="线程池">线程池</h3><h4 id="优点">优点</h4><p>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><h4 id="为什么不用executors">为什么不用Executors</h4><p>通过<code>Executors</code>工具类可以创建多种类型的线程池，包括：</p><ul><li><code>FixedThreadPool</code>：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><code>SingleThreadExecutor</code>：只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><code>CachedThreadPool</code>：可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li><code>ScheduledThreadPool</code>：给定的延迟后运行任务或者定期执行任务的线程池</li></ul><p><code>Executors</code> 返回线程池对象的弊端如下：</p><ul><li><code>FixedThreadPool</code> 和<code>SingleThreadExecutor</code>:使用的是无界的<code>LinkedBlockingQueue</code>，任务队列最大长度为<code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li><li><code>CachedThreadPool</code>:使用的是同步队列<code>SynchronousQueue</code>, 允许创建的线程数量为<code>Integer.MAX_VALUE</code>，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致OOM。</li><li><code>ScheduledThreadPool</code> 和<code>SingleThreadScheduledExecutor</code>:使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为<code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li></ul><h4 id="核心参数">核心参数</h4><ul><li><p><strong>intcorePoolSize</strong>：该线程池中<strong>核心线程数最大值</strong></p><blockquote><p>核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。</p></blockquote></li><li><p><strong>intmaximumPoolSize</strong>：该线程池中<strong>线程总数最大值</strong>。</p><blockquote><p>该值等于核心线程数量 + 非核心线程数量。</p></blockquote></li><li><p><strong>longkeepAliveTime</strong>：<strong>非核心线程闲置超时时长</strong>。</p><blockquote><p>非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。</p></blockquote></li><li><p><strong>TimeUnit unit</strong>：keepAliveTime的单位。</p><p>TimeUnit是一个枚举类型 ，包括以下属性：</p><blockquote><p>NANOSECONDS ： 1微毫秒 = 1微秒 / 1000 MICROSECONDS ： 1微秒 = 1毫秒 /1000 MILLISECONDS ： 1毫秒 = 1秒 /1000 SECONDS ： 秒 MINUTES ： 分 HOURS： 小时 DAYS ： 天</p></blockquote></li><li><p><strong>BlockingQueueworkQueue</strong>：阻塞队列，维护着<strong>等待执行的Runnable任务对象</strong>。</p><p>常用的几个阻塞队列：</p><ol type="1"><li><p><strong>LinkedBlockingQueue</strong></p><p>链式阻塞队列，底层数据结构是链表，默认大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。</p></li><li><p><strong>ArrayBlockingQueue</strong></p><p>数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</p></li><li><p><strong>SynchronousQueue</strong></p><p>同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</p></li><li><p><strong>DelayQueue</strong></p><p>延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。</p></li><li><p><strong>PriorityBlockingQueue</strong></p><p>优先级阻塞队列,创建 <code>PriorityBlockingQueue</code> 时传入一个<code>Comparator</code> 对象来指定任务之间的排序规则</p></li></ol></li><li><p><strong>RejectedExecutionHandler handler</strong></p><p><strong>拒绝处理策略</strong>，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为：</p><ol type="1"><li><strong>ThreadPoolExecutor.AbortPolicy</strong>：<strong>默认拒绝处理策略</strong>，丢弃任务并抛出RejectedExecutionException异常。</li><li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常。</li><li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</li><li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：由调用线程处理该任务。</li></ol></li></ul><h4 id="执行流程">执行流程</h4><ol type="1"><li>线程总数量 &lt;corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量&lt;corePoolSize时）。<strong>注意，这一步需要获得全局锁。</strong></li><li>线程总数量 &gt;=corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了<strong>线程复用</strong>）。</li><li>当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。<strong>注意，这一步需要获得全局锁。</strong></li><li>缓存队列满了，且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240416154159.png" /></p><h3 id="future">Future</h3><p><code>Future</code>类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过<code>Future</code>类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><h4 id="runable和callable">runable和callable</h4><p>runnable没有返回值，而实现callable接口的任务线程能返回执行结果</p><h3 id="aqs">AQS</h3><p>抽象队列同步器,主要用来构建锁和同步器。</p><p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS 是用 <strong>CLH 队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个 CLH锁队列的一个结点（Node）来实现锁的分配。在 CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p><h3 id="semaphore">Semaphore</h3><p><code>synchronized</code> 和 <code>ReentrantLock</code>都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。<code>Semaphore</code>是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为<code>permits</code>，你可以将 <code>permits</code>的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p><h3 id="countdownlatch">CountDownLatch</h3><p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的<code>state</code> 值为 <code>count</code>。当线程使用<code>countDown()</code>方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少<code>state</code>,直至 <code>state</code> 为 0 。当调用<code>await()</code> 方法的时候，如果 <code>state</code> 不为0，那就证明任务还没有执行完毕，<code>await()</code>方法就会一直阻塞，也就是说 <code>await()</code>方法之后的语句不会被执行。直到<code>count</code>个线程调用了<code>countDown()</code>使 state 值被减为0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code>方法之后的语句得到执行。</p><p>我们要读取处理 6 个文件，这 6个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。为此我们定义了一个线程池和count 为 6 的<code>CountDownLatch</code>对象。使用线程池处理读取任务，每一个线程处理完之后就将count-1，调用<code>CountDownLatch</code>对象的<code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>八股-Java集合</title>
    <link href="/2024/04/15/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Java%E9%9B%86%E5%90%88/"/>
    <url>/2024/04/15/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>Java集合学习</p><span id="more"></span><h3 id="list">List</h3><h4 id="arraylist和array的区别">ArrayList和Array的区别</h4><ol type="1"><li><p><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而<code>Array</code> 被创建之后就不能改变它的长度了。</p></li><li><p><code>ArrayList</code>允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</p></li><li><p><code>ArrayList</code>中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如Integer、Double 等）。<code>Array</code>可以直接存储基本类型数据，也可以存储对象。</p></li><li><p><code>ArrayList</code>支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如<code>add()</code>、<code>remove()</code>等。<code>Array</code>只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</p></li><li><p><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</p></li></ol><h4 id="arraylist和linkedlist">ArrayList和LinkedList</h4><ol type="1"><li>ArrayList的插入在不引发扩容的情况下，要看插入位置，头插<code>O(n)</code>，尾插<code>O(1)</code>,其他位置平均<code>O(n)</code>。由于ArrayList支持动态扩容，当前数组容量不足以插入的时候会创建新的列表，同时把数据拷贝过去，因此扩容需要<code>O(n)</code>的时间复杂度。删除同理但是不需要考虑扩容问题。</li><li>LinkedList是双向链表，头尾插删均为<code>O(1)</code>,指定位置插删需要先移动到指定位置，因此为<code>O(n)</code></li></ol><h4 id="arraylist扩容过程">ArrayList扩容过程</h4><p>以无参数构造方法创建 <code>ArrayList</code>时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10</p><p>在添加元素前，首先判断容量是否满足</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 加元素之前，先调用ensureCapacityInternal方法</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">// 这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>calculateCapacity计算当前所需容量，如果第一次添加元素同时采用默认构造方式，会构造一个长度为10的列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据给定的最小容量和当前数组元素来计算所需容量。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span><br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-comment">// 否则直接返回最小容量</span><br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br><br><span class="hljs-comment">// 确保内部容量达到指定的最小容量。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果当前容量小于最小需要的容量，就会进行扩容操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断是否需要扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">//判断当前数组容量是否足以存储minCapacity个元素</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//调用grow方法进行扩容</span><br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 要分配的最大数组大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ArrayList扩容的核心方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-comment">// 将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>    <span class="hljs-comment">// 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br><br>    <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span><br>    <span class="hljs-comment">// 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br><br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>Arrays.copyOf()内部调用System.arraycopy，内部自动申请一个新的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] copyOf(<span class="hljs-type">int</span>[] original, <span class="hljs-type">int</span> newLength) &#123;<br>  <span class="hljs-comment">// 申请一个新的数组</span><br>    <span class="hljs-type">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[newLength];<br><span class="hljs-comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span><br>    System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,<br>                     Math.min(original.length, newLength));<br>    <span class="hljs-keyword">return</span> copy;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="hashmap">HashMap</h3><h4 id="扩容机制">扩容机制</h4><p>jdk1.8之前采用数组+链表实现，即拉链法避免冲突</p><p>jdk1.8之后，当链表长度大于阈值（默认为 8）时，会首先调用<code>treeifyBin()</code>方法。这个方法会根据 HashMap数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行<code>resize()</code> 方法对数组扩容。</p><h4 id="负载因子">负载因子</h4><p>oadFactor 负载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于1，那么数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。默认值为0.75。<code>HashMap</code>默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</p><h4 id="插入元素">插入元素</h4><p>如果定位到的数组位置没有元素 就直接插入。</p><p>如果定位到的数组位置有元素就和要插入的 key 比较，如果存在 key相同就直接覆盖，如果 key 不相同，就判断 p是否是一个树节点，如果是就将元素添加进入红黑树。如果不是就遍历链表插入(插入的是链表尾部)。</p><h4 id="hashmap和hashset">HashMap和Hashset</h4><p>在 <code>HashSet</code> 的实现中，每个插入到 <code>HashSet</code>中的元素实际上作为 <code>HashMap</code>的键存储，而与每个键关联的值（value）则是一个固定的对象，通常是一个预定义的静态的私有对象（通常是<code>new Object()</code>的实例或者类似的占位符对象）。这个对象在所有的实例中是相同的</p><h4 id="hashmap和treemap">HashMap和TreeMap</h4><p><code>TreeMap</code> 和<code>HashMap</code>都继承自<code>AbstractMap</code>，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code>接口。</p><p><code>NavigableMap</code> 接口提供了丰富的方法来探索和操作键值对:</p><ol type="1"><li><p><strong>定向搜索</strong>: <code>ceilingEntry()</code>,<code>floorEntry()</code>, <code>higherEntry()</code>和<code>lowerEntry()</code>等方法可以用于定位大于、小于、大于等于、小于等于给定键的最接近的键值对。</p></li><li><p><strong>子集操作</strong>: <code>subMap()</code>,<code>headMap()</code>和 <code>tailMap()</code>方法可以高效地创建原集合的子集视图，而无需复制整个集合。</p></li><li><p><strong>逆序视图</strong>:<code>descendingMap()</code>方法返回一个逆序的 <code>NavigableMap</code> 视图，使得可以反向迭代整个<code>TreeMap</code>。</p></li><li><p><strong>边界操作</strong>: <code>firstEntry()</code>,<code>lastEntry()</code>, <code>pollFirstEntry()</code>和<code>pollLastEntry()</code> 等方法可以方便地访问和移除元素</p></li></ol><p>这些方法都是基于红黑树数据结构的属性实现的，红黑树保持平衡状态，从而保证了搜索操作的时间复杂度为O(log n)，这让 <code>TreeMap</code>成为了处理有序集合搜索问题的强大工具。</p><p><code>SortedMap</code>接口让 <code>TreeMap</code>有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，</p><h4 id="hashmap为什么线程不安全">Hashmap为什么线程不安全</h4><p>两个线程 1,2 同时进行 put操作，并且发生了哈希冲突。不同的线程可能在不同的时间片获得 CPU执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2先完成了插入操作。随后，线程 1 获得时间片，由于之前已经进行过 hash碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1覆盖了。</p><h4 id="concurrenthashmap">ConcurrentHashMap</h4><p>Java7 中 <code>ConcurrentHashMap</code> 使用的分段锁，也就是每一个Segment 上同时只有一个线程可以操作，每一个 <code>Segment</code>都是一个类似 <code>HashMap</code>数组的结构，它可以扩容，它的冲突会转化为链表。但是 <code>Segment</code>的个数一但初始化就不能改变。</p><p>Java8 中的 <code>ConcurrentHashMap</code> 使用的<code>Synchronized</code> 锁加 CAS 的机制。结构也由 Java7 中的<strong><code>Segment</code> 数组 + <code>HashEntry</code> 数组 +链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node是类似于一个 HashEntry的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p><h4 id="linkedhashmap">LinkedHashMap</h4><p><code>LinkedHashMap</code> 是 Java 集合框架中 <code>HashMap</code>的一个子类，它继承了 <code>HashMap</code> 的所有属性和方法，并且在<code>HashMap</code> 的基础重写了<code>afterNodeRemoval</code>、<code>afterNodeInsertion</code>、<code>afterNodeAccess</code>方法。使之拥有顺序插入和访问有序的特性。</p><ol type="1"><li><p>如何按照插入顺序迭代元素？</p><p>LinkedHashMap内部维护了一个双向链表，用于记录元素的插入顺序。当使用迭代器迭代元素时即为在链表中进行移动</p></li><li><p>如何按照访问顺序迭代元素</p><p>通过构造函数中的accessOrder参数指定，当设置为true时，每访问一个元素，该元素会被移动到链表的末尾</p></li><li><p>如何实现LRU</p><p>将accessOrder设置为true，同时重写removeEldestEntry当链表大小超过容量时返回true，这样一旦插入操作使得返回为true时，会移除链表首元素。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">super</span>(capacity, <span class="hljs-number">0.75f</span>, <span class="hljs-literal">true</span>);<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;<br>        <span class="hljs-keyword">return</span> size() &gt; capacity;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h4 id="copyonwritearraylist">CopyOnWriteArrayList</h4><p>当需要修改（ <code>add</code>，<code>set</code>、<code>remove</code>等操作） <code>CopyOnWriteArrayList</code>的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 插入元素到 CopyOnWriteArrayList 的尾部</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 加锁</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取原来的数组</span><br>        Object[] elements = getArray();<br>        <span class="hljs-comment">// 原来数组的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        <span class="hljs-comment">// 创建一个长度+1的新数组，并将原来数组的元素复制给新数组</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 元素放在新数组末尾</span><br>        newElements[len] = e;<br>        <span class="hljs-comment">// array指向新数组</span><br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 解锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="arrayblockingqueue">ArrayBlockingQueue</h4><p><code>ArrayBlockingQueue</code> 是 <code>BlockingQueue</code>接口的有界队列实现类，常用于多线程之间的数据共享，底层采用数组实现.</p><ul><li><code>ArrayBlockingQueue</code>内部维护一个定长的数组用于存储元素。</li><li>通过使用 <code>ReentrantLock</code>锁对象对读写操作进行同步，即通过锁机制来实现线程安全。</li><li>通过 <code>Condition</code> 实现线程间的等待和唤醒操作。</li></ul><p>这里再详细介绍一下线程间的等待和唤醒具体的实现（不需要记具体的方法，面试中回答要点即可）：</p><ul><li>当队列已满时，生产者线程会调用 <code>notFull.await()</code>方法让生产者进行等待，等待队列非满时插入（非满条件）。</li><li>当队列为空时，消费者线程会调用<code>notEmpty.await()</code>方法让消费者进行等待，等待队列非空时消费（非空条件）。</li><li>当有新的元素被添加时，生产者线程会调用<code>notEmpty.signal()</code>方法唤醒正在等待消费的消费者线程。</li><li>当队列中有元素被取出时，消费者线程会调用<code>notFull.signal()</code>方法唤醒正在等待插入元素的生产者线程。</li></ul><h4 id="delayqueue">DelayQueue</h4><ol type="1"><li><p>实现原理</p><p><code>DelayQueue</code> 底层是使用优先队列 <code>PriorityQueue</code>来存储元素，而 <code>PriorityQueue</code>采用二叉小顶堆的思想确保值小的元素排在最前面，这就使得<code>DelayQueue</code> 对于延迟任务优先级的管理就变得十分方便了。同时<code>DelayQueue</code> 为了保证线程安全还用到了可重入锁<code>ReentrantLock</code>,确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率，<code>DelayQueue</code>还用到了 <code>Condition</code>，通过 <code>Condition</code> 的<code>await</code> 和 <code>signal</code>方法完成多线程之间的等待唤醒。</p></li><li><p>使用场景</p><p><code>DelayQueue</code>通常用于实现定时任务调度和缓存过期删除等场景。在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到<code>DelayQueue</code> 中，<code>DelayQueue</code>会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。对于缓存过期这个场景而言，在数据被缓存到内存之后，我们可以将缓存的key 封装成一个延迟的删除任务，并将其添加到 <code>DelayQueue</code>中，当数据过期时，拿到这个任务的 key，将这个 key 从内存中移除。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博弈论</title>
    <link href="/2024/04/12/Algorithm/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <url>/2024/04/12/Algorithm/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>博弈论相关问题 <span id="more"></span></p><h3 id="nim游戏">NIM游戏</h3><p>给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</p><p>我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。NIM博弈不存在平局，只有先手必胜和先手必败两种情况。</p><p>定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0</p><h3 id="sg函数">SG函数</h3><p>在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1,y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk的SG函数值构成的集合再执行mex(S)运算的结果，即： SG(x) = mex({SG(y1),SG(y2), …, SG(yk)})特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G)= SG(s)。</p><h4 id="mex运算">Mex运算</h4><p>设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：mex(S) = min{x}, x属于自然数，且x不属于S</p><h4 id="有向图游戏的和">有向图游戏的和</h4><p>设G1, G2, …, Gm是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1,G2, …, Gm的和。有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)</p><h4 id="例题">例题</h4><p>给定堆石子以及一个由k个不同正整数构成的数字集合S。现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合S,最后无法进行操作的人视为失败。问如果两人都采用最优策略，先手是否必胜。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> s[<span class="hljs-number">110</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">10010</span>];<br><br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[x] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[x];<br>    set&lt;<span class="hljs-type">int</span>&gt; se;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x &gt;= s[i]) se.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">sg</span>(x-s[i]));<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;;i++)&#123;<br>        <span class="hljs-keyword">if</span>(se.<span class="hljs-built_in">find</span>(i) == se.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> f[x] = i;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;s[i];<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> f);<br>    cin&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        res ^= <span class="hljs-built_in">sg</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(res) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/04/10/%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83/"/>
    <url>/2024/04/10/%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<h3 id="使用的数据分布">使用的数据分布</h3><p>训练集分布： {0: 6, 1: 171, 2: 244} 测试集分布： {0: 41, 1: 28, 2:35} 验证集分布： {0: 55, 1: 42, 2: 64}</p><p>由于风险次序是【1，0，2】，所以处于中间风险的应为类别0.所以构造了类别0极少，其他两类相对均衡的训练数据，测试集和验证集仍保留了较多的第0类样本。</p><h3 id="baseline">baseline</h3><p>直接进行三分类，在1、2类上能够得到80+的准确度</p><p>测试集总体精度为: 0.5096153616905212<br />测试集各类精度为: tensor([0.0000, 0.8571, 0.8286])<br />测试集混淆矩阵为: tensor([[ 0., 31., 10.],<br />[ 0., 24., 4.],<br />[ 0., 6., 29.]])</p><h4 id="次序约束">次序约束</h4><p>添加次序约束，同时使用KL散度和交叉熵,结果和baseline几乎无区别</p><p>测试集总体精度为: 0.5192307829856873 测试集各类精度为:tensor([0.0000, 0.8929, 0.8286]) 测试集混淆矩阵为: tensor([[ 0., 31.,10.], [ 0., 25., 3.], [ 0., 6., 29.]])</p><h4 id="次序约束构造第二类样本">次序约束+构造第二类样本</h4><p>训练前期真实特征分布还并未向期望特征分布靠拢，因此在前期就进行mix-up操作并不合理，可能会起到反向作用。</p><p>训练过程：先进行上述次序约束实验，得到<strong>训练后模型</strong>后再固定分类器之前的网络参数，将最后的全连接层改为新的全连接层进行训练。这样在得到高维特征时可以保证符合先验分布，两侧特征相加才能等效中间类特征。</p><p>mix-up：在网络提取出高维特征之后，随机选择若干对1、2类样本，对特征求平均，加入中间数据中，同时标签中加入第0类。随后再进行全连接分类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">features_0 = features[chosen_idx_0[i]].unsqueeze(<span class="hljs-number">0</span>) <br>features_2 = features[chosen_idx_2[i]].unsqueeze(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 将features相加</span><br>mixed_features = (features_0 + features_2) / <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 将新的features和新的label（这里为0）添加到列表中</span><br>new_features.append(mixed_features)<br>new_labels.append(torch.tensor([<span class="hljs-number">0</span>], device=device))<br></code></pre></td></tr></table></figure><p>测试集总体精度为: 0.48076921701431274 测试集各类精度为:tensor([0.0000, 0.8571, 0.7429]) 测试集混淆矩阵为: tensor([[ 0., 27.,14.], [ 0., 24., 4.], [ 0., 9., 26.]])</p><p>结果并不好，对中间风险（第0类）仍然没有分辨能力。</p><p>观察一下标签为0的样本，模型对第0类样本的概率确实不像之前趋于0（前两个实验都是趋于0的），但是也没有超过1/3的</p><p><img src="C:\Users\chenl\AppData\Roaming\Typora\typora-user-images\image-20240410183811110.png" alt="image-20240410183811110" style="zoom:50%;" /></p><p>观察其他两类的样本，可以看出来似乎<strong>无论样本属于哪一类</strong>，<strong>模型对第0类的期望概率都差不多</strong>。模型对第0类似乎还是分辨不出来</p><p><img src="C:\Users\chenl\AppData\Roaming\Typora\typora-user-images\image-20240410183925468.png" alt="image-20240410183925468" style="zoom:50%;" /></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>后端八股</title>
    <link href="/2024/04/02/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/04/02/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>Java基础学习</p><span id="more"></span><h3 id="resource-和-autowired"><span class="citation"data-cites="Resource">@Resource</span> 和 <span class="citation"data-cites="Autowired">@Autowired</span></h3><p><code>@Autowired</code>和<code>@Resource</code>都是Spring框架提供的用于依赖注入的注解，但它们在注入方式和来源上有所不同。</p><h4 id="autowired"><code>@Autowired</code></h4><ul><li><strong>按类型自动装配</strong>：<code>@Autowired</code>默认按照类型进行自动装配。如果Spring容器中存在多个相同类型的bean，则会抛出异常，除非使用<code>@Qualifier</code>注解指定具体的bean。</li><li><strong>不需要指定bean的名称</strong>：因为<code>@Autowired</code>是按类型注入的，所以它不依赖于变量的名称。这意味着不管变量叫什么名字，只要类型匹配，Spring就会注入相应的bean。</li><li><strong>可选性</strong>：通过设置<code>@Autowired(required = false)</code>，可以使得某个bean的注入变为可选，即如果容器中没有找到对应类型的bean，Spring不会抛出异常，而是会留下一个null值。</li><li><strong>灵活性和使用范围</strong>：<code>@Autowired</code>可以用于构造函数、setter方法、属性以及自定义方法上，提供了更广的使用范围。</li></ul><h4 id="resource"><code>@Resource</code></h4><ul><li><strong>按名称自动装配</strong>：<code>@Resource</code>默认按照名称进行自动装配。如果没有指定名称，它会使用变量名作为bean名称去查找对应的bean。如果找不到匹配的名称，才会退回到按类型查找。</li><li><strong>需要考虑bean的名称</strong>：因为<code>@Resource</code>首先尝试按名称匹配bean，所以变量名或者指定的名称（使用<code>name</code>属性）对于找到正确的bean很重要。</li><li><strong>来源不同</strong>：<code>@Resource</code>注解是由JDK提供的（<code>javax.annotation.Resource</code>），属于JSR-250规范的一部分，而<code>@Autowired</code>是Spring特有的注解。</li></ul><h4 id="使用场景和选择">使用场景和选择</h4><ul><li>当你想要更精确地控制bean的选择时（特别是当存在多个相同类型的bean，但你希望注入一个特定名称的bean），<code>@Resource</code>可能是更好的选择。</li><li>如果你倾向于按类型装配依赖，或者想要利用Spring更丰富的自动装配特性（例如可选注入、构造函数注入等），<code>@Autowired</code>可能更适合你的需求。</li></ul><h3 id="所有对象实例都存在于堆中吗">所有对象实例都存在于堆中吗？</h3><p>在Java中，对象通常是在堆内存中分配的。堆内存用于存储Java程序运行期间创建的对象实例，而栈内存则用于存储方法调用时的局部变量和方法调用的上下文。但是，有一种优化技术，称为逃逸分析，可以改变这种分配方式。</p><p>逃逸分析是一种确定对象分配范围和寿命的技术。简单来说，它分析数据是否会“逃逸”出它被创建的上下文。如果一个对象只在一个方法中被使用，并且不会被返回或赋值给方法外的变量，那么这个对象就被认为是“不逃逸”的。</p><p>如果JIT（Just-In-Time编译器）在运行时通过逃逸分析确定一个对象不会逃逸到方法外部，它可以采取一种称为“标量替换”的优化手段。标量替换允许JIT编译器“拆解”这个对象，将其字段直接存储在栈上，而不是作为一个整体对象存储在堆上。这样做有几个好处：</p><ol type="1"><li><strong>性能提升</strong>：访问栈上的数据比堆上的数据要快，因为栈上的数据通常在内存中的位置更为靠近执行线程。</li><li><strong>减少垃圾收集压力</strong>：由于对象不在堆上分配，因此不需要由垃圾收集器回收，这可以减少垃圾收集的开销。</li></ol><h3 id="浮点数运算精度丢失">浮点数运算精度丢失</h3><p>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p><p><code>BigDecimal</code>可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过<code>BigDecimal</code> 来做的。</p><h3 id="重载和重写">重载和重写</h3><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p><h3 id="面向对象三大特性">面向对象三大特性</h3><h4 id="封装">封装</h4><p>封装是指把一个对象的状态信息（也就是属性）<strong>隐藏</strong>在对象内部，不允许外部对象直接访问对象的<strong>内部信息</strong>。但是可以提供一些可以被外界访问的方法来操作属性。</p><h4 id="继承">继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。同时，每一个对象还定义了额外的特性使得他们与众不同。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间，提高我们的开发效率。</p><h4 id="多态">多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例</p><ol type="1"><li><p>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</p></li><li><p>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</p></li><li><p>多态不能调用“只在子类存在但在父类不存在”的方法；</p></li><li><p>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</p></li></ol><h3id="接口和抽象类有什么共同点和区别">接口和抽象类有什么共同点和区别？</h3><p><strong>共同点</strong>：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 <code>default</code>关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong>：</p><ul><li>接口主要用于对类的行为进行约束，是横向对功能的拓展。你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 <code>public static final</code>类型的，不能被修改且必须有初始值，而抽象类的成员变量默认default，可在子类中被重新定义，也可被重新赋值</li></ul><h3id="深拷贝和浅拷贝区别了解吗-什么是引用拷贝">深拷贝和浅拷贝区别了解吗-什么是引用拷贝</h3><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p><ul><li><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p></li><li><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p></li><li><p><strong>引用拷贝</strong>:引用拷贝就是两个不同的引用指向同一个对象</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240403201541.png" /></p></li></ul><h3 id="和-equals-的区别">== 和 equals() 的区别</h3><p><strong><code>==</code></strong>比较的就是值，对于基本数据类型来说，<code>==</code>比较的就是本身的数值，对于引用数据类型来说，它存的值是对象的地址，所以此时<code>==</code>比较的是对象的内存地址。<code>equals()</code>是<code>Object</code>类的一个方法，所以基本数据类型是没有equals这个方法的，但是所有引用数据类型都有equals方法</p><p><strong><code>equals()</code></strong>不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p><ul><li><strong>类没有重写<code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是<code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写<code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回true(即，认为这两个对象相等)。</li></ul><h3 id="为什么要有-hashcode">为什么要有 hashCode？</h3><blockquote><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code>会先计算对象的 <code>hashCode</code>值来判断对象加入的位置，同时也会与其他已经加入的对象的<code>hashCode</code> 值作比较，如果没有相符的<code>hashCode</code>，<code>HashSet</code>会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code>值的对象，这时会调用 <code>equals()</code> 方法来检查<code>hashCode</code>相等的对象是否真的相同。如果两者相同，<code>HashSet</code>就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了<code>equals</code> 的次数，相应就大大提高了执行速度。</p></blockquote><p>其实， <code>hashCode()</code> 和<code>equals()</code>都是用于比较两个对象是否相等。</p><p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p><p>这是因为在一些容器（比如<code>HashMap</code>、<code>HashSet</code>）中，有了<code>hashCode()</code>之后，判断元素是否在对应容器中的<strong>效率会更高</strong>（参考添加元素进<code>HashSet</code>的过程）</p><p><strong>为什么重写 equals() 时必须重写 hashCode() 方法？</strong></p><p><code>equals()</code>是判断两个对象相等的金标准。那为什么要有hashcode呢？因为有了<code>hashCode()</code>之后，判断元素是否在对应容器中的<strong>效率会更高</strong>，在hashset中想插入一个对象，会先比较是否有hashcode相等的对象，如果相等，因为有散列冲突的问题存在，就需要进一步使用equals进行比较。也就是说如果<code>equals</code> 方法判断两个对象是相等的，那这两个对象的<code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code>方法的话就可能会导致 <code>equals</code>方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p><strong>总结</strong>：</p><ul><li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的<code>hashCode</code> 值也要相等。</li><li>两个对象有相同的 <code>hashCode</code>值，他们也不一定是相等的（哈希碰撞）。</li></ul><h3id="为什么jdk动态代理需要实现接口的类">为什么JDK动态代理需要实现接口的类？</h3><p><strong>JDK 动态代理类使用步骤</strong></p><ol type="1"><li>定义一个接口及其实现类；</li><li>自定义 <code>InvocationHandler</code>并重写<code>invoke</code>方法，在 <code>invoke</code>方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li><li>通过<code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code>方法创建代理对象；</li></ol><p>jdk动态代理生成的代理类实现了我们业务定义的接口，并重写了我们接口的方法，如此才实现代理的功能，所以我们的目标类需要实现接口。</p><p>在JDK动态代理中，当你创建一个代理实例时，你需要提供一个实现了一个或多个接口的类的实例，以及一个调用处理器（InvocationHandler）。Java运行时使用这些信息<strong>动态创建一个新的类</strong>，这个类在运行时被定义为提供的接口的一个<strong>实现</strong>。这意味着动态代理类在运行时创建，并且其类型信息是基于这些接口的。</p><p><strong>这个动态创建的类会将所有方法调用转发给调用处理器</strong>，这允许你在方法调用前后插入自定义逻辑，例如日志记录、事务处理等。这种转发是通过在代理类中重写接口的方法实现的，然后在这些方法中调用调用处理器。</p><h3 id="代理模式">代理模式</h3><p><strong>使用代理对象来代替对真实对象(realobject)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p><ol type="1"><li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB可以代理未实现任何接口的类。</strong>JDK动态代理基于<strong>接口</strong>实现,CGLIB基于<strong>继承</strong>实现.CGLIB动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK版本的升级，这个优势更加明显。</li></ol><h3 id="为什么bigdecimal没有精度问题">为什么BigDecimal没有精度问题</h3><p><code>BigDecimal</code>内部通过一个整数（<code>BigInteger</code>）来表示小数的精确值，和一个单独的整数来表示小数点的位置（也就是说，一个<code>BigDecimal</code>由一个不可变的<strong>任意精度整数</strong>非标度值和<strong>32位的整数标度组成</strong>，标度表示小数点右边的位数）。这意味着<code>BigDecimal</code>可以表示任意精度的小数，精度仅受可用内存的限制。</p><p>BigDecimal等值比较应使用compareTo()方法,而不是equals()方法,因为前者不会判断精度</p><h3 id="基本类型和包装类型">基本类型和包装类型</h3><ol type="1"><li>包装类型可用于泛型，而基本类型不可以</li><li>基本数据类型作为局部变量存放在栈中的局部变量表，成员变量存放在堆中；包装类型几乎都存在于堆中（逃逸分析）</li><li>基本数据类型有默认值，包装类型默认为null</li></ol><h3 id="为什么string是不可变的">为什么String是不可变的</h3><ol type="1"><li>保证 String对象的安全性，避免被篡改，毕竟像密码这种隐私信息一般就是用字符串存储的</li><li>保证哈希值不会频繁变更。毕竟要经常作为哈希表的键值，经常变更的话，哈希表的性能就会很差劲。</li><li>可以实现字符串常量池，Java会将相同内容的字符串存储在字符串常量池中。这样，具有相同内容的字符串变量可以指向同一个String 对象，节省内存空间。</li></ol><h3 id="字符串常量池">字符串常量池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;陈&quot;</span>);<br></code></pre></td></tr></table></figure><p>这行代码共创建了一个或两个对象：一个在字符串常量池中，一个在堆中</p><p>字符串常量池的位置：</p><ol type="1"><li>Java7之前在永久代中，永久代在堆中</li><li>java7时移动到堆中，永久代还在堆中</li><li>java8之后永久代被元空间替代，字符串常量池仍在堆中</li></ol><h3 id="永久代方法区元空间">永久代、方法区、元空间</h3><ul><li>方法区是 Java 虚拟机规范中的一个概念，就像是一个接口</li><li>永久代是 HotSpot虚拟机中对方法区的一个实现，就像是接口的实现类；</li><li>Java 8的时候，移除了永久代，取而代之的是元空间，是方法区的另外一种实现，更灵活了。<ul><li>它不会导致 OutOfMemoryError错误，因为元空间的大小可以动态调整。</li><li>元空间使用本机内存，而不是 JVM堆内存，这可以避免堆内存的碎片化问题。</li><li>元空间中的垃圾收集与堆中的垃圾收集是分离的，这可以避免应用程序在运行过程中因为进行类加载和卸载而频繁地触发Full GC。</li></ul></li></ul><h3 id="intern的作用">intern()的作用</h3><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br></code></pre></td></tr></table></figure><p>JVM首先会检查字符串常量池中是否已经存在字面值为"Java"的字符串对象。如果存在，就不会再创建一个新的字符串对象，而是直接将<code>s1</code>引用指向常量池中那已存在的字符串对象。如果不存在，JVM会在字符串常量池中创建一个新的字符串对象"Java"，然后<code>s1</code>引用指向这个新创建的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Java&quot;</span>)<br></code></pre></td></tr></table></figure><p>首先，如果字符串常量池中没有字面值为"java"的字符串，JVM会在常量池中创建一个"java"的字符串对象。如果常量池中已经存在"java"，则不会再创建。接着，<code>new String("java")</code>表达式会在堆内存中创建一个新的<code>String</code>对象。这个新的<code>String</code>对象会复制一份常量池中的"java"字符串作为自己的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;bro&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br>System.out.println(s1 == s2);<br></code></pre></td></tr></table></figure><p>返回false，因为s1指向的是堆中的对象，但是s2指向的是字符串常量池中的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br>System.out.println(s1 == s2);<br></code></pre></td></tr></table></figure><p>返回true，因为s1是对于常量池中的引用，s2也是</p><h3 id="stringbuffer和stringbuilder">StringBuffer和StringBuilder</h3><ol type="1"><li><code>String</code>中的对象是不可变的，也就可以理解为常量，线程安全。</li><li><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与<code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如<code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code>等公共方法。</li><li><code>StringBuffer</code>对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li><li><code>StringBuilder</code>并没有对方法进行加同步锁，所以是非线程安全的。如果要在多线程环境下修改字符串，可以使用<code>ThreadLocal</code>来避免多线程冲突。</li></ol><h3 id="异常">异常</h3><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240415163935.png" style="zoom: 67%;" /></p><ol type="1"><li><p><strong><code>Exception</code></strong>:程序本身可以处理的异常，可以通过 <code>catch</code>来进行捕获。</p></li><li><p><strong><code>Error</code></strong>：<code>Error</code>属于程序无法处理的错误</p></li><li><p>Java 代码在编译过程中，如果受检查异常（Checked Exception）没有被<code>catch</code>或者<code>throws</code>关键字处理的话，就没办法通过编译。</p></li></ol><h3 id="try-catch-final">try-catch-final</h3><h4id="try和final中都有return怎么执行">try和final中都有return，怎么执行？</h4><p>当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return语句会被忽略。这是因为 try 语句中的 return返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p><h4 id="final一定会执行吗">final一定会执行吗？</h4><p>finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Try to do something&quot;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;RuntimeException&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());<br>    <span class="hljs-comment">// 终止当前正在运行的Java虚拟机</span><br>    System.exit(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Finally&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射">反射</h3><p>赋予了我们在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis采用string存储实体对象</title>
    <link href="/2024/03/25/SoftwareDevelopment/Redis%E9%87%87%E7%94%A8string%E5%AD%98%E5%82%A8%E5%AE%9E%E4%BD%93%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/03/25/SoftwareDevelopment/Redis%E9%87%87%E7%94%A8string%E5%AD%98%E5%82%A8%E5%AE%9E%E4%BD%93%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>记录采用String而非Hash存储实体化对象的过程 <span id="more"></span></p><h3 id="问题描述">问题描述</h3><p>问题背景是在做登录验证的时候，需要将user暂时存储到redis上。</p><p>但是StringRedisTemplate无法直接将实体类对象转化为JSON格式存储，因此解决方案为</p><ol type="1"><li>使用Hash类型</li><li>进行序列化</li></ol><h3 id="json序列化">JSON序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">redisCode</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;login:code:&quot;</span> + phone);<br><br>    <span class="hljs-keyword">if</span>(!code.equals(redisCode))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>    &#125;<br><br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.eq(<span class="hljs-string">&quot;phone&quot;</span>,phone);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.selectOne(queryWrapper);<br><br>    <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">// 注册</span><br>        user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setCreateTime(DateTime.now().toLocalDateTime());<br>        user.setPhone(phone);<br>        user.setNickName(<span class="hljs-string">&quot;user_&quot;</span> + RandomUtil.randomString(<span class="hljs-number">10</span>));<br>        userMapper.insert(user);<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br><br>    <span class="hljs-comment">// 引入ObjectMapper</span><br>    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">userJson</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(user);<br><br>    redisTemplate.opsForValue().set(<span class="hljs-string">&quot;login:token:&quot;</span> + token, userJson, <span class="hljs-number">120</span>, TimeUnit.MINUTES);<br><br>    <span class="hljs-keyword">return</span> Result.ok(token);<br>&#125;<br></code></pre></td></tr></table></figure><p>在将user转化为json的时候，此处采用jackson的objectMapper，首先需要导入三个依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-datatype-jsr310<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中最后一个依赖用于在java8下将datetime类型转化为字符串。</p><p>同时，在pojo层还需要对datetime类型进行如下注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="hljs-meta">@JsonSerialize(using = LocalDateTimeSerializer.class)</span><br><span class="hljs-meta">@JsonDeserialize(using = LocalDateTimeDeserializer.class)</span><br><span class="hljs-keyword">private</span> LocalDateTime createTime;<br></code></pre></td></tr></table></figure><p>user的转化方式即为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 引入ObjectMapper</span><br><span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">userJson</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(user);<br></code></pre></td></tr></table></figure><p>读取时仍然采用objectMapper将字符串转化为User类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">userJson</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;login:token:&quot;</span> + token);<br><span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> objectMapper.readValue(userJson, User.class);<br></code></pre></td></tr></table></figure><p>可以看到Redis可以正确的进行存储</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240325201810.png" /></p><h3 id="更简单的序列化方式">更简单的序列化方式</h3><p>基于Hutools进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">redisTemplate.opsForValue().set(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id, JSONUtil.toJsonStr(shop));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id);<br><span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br></code></pre></td></tr></table></figure><h3 id="hash">Hash</h3><p>首先采用BeanUtil.copyProperties将User类映射到UserDTO(隐藏敏感信息)，然后使用BeanUtil.beanToMap将实体类对象转化为Map，然后就可以使用putAll插入到Redis中。注意使用opsForHash就只能单独设置有效期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br>Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),<br>        CopyOptions.create()<br>                .setIgnoreNullValue(<span class="hljs-literal">true</span>)<br>                .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));<br><span class="hljs-comment">// 7.3.存储</span><br><span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);<br><span class="hljs-comment">// 7.4.设置token有效期</span><br>stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);<br></code></pre></td></tr></table></figure><p>然后采用如下方式获取存储的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);<br><span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMao(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2024/03/24/SoftwareDevelopment/Redis/"/>
    <url>/2024/03/24/SoftwareDevelopment/Redis/</url>
    
    <content type="html"><![CDATA[<p>Redis学习</p><span id="more"></span><h3 id="sql-nosql">SQL &amp; noSQL</h3><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240324171909.png" /></p><h3 id="安装与启动">安装与启动</h3><h4 id="安装">安装</h4><p>Redis只能在Linux服务器使用，同时需要gcc环境</p><h4 id="后台启动">后台启动</h4><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，在解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span><br><span class="hljs-attr">bind</span> <span class="hljs-string">0.0.0.0</span><br><span class="hljs-comment"># 守护进程，修改为yes后即可后台运行</span><br><span class="hljs-attr">daemonize</span> <span class="hljs-string">yes </span><br><span class="hljs-comment"># 密码，设置后访问Redis必须输入密码</span><br><span class="hljs-attr">requirepass</span> <span class="hljs-string">123321</span><br></code></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 监听的端口</span><br><span class="hljs-attr">port</span> <span class="hljs-string">6379</span><br><span class="hljs-comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">.</span><br><span class="hljs-comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><br><span class="hljs-attr">databases</span> <span class="hljs-string">1</span><br><span class="hljs-comment"># 设置redis能够使用的最大内存</span><br><span class="hljs-attr">maxmemory</span> <span class="hljs-string">512mb</span><br><span class="hljs-comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span><br><span class="hljs-attr">logfile</span> <span class="hljs-string">&quot;redis.log&quot;</span><br></code></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入redis安装目录 </span><br><span class="hljs-built_in">cd</span> /usr/local/src/redis-6.2.6<br><span class="hljs-comment"># 启动</span><br>redis-server redis.conf<br></code></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span><br><span class="hljs-comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span><br>redis-cli -u 123321 shutdown<br></code></pre></td></tr></table></figure><h4 id="开机自启">开机自启</h4><p>通过配置来实现开机自启。首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vi /etc/systemd/system/redis.service<br></code></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf">[Unit]<br>Description=redis-server<br>After=network.target<br><br>[Service]<br>Type=forking<br>ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf<br>PrivateTmp=true<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl daemon-reload<br></code></pre></td></tr></table></figure><p>用下面这组命令来操作redis：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 启动</span><br>systemctl start redis<br><span class="hljs-comment"># 停止</span><br>systemctl stop redis<br><span class="hljs-comment"># 重启</span><br>systemctl restart redis<br><span class="hljs-comment"># 查看状态</span><br>systemctl status redis<br></code></pre></td></tr></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl <span class="hljs-built_in">enable</span> redis<br></code></pre></td></tr></table></figure><h4 id="命令行客户端">命令行客户端</h4><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli [options] [commonds]<br></code></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p><h4 id="远程连接">远程连接</h4><p>使用一些图形化客户端程序进行链接，服务器一定注意开启6397端口号</p><h3 id="常用数据结构与命令">常用数据结构与命令</h3><h4 id="通用">通用</h4><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除（验证码）</li><li>TTL：查看一个KEY的剩余有效期</li></ul><h4 id="string">String</h4><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><p>层级结构</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用':'隔开，格式如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">项目名:业务名:类型:<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p><p>例如我们的项目名称叫heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr class="header"><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr class="odd"><td>heima:user:1</td><td>{"id":1, "name": "Jack", "age": 21}</td></tr><tr class="even"><td>heima:product:1</td><td>{"id":1, "name": "小米11", "price": 4999}</td></tr></tbody></table><h4 id="hash">Hash</h4><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240325132100.png" /></p><h4 id="list">List</h4><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><ul><li>LPUSH key element ... ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element ... ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p>List使用示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryTypeList</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; shops = redisTemplate.opsForList().range(<span class="hljs-string">&quot;cache:shop-type&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(shops != <span class="hljs-literal">null</span> &amp;&amp; !shops.isEmpty())&#123;<br>        List&lt;ShopType&gt; shopTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String type:shops)&#123;<br>            shopTypes.add(JSONUtil.toBean(type, ShopType.class));<br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.ok(shopTypes);<br>    &#125;<br><br>    QueryWrapper&lt;ShopType&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.orderByAsc(<span class="hljs-string">&quot;sort&quot;</span>);<br><br>    List&lt;ShopType&gt; shopTypes = shopTypeMapper.selectList(queryWrapper);<br>    <span class="hljs-keyword">if</span>(shops != <span class="hljs-literal">null</span> &amp;&amp; !shopTypes.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;无店铺类型信息&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(ShopType shopType : shopTypes)&#123;<br>        redisTemplate.opsForList().rightPush(<span class="hljs-string">&quot;cache:shop-type&quot;</span>, JSONUtil.toJsonStr(shopType));<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok(shopTypes);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="set">Set</h4><ul><li>SADD key member ... ：向set中添加一个或多个元素</li><li>SREM key member ... : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 ... ：求key1与key2的交集</li><li>SDIFF key1 key2 ... ：求key1与key2的差集</li><li>SUNION key1 key2 ... ：求key1与key2的并集</li></ul><h4 id="sorted-set">Sorted Set</h4><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加hash表。</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sortedset中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key minmax：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK keymember</p></li><li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANKkey memeber</p></li></ul><p>将班级的下列学生得分存入Redis的SortedSet中：</p><p>Jack 85, Lucy 89, Rose 82, Tom 95, Jerry 78, Amy 92, Miles 76</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zadd stu <span class="hljs-number">85</span> jack <span class="hljs-number">89</span> lucy <span class="hljs-number">82</span> rose <span class="hljs-number">95</span> tom <span class="hljs-number">78</span> jerry <span class="hljs-number">92</span> amy <span class="hljs-number">76</span> miles<br></code></pre></td></tr></table></figure><p>并实现下列功能：</p><ul><li><p>删除Tom同学</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zrem stu tom<br></code></pre></td></tr></table></figure></p></li><li><p>获取Amy同学的分数</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zscore stu amy<br></code></pre></td></tr></table></figure></p></li><li><p>获取Rose同学的排名</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zrevrank stu rose<br></code></pre></td></tr></table></figure></p></li><li><p>查询80分以下有几个学生</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zcount stu <span class="hljs-number">0</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure></p></li><li><p>给Amy同学加2分</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zincrby stu <span class="hljs-number">2</span> amy<br></code></pre></td></tr></table></figure></p></li><li><p>查出成绩前3名的同学</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zrevrange stu <span class="hljs-number">0</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></p></li><li><p>查出成绩80分以下的所有同学 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ZRANGEBYSCORE stu <span class="hljs-number">0</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure></p></li></ul><h3 id="java客户端">Java客户端</h3><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h4 id="jedis">Jedis</h4><p>1）引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jedis--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--单元测试--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）建立连接</p><p>新建一个单元测试类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Jedis jedis;<br><br><span class="hljs-meta">@BeforeEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.建立连接</span><br>    jedis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.150.101&quot;</span>, <span class="hljs-number">6379</span>);<br>    <span class="hljs-comment">// 2.设置密码</span><br>    jedis.auth(<span class="hljs-string">&quot;123321&quot;</span>);<br>    <span class="hljs-comment">// 3.选择库</span><br>    jedis.select(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>3）测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 存入数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;虎哥&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>    <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 插入hash数据</span><br>    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);<br>    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>);<br><br>    <span class="hljs-comment">// 获取</span><br>    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="hljs-string">&quot;user:1&quot;</span>);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>4）释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;<br>        jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5）连接池</p><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，使用Jedis连接池代替Jedis的直连方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heima.jedis.util;<br><br><span class="hljs-keyword">import</span> redis.clients.jedis.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectionFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 配置连接池</span><br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        poolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>        poolConfig.setMaxIdle(<span class="hljs-number">8</span>);<br>        poolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>        poolConfig.setMaxWaitMillis(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span><br>        jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig, <span class="hljs-string">&quot;192.168.150.101&quot;</span>, <span class="hljs-number">6379</span>, <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;123321&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> jedisPool.getResource();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="springdataredis">SpringDataRedis</h4><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><h5 id="redistemplate">RedisTemplate</h5><p>1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redis-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>redis-demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--redis依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--common-pool--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--Jackson依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）配置Redis</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123321</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">100ms</span><br></code></pre></td></tr></table></figure><p>3）注入RedisTemplate</p><p>因为有了SpringBoot的自动装配，我们可以拿来就用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>&#125;<br></code></pre></td></tr></table></figure><p>4）编写测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate edisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 写入一条String数据</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;虎哥&quot;</span>);<br>        <span class="hljs-comment">// 获取string数据</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="springredistemplate">SpringRedisTemplate</h5><p>RedisTemplate不能自动序列化、反序列化，使用不便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br></code></pre></td></tr></table></figure><h3 id="redis进行登录校验">Redis进行登录校验</h3><p>核心流程如下图所示</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240325202024.png" /></p><h3 id="缓存">缓存</h3><h4 id="基本思路">基本思路</h4><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240326191446.png" /></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 查Redis</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id);<br>    <span class="hljs-keyword">if</span> (!StrUtil.isBlank(shopJson))&#123;<span class="hljs-comment">// 如果存在，直接返回</span><br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> shopMapper.selectById(id);<span class="hljs-comment">// 如果不存在，数据库查</span><br>    <span class="hljs-keyword">if</span>(shop == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>    &#125;<br><br>    redisTemplate.opsForValue().set(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id, JSONUtil.toJsonStr(shop));<span class="hljs-comment">// 写入Redis</span><br>    <span class="hljs-keyword">return</span> Result.ok(shop);<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数据不一致问题">数据不一致问题</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等</p><p>如果我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li>删除缓存还是更新缓存？<ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul></li><li>如何保证缓存与数据库的操作的同时成功或失败？<ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li></ul><p>应当是<strong>先操作数据库，再删除缓存</strong>，原因在于，如果选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240326205608.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">updateShop</span><span class="hljs-params">(Shop shop)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> shop.getId();<br>    <span class="hljs-keyword">if</span>(id == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;无商店信息&quot;</span>);<br>    &#125;<br>    shopMapper.updateById(shop);<br>    redisTemplate.delete(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="缓存穿透问题">缓存穿透问题</h4><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p><h4 id="缓存雪崩问题">缓存雪崩问题</h4><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><h4 id="缓存击穿问题">缓存击穿问题</h4><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法，那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240327174916.png" /></p><p>解决方案一、使用锁来解决：</p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法+ double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240327175011.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id);<br>    <span class="hljs-keyword">if</span> (!StrUtil.isBlank(shopJson))&#123;<br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;&quot;</span>.equals(shopJson))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 获取互斥锁</span><br>    <span class="hljs-keyword">if</span>(tryLock(<span class="hljs-string">&quot;shop:lock&quot;</span>))&#123;<br>        <span class="hljs-comment">// double check, 如果其他线程已经重建完成，那么递归到这里的时候就不应该再次重建</span><br>        shopJson = redisTemplate.opsForValue().get(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id);<br>        <span class="hljs-keyword">if</span> (!StrUtil.isBlank(shopJson))&#123;<br>            shop = JSONUtil.toBean(shopJson, Shop.class);<br>            <span class="hljs-keyword">return</span> Result.ok(shop);<br>        &#125;<br><br>        shop = shopMapper.selectById(id);<br>        <span class="hljs-keyword">if</span>(shop == <span class="hljs-literal">null</span>)&#123;<br>            redisTemplate.opsForValue().set(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">2</span>, TimeUnit.MINUTES);<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>        &#125;<br><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id, JSONUtil.toJsonStr(shop), <span class="hljs-number">30</span>, TimeUnit.MINUTES);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        Thread.sleep(<span class="hljs-number">50</span>);   <span class="hljs-comment">// 休眠50ms之后递归访问</span><br>        <span class="hljs-keyword">return</span> queryById(id);<br>    &#125;<br><br>    unlock(<span class="hljs-string">&quot;shop:lock&quot;</span>);<br>    <span class="hljs-keyword">return</span> Result.ok(shop);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span>&#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>    <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span>&#123;<br>    redisTemplate.delete(key);<br>&#125;<br></code></pre></td></tr></table></figure><p>解决方案二、逻辑过期方案</p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个线程去进行以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁，而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240327175025.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisData</span> &#123;<br>    <span class="hljs-keyword">private</span> LocalDateTime expireTime;<br>    <span class="hljs-keyword">private</span> Object data;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">( Long id )</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;<br>    <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isBlank(json)) &#123;<br>        <span class="hljs-comment">// 3.存在，直接返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4.命中，需要先把json反序列化为对象</span><br>    <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, RedisData.class);<br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);<br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>    <span class="hljs-comment">// 5.判断是否过期</span><br>    <span class="hljs-keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 5.1.未过期，直接返回店铺信息</span><br>        <span class="hljs-keyword">return</span> shop;<br>    &#125;<br>    <span class="hljs-comment">// 5.2.已过期，需要缓存重建</span><br>    <span class="hljs-comment">// 6.缓存重建</span><br>    <span class="hljs-comment">// 6.1.获取互斥锁</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>    <span class="hljs-comment">// 6.2.判断是否获取锁成功</span><br>    <span class="hljs-keyword">if</span> (isLock)&#123;<br>        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;<br><br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//重建缓存</span><br>                <span class="hljs-built_in">this</span>.saveShop2Redis(id,<span class="hljs-number">20L</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                unlock(lockKey);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 6.4.返回过期的商铺信息</span><br>    <span class="hljs-keyword">return</span> shop;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240327175039.png" /></p><h3 id="秒杀">秒杀</h3><h4 id="全局id">全局ID</h4><p>订单表如果使用数据库自增ID就存在一些问题：</p><ul><li>id的规律性太明显</li><li>受单表数据量的限制</li></ul><p>场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p><p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的，于是乎我们需要保证id的唯一性。</p><p><strong>基于Redis实现的全局ID组成部分</strong>：</p><p>符号位：1bit，永远为0</p><p>时间戳：31bit，以秒为单位，可以使用69年</p><p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdWorker</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始时间戳</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1640995200L</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列号的位数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisIdWorker</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span> &#123;<br>        <span class="hljs-comment">// 1.生成时间戳</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> nowSecond - BEGIN_TIMESTAMP;<br><br>        <span class="hljs-comment">// 2.生成序列号</span><br>        <span class="hljs-comment">// 2.1.获取当前日期，精确到天</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-comment">// 2.2.自增长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);<br><br>        <span class="hljs-comment">// 3.拼接并返回</span><br>        <span class="hljs-keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基本逻辑">基本逻辑</h4><p>首先判断秒杀券的时间，然后先扣减库存，再生成订单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">secikllVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> voucherMapper.selectById(voucherId);<br>    <span class="hljs-keyword">if</span>(seckillVoucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(seckillVoucher.getEndTime().isBefore(LocalDateTime.now()))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(seckillVoucher.getStock() &lt; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>    &#125;<br><br>    seckillVoucher.setStock(seckillVoucher.getStock() - <span class="hljs-number">1</span>);<br>    voucherMapper.updateById(seckillVoucher);<br><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> idWorker.nextId(<span class="hljs-string">&quot;voucher:order&quot;</span>);<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><br>    voucherOrder.setUserId(userId);<br>    voucherOrder.setVoucherId(voucherId);<br>    voucherOrder.setId(orderId);<br>    save(voucherOrder);<br><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="超卖问题">超卖问题</h4><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240330185537.png" /></p><p>乐观锁的典型代表：就是cas（compare andswap），利用cas进行无锁化机制加锁，var5是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 ==内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p><p>其中do while是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> var5;<br><span class="hljs-keyword">do</span> &#123;<br>    var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2);<br>&#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br><br><span class="hljs-keyword">return</span> var5;<br></code></pre></td></tr></table></figure><p>实际操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">seckillVoucher.setStock(seckillVoucher.getStock() - <span class="hljs-number">1</span>);<br>QueryWrapper&lt;SeckillVoucher&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>wrapper.gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> voucherMapper.update(seckillVoucher, wrapper);<br><span class="hljs-keyword">if</span>(row == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一人一单问题">一人一单问题</h4><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240330202206.png" /></p><p>需要注意的一些问题：</p><ol type="1"><li><p>在方法上添加了一把synchronized锁？锁的粒度太粗了，应该对单个用户加锁</p></li><li><p><code>intern()</code>方法是用于返回字符串对象的规范表示形式，这里的目的是确保即使有多个相同内容的字符串对象，锁定的也是同一个对象，从而确保线程安全。</p></li><li><p>锁为什么在主函数的return前后？如果加在子方法，子方法被spring的事务控制，如果在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题</p></li><li><p>在Spring框架中，当你在一个对象的内部方法中使用<code>this</code>关键字调用另一个方法时，你直接调用的是那个方法的本体。这种调用方式会<strong>绕过Spring的代理机制</strong>，导致与那个方法相关的AOP逻辑（例如事务管理）不会被触发。为了让事务能够正确管理，需要通过Spring的代理对象来调用那个方法，这样Spring框架就能够在调用前后执行相关的AOP逻辑，比如开启和提交（或回滚）事务。</p></li><li><p>为了实现该方法，需要添加依赖和注解</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.hmdp.mapper&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableAspectJAutoProxy(exposeProxy = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HmDianPingApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(HmDianPingApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">secikllVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> voucherMapper.selectById(voucherId);<br>    <span class="hljs-keyword">if</span>(seckillVoucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(seckillVoucher.getEndTime().isBefore(LocalDateTime.now()))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(seckillVoucher.getStock() &lt; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>    <span class="hljs-keyword">synchronized</span> (user.getId().toString().intern())&#123;<br>        <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>        <span class="hljs-keyword">return</span> proxy.createOrder(seckillVoucher);<br>    &#125;<br><br>&#125;<br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createOrder</span><span class="hljs-params">(SeckillVoucher seckillVoucher)</span>&#123;<br><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>    QueryWrapper&lt;VoucherOrder&gt; wrapper1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    wrapper1.eq(<span class="hljs-string">&quot;user_id&quot;</span>, user.getId()).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, seckillVoucher.getVoucherId());<br>    List&lt;VoucherOrder&gt; voucherOrders = getBaseMapper().selectList(wrapper1);<br>    <span class="hljs-keyword">if</span>(!voucherOrders.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不可重复下单&quot;</span>);<br>    &#125;<br><br>    seckillVoucher.setStock(seckillVoucher.getStock() - <span class="hljs-number">1</span>);<br>    QueryWrapper&lt;SeckillVoucher&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    wrapper.gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> voucherMapper.update(seckillVoucher, wrapper);<br><br>    <span class="hljs-keyword">if</span>(row == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> idWorker.nextId(<span class="hljs-string">&quot;voucher:order&quot;</span>);<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><br>    voucherOrder.setUserId(userId);<br>    voucherOrder.setVoucherId(seckillVoucher.getVoucherId());<br>    voucherOrder.setId(orderId);<br>    save(voucherOrder);<br><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="集群环境下的并发问题">集群环境下的并发问题</h4><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240330210546.png" /></p><h3 id="基于redis的分布式锁">基于Redis的分布式锁</h3><h4 id="基础版本">基础版本</h4><p>利用redis 的setNx方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis中就有这个key了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    StringRedisTemplate redisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisLock</span><span class="hljs-params">(String name, StringRedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, String.valueOf(id), timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        redisTemplate.delete(KEY_PREFIX + name);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br><span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> user.getId();<br><span class="hljs-type">RedisLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisLock</span>(<span class="hljs-string">&quot;order:&quot;</span> + voucherId + <span class="hljs-string">&quot;:&quot;</span> + id, redisTemplate);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">100</span>);<br><span class="hljs-keyword">if</span>(!isLock)&#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createOrder(seckillVoucher);<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="误删问题">误删问题</h4><p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><p>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p><ul><li>如果一致则释放锁</li><li>如果不一致则不释放锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    StringRedisTemplate redisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.fastUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&#x27;-&#x27;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisLock</span><span class="hljs-params">(String name, StringRedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, id, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(KEY_PREFIX + name);<br>        <span class="hljs-keyword">if</span> ((ID_PREFIX + Thread.currentThread().getId()).equals(id))&#123;<br>            redisTemplate.delete(KEY_PREFIX + name);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="原子性问题">原子性问题</h4><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的。</p><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：https://www.runoob.com/lua/lua-tutorial.html，</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>]) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    StringRedisTemplate redisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.fastUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&#x27;-&#x27;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<br>    <span class="hljs-keyword">static</span> &#123;<br>        UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>));<br>        UNLOCK_SCRIPT.setResultType(Long.class);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisLock</span><span class="hljs-params">(String name, StringRedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, id, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        redisTemplate.execute(<br>                UNLOCK_SCRIPT, <br>                Collections.singletonList(KEY_PREFIX + name), <br>                ID_PREFIX + Thread.currentThread().getId());<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="redisson">Redisson</h3><p>上述基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong>如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory DataGrid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><h4 id="基本实现">基本实现</h4><ol type="1"><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>配置Redisson</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://43.153.142.8:6379&quot;</span>).setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>使用Redisson</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + voucherId + <span class="hljs-string">&quot;:&quot;</span> + id);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br><br><span class="hljs-keyword">if</span>(!isLock)&#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createOrder(seckillVoucher);<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可重入性">可重入性</h4><p>redis中锁的存储使用hash结构，其中key为线程名称，value为重入次数，第一次获取即为1，第二次当前线程获取时即变为2</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240401220957.png" /></p><h4 id="主从一致性">主从一致性</h4><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上，主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的，这把锁加锁的逻辑需要写入到每一个主丛节点上，<strong>只有所有的服务器都写入成功，此时才是加锁成功</strong>，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数* 1500ms，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功，那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p><h3 id="秒杀优化">秒杀优化</h3><h4 id="异步秒杀">异步秒杀</h4><p>当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p><p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240402185808.png" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240402185840.png" /></p><ol type="1"><li><p>在添加秒杀券的时候同步存入redis</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSeckillVoucher</span><span class="hljs-params">(Voucher voucher)</span> &#123;<br>    <span class="hljs-comment">// 保存优惠券</span><br>    save(voucher);<br>    <span class="hljs-comment">// 保存秒杀信息</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeckillVoucher</span>();<br>    seckillVoucher.setVoucherId(voucher.getId());<br>    seckillVoucher.setStock(voucher.getStock());<br>    seckillVoucher.setBeginTime(voucher.getBeginTime());<br>    seckillVoucher.setEndTime(voucher.getEndTime());<br>    seckillVoucherService.save(seckillVoucher);<br>    <span class="hljs-comment">// 保存秒杀库存到Redis中</span><br>    <span class="hljs-comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span><br>    <span class="hljs-comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span><br>    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>编写lua脚本保证原子性</p><p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 1.参数列表</span><br><span class="hljs-comment">-- 1.1.优惠券id</span><br><span class="hljs-keyword">local</span> voucherId = ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-comment">-- 1.2.用户id</span><br><span class="hljs-keyword">local</span> userId = ARGV[<span class="hljs-number">2</span>]<br><span class="hljs-comment">-- 1.3.订单id</span><br><span class="hljs-keyword">local</span> orderId = ARGV[<span class="hljs-number">3</span>]<br><br><span class="hljs-comment">-- 2.数据key</span><br><span class="hljs-comment">-- 2.1.库存key</span><br><span class="hljs-keyword">local</span> stockKey = <span class="hljs-string">&#x27;seckill:stock:&#x27;</span> .. voucherId<br><span class="hljs-comment">-- 2.2.订单key</span><br><span class="hljs-keyword">local</span> orderKey = <span class="hljs-string">&#x27;seckill:order:&#x27;</span> .. voucherId<br><br><span class="hljs-comment">-- 3.脚本业务</span><br><span class="hljs-comment">-- 3.1.判断库存是否充足 get stockKey</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.2.库存不足，返回1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.3.存在，说明是重复下单，返回2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.4.扣库存 incrby stockKey -1</span><br>redis.call(<span class="hljs-string">&#x27;incrby&#x27;</span>, stockKey, <span class="hljs-number">-1</span>)<br><span class="hljs-comment">-- 3.5.下单（保存用户）sadd orderKey userId</span><br>redis.call(<span class="hljs-string">&#x27;sadd&#x27;</span>, orderKey, userId)<br><span class="hljs-comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span><br>redis.call(<span class="hljs-string">&#x27;xadd&#x27;</span>, <span class="hljs-string">&#x27;stream.orders&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;userId&#x27;</span>, userId, <span class="hljs-string">&#x27;voucherId&#x27;</span>, voucherId, <span class="hljs-string">&#x27;id&#x27;</span>, orderId)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></p></li><li><p>添加堵塞队列，返回结果</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">secikllVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> redisTemplate.execute(<br>            SECKILL_SCRIPT,<br>            Collections.emptyList(),<br>            voucherId,<br>            UserHolder.getUser().getId()<br>    );<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> result.intValue();<br>    <span class="hljs-keyword">if</span>(r!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(r==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不能重复下单&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> idWorker.nextId(<span class="hljs-string">&quot;voucher:order&quot;</span>);<br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="/2024/03/22/SoftwareDevelopment/SpringMVC/"/>
    <url>/2024/03/22/SoftwareDevelopment/SpringMVC/</url>
    
    <content type="html"><![CDATA[<p>springMVC学习</p><span id="more"></span><h3 id="核心组件与调用流程">核心组件与调用流程</h3><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240322155606.png" /></p><p><strong>SpringMVC涉及组件理解：</strong> 1. DispatcherServlet :SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发！[CEO ] 2. HandlerMapping :SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！[秘书]3. HandlerAdapter :SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器！[经理]4. Handler :handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果！[打工人]5. ViewResovler :SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的！[财务]</p><h3 id="参数接收">参数接收</h3><p>参见SpringBoot模块</p><h3 id="全局异常处理">全局异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * projectName: com.atguigu.execptionhandler</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * description: 全局异常处理器,内部可以定义异常处理Handler!</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RestControllerAdvice</span> = <span class="hljs-doctag">@ControllerAdvice</span> + <span class="hljs-doctag">@ResponseBody</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ControllerAdvice</span> 代表当前类的异常处理controller! </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常处理handler </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@ExceptionHandler</span>(HttpMessageNotReadableException.class) </span><br><span class="hljs-comment">     * 该注解标记异常处理Handler,并且指定发生异常调用该方法!</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 获取异常对象!</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回handler处理结果!</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(HttpMessageNotReadableException.class)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">handlerJsonDateException</span><span class="hljs-params">(HttpMessageNotReadableException e)</span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当发生空指针异常会触发此方法!</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(NullPointerException.class)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">handlerNullException</span><span class="hljs-params">(NullPointerException e)</span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 所有异常都会触发此方法!但是如果有具体的异常处理Handler! </span><br><span class="hljs-comment">     * 具体异常处理Handler优先级更高!</span><br><span class="hljs-comment">     * 例如: 发生NullPointerException异常!</span><br><span class="hljs-comment">     *       会触发handlerNullException方法,不会触发handlerException方法!</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">handlerException</span><span class="hljs-params">(Exception e)</span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拦截器">拦截器</h3><h4 id="拦截器和过滤器">拦截器和过滤器</h4><p>Filter处于整个SpringMVC外部进行过滤，拦截器在Handler方法调用前后进行拦截</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240322164304.png" /></p><p>拦截器 Springmvc VS 过滤器 javaWeb：</p><ul><li>相似点<ul><li>拦截：必须先把请求拦住，才能执行后续操作</li><li>过滤：拦截器或过滤器存在的意义就是对请求进行统一处理</li><li>放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源</li></ul></li><li>不同点<ul><li>工作平台不同<ul><li>过滤器工作在 Servlet 容器中</li><li>拦截器工作在 SpringMVC 的基础上</li></ul></li><li>拦截的范围<ul><li>过滤器：能够拦截到的最大范围是整个 Web 应用</li><li>拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求</li></ul></li><li>IOC 容器支持<ul><li>过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的</li><li>拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC容器中装配组件，也就是可以直接得到 IOC 容器的支持</li></ul></li></ul></li></ul><figure><imgsrc="https://secure-bigfile.wostatic.cn/static/prqG4dtu3rDWj7VwX4WgsW/image.png?auth_key=1711097129-t5FPdcvuXo9HR3hbxiT6bu-0-8562a1a0170f20142e3bd7656e687ca7&amp;file_size=9432213"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="使用方法">使用方法</h4><p>创建拦截器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Process01Interceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-comment">// if( ! preHandler())&#123;return;&#125;</span><br>    <span class="hljs-comment">// 在处理请求的目标 handler 方法前执行</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;request = &quot;</span> + request + <span class="hljs-string">&quot;, response = &quot;</span> + response + <span class="hljs-string">&quot;, handler = &quot;</span> + handler);<br>        System.out.println(<span class="hljs-string">&quot;Process01Interceptor.preHandle&quot;</span>);<br>         <br>        <span class="hljs-comment">// 返回true：放行</span><br>        <span class="hljs-comment">// 返回false：不放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">// 在目标 handler 方法之后，handler报错不执行!</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;request = &quot;</span> + request + <span class="hljs-string">&quot;, response = &quot;</span> + response + <span class="hljs-string">&quot;, handler = &quot;</span> + handler + <span class="hljs-string">&quot;, modelAndView = &quot;</span> + modelAndView);<br>        System.out.println(<span class="hljs-string">&quot;Process01Interceptor.postHandle&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">// 渲染视图之后执行(最后),一定执行!</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;request = &quot;</span> + request + <span class="hljs-string">&quot;, response = &quot;</span> + response + <span class="hljs-string">&quot;, handler = &quot;</span> + handler + <span class="hljs-string">&quot;, ex = &quot;</span> + ex);<br>        System.out.println(<span class="hljs-string">&quot;Process01Interceptor.afterCompletion&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebMvc</span>  <span class="hljs-comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;)</span> <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 进行controller扫描</span><br><span class="hljs-comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-comment">//添加拦截器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123; <br>        <span class="hljs-comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Process01Interceptor</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>    <br>    <span class="hljs-comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span><br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Process01Interceptor</span>());<br>    <br>    <span class="hljs-comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span><br>    <span class="hljs-comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span><br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Process01Interceptor</span>()).addPathPatterns(<span class="hljs-string">&quot;/common/request/one&quot;</span>,<span class="hljs-string">&quot;/common/request/tow&quot;</span>);<br>    <br>    <br>    <span class="hljs-comment">//排除匹配,排除应该在匹配的范围内排除</span><br>    <span class="hljs-comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span><br>    <span class="hljs-comment">//excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内</span><br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Process01Interceptor</span>())<br>            .addPathPatterns(<span class="hljs-string">&quot;/common/request/one&quot;</span>,<span class="hljs-string">&quot;/common/request/tow&quot;</span>)<br>            .excludePathPatterns(<span class="hljs-string">&quot;/common/request/tow&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>毕设</title>
    <link href="/2024/03/21/School/%E6%AF%95%E8%AE%BE/"/>
    <url>/2024/03/21/School/%E6%AF%95%E8%AE%BE/</url>
    
    <content type="html"><![CDATA[<p>本科毕设 <span id="more"></span></p><h2 id="现有情况">现有情况</h2><ol type="1"><li><p>Exp17为做基于特征分布的零样本学习的文件夹</p><ol type="1"><li>输入数据格式为（batch_size, 4, 96, 96, 64）</li></ol></li><li><p>Exp10/utils是生成训练数据的代码</p><ol type="1"><li>上面的4代表四个模态['FLAIR', 'T1', 'T1C', 'T2']</li><li>（96，96，64）为经过mask之后将图片缩放到的大小</li><li>labels = np.array([tri_category, six_category, IDH,onep19q])，因此在进行三分类、六分类的时候要改WholeDataset里面的信息。</li></ol></li><li><p>七个模态</p><p>这些模态通常指的是磁共振成像（MRI）中的不同成像技术或序列，每种模态可以揭示脑组织的不同属性或病理状态。MRI是一种强大的医学成像工具，能够提供高分辨率的三维图像，用于诊断、研究和治疗规划。以下是提到的模态的简要说明：</p><ol type="1"><li><strong>ADC (Apparent Diffusion Coefficient)</strong>:体现水分子在组织中扩散能力的图像。ADC图像常用于脑卒中的诊断，特别是早期识别缺血性脑卒中，因为水分子在受损脑细胞中的扩散受到限制。</li><li><strong>DWI (Diffusion Weighted Imaging)</strong>:一种特殊的MRI技术，用来测量水分子在脑组织中的扩散过程。DWI对于检测急性或早期脑缺血非常有用，因为缺血区域的水分子扩散会受到限制。</li><li><strong>FLAIR (Fluid Attenuated Inversion Recovery)</strong>:一种特殊的成像序列，用于抑制脑脊液（CSF）的信号，使脑组织中的病变（如多发性硬化斑块或其他炎症）更容易被检测到。</li><li><strong>T1</strong>:一种MRI序列，能够提供组织结构的详细图像。在T1加权成像中，脂肪组织显示为高信号（亮白色），而水和脑脊液显示为低信号（暗色）。</li><li><strong>T1C (T1 with Contrast)</strong>:使用对比剂（如含钆的药物）进行的T1成像。对比剂可以提高某些病变（如肿瘤）的可见性，因为这些病变可能会吸收对比剂而显示为更高的信号强度。</li><li><strong>T2</strong>:另一种MRI序列，与T1成像相反，水和脑脊液在T2加权成像中显示为高信号（亮白色）。T2成像对于检测脑内的水分变化和病变非常有用。</li></ol><p>这些模态各有其独特的优点，在临床诊断和研究中常常结合使用，以提供有关疾病状态的更全面视图。例如，结合使用这些模态可以更精确地检测和定位脑肿瘤、脑缺血、炎症性疾病和其他脑部病变。</p></li><li><p>样本分布</p><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240401154222425.png"alt="image-20240401154222425" /><figcaption aria-hidden="true">image-20240401154222425</figcaption></figure><p>匹配到1243个数据 WHO三分类数据分布: [302, 241, 700]WHO六分类数据分布: [209, 700, 91, 2, 164, 77]</p></li></ol><p>三分类 训练集分布： {0: 302, 1: 241, 2: 697} 测试集分布： {0: 41, 1:28, 2: 83} 验证集分布： {0: 55, 1: 42, 2: 126} 六分类 训练集分布： {0:209, 1: 697, 2: 91, 3: 2, 4: 164, 5: 77} 测试集分布： {0: 28, 1: 83, 2:12, 3: 1, 4: 19, 5: 9} 验证集分布： {0: 36, 1: 126, 2: 18, 3: 1, 4: 27,5: 15}</p><h2 id="实验结果">实验结果</h2><h3 id="全数据废弃">全数据（废弃）</h3><h4 id="三分类baseline-300轮">三分类baseline 300轮</h4><p>数据来源于Exp19</p><p>测试集总体精度为: 0.9850746393203735 测试集各类精度为:tensor([1.0000, 0.9688, 0.9848]) 测试集混淆矩阵为: tensor([[ 37., 0.,0.], [ 1., 31., 0.], [ 2., 0., 130.]])</p><h4 id="三分类次序约束全样本-300轮">三分类+次序约束+全样本 300轮</h4><p>数据来源于Exp18</p><p>测试集总体精度为: 0.7960199117660522 测试集各类精度为:tensor([0.4865, 0.6250, 0.9242]) 测试集混淆矩阵为: tensor([[ 18., 5.,14.], [ 7., 20., 5.], [ 5., 5., 122.]])</p><h4 id="三分类0样本学习-300轮">三分类+0样本学习 300轮</h4><p>数据来源于Exp20</p><p>测试集总体精度为: 0.7661691308021545 测试集各类精度为:tensor([0.0000, 0.9697, 0.9919]) 测试集混淆矩阵为: tensor([[ 0., 26.,19.], [ 0., 32., 1.], [ 0., 1., 122.]])</p><h4 id="三分类特征约束0样本学习-300轮">三分类+特征约束+0样本学习300轮</h4><p>数据来源于Exp17_fix_fix</p><p>测试集总体精度为: 0.6915422677993774 测试集各类精度为:tensor([0.0000, 0.6667, 0.9512]) 测试集混淆矩阵为: tensor([[ 0., 24.,21.], [ 0., 22., 11.], [ 0., 6., 117.]])</p><h3 id="匹配数据废弃">匹配数据（废弃）</h3><h4 id="三分类baseline-200轮">三分类baseline 200轮</h4><p>数据来源于Exp19</p><p>测试集总体精度为: 0.875 测试集各类精度为: tensor([0.8780, 0.7143,0.9277]) 测试集混淆矩阵为: tensor([[36., 1., 4.], [ 5., 20., 3.], [ 5.,1., 77.]])</p><h3 id="均衡后匹配数据废弃">均衡后匹配数据（废弃）</h3><p>训练集分布： {0: 206, 1: 171, 2: 254} 测试集分布： {0: 41, 1: 28, 2:42} 验证集分布： {0: 55, 1: 42, 2: 61}</p><h4 id="baseline300">baseline300</h4><p>Exp19_balanced</p><p>测试集总体精度为: 0.6126126050949097 测试集各类精度为:tensor([0.8537, 0.3571, 0.5476]) 测试集混淆矩阵为: tensor([[35., 2.,4.], [16., 10., 2.], [14., 5., 23.]])</p><h4 id="次序约束200">次序约束200</h4><p>Exp18_balanced</p><p>测试集总体精度为: 0.6666666865348816 测试集各类精度为:tensor([0.5366, 0.6429, 0.8095]) 测试集混淆矩阵为: tensor([[22., 11.,8.], [ 8., 18., 2.], [ 7., 1., 34.]])</p><h4 id="次序约束0样本300">次序约束0样本300</h4><p>exp22</p><p>测试集总体精度为: 0.5405405163764954 测试集各类精度为:tensor([0.0000, 0.7857, 0.9048]) 测试集混淆矩阵为: tensor([[ 0., 27.,14.], [ 0., 22., 6.], [ 0., 4., 38.]])</p><h3 id="均衡后匹配数据第二类极少样本">均衡后匹配数据+第二类极少样本</h3><p>郑大generated后数据_balanced_less</p><p>训练集分布： {0: 6, 1: 171, 2: 244} 测试集分布： {0: 41, 1: 28, 2:35} 验证集分布： {0: 55, 1: 42, 2: 64}</p><h4 id="baseline">baseline</h4><p>测试集总体精度为: 0.5096153616905212<br />测试集各类精度为: tensor([0.0000, 0.8571, 0.8286])<br />测试集混淆矩阵为: tensor([[ 0., 31., 10.],<br />[ 0., 24., 4.],<br />[ 0., 6., 29.]])</p><h4 id="次序约束">次序约束</h4><p>测试集总体精度为: 0.5192307829856873 测试集各类精度为:tensor([0.0000, 0.8929, 0.8286]) 测试集混淆矩阵为: tensor([[ 0., 31.,10.], [ 0., 25., 3.], [ 0., 6., 29.]])</p><h4 id="mix-up">mix-up</h4><p>测试集总体精度为: 0.4038461446762085 测试集各类精度为:tensor([0.2439, 0.6786, 0.3714]) 测试集混淆矩阵为: tensor([[10., 25.,6.], [ 9., 19., 0.], [18., 4., 13.]])</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/2024/03/13/SoftwareDevelopment/Mybatis/"/>
    <url>/2024/03/13/SoftwareDevelopment/Mybatis/</url>
    
    <content type="html"><![CDATA[<p>记录Mybatis主要用法 <span id="more"></span></p><h2 id="基本概念">基本概念</h2><h3 id="mybatis">Mybatis</h3><p>Mybatis 是一个半 ORM(对象关系映射)框架,它内部封装了JDBC,开发时只需要关注 SQL语句本身,不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态 sql,可以严格控制 sql执行性能,灵活度高。</p><p>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC代码和手动设置参数以及获取结果集。</p><h3 id="orm">ORM</h3><p>ORM( Object RelationalMapping),对象关系映射,是一种为了解决关系型数据库数据与简单Java对象(POJO)的映射关系的技术。简单来说,ORM是通过使用描述对象和数据库之间映射的元数据,将程序中的对象自动持久化到关系型数据库中。</p><p>Mybatis在查询关联对象或关联集合对象时,需要手动编写SQL来完成,所以,被称之为半自动ORM映射工具。</p><h3 id="mybatis和ibatis">Mybatis和ibatis</h3><p>ibatis通过直接调用sqlsession的select等方法进行操作，而Mybatis首先创建一个mapper接口，通过sqlsession的getMapper方法传入这个接口，sqlSession会基于jdk动态代理生成一个代理对象，根据类的全限定符、方法名在mapper.xml文件中自动实现接口的功能，事实上就是底层调用ibatis进行实现。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240313202035.png" /></p><h2 id="基础示例">基础示例</h2><ol type="1"><li><p>数据库配置</p><p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE `mybatis<span class="hljs-operator">-</span>example`;<br><br>USE `mybatis<span class="hljs-operator">-</span>example`;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_emp`(<br>  emp_id <span class="hljs-type">INT</span> AUTO_INCREMENT,<br>  emp_name <span class="hljs-type">CHAR</span>(<span class="hljs-number">100</span>),<br>  emp_salary <span class="hljs-keyword">DOUBLE</span>(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>),<br>  <span class="hljs-keyword">PRIMARY</span> KEY(emp_id)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_emp`(emp_name,emp_salary) <span class="hljs-keyword">VALUES</span>(&quot;tom&quot;,<span class="hljs-number">200.33</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_emp`(emp_name,emp_salary) <span class="hljs-keyword">VALUES</span>(&quot;jerry&quot;,<span class="hljs-number">666.66</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_emp`(emp_name,emp_salary) <span class="hljs-keyword">VALUES</span>(&quot;andy&quot;,<span class="hljs-number">777.77</span>);<br></code></pre></td></tr></table></figure></p></li><li><p>依赖导入</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- mybatis依赖 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- MySQL驱动 mybatis底层依赖jdbc驱动实现,本次不需要导入连接池,mybatis自带! --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--junit5测试--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></p></li><li><p>实体类（pojo）</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer empId;<br><br>    <span class="hljs-keyword">private</span> String empName;<br><br>    <span class="hljs-keyword">private</span> Double empSalary;<br>    <br>    <span class="hljs-comment">//getter | setter</span><br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>mapper接口</p><p>注意这里mapper定义的是接口并非类，接口的实现依赖xml文件而不是类</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmployeeMapper</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据员工id查询员工数据方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> empId  员工id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 员工实体对象</span><br><span class="hljs-comment">     */</span><br>    Employee <span class="hljs-title function_">selectEmployee</span><span class="hljs-params">(Integer empId)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>mapper xml文件</p><p><mapper>标签中的namespace为对应的接口文件名，注意在接口中不支持重载方法，因为xml文件无法进行映射。</p><p>注意如果不经过特殊设置，要把数据库字段映射到pojo的属性名上</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.spring.mapper.EmployeeMapper&quot;</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 查询使用 select标签</span><br><span class="hljs-comment">            id = 方法名</span><br><span class="hljs-comment">            resultType = 返回值类型</span><br><span class="hljs-comment">            标签内编写SQL语句</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmployee&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.spring.pojo.Employee&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- #&#123;empId&#125;代表动态传入的参数,并且进行赋值!后面详细讲解 --&gt;</span><br>        select emp_id empId,emp_name empName, emp_salary empSalary from <br>           t_emp where emp_id = #&#123;empId&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></p></li><li><p>mybatis配置文件</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- Mybatis的内置的事务管理器 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>      <span class="hljs-comment">&lt;!-- 配置数据源 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 建立数据库连接的具体信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt;</span><br>    <span class="hljs-comment">&lt;!--    对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/EmployeeMapper.xml&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></p></li><li><p>测试</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectEmployee</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">// 1.创建SqlSessionFactory对象</span><br>        <span class="hljs-comment">// ①声明Mybatis全局配置文件的路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">mybatisConfigFilePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br><br>        <span class="hljs-comment">// ②以输入流的形式加载Mybatis配置文件</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(mybatisConfigFilePath);<br><br>        <span class="hljs-comment">// ③基于读取Mybatis配置文件的输入流创建SqlSessionFactory对象</span><br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br><br>        <span class="hljs-comment">// 2.使用SqlSessionFactory对象开启一个会话</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-comment">// 3.根据EmployeeMapper接口的Class对象获取Mapper接口类型的对象(动态代理技术)</span><br>        <span class="hljs-type">EmployeeMapper</span> <span class="hljs-variable">employeeMapper</span> <span class="hljs-operator">=</span> session.getMapper(EmployeeMapper.class);<br><br>        <span class="hljs-comment">// 4. 调用代理类方法既可以触发对应的SQL语句</span><br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> employeeMapper.selectEmployee(<span class="hljs-number">1</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;employee = &quot;</span> + employee);<br><br>        <span class="hljs-comment">// 4.关闭SqlSession</span><br>        session.commit(); <span class="hljs-comment">//提交事务 [DQL不需要,其他需要]</span><br>        session.close(); <span class="hljs-comment">//关闭会话</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h2 id="详解">详解</h2><h3 id="配置日志输出">配置日志输出</h3><p>在mybatis-config.xml文件中设置settings标签,应注意需要处于environments标签上方</p><p>value取值：SLF4J | LOG4J（3.5.9 起废弃） | LOG4J2 | JDK_LOGGING |COMMONS_LOGGING | STDOUT_LOGGING |NO_LOGGING</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="配置驼峰自动映射">配置驼峰自动映射</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在全局范围内对Mybatis进行配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 具体配置 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 从org.apache.ibatis.session.Configuration类中可以查看能使用的配置项 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 将mapUnderscoreToCamelCase属性配置为true，表示开启自动映射驼峰式命名规则 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 规则要求数据库表字段命名方式：单词_单词 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 规则要求Java实体类属性名命名方式：首字母小写的驼峰式命名 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="和的区别">#{}和${}的区别</h3><p>Mybatis会将SQL语句中的#{}转换为问号占位符；</p><p>${}形式传参，底层Mybatis做的是字符串拼接操作，会有SQL注入攻击问题</p><p>通常不会采用${}的方式传值。一个特定的适用场景是：通过Java程序动态生成数据库表，表名部分需要Java程序通过参数传入；而JDBC对于表名部分是不能使用问号占位符的，此时只能使用</p><h3 id="数据传入">数据传入</h3><h4 id="简单类型参数">简单类型参数</h4><p>对于参数是简单的单值类型，方法的参数名即为xml中的参数名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span>&gt;</span><br>    delete from t_emp where emp_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="实体类型参数">实体类型参数</h4><p>方法中为实体类对象，xml文件中以实体类的变量名作为参数名</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240315205558.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">insertEmployee</span><span class="hljs-params">(Employee employee)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertEmployee&quot;</span>&gt;</span><br>    insert into t_emp(emp_name, emp_salary) values (#&#123;empName&#125;, #&#123;empSalary&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="多个简单类型">多个简单类型</h4><p>必须在方法参数列表添加@Param,括号内部是参数名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; <span class="hljs-title function_">queryByNameAndSalary</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String name, <span class="hljs-meta">@Param(&quot;salary&quot;)</span> Double salary)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryByNameAndSalary&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.spring.pojo.Employee&quot;</span>&gt;</span><br>    select emp_id empId,emp_name empName, emp_salary empSalary from<br>    t_emp where emp_name = #&#123;name&#125; and emp_salary &gt; #&#123;salary&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="map类型参数">Map类型参数</h4><p>xml文件中的参数名为map的key值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">insertEmployeeMap</span><span class="hljs-params">(Map&lt;String, Object&gt; data)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertEmployeeMap&quot;</span>&gt;</span><br>    insert into t_emp(emp_name, emp_salary) values (#&#123;name&#125;, #&#123;salary&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; stringObjectMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>stringObjectMap.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;chen2&quot;</span>);<br>stringObjectMap.put(<span class="hljs-string">&quot;salary&quot;</span>, <span class="hljs-number">1000.0</span>);<br>employeeMapper.insertEmployeeMap(stringObjectMap);<br></code></pre></td></tr></table></figure><h3 id="数据输出">数据输出</h3><h4 id="简单类型输出">简单类型输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">queryNameById</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryNameById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;string&quot;</span>&gt;</span><br>    select emp_name from t_emp where tmp_id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="实体类型输出">实体类型输出</h4><p>select标签中要指定resultType，值为指定类类型的全限定符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Employee <span class="hljs-title function_">queryById</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.spring.pojo.Employee&quot;</span>&gt;</span><br>    select emp_id empId,emp_name empName, emp_salary empSalary from<br>    t_emp where emp_id = #&#123;empId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="map输出">Map输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,Object&gt; <span class="hljs-title function_">selectEmpNameAndMaxSalary</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmpNameAndMaxSalary&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>  SELECT<br>    emp_name 员工姓名,<br>    emp_salary 员工工资,<br>    (SELECT AVG(emp_salary) FROM t_emp) 部门平均工资<br>  FROM t_emp WHERE emp_salary=(<br>    SELECT MAX(emp_salary) FROM t_emp<br>  )<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="list类型">List类型</h4><p>方法的返回值为List，但xml文件不做改变，返回List内部的类型即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; <span class="hljs-title function_">queryBySalary</span><span class="hljs-params">(Double salary)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBySalary&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.spring.pojo.Employee&quot;</span>&gt;</span><br>    select emp_id empId,emp_name empName, emp_salary empSalary from<br>    t_emp where emp_salary &gt; #&#123;salary&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="resultmap简单自定义映射">resultMap简单自定义映射</h4><p>resultType安装规则自动映射，只能映射一层结构，多表查询的时候结果无法映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;employeeMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.spring.pojo.Employee&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empId&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_salary&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empSalary&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;employeeMap&quot;</span>&gt;</span><br>    select * from t_emp where emp_id = #&#123;empId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="主键回显">主键回显</h4><h5 id="自增长">自增长</h5><p>在xml文件中设置useGeneratedKeys为true，随后指定数据库中列明和映射的属性名即可，这样主键就赋值到了insert的实体类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">insertEmployee</span><span class="hljs-params">(Employee employee)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertEmployee&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyColumn</span>=<span class="hljs-string">&quot;emp_id&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;empId&quot;</span>&gt;</span><br>    insert into t_emp(emp_name, emp_salary) values (#&#123;empName&#125;, #&#123;empSalary&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();<br>employee.setEmpSalary(<span class="hljs-number">10000.0</span>);<br>employee.setEmpName(<span class="hljs-string">&quot;chen&quot;</span>);<br>employeeMapper.insertEmployee(employee);<br>System.out.println(employee.getEmpId());<br></code></pre></td></tr></table></figure><h5 id="非自增长">非自增长</h5><p>selectKey的order代表在sql语句之前还是之后运行，keyProperty代表结果映射到的变量名，可以在sql语句中使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span>&gt;</span><br>        SELECT UUID() as id<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br>    INSERT INTO user (id, username, password) <br>    VALUES (<br>        #&#123;id&#125;,<br>        #&#123;username&#125;,<br>        #&#123;password&#125;<br>    )<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="多表映射">多表映射</h3><h4 id="对一映射">对一映射</h4><p>在编写resultMap的时候注意一层一层编写，首先写Order类的id、属性，然后对于实体类对象，采用association来指定映射对象类，然后再继续编写Customer类的id、属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Order <span class="hljs-title function_">queryOrderById</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.spring.mapper.OrderMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.spring.pojo.Order&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderName&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerId&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customer&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.spring.pojo.Customer&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerId&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerName&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryOrderById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;orderMap&quot;</span>&gt;</span><br>        select * from t_order, t_customer<br>        where t_order.customer_id = t_customer.customer_id and order_id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="对多映射">对多映射</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Customer <span class="hljs-title function_">selectCustomerWithOrderList</span><span class="hljs-params">(Integer customerId)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置resultMap实现从Customer到OrderList的“对多”关联关系 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectCustomerWithOrderListResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 映射Customer本身的属性 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerId&quot;</span>/&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerName&quot;</span>/&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- collection标签：映射“对多”的关联关系 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- property属性：在Customer类中，关联“多”的一端的属性名 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- ofType属性：集合属性中元素的类型 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 映射Order的属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderName&quot;</span>/&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Customer selectCustomerWithOrderList(Integer customerId); --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectCustomerWithOrderList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;selectCustomerWithOrderListResultMap&quot;</span>&gt;</span><br>  SELECT c.customer_id,c.customer_name,o.order_id,o.order_name<br>  FROM t_customer c<br>  LEFT JOIN t_order o<br>  ON c.customer_id=o.customer_id<br>  WHERE c.customer_id=#&#123;customerId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="动态sql">动态SQL</h3><h4 id="where-if">where &amp; if</h4><p>where标签在检测到内部有任何if满足的时候，会添加where关键字，同时会自动去掉“标签体内前面多余的and/or</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByCondition(Employee employee); --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmployeeByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;employee&quot;</span>&gt;</span><br>    select emp_id,emp_name,emp_salary from t_emp<br>    <span class="hljs-comment">&lt;!-- ” --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 使用if标签，让我们可以有选择的加入SQL语句的片段。这个SQL语句片段是否要加入整个SQL语句，就看if标签判断的结果是否为true --&gt;</span><br>        <span class="hljs-comment">&lt;!-- 在if标签的test属性中，可以访问实体类的属性，不可以访问数据库表的字段 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null&quot;</span>&gt;</span><br>            emp_name=#&#123;empName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empSalary <span class="hljs-symbol">&amp;gt;</span> 2000&quot;</span>&gt;</span><br>            or emp_salary&gt;#&#123;empSalary&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="set-if">set if</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- void updateEmployeeDynamic(Employee employee) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateEmployeeDynamic&quot;</span>&gt;</span><br>    update t_emp<br>    <span class="hljs-comment">&lt;!-- set emp_name=#&#123;empName&#125;,emp_salary=#&#123;empSalary&#125; --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用set标签动态管理set子句，并且动态去掉两端多余的逗号 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null&quot;</span>&gt;</span><br>            emp_name=#&#123;empName&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empSalary <span class="hljs-symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span><br>            emp_salary=#&#123;empSalary&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where emp_id=#&#123;empId&#125;<br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">         第一种情况：所有条件都满足 SET emp_name=?, emp_salary=?</span><br><span class="hljs-comment">         第二种情况：部分条件满足 SET emp_salary=?</span><br><span class="hljs-comment">         第三种情况：所有条件都不满足 update t_emp where emp_id=?</span><br><span class="hljs-comment">            没有set子句的update语句会导致SQL语法错误</span><br><span class="hljs-comment">     --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="choose-when-otherwise">choose &amp; when &amp; otherwise</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByChoose(Employee employee) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmployeeByConditionByChoose&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span><br>    select emp_id,emp_name,emp_salary from t_emp<br>    where<br>    <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null&quot;</span>&gt;</span>emp_name=#&#123;empName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empSalary <span class="hljs-symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span>emp_salary <span class="hljs-symbol">&amp;lt;</span> 3000<span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span>1=1<span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">     第一种情况：第一个when满足条件 where emp_name=?</span><br><span class="hljs-comment">     第二种情况：第二个when满足条件 where emp_salary &lt; 3000</span><br><span class="hljs-comment">     第三种情况：两个when都不满足 where 1=1 执行了otherwise</span><br><span class="hljs-comment">     --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="批量操作">批量操作</h4><h5 id="批量查询">批量查询</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.spring.mapper.OrderMapper&quot;</span>&gt;</span><br>    select * from t_order where<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="批量删除">批量删除</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;delete&quot;</span>&gt;</span><br>    delete from t_order where order_id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="批量插入">批量插入</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span>&gt;</span><br>    insert into t_order(order_name, customer_id) values <br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>            (#&#123;order.orderName&#125;, #&#123;order.customerId&#125;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="批量更新">批量更新</h5><p>批量插入的例子本质上是一条SQL语句，而实现批量更新则需要多条SQL语句拼起来，用分号分开。也就是一次性发送多条SQL语句让数据库执行。此时需要在数据库连接信息的URL地址中设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">atguigu.dev.url=jdbc:mysql:///mybatis-example?allowMultiQueries=true<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span><br>        update t_order set order_name = #&#123;order.orderName&#125; where order_id = #&#123;order.orderId&#125;;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="mybatisplus">MybatisPlus</h2><h3 id="排序">排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">QueryWrapper&lt;ShopType&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>queryWrapper.orderByAsc(<span class="hljs-string">&quot;sort&quot;</span>);<br>List&lt;ShopType&gt; shopTypes = shopTypeMapper.selectList(queryWrapper);<br></code></pre></td></tr></table></figure><h3 id="逻辑删除">逻辑删除</h3><ol type="1"><li>数据库和实体类添加逻辑删除字段,可以是一个布尔类型、整数类型或枚举类型。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">ADD</span> deleted <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> ;  # <span class="hljs-type">int</span> 类型 <span class="hljs-number">1</span> 逻辑删除 <span class="hljs-number">0</span> 未逻辑删除<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><p>指定逻辑删除字段和属性值</p><p>单一指定</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-variable">@Data</span><br>public class <span class="hljs-keyword">User</span> &#123;<br><br>   <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-variable">@TableId</span><br>    private <span class="hljs-type">Integer</span> id;<br>    private String name;<br>    private <span class="hljs-type">Integer</span> age;<br>    private String email;<br>     <span class="hljs-variable">@TableLogic</span><br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>逻辑删除字段 <span class="hljs-type">int</span> mybatis<span class="hljs-operator">-</span>plus下,默认 逻辑删除值为<span class="hljs-number">1</span> 未逻辑删除 <span class="hljs-number">1</span> <br>    private <span class="hljs-type">Integer</span> deleted;<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 全局指定</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">logic-delete-field:</span> <span class="hljs-string">deleted</span> <span class="hljs-comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span><br>      <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 逻辑已删除值(默认为 1)</span><br>      <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 逻辑未删除值(默认为 0)</span><br></code></pre></td></tr></table></figure><h3 id="乐观锁和悲观锁">乐观锁和悲观锁</h3><h4 id="悲观锁">悲观锁</h4><p>悲观锁的基本思想是，在整个数据访问过程中，将共享资源锁定，以确保其他线程或进程不能同时访问和修改该资源。悲观锁的核心思想是"先保护，再修改"。在悲观锁的应用中，线程在访问共享资源之前会获取到锁，并在整个操作过程中保持锁的状态，阻塞其他线程的访问。只有当前线程完成操作后，才会释放锁，让其他线程继续操作资源。这种锁机制可以确保资源独占性和数据的一致性，但是在高并发环境下，悲观锁的效率相对较低。</p><h4 id="乐观锁">乐观锁</h4><p>乐观锁的基本思想是，认为并发冲突的概率较低，因此不需要提前加锁，而是<strong>在数据更新阶段</strong>进行冲突检测和处理。乐观锁的核心思想是"先修改，后校验"。在乐观锁的应用中，线程在读取共享资源时不会加锁，而是记录特定的<strong>版本信息</strong>。当线程准备更新资源时，会先检查该资源的版本信息是否与之前读取的版本信息一致，如果一致则执行更新操作，否则说明有其他线程修改了该资源，需要进行相应的冲突处理。乐观锁通过避免加锁操作，提高了系统的并发性能和吞吐量，但是在并发冲突较为频繁的情况下，乐观锁会导致较多的冲突处理和重试操作。</p><h4 id="乐观锁实现">乐观锁实现</h4><p>添加版本号更新插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>    interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimisticLockerInnerInterceptor</span>());<br>    <span class="hljs-keyword">return</span> interceptor;<br>&#125;<br></code></pre></td></tr></table></figure><p>乐观锁字段添加@Version注解</p><p>注意: 数据库也需要添加version字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">ALTER TABLE USER ADD VERSION INT DEFAULT <span class="hljs-number">1</span> ;  # <span class="hljs-type">int</span> 类型 乐观锁字段<br></code></pre></td></tr></table></figure><pre><code class="hljs">- 支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime- 仅支持 `updateById(id)` 与 `update(entity, wrapper)` 方法</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Version</span><br><span class="hljs-keyword">private</span> Integer version;<br></code></pre></td></tr></table></figure><p>正常更新使用即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//演示乐观锁生效场景</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQuick7</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//步骤1: 先查询,在更新 获取version数据</span><br>    <span class="hljs-comment">//同时查询两条,但是version唯一,最后更新的失败</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span>  <span class="hljs-operator">=</span> userMapper.selectById(<span class="hljs-number">5</span>);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user1</span>  <span class="hljs-operator">=</span> userMapper.selectById(<span class="hljs-number">5</span>);<br><br>    user.setAge(<span class="hljs-number">20</span>);<br>    user1.setAge(<span class="hljs-number">30</span>);<br><br>    userMapper.updateById(user);<br>    <span class="hljs-comment">//乐观锁生效,失败!</span><br>    userMapper.updateById(user1);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring-AOP</title>
    <link href="/2024/03/10/SoftwareDevelopment/Spring-AOP/"/>
    <url>/2024/03/10/SoftwareDevelopment/Spring-AOP/</url>
    
    <content type="html"><![CDATA[<p>记录Spring-AOP学习过程 <span id="more"></span></p><h3 id="什么是aop">什么是AOP</h3><p>AOP：面向切面编程。简单说，就是把一些业务逻辑中的相同的代码抽取到一个独立的模块中，让业务逻辑更加清爽。</p><p>具体来说 , 假如我现在要 crud写一堆业务,我们可以把日志记录和数据校验<strong>可重用的功能模块</strong>分离出来,然后在程序的执行的合适的地方动态地植入这些代码并执行。这样就简化了代码的书写。业务逻辑代码中没有参和通用逻辑的代码,业务模块更简洁, 只包含核心业务代码。实现了业务逻辑和通用逻辑的代码分离,便于维护和升级,<strong>降低了业务逻辑和通用逻辑的耦合性</strong>。</p><h3 id="spring-aop">Spring-AOP</h3><ul><li>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口。</li><li>cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口。</li><li>AspectJ：早期的AOP实现的框架，SpringAOP借用了AspectJ中的AOP注解。</li></ul><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240310162431.png" /></p><h3 id="实现流程">实现流程</h3><h4 id="导入相关依赖">导入相关依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-comment">&lt;!--注解形式--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="准备接口">准备接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="核心代码实现类">核心代码实现类</h4><p>使用Spring自然要把实现类加入到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorPureImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i + j;<br>    <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i - j;<br>    <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i * j;<br>    <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i / j;<br>    <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="切面类">切面类</h4><p>对于切片类要声明两个参数：</p><ol type="1"><li><span class="citation"data-cites="Aspect表明这个类是切面类">@Aspect表明这个类是切面类</span></li><li><span class="citation"data-cites="Component将这个类加入IOC容器">@Component将这个类加入IOC容器</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.advice;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">// @Aspect表示这个类是一个切面类</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-comment">// @Component注解保证这个切面类能够放入IOC容器</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br>        <br>    <span class="hljs-comment">// @Before注解：声明当前方法是前置通知方法</span><br>    <span class="hljs-comment">// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上</span><br>    <span class="hljs-meta">@Before(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLogBeforeCore</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[AOP前置通知] 方法开始了&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@AfterReturning(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLogAfterSuccess</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[AOP返回通知] 方法成功返回了&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@AfterThrowing(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLogAfterException</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[AOP异常通知] 方法抛异常了&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@After(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLogFinallyEnd</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[AOP后置通知] 方法最终结束了&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="开启aspectj支持">开启AspectJ支持</h4><p>要在配置类中添加@EnableAspectJAutoProxy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.PropertySource;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.spring&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试">测试</h4><p>需要注意的是注入的事实上是代理对象，需要用接口接值，不能用纯净实现类接值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringJUnitConfig(value=Config.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AOPtest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Calculator calculator;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAOP</span><span class="hljs-params">()</span> &#123;<br>        calculator.add(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取切点详细信息">获取切点详细信息</h3><h4 id="获取目标方法信息">获取目标方法信息</h4><p>所有切面方法里面都可以这么获取：在参数中定义joinPoint</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com.spring.CalculatorPureImpl.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br><br>    <span class="hljs-comment">// 获取方法属于的类的信息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">simpleName</span> <span class="hljs-operator">=</span> joinPoint.getTarget().getClass().getSimpleName();<br>    System.out.println(<span class="hljs-string">&quot;simpleName: &quot;</span> + simpleName);<br><br>    <span class="hljs-comment">// 获取方法的修饰符</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getModifiers();<br>    System.out.println(<span class="hljs-string">&quot;modifiers: &quot;</span> + Modifier.toString(modifiers));<br><br>    <span class="hljs-comment">// 获取方法名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();<br>    System.out.println(<span class="hljs-string">&quot;name: &quot;</span> + name);<br><br>    <span class="hljs-comment">// 获取参数列表</span><br>    Object[] args = joinPoint.getArgs();<br>    System.out.println(<span class="hljs-string">&quot;args: &quot;</span> + args[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot; &quot;</span> + args[<span class="hljs-number">1</span>]);<br><br>    System.out.println(<span class="hljs-string">&quot;start log&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4id="在afterreturning中获取返回值信息">在AfterReturning中获取返回值信息</h4><p>注意要在@AfterReturning括号内加入returning的参数名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterReturning(value = &quot;execution(* com.spring.CalculatorPureImpl.*(..))&quot;, returning = &quot;result&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">(JoinPoint joinPoint, Object result)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;afterReturning, result=&quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure><h4id="在afterthrowing中获取异常信息">在AfterThrowing中获取异常信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterThrowing(value = &quot;execution(* com.spring.CalculatorPureImpl.*(..))&quot;, throwing = &quot;e&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">(JoinPoint joinPoint, Throwable e)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;afterThrowing, e=&quot;</span> + e);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切点表达式">切点表达式</h3><h4 id="格式">格式</h4><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240310164540.png" /></p><h4 id="统一管理切点">统一管理切点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(* com.spring.CalculatorPureImpl.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-meta">@AfterThrowing(value = &quot;pointcut()&quot;, throwing = &quot;e&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">(JoinPoint joinPoint, Throwable e)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;afterThrowing, e=&quot;</span> + e);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="环绕通知">环绕通知</h4><ol type="1"><li>参数需要添加ProceedingJointPoint，使用jointPoint.proceed()来执行方法</li><li>catch代码块一定要把异常再次throw出去，不然外部接收不到异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAroundAdvice</span> &#123;<br><br>    <span class="hljs-meta">@Around(&quot;execution(* com.spring.CalculatorPureImpl.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;around before&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            result = joinPoint.proceed();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;around afterThrowing&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;around after&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切面优先级设置">切面优先级设置</h3><p>使用 <span class="citation" data-cites="Order">@Order</span>注解可以控制切面的优先级：</p><ul><li><span class="citation"data-cites="Order">@Order</span>(较小的数)：优先级高</li><li><span class="citation"data-cites="Order">@Order</span>(较大的数)：优先级低</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2024/03/07/SoftwareDevelopment/MySQL/"/>
    <url>/2024/03/07/SoftwareDevelopment/MySQL/</url>
    
    <content type="html"><![CDATA[<p>MySQL学习 <span id="more"></span></p><h2 id="基本语法">基本语法</h2><h3 id="数据库相关操作">数据库相关操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">查询所有数据库<br>show databases;<br><br>指定某个数据库<br>use xxx<br><br>创建数据库<br>create database [if not exists] xxx<br><br>删除数据库<br>drop database [if exists] xxx<br></code></pre></td></tr></table></figure><h3 id="表相关操作">表相关操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql">创建表<br>create table user(<br>    id bigint auto_increment primary key ,<br>    name varchar(30),<br>    age int,<br>    email varchar(50)<br>);<br><br>约束类型：<br>not null<br>unique<br>primary key<br>default<br>foreign key<br><br>删除表<br>drop table [if exists] user<br><br>查询当前数据库所有表<br>show tables;<br><br>查询表结构<br>desc user;<br><br>修改表名<br>rename table xxx to yyy<br><br>添加字段<br>alter table user add gender int;<br><br>删除字段<br>alter table user drop gender<br></code></pre></td></tr></table></figure><h3 id="数据相关操作">数据相关操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs mysql">插入数据<br>INSERT INTO user(name, age, email, gender) VALUES(&#x27;陈&#x27;, 18, &#x27;test@emails.com&#x27;, 1);<br><br>更新数据<br>update user set name=&quot;liu&quot; where id = 1;<br><br>删除数据<br>delete from user where id=1<br>删除全部数据<br>delete from user<br><br>基础查询<br>select * from mybatis_example.tb_emp<br>         WHERE entrydate &gt;= &#x27;2000-01-01&#x27; and entrydate &lt;= &#x27;2012-11-01&#x27;;<br>         <br>模糊查询(_代表一个字符，%代表任意个字符)<br>select * from mybatis_example.tb_emp<br>         WHERE name like &#x27;__&#x27;;<br><br>聚合查询<br>select count(name) from tb_emp<br><br>分组查询<br>select gender, count(*) from tb_emp group by gender having count(*) &gt; 6;<br><br>排序<br>select * from tb_emp order by entrydate DESC ;<br><br>分页查询(从0开始查询五个)<br>select * from tb_emp limit 0,5<br><br>多表查询<br>select * from tb_emp where dept_id = (select id from tb_dept where name = &#x27;教研部&#x27;);<br>select * from tb_emp where dept_id in (select id from tb_dept where name = &#x27;教研部&#x27; or name = &#x27;咨询部&#x27;);<br><br></code></pre></td></tr></table></figure><h2 id="事务">事务</h2><h3 id="四大特性">四大特性</h3><ul><li>原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><blockquote><p>事务的四大特性简称为：ACID</p></blockquote><h2 id="索引">索引</h2><h3 id="语法">语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create index idx_sku_sn on tb_sku (sn);<br><br>show  index  from  tb_emp;<br><br>drop index idx_emp_name on tb_emp;<br></code></pre></td></tr></table></figure><p>优点：</p><ol type="1"><li>提高数据查询的效率，降低数据库的IO成本。</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗。</li></ol><p>缺点：</p><ol type="1"><li>索引会占用存储空间。</li><li>索引大大提高了查询效率，同时却也降低了insert、update、delete的效率。</li></ol><h3 id="结构">结构</h3><p>我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree结构组织的索引。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2024/03/07/SoftwareDevelopment/SpringBoot/"/>
    <url>/2024/03/07/SoftwareDevelopment/SpringBoot/</url>
    
    <content type="html"><![CDATA[<p>springBoot学习</p><span id="more"></span><h3 id="简单示例">简单示例</h3><p>首先在新创建的Springboot的项目中新建controller文件夹，创建一个controller文件</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240307182743.png" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.springboot.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><span class="hljs-comment">// Controller + ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><span class="hljs-comment">// 设置路径,RequestMapping可以接收各种方式的请求</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;<span class="hljs-comment">// 返回值</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="各种参数传递方式">各种参数传递方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.springboot.pojo;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> Integer age;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.springboot.pojo;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-keyword">private</span> String city;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.springboot.pojo;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComplexUser</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Address address;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 简单参数传递</span><br><span class="hljs-comment">// 要求传参的名字和参数名字相同</span><br><span class="hljs-meta">@GetMapping(&quot;/request_1&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">request1</span><span class="hljs-params">(String name, Integer age)</span>&#123;<br>    <span class="hljs-keyword">return</span> name + String.valueOf(age);<br>&#125;<br><br><span class="hljs-comment">// 可以使用RequestParam来指定传过来的参数名字</span><br><span class="hljs-meta">@GetMapping(&quot;/request_2&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">request2</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(name=&quot;username&quot;)</span>String name, Integer age)</span>&#123;<br>    <span class="hljs-keyword">return</span> name + String.valueOf(age);<br>&#125;<br><br><span class="hljs-comment">// 通过Get获得实体参数，传参方式同上</span><br><span class="hljs-comment">// 可以只传一部分属性</span><br><span class="hljs-meta">@GetMapping(&quot;/request_3&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">request3</span><span class="hljs-params">(User user)</span>&#123;<br>    <span class="hljs-keyword">return</span> user.getUsername() + String.valueOf(user.getAge());<br>&#125;<br><br><span class="hljs-comment">// 通过Post传递复杂实体，注意一定要实现getter和setter方法（用@Data注解简化）</span><br><span class="hljs-meta">@PostMapping(&quot;/request_4&quot;)</span><br><span class="hljs-keyword">public</span> ComplexUser <span class="hljs-title function_">request4</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> ComplexUser user)</span>&#123;<span class="hljs-comment">// 注意一定要@RequestBody</span><br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br><br><span class="hljs-comment">// 路径参数</span><br><span class="hljs-meta">@PostMapping(&quot;request_5/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">request5</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>    <span class="hljs-keyword">return</span> id;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统一返回类">统一返回类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer code;<br>    <span class="hljs-keyword">private</span> String msg;<br>    <span class="hljs-keyword">private</span> Object data;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cookie和请求头">Cookie和请求头</h3><h4 id="接收cookie">接收Cookie</h4><p>可以使用 <span class="citation"data-cites="CookieValue">@CookieValue</span> 注释将 HTTP Cookie的值绑定到控制器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span> &#123; <br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="设置cookie方式">设置cookie方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/save&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(HttpServletResponse response)</span> &#123;<br>    <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;JSESSIONID&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br>    response.addCookie(cookie);<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="接收请求头">接收请求头</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding, </span><br><span class="hljs-params">    <span class="hljs-meta">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class="hljs-type">long</span> keepAlive)</span> &#123; <br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统一配置文件">统一配置文件</h3><p>SpringBoot工程下，进行统一的配置管理，任何参数（端口号、项目根路径、数据库连接信息等等)都集中到一个固定位置和命名的配置文件（<code>application.properties</code>或<code>application.yml</code>）中</p><p>配置文件应该放置在SpringBoot工程的<code>src/main/resources</code>目录下。这是因为<code>src/main/resources</code>目录是SpringBoot默认的类路径（classpath），配置文件会被自动加载并可供应用程序访问。</p><h4 id="常见配置">常见配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># application.properties 为统一配置文件</span><br><span class="hljs-comment"># 内部包含: 固定功能的key,自定义的key</span><br><span class="hljs-comment"># 此处的配置信息,我们都可以在程序中@Value等注解读取</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 固定的key</span><br><span class="hljs-comment"># 启动端口号</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">80 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 自定义</span><br><span class="hljs-attr">spring.jdbc.datasource.driverClassName</span>=<span class="hljs-string">com.mysql.cj.jdbc.driver</span><br><span class="hljs-attr">spring.jdbc.datasource.url</span>=<span class="hljs-string">jdbc:mysql:///springboot_01</span><br><span class="hljs-attr">spring.jdbc.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.jdbc.datasource.password</span>=<span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><h4 id="yaml格式">yaml格式</h4><p>yaml语法说明 1. 数据结构用树形结构呈现，通过缩进来表示层级， 2.连续的项目（集合）通过减号 ” - ” 来表示 3.键值结构里面的key/value对用冒号 ” : ” 来分隔。 4.YAML配置文件的扩展名是yaml 或 yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-comment"># YAML配置文件示例</span><br><span class="hljs-attr">app_name:</span> <span class="hljs-string">我的应用程序</span><br><span class="hljs-attr">version:</span> <span class="hljs-number">1.0</span><span class="hljs-number">.0</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">张三</span><br><br><span class="hljs-attr">database:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">5432</span><br>  <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span><br>  <span class="hljs-attr">password:</span> <span class="hljs-string">password123</span><br><br><span class="hljs-attr">features:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">登录</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">注册</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">仪表盘</span><br><br><span class="hljs-attr">settings:</span><br>  <span class="hljs-attr">analytics:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">theme:</span> <span class="hljs-string">dark</span><br></code></pre></td></tr></table></figure><h4 id="批量配置文件属性读取">批量配置文件属性读取</h4><p><span class="citation"data-cites="ConfigurationProperties是SpringBoot提供的重要注解">@ConfigurationProperties是SpringBoot提供的重要注解</span>,他可以将一些配置属性批量注入到bean对象。</p><p>在类上通过@ConfigurationProperties注解声明该类要读取属性配置</p><p>prefix="spring.jdbc.datasource"读取属性文件中前缀为spring.jdbc.datasource的值。前缀和属性名称和配置文件中的key必须要保持一致才可以注入成功</p><p>另外还有一个很大的优点：<span class="citation"data-cites="Value并不能读取list">@Value并不能读取list</span>，只能读取单值；用@ConfigurationProperties则可以解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.atguigu.properties;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.jdbc.datasource&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceConfigurationProperties</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String driverClassName;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多环境配置与激活">多环境配置与激活</h4><p>application-dev.yml（开发）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jdbc:</span><br>    <span class="hljs-attr">datasource:</span><br>      <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql:///dev</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p>application-test.yml（测试）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jdbc:</span><br>    <span class="hljs-attr">datasource:</span><br>      <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql:///test</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p>application-prod.yml（生产）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jdbc:</span><br>    <span class="hljs-attr">datasource:</span><br>      <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql:///prod</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p>环境激活</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><h3 id="拦截器">拦截器</h3><ol type="1"><li>定义Interceptor拦截方式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.springboot.interceptor;<br><br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.ModelAndView;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyInterceptor拦截器的preHandle方法执行....&quot;</span>);<br>        <span class="hljs-keyword">return</span> HandlerInterceptor.<span class="hljs-built_in">super</span>.preHandle(request, response, handler);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyInterceptor拦截器的postHandle方法执行....&quot;</span>);<br>        HandlerInterceptor.<span class="hljs-built_in">super</span>.postHandle(request, response, handler, modelAndView);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyInterceptor拦截器的afterCompletion方法执行....&quot;</span>);<br>        HandlerInterceptor.<span class="hljs-built_in">super</span>.afterCompletion(request, response, handler, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>创建SpringMVC配置文件，添加Interceptor，只要在main的目录下即可自动扫描到。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.springboot.config;<br><br><span class="hljs-keyword">import</span> org.example.springboot.interceptor.MyInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MyInterceptor myInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(myInterceptor).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="声明式事务">声明式事务</h3><p>SpringBoot项目会自动配置一个DataSourceTransactionManager，所以只需在方法（或者类）加上 <spanclass="citation" data-cites="Transactional">@Transactional</span>注解，就自动纳入 Spring 的事务管理了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setId(<span class="hljs-number">1</span>);<br>    user.setPassword(<span class="hljs-string">&quot;test2&quot;</span>);<br>    user.setAccount(<span class="hljs-string">&quot;test2&quot;</span>);<br>    userMapper.update(user);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="aop">AOP</h3><p>直接使用aop注解即可:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAdvice</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(* com..service.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;LogAdvice.before&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;joinPoint = &quot;</span> + joinPoint);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="连接服务器">连接服务器</h3><p>在properties文件中指定这三个变量即可</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">cdt</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://43.143.187.188:3308/chongdetang?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useAffectedRows=true</span><br><br></code></pre></td></tr></table></figure><h3 id="项目打包">项目打包</h3><h4 id="添加打包插件">添加打包插件</h4><p>在SpringBoot项目中添加<code>spring-boot-maven-plugin</code>插件是为了支持将项目打包成可执行的可运行jar包。如果不添加<code>spring-boot-maven-plugin</code>插件配置，使用常规的<code>java -jar</code>命令来运行打包后的SpringBoot项目是无法找到应用程序的入口点，因此导致无法运行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!--    SpringBoot应用打包插件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="打包">打包</h4><p>在idea点击package进行打包，可以在编译的target文件中查看jar包</p><h4 id="部署">部署</h4><p><code>java -jar</code>命令用于在Java环境中执行可执行的JAR文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs XML">命令格式：java -jar  [选项] [参数] <span class="hljs-tag">&lt;<span class="hljs-name">jar文件名</span>&gt;</span><br></code></pre></td></tr></table></figure><ol type="1"><li><code>-D&lt;name&gt;=&lt;value&gt;</code>：设置系统属性，可以通过<code>System.getProperty()</code>方法在应用程序中获取该属性值。例如：<code>java -jar -Dserver.port=8080 myapp.jar</code>。</li><li><code>-X</code>：设置JVM参数，例如内存大小、垃圾回收策略等。常用的选项包括：<ul><li><code>-Xmx&lt;size&gt;</code>：设置JVM的最大堆内存大小，例如<code>-Xmx512m</code> 表示设置最大堆内存为512MB。</li><li><code>-Xms&lt;size&gt;</code>：设置JVM的初始堆内存大小，例如<code>-Xms256m</code> 表示设置初始堆内存为256MB。</li></ul></li><li><code>-Dspring.profiles.active=&lt;profile&gt;</code>：指定SpringBoot的激活配置文件，可以通过<code>application-&lt;profile&gt;.properties</code>或<code>application-&lt;profile&gt;.yml</code>文件来加载相应的配置。例如：<code>java -jar -Dspring.profiles.active=dev myapp.jar</code>。</li></ol><figure><imgsrc="https://secure2.wostatic.cn/static/66fP6WRTExeyyKpybyBx7B/image.png?auth_key=1711188390-YuNZShUpKsUvM8pHJdvf7-0-869fc54faa72600c5332dfff1e7a1570&amp;file_size=426147"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaBasis</title>
    <link href="/2024/03/06/SoftwareDevelopment/JavaBasis/"/>
    <url>/2024/03/06/SoftwareDevelopment/JavaBasis/</url>
    
    <content type="html"><![CDATA[<p>Java基础的学习</p><span id="more"></span><h3 id="scanner键盘录入">Scanner键盘录入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">lesson1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 声明Scanner</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">// 获取下一个输入</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> scanner.next();<br>        System.out.println(next);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="random">Random</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">10</span>);<br>System.out.println(i);<br></code></pre></td></tr></table></figure><h3 id="数组">数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> []a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> [][]b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> a.length;  <span class="hljs-comment">// 获取数组长度</span><br><br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>b[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>System.out.println(Arrays.toString(a)); <span class="hljs-comment">// 打印数组</span><br>System.out.println(Arrays.deepToString(b)); <span class="hljs-comment">// 打印二维数组</span><br></code></pre></td></tr></table></figure><h3 id="字符串">字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcde&quot;</span>;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">substring</span> <span class="hljs-operator">=</span> s.substring(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);   <span class="hljs-comment">// [1,3)</span><br>System.out.println(substring);  <span class="hljs-comment">// &quot;bc&quot;</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">substring1</span> <span class="hljs-operator">=</span> s.substring(<span class="hljs-number">3</span>); <span class="hljs-comment">// [3,)</span><br>System.out.println(substring1); <span class="hljs-comment">// &quot;de&quot;</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.indexOf(<span class="hljs-string">&quot;de&quot;</span>);<br>System.out.println(i);  <span class="hljs-comment">// 3</span><br><br>s = <span class="hljs-string">&quot;abcabcabc&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> s.indexOf(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 从下标为3的位置开始找</span><br>System.out.println(i1); <span class="hljs-comment">// 5</span><br><br><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcabcabc&quot;</span>;<br><span class="hljs-keyword">if</span>(s.equals(s2))&#123;   <span class="hljs-comment">// == 是比较内存地址， equals是比较内容</span><br>    System.out.println(<span class="hljs-string">&quot;equals&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="arraylist">ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>arrayList.add(<span class="hljs-number">5</span>);<br>arrayList.add(<span class="hljs-number">10</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> arrayList.size();<br>System.out.println(size);<br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arrayList.get(<span class="hljs-number">1</span>);<br>System.out.println(i);<br><br>arrayList.remove(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 移除下标为1的元素</span><br>System.out.println(arrayList);  <span class="hljs-comment">// [5]</span><br><br>arrayList.set(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>);<br>System.out.println(arrayList);  <span class="hljs-comment">// [10]</span><br></code></pre></td></tr></table></figure><h3 id="hashset">HashSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>set.add(<span class="hljs-number">1</span>);<br>set.add(<span class="hljs-number">1</span>);<br>set.add(<span class="hljs-number">3</span>);<br><br>System.out.println(set);<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">contains</span> <span class="hljs-operator">=</span> set.contains(<span class="hljs-number">3</span>);<br>System.out.println(contains);<br><br>set.remove(<span class="hljs-number">1</span>);<br>System.out.println(set);<br></code></pre></td></tr></table></figure><h3 id="priorityqueue">PriorityQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br><br><span class="hljs-comment">// 添加元素</span><br>queue.offer(<span class="hljs-number">3</span>);<br>queue.offer(<span class="hljs-number">1</span>);<br>queue.offer(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 删除元素</span><br>queue.poll();<br>System.out.println(queue);  <span class="hljs-comment">// [3,5]</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">peek</span> <span class="hljs-operator">=</span> queue.peek();<br>System.out.println(peek); <span class="hljs-comment">// 返回顶端元素</span><br></code></pre></td></tr></table></figure><h3 id="hashmap">HashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>map.put(<span class="hljs-string">&quot;陈&quot;</span>, <span class="hljs-number">21</span>);<br>map.put(<span class="hljs-string">&quot;刘&quot;</span>, <span class="hljs-number">18</span>);<br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">&quot;陈&quot;</span>);<br>System.out.println(i);  <span class="hljs-comment">// 21</span><br><br><span class="hljs-comment">// 修改元素</span><br>map.put(<span class="hljs-string">&quot;陈&quot;</span>, <span class="hljs-number">22</span>);<br>System.out.println(map.get(<span class="hljs-string">&quot;陈&quot;</span>));<br><br>map.remove(<span class="hljs-string">&quot;刘&quot;</span>);<br>System.out.println(map);<br></code></pre></td></tr></table></figure><h3 id="collections">Collections</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>arrayList.add(<span class="hljs-number">3</span>);<br>arrayList.add(<span class="hljs-number">1</span>);<br>arrayList.add(<span class="hljs-number">5</span>);<br><br>Collections.sort(arrayList);<span class="hljs-comment">// 排序</span><br>System.out.println(arrayList);<br><br>Collections.shuffle(arrayList);<span class="hljs-comment">// 打乱</span><br>System.out.println(arrayList);<br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Collections.max(arrayList);<span class="hljs-comment">// 获取最大值</span><br>System.out.println(max);<br></code></pre></td></tr></table></figure><h3 id="静态工厂">静态工厂</h3><p>https://chat.openai.com/share/f828a7ac-be8f-48e5-abee-63c659b6a088</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有化构造函数，防止外部通过new创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 公共的静态工厂方法，返回唯一实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>小知识</title>
    <link href="/2024/03/06/Algorithm/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/03/06/Algorithm/%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>记录常见的小知识点</p><span id="more"></span><h3 id="位运算相关操作">位运算相关操作</h3><ol type="1"><li><p>获取一个数的二进制表示中第k位</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">n&gt;&gt;k&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></p></li><li><p>获取一个数最后一位1</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">n&amp;-n<br></code></pre></td></tr></table></figure></p><p>给定一个长度为 n的数列，请你求出数列中每个数的二进制表示中 1的个数。</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> m;<br>        cin&gt;&gt;m;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(m&amp;-m)&#123;<br>            cnt ++;<br>            m -= (m &amp; -m);<br>        &#125;<br>        cout&lt;&lt;cnt&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java</title>
    <link href="/2023/07/25/SoftwareDevelopment/Java/"/>
    <url>/2023/07/25/SoftwareDevelopment/Java/</url>
    
    <content type="html"><![CDATA[<p>Java基础学习</p><span id="more"></span><h3 id="代码块">代码块</h3><ol type="1"><li>静态代码块:<ol type="1"><li><strong>格式</strong>：static { }</li><li><strong>特点</strong>：类加载时自动执行，由于类只会加载一次，所以静态代码块也只会执行一次。</li><li><strong>作用</strong>：完成类的初始化，例如：对类变量的初始化赋值。</li></ol></li><li>实例代码块<ol type="1"><li><strong>格式</strong>：{ }<br /></li><li><strong>特点</strong>：每次创建对象时，执行实例代码块，并在构造器前执行。</li><li><strong>作用：</strong>和构造器一样，都是用来完成对象的初始化的，例如：对实例变量进行初始化赋值。</li></ol></li></ol><h3 id="单例设计模式">单例设计模式</h3><ol type="1"><li>保证一个类只有一个对象，防止内存占用</li><li>定义方法：把类的构造器私有；定义一个类变量存储类的一个对象；提供一个类方法返回对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">//2. 类变量存储唯一类对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    <br>    <span class="hljs-comment">//1. 私有构造器使得在外部无法构造类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">//3. 定义一个类方法返回对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> A <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多态">多态</h3><ol type="1"><li><p>在函数传参时可以直接定义为父类并传入各个子类，但此时无法调用各个类特有的方法。</p><p>为了解决该问题，可以在传入后强转类型到子类类型再处理。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果p接收的是子类对象</span><br><span class="hljs-keyword">if</span>(父类变量 instance 子类)&#123;<br>    <span class="hljs-comment">//则可以将p转换为子类类型</span><br>    子类 变量名 = (子类)父类变量;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="final">final</h3><ol type="1"><li>用法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">- <span class="hljs-keyword">final</span>修饰类：该类称为最终类，特点是不能被继承<br>- <span class="hljs-keyword">final</span>修饰方法：该方法称之为最终方法，特点是不能被重写。<br>- <span class="hljs-keyword">final</span>修饰变量：该变量只能被赋值一次。<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>被 static final 修饰的成员变量，称之为常量。</li></ol><h3 id="object">Object</h3><ol type="1"><li><p>可以通过重写toString()和equals()来自定义打印的信息和比较的规则</p></li><li><p>如果想实现拷贝，需要实现Cloneble接口</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 在使用时以如下方式调用 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;wo666&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[]&#123;<span class="hljs-number">99.0</span>,<span class="hljs-number">99.5</span>&#125;);<br><span class="hljs-comment">//调用方法克隆得到一个新对象</span><br>   <span class="hljs-type">User</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> (User) u1.clone();<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="日期旧">日期（旧）</h3><ol type="1"><li><p>使用Date类获取当前时间 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>System.out.println(d);<br></code></pre></td></tr></table></figure></p></li><li><p>将日期格式化</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;</span>);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> sdf.format(d);<br><br><span class="hljs-type">Date</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> sdf.parse(rs)<br></code></pre></td></tr></table></figure></p></li><li><p>Calendar</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>now.get(Calendar.YEAR)<span class="hljs-comment">// 获取年份信息</span><br>now.getTime()<span class="hljs-comment">// 获取Date对象</span><br>now.set(Calendar.MONTH, <span class="hljs-number">9</span>);<span class="hljs-comment">// 修改日期</span><br><br><span class="hljs-comment">//为某个信息增加或者减少多少</span><br>now.add(Calendar.DAY_OF_YEAR, <span class="hljs-number">100</span>);<br>now.add(Calendar.DAY_OF_YEAR, -<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="日期jdk8">日期（JDK8）</h3><ol type="1"><li><p>LocalDate 年月日</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld</span> <span class="hljs-operator">=</span> LocalDate.now();<span class="hljs-comment">// 2023-07-25</span><br>ld.getMonth();<span class="hljs-comment">// JULY</span><br>ld.withMonth(<span class="hljs-number">12</span>);<span class="hljs-comment">// 修改月份</span><br>ld.plusYears(<span class="hljs-number">2</span>);<span class="hljs-comment">// 添加年份</span><br>ld.minusYears(<span class="hljs-number">2</span>);<span class="hljs-comment">// 减小年份</span><br><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld8</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2099</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>);<span class="hljs-comment">// 创建LocalDate</span><br><span class="hljs-comment">//判断2个日期对象，是否相等，在前还是在后： equals isBefore isAfter</span><br>System.out.println(ld8.equals(ld9));<span class="hljs-comment">// true</span><br>System.out.println(ld8.isAfter(ld)); <span class="hljs-comment">// true</span><br>System.out.println(ld8.isBefore(ld)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></p></li><li><p>LocalTime 时 分 秒 纳秒</p><p>内置函数同LocalDate</p></li><li><p>LocalDateTime 年 月 日 时 分 秒 纳秒</p></li><li><p>DateTimeFormatter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);<br><br>formatter.format(LocalDateTime.now());<span class="hljs-comment">// 转化</span><br>LocalDateTime.parse(dateStr, formatter);<span class="hljs-comment">// 解析</span><br></code></pre></td></tr></table></figure></li><li><p>Period &amp; Duration</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2029</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2029</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>);<br><br><span class="hljs-comment">// 1、创建Period对象，封装两个日期对象。</span><br><span class="hljs-type">Period</span> <span class="hljs-variable">period</span> <span class="hljs-operator">=</span> Period.between(start, end);<br><br><span class="hljs-comment">// 2、通过period对象获取两个日期对象相差的信息。</span><br>System.out.println(period.getYears());<br>System.out.println(period.getMonths());<br>System.out.println(period.getDays());<br><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2025</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2025</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>);<br><span class="hljs-comment">// 1、得到Duration对象</span><br><span class="hljs-type">Duration</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> Duration.between(start, end);<br><br><span class="hljs-comment">// 2、获取两个时间对象间隔的信息</span><br>System.out.println(duration.toDays());<span class="hljs-comment">// 间隔多少天</span><br>System.out.println(duration.toHours());<span class="hljs-comment">// 间隔多少小时</span><br>System.out.println(duration.toMinutes());<span class="hljs-comment">// 间隔多少分</span><br>System.out.println(duration.toSeconds());<span class="hljs-comment">// 间隔多少秒</span><br>System.out.println(duration.toMillis());<span class="hljs-comment">// 间隔多少毫秒</span><br>System.out.println(duration.toNanos());<span class="hljs-comment">// 间隔多少纳秒</span><br></code></pre></td></tr></table></figure></p></li></ol><h3 id="任意类数组排序">任意类数组排序</h3><ol type="1"><li><p>方法一</p><p>首先对于类，需要实现Compareable接口</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;<br></code></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student s)</span> &#123;<br>    <span class="hljs-keyword">return</span> s.getChinese() - <span class="hljs-built_in">this</span>.getChinese();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>随后在使用时如下所示</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(students)<br></code></pre></td></tr></table></figure></p></li><li><p>方法二</p><p>在调用时实现比较函数</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(students, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> Double.compare(o1.getHeight(), o2.getHeight()); <span class="hljs-comment">// 升序</span><br>        <span class="hljs-comment">// return Double.compare(o2.getHeight(), o1.getHeight()); // 降序</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></p><p>Lambda写法</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(students, (Student o1, Student o2) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> Double.compare(o1.getHeight(), o2.getHeight()); <span class="hljs-comment">// 升序</span><br>&#125;);<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="异常">异常</h3><ol type="1"><li><p>自定义异常</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeIllegalException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<span class="hljs-comment">// 继承Exception类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AgeIllegalException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AgeIllegalException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>抛出异常</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>    <span class="hljs-keyword">if</span>(age &gt; <span class="hljs-number">0</span> &amp;&amp; age &lt; <span class="hljs-number">150</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;年龄被成功保存： &quot;</span> + age);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 用一个异常对象封装这个问题</span><br>        <span class="hljs-comment">// throw 抛出去这个异常对象</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AgeIllegalRuntimeException</span>(<span class="hljs-string">&quot;/age is illegal, your age is &quot;</span> + age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>捕获异常</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    saveAge2(<span class="hljs-number">225</span>);<br>    System.out.println(<span class="hljs-string">&quot;saveAge2底层执行是成功的！&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (AgeIllegalException e) &#123;<br>    e.printStackTrace();<br>    System.out.println(<span class="hljs-string">&quot;saveAge2底层执行是出现bug的！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="properties属性文件">Properties属性文件</h3><ol type="1"><li><p>格式</p><ol type="1"><li>属性文件后缀以<code>.properties</code>结尾</li><li>属性文件里面的每一行都是一个键值对，键和值中间用=隔开。比如:<code>admin=123456</code></li><li><code>#</code>表示这样是注释信息，是用来解释这一行配置是什么意思。</li><li>每一行末尾不要习惯性加分号，以及空格等字符；不然会把分号，空格会当做值的一部分。</li><li>键不能重复，值可以重复</li></ol></li><li><p>读取/写入</p><ol type="1"><li><p>读取</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;path&quot;</span>));<br>properties.getProperty(<span class="hljs-string">&quot;a&quot;</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>写入</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.setProperty(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;minmin&quot;</span>);<br>properties.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;path&quot;</span>), <span class="hljs-string">&quot;i saved many users!&quot;</span>);<br></code></pre></td></tr></table></figure></p></li></ol></li></ol><h3 id="logback日志">Logback日志</h3><ol type="1"><li><p>导入库</p><ol type="1"><li><p>在资料中找到<code>slftj-api.jar、logback-core.jar、logback-classes.jar</code>这三个jar包，复制一下</p></li><li><p>在当前模块下面新建一个lib文件夹，把刚刚复制的三个jar包都粘贴到此处</p></li><li><p>右键lib文件夹，点击<code>Add as Library</code></p></li><li><p>从资料中找到<code>logback.xml</code>配置文件，将此文件复制粘贴到src目录下（必须是src目录）</p></li></ol></li><li><p>在代码中使用</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;LogTest&quot;</span>);<span class="hljs-comment">// 创建Logger对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            LOGGER.info(<span class="hljs-string">&quot;除法准备执行&quot;</span>);<br>            div(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>);<br>            LOGGER.info(<span class="hljs-string">&quot;除法正常执行&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            LOGGER.error(<span class="hljs-string">&quot;除法异常&quot;</span>);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        LOGGER.debug(<span class="hljs-string">&quot;参数a=&quot;</span>+a+<span class="hljs-string">&quot;;参数b=&quot;</span>+b+<span class="hljs-string">&quot;;&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a/b;<br>        System.out.println(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="多线程">多线程</h3><ol type="1"><li><p><strong>继承Thread类</strong></p><ol type="1"><li><p>创建线程类</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<span class="hljs-comment">// 继承Thread类</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 描述线程执行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>在程序中使用</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<span class="hljs-comment">// 实例化</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        t.start();<span class="hljs-comment">// 运行，调用run方法</span><br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol></li><li><p><strong>实现Runable接口</strong></p><ol type="1"><li><p>实现接口</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 描述线程执行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>使用</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>       <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol></li><li><p><strong>Runable接口其他实现</strong></p><ol type="1"><li><p>匿名内部类</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>               <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>                   System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>+i);<br>               &#125;<br>           &#125;<br>       &#125;;<br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>简化</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure></p></li><li><p>进一步简化</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>+i);<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure></p></li></ol></li><li><p><strong>实现Callable接口</strong></p><p><strong>好处</strong>：可以返回线程执行结果</p><ol type="1"><li><p>实现接口</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">this</span>.n;i++)&#123;<br>            sum += i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> String.valueOf(sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>使用</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;String&gt; call = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-number">100</span>);<span class="hljs-comment">// 创建Callable类</span><br>FutureTask&lt;String&gt; f1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);<span class="hljs-comment">// 创建FutureTask类</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(f1).start();<span class="hljs-comment">// 运行</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> f1.get();<span class="hljs-comment">// 获取执行结果</span><br><br>System.out.println(res);<br></code></pre></td></tr></table></figure></p></li></ol></li><li><p>常用API</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/1668051403591.png" style="zoom:50%;" /></p></li></ol><h3 id="同步问题">同步问题</h3><ol type="1"><li><p>同步代码块</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱&quot;</span> + money + <span class="hljs-string">&quot;成功！&quot;</span>);<br>        <span class="hljs-built_in">this</span>.money -= money;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱：余额不足~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><ol type="1"><li>建议把共享资源作为锁对象, 不要将随便无关的对象当做锁对象</li><li>对于实例方法，建议使用this作为锁对象</li><li>对于静态方法，建议把类的字节码(类名.class)当做锁对象</li></ol></li><li><p>同步方法</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<span class="hljs-comment">// 在声明时声明synchronized</span><br>    <span class="hljs-comment">// 先搞清楚是谁来取钱？</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>    <span class="hljs-comment">// 1、判断余额是否足够</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱&quot;</span> + money + <span class="hljs-string">&quot;成功！&quot;</span>);<br>        <span class="hljs-built_in">this</span>.money -= money;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱：余额不足~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>Lock自定义锁</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">// 创建锁</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-comment">// 先搞清楚是谁来取钱？</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        <span class="hljs-keyword">try</span> &#123;<br>            lk.lock(); <span class="hljs-comment">// 加锁</span><br>            <span class="hljs-comment">// 1、判断余额是否足够</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>                System.out.println(name + <span class="hljs-string">&quot;来取钱&quot;</span> + money + <span class="hljs-string">&quot;成功！&quot;</span>);<br>                <span class="hljs-built_in">this</span>.money -= money;<br>                System.out.println(name + <span class="hljs-string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                System.out.println(name + <span class="hljs-string">&quot;来取钱：余额不足~&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">// 在finally里解锁，防止出现异常无法解锁</span><br>            lk.unlock(); <span class="hljs-comment">// 解锁</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="线程池">线程池</h3><ul><li><p>临时线程什么时候创建？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">新任务提交时，发现核心线程都在忙、任务队列满了、并且还可以创建临时线程，此时会创建临时线程。<br></code></pre></td></tr></table></figure></li><li><p>什么时候开始拒绝新的任务？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">核心线程和临时线程都在忙、任务队列也满了、新任务过来时才会开始拒绝任务。<br></code></pre></td></tr></table></figure></li></ul><ol type="1"><li>创建线程池</li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230726180918.png" /></p><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">3</span>,<span class="hljs-comment">//核心线程数有3个</span><br>    <span class="hljs-number">5</span>,  <span class="hljs-comment">//最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2</span><br>    <span class="hljs-number">8</span>,<span class="hljs-comment">//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。</span><br>    TimeUnit.SECONDS,<span class="hljs-comment">//时间单位（秒）</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">4</span>), <span class="hljs-comment">//任务阻塞队列，没有来得及执行的任务在，任务队列中等待</span><br>    Executors.defaultThreadFactory(), <span class="hljs-comment">//用于创建线程的工厂对象</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="hljs-comment">//拒绝策略</span><br>);<br></code></pre></td></tr></table></figure></code></pre><ol start="2" type="1"><li>执行Runnable对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 任务是干啥的？</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ==&gt; 输出666~~&quot;</span>);<br>        <span class="hljs-comment">//为了模拟线程一直在执行，这里睡久一点</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(Integer.MAX_VALUE);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>pool.execute(target); <span class="hljs-comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span><br>pool.execute(target); <br>pool.execute(target); <br><br>pool.shutdown();<span class="hljs-comment">// 等待线程全部执行结束后关闭</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>执行Callable对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCallable</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br><br>    <span class="hljs-comment">// 2、重写call方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 描述线程的任务，返回线程执行返回后的结果。</span><br>        <span class="hljs-comment">// 需求：求1-n的和返回。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Thread.currentThread().getName() + <span class="hljs-string">&quot;求出了1-&quot;</span> + n + <span class="hljs-string">&quot;的和是：&quot;</span> + sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">3</span>,<br>            <span class="hljs-number">5</span>,<br>            <span class="hljs-number">8</span>,<br>            TimeUnit.SECONDS, <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">4</span>),<br>            Executors.defaultThreadFactory(),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br><br>        <span class="hljs-comment">// 2、使用线程处理Callable任务。</span><br>        Future&lt;String&gt; f1 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">100</span>));<br>        Future&lt;String&gt; f2 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">200</span>));<br>        Future&lt;String&gt; f3 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">300</span>));<br>        Future&lt;String&gt; f4 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">400</span>));<br><br>        <span class="hljs-comment">// 3、执行完Callable任务后，需要获取返回结果。</span><br>        System.out.println(f1.get());<br>        System.out.println(f2.get());<br>        System.out.println(f3.get());<br>        System.out.println(f4.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230726201654.png" /></p><h3 id="网络通信">网络通信</h3><ol type="1"><li><p>InetAddress</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InetAddress</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> InetAddress.getLocalHost();<br>System.out.println(ip.getHostAddress());<span class="hljs-comment">// 获取IP地址</span><br>System.out.println(ip.getHostName());<span class="hljs-comment">// 获取机器名4</span><br><br><span class="hljs-type">InetAddress</span> <span class="hljs-variable">ip2</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;www.baidu.com&quot;</span>);<span class="hljs-comment">// 根据url获取ip</span><br>System.out.println(ip2.isReachable(<span class="hljs-number">5000</span>));<span class="hljs-comment">// 判断是否可达</span><br></code></pre></td></tr></table></figure></p></li><li><p>UDP通信</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-string">&quot;test&quot;</span>.getBytes();<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf,buf.length, InetAddress.getLocalHost(),<span class="hljs-number">6666</span>);<br><br>        socket.send(packet);<br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">6666</span>);<br><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">24</span>];<br><br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf,buf.length);<br><br>        socket.receive(packet);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> packet.getLength();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span> , len);<br>        System.out.println(rs);<br>        socket.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>TCP多线程通信</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReaderThread</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(is);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> dis.readUTF();<br>                    System.out.println(msg);<br><br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;有人下线了：&quot;</span> + socket.getRemoteSocketAddress());<br>                    dis.close();<br>                    socket.close();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;-----服务端启动成功-------&quot;</span>);<br>        <span class="hljs-comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8888</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br><br>            System.out.println(<span class="hljs-string">&quot;有人上线了：&quot;</span> + socket.getRemoteSocketAddress());<br><br>            <span class="hljs-comment">// 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderThread</span>(socket).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="junit测试">junit测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringUtil</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNumber</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;名字长度：&quot;</span>+name.length());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringUtilTest</span>&#123;<br>    <span class="hljs-meta">@Test</span><span class="hljs-comment">// 必须加注解</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetMaxIndex</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> StringUtil.getMaxIndex(<span class="hljs-literal">null</span>);<br>       System.out.println(index1);<br>        <br>       <span class="hljs-type">int</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> StringUtil.getMaxIndex(<span class="hljs-string">&quot;admin&quot;</span>);<br>       System.out.println(index2);<br>        <br>        <span class="hljs-comment">//断言机制：预测index2的结果,用来判断逻辑是否有问题</span><br>        Assert.assertEquals(<span class="hljs-string">&quot;方法内部有Bug&quot;</span>,<span class="hljs-number">4</span>,index2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230727215753.png" /></p><p>假设我想在每个测试方法中使用Socket对象，并且用完之后，需要把Socket关闭，上述注解就会起作用</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SSM学习</title>
    <link href="/2023/07/23/SoftwareDevelopment/SSM%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/07/23/SoftwareDevelopment/SSM%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>黑马SSM学习 <span id="more"></span></p><h2 id="spring">Spring</h2><h3 id="iocinversion-of-control控制反转"><strong>IoC</strong>（Inversionof Control）控制反转：</h3><ol type="1"><li><p>使用对象时由主动new产生对象转化为由IoC提供对象,目的是进行解耦</p></li><li><p>IoC容器负责对象的创建、初始化等一系列工作，被创建的对象称为<strong>Bean</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;bookDao&quot;</span> class=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建Ioc对象</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><span class="hljs-comment">// 取出Bean</span><br><span class="hljs-type">BookDao</span> <span class="hljs-variable">bookDao</span> <span class="hljs-operator">=</span> (BookDao) ctx.getBean(<span class="hljs-string">&quot;bookDao&quot;</span>);<br><span class="hljs-comment">// 调用函数进行操作</span><br>bookDao.save();<br></code></pre></td></tr></table></figure><h3 id="didependency-injection依赖注入"><strong>DI</strong>(DependencyInjection)依赖注入</h3><ol type="1"><li>在容器中建立bean与bean之间的依赖关系的整个过程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在service层为IoC容器提供set方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBookDao</span><span class="hljs-params">(BookDao bookDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bookDao = bookDao;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;bookService&quot;</span> class=<span class="hljs-string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;<br>   &lt;!--配置server与dao的关系--&gt;<br>   &lt;!--property标签表示配置当前bean的属性<br>   name属性表示配置哪一个具体的属性<br>   ref属性表示参照哪一个bean--&gt;<br>   &lt;property name=<span class="hljs-string">&quot;bookDao&quot;</span> ref=<span class="hljs-string">&quot;bookDao&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>建立之后在Service中可以直接不使用new创建DAO对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> BookDao bookDao;<br></code></pre></td></tr></table></figure><h3 id="bean">Bean</h3><ol type="1"><li>默认单例，即多次创建指向的都是同一个对象，可以通过scope属性更改</li><li>可以使用无参构造方法创建，即对bean对应的class中写一个无参构造函数（或者别写有参构造函数，默认会有一个无参构造函数）</li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux服务器工具</title>
    <link href="/2023/07/13/SoftwareDevelopment/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E5%85%B7/"/>
    <url>/2023/07/13/SoftwareDevelopment/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>tmux、vim用法 <span id="more"></span></p><h2 id="tmux">tmux</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs stata">功能：<br>    (1) 分屏。<br>    (2) 允许断开Terminal连接后，继续运行进程。<br>结构：<br>    一个tmux可以包含多个session，一个session可以包含多个<span class="hljs-keyword">window</span>，一个<span class="hljs-keyword">window</span>可以包含多个pane。<br>    实例：<br>        tmux:<br>            session 0:<br>                <span class="hljs-keyword">window</span> 0:<br>                    pane 0<br>                    pane 1<br>                    pane 2<br>                    ...<br>                <span class="hljs-keyword">window</span> 1<br>                <span class="hljs-keyword">window</span> 2<br>                ...<br>            session 1<br>            session 2<br>            ...<br>操作：<br>    (1) tmux：新建一个session，其中包含一个<span class="hljs-keyword">window</span>，<span class="hljs-keyword">window</span>中包含一个pane，pane里打开了一个<span class="hljs-keyword">shell</span>对话框。<br>    (2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。<br>    (3) 按下Ctrl + a后手指松开，然后按<span class="hljs-string">&quot;（注意是双引号&quot;</span>）：将当前pane上下平分成两个pane。<br>    (4) Ctrl + <span class="hljs-keyword">d</span>：关闭当前pane；如果当前<span class="hljs-keyword">window</span>的所有pane均已关闭，则自动关闭<span class="hljs-keyword">window</span>；如果当前session的所有<span class="hljs-keyword">window</span>均已关闭，则自动关闭session。<br>    (5) 鼠标点击可以选pane。<br>    (6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。<br>    (7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。<br>    (8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。<br>    (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。<br>    (10) 按下ctrl + a后手指松开，然后按<span class="hljs-keyword">d</span>：挂起当前session。<br>    (11) tmux a：打开之前挂起的session。<br>    (12) 按下ctrl + a后手指松开，然后按s：选择其它session。<br>        方向键 —— 上：选择上一项 session/<span class="hljs-keyword">window</span>/pane<br>        方向键 —— 下：选择下一项 session/<span class="hljs-keyword">window</span>/pane<br>        方向键 —— 右：展开当前项 session/<span class="hljs-keyword">window</span><br>        方向键 —— 左：闭合当前项 session/<span class="hljs-keyword">window</span><br>    (13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的<span class="hljs-keyword">window</span>。<br>    (14) 按下Ctrl + a后手指松开，然后按w：选择其他<span class="hljs-keyword">window</span>，操作方法与(12)完全相同。<br>    (15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。<br>    (16) 鼠标滚轮：翻阅当前pane内的内容。<br>    (17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持<span class="hljs-keyword">Mac</span>，不过该操作并不是必须的，因此影响不大）<br>    (18) tmux中复制/粘贴文本的通用方式：<br>        (1) 按下Ctrl + a后松开手指，然后按[<br>        (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板<br>        (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处<br></code></pre></td></tr></table></figure><h2 id="vim">vim</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs bash">功能：<br> (1) 命令行模式下的文本编辑器。<br> (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。<br> (3) 使用方式：vim filename<br>     如果已有该文件，则打开它。<br>     如果没有该文件，则打开个一个新的文件，并命名为filename<br>模式：<br> (1) 一般命令模式<br>     默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。<br> (2) 编辑模式<br>     在一般命令模式里按下i，会进入编辑模式。<br>     按下ESC会退出编辑模式，返回到一般命令模式。<br> (3) 命令行模式<br>     在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。<br>     可以查找、替换、保存、退出、配置编辑器等。<br>操作：<br> (1) i：进入编辑模式<br> (2) ESC：进入一般命令模式<br> (3) h 或 左箭头键：光标向左移动一个字符<br> (4) j 或 向下箭头：光标向下移动一个字符<br> (5) k 或 向上箭头：光标向上移动一个字符<br> (6) l 或 向右箭头：光标向右移动一个字符<br> (7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符<br> (8) 0 或 功能键[Home]：光标移动到本行开头<br> (9) $ 或 功能键[End]：光标移动到本行末尾<br> (10) G：光标移动到最后一行<br> (11) :n 或 nG：n为数字，光标移动到第n行<br> (12) gg：光标移动到第一行，相当于1G<br> (13) n&lt;Enter&gt;：n为数字，光标向下移动n行<br> (14) /word：向光标之下寻找第一个值为word的字符串。<br> (15) ?word：向光标之上寻找第一个值为word的字符串。<br> (16) n：重复前一个查找操作<br> (17) N：反向重复前一个查找操作<br> (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2<br> (19) :1,<span class="hljs-variable">$s</span>/word1/word2/g：将全文的word1替换为word2<br> (20) :1,<span class="hljs-variable">$s</span>/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。<br> (21) v：选中文本<br> (22) d：删除选中的文本<br> (23) <span class="hljs-built_in">dd</span>: 删除当前行<br> (24) y：复制选中的文本<br> (25) yy: 复制当前行<br> (26) p: 将复制的数据在光标的下一行/下一个位置粘贴<br> (27) u：撤销<br> (28) Ctrl + r：取消撤销<br> (29) 大于号 &gt;：将选中的文本整体向右缩进一次<br> (30) 小于号 &lt;：将选中的文本整体向左缩进一次<br> (31) :w 保存<br> (32) :w! 强制保存<br> (33) :q 退出<br> (34) :q! 强制退出<br> (35) :wq 保存并退出<br> (36) :<span class="hljs-built_in">set</span> <span class="hljs-built_in">paste</span> 设置成粘贴模式，取消代码自动缩进<br> (37) :<span class="hljs-built_in">set</span> nopaste 取消粘贴模式，开启代码自动缩进<br> (38) :<span class="hljs-built_in">set</span> nu 显示行号<br> (39) :<span class="hljs-built_in">set</span> nonu 隐藏行号<br> (40) gg=G：将全文代码格式化<br> (41) :noh 关闭查找关键词高亮<br> (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令<br>异常处理：<br> 每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。<br> 如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：<br>     (1) 找到正在打开该文件的程序，并退出<br>     (2) 直接删掉该swp文件即可<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>夏令营面试</title>
    <link href="/2023/06/24/School/%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%9D%A2%E8%AF%95/"/>
    <url>/2023/06/24/School/%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>夏令营面试 <span id="more"></span></p><h2 id="高数">高数</h2><ol type="1"><li><p><strong>函数</strong></p><p>对于一个给定的数集D，对于每个值x属于D，按照一定的法则f，有一个确定的值y与之对应，则称y为x的函数</p></li><li><p><strong>极限</strong></p><p>若函数f(x)在点<spanclass="math inline">\(x_0\)</span>的去心邻域中有定义，若存在常数A，对于任意给定的<spanclass="math inline">\(\varepsilon &gt;0\)</span>,总存在正数<spanclass="math inline">\(\sigma\)</span>,使得当<spanclass="math inline">\(0&lt;|x-x_0|&lt;\sigma\)</span>时，对应的函数值</p><p>f(x)都满足不等式<spanclass="math inline">\(|f(x)-A|&lt;\varepsilon\)</span>，则A称为f(x)当x-&gt;x0的极限</p></li><li><p><strong>拐点</strong></p><p>连续曲线的凹弧与凸弧的分界点称为该曲线的拐点</p><p>二阶导为0三阶导不为0</p></li><li><p><strong>罗尔定理</strong></p><p>f(x)满足在[a,b]上连续，在(a,b)可导，f(a)=f(b),则存在一点c，使得f'(c)=0</p></li><li><p><strong>拉格朗日中值定理</strong></p><p>f(x)满足在[a,b]上连续，在(a,b)可导，则有<spanclass="math inline">\(f(b)-f(a)=f&#39;(c)(b-a)\)</span></p></li><li><p><strong>柯西中值定理</strong></p><p>f(x),g(x)满足在[a,b]连续，(a,b)可导，则存在一点c属于(a,b),有<spanclass="math inline">\(\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f&#39;(c)}{g&#39;(c)}\)</span></p></li><li><p><strong>二元函数极限</strong></p><p>f(x,y)在(x0,y0)的去心领域内有定义，且(x,y)以任意方式趋向于(x0,y0)时，f(x,y)均趋向于A</p></li><li><p><strong>一元函数可微条件</strong></p><p>可导必可微，可微必可导</p><p>可导条件：函数在该点的 去心邻域 内有定义；左右导数存在且相同</p></li><li><p><strong>二元函数可微条件</strong></p><p>全增量减去线性增量比上根号下derta x的平方加dertay的平方的极限值若趋于0则可微</p></li><li><p><strong>方向导数</strong></p><p>在函数定义域内的点，对某一方向求导得到的导数</p><p><span class="math inline">\(\frac{\partial f}{\partiall}=\mathrm{grad}f\cdot\frac{\overline{l}}{\left|\overline{l}\right|}\)</span></p></li><li><p><strong>梯度</strong></p><p><span class="math inline">\(\text{grad}f=(\frac{\partial f}{\partialx},\frac{\partial f}{\partial y})\)</span></p></li><li><p><strong>散度</strong></p><p><span class="math inline">\(\operatorname{div}F:=\nabla\cdotF={\frac{\partial F_{x}}{\partial x}}+{\frac{\partial F_{y}}{\partialy}}+{\frac{\partial F_{z}}{\partial z}}\)</span></p></li></ol><h2 id="线代">线代</h2><ol type="1"><li><p><strong>线性相关</strong></p><p>对m个n维向量<spanclass="math inline">\(\alpha_1、\alpha_2,...,\alpha_m\)</span>，若存在一组不全为0的数<spanclass="math inline">\(k_1,k_2,...,k_m\)</span>，使得<spanclass="math inline">\(k_1\alpha_1+k_2\alpha_2+...+k_m\alpha_m=0\)</span>则称该向量组线性相关</p></li><li><p><strong>矩阵的秩</strong></p><p>矩阵的最高阶非零子式的阶数</p><p>矩阵A中有一个r阶子式Dr!=0且所有r+1阶子式值全等于0</p></li><li><p><strong>向量组的秩</strong></p><p>向量组的极大线性无关组中所含向量的个数r称为向量组的秩</p></li><li><p><strong>特征向量</strong></p><p>设A是n阶矩阵，<spanclass="math inline">\(\lambda\)</span>是一个数，若存在n维非零列向量x使得<spanclass="math inline">\(Ax=\lambda x\)</span>,则称<spanclass="math inline">\(\lambda\)</span>是A的特征值，x是A的对应于特征值<spanclass="math inline">\(\lambda\)</span>的特征向量</p></li><li><p><strong>矩阵的相似</strong></p><p>AB是两个n阶方阵，若存在P，使得<spanclass="math inline">\(P^{-1}AP=B\)</span>,则称A相似于B</p><p>相似的矩阵是同一个线性变换在不同基/坐标系下的的不同描述</p><p><span class="math inline">\(Bx =P^{-1}APx\)</span>,即先对x使用P变换到新的坐标系，然后使用A进行线性变换，然后再使用<spanclass="math inline">\(P^{-1}\)</span>回到当前坐标系</p></li><li><p><strong>矩阵的相似对角化</strong></p><p>对于A若有<spanclass="math inline">\(P^{-1}AP=B\)</span>,其中B是对角矩阵，则称A可相似对角化</p><p>A可以相似对角化的充要条件为A有n个线性无关的特征向量</p><p><strong>只有实对称矩阵能正交相似对角化</strong></p></li><li><p>实对称矩阵<strong>A</strong>的不同<ahref="https://baike.baidu.com/item/特征值/11034909?fromModule=lemma_inlink">特征值</a>对应的<ahref="https://baike.baidu.com/item/特征向量/8663983?fromModule=lemma_inlink">特征向量</a>是正交的。</p></li><li><p><strong>特征值对应的特征向量就是理想中想取得正确的坐标轴，而特征值就等于数据在旋转之后的坐标上对应维度上的方差。</strong></p></li><li><p><strong>正定矩阵</strong></p><p>若对于任意的x，均有<spanclass="math inline">\(x^TAx&gt;0\)</span>,则称A为正定矩阵</p><p>特征值都大于0</p></li><li><p><strong>向量范数</strong></p><ol type="1"><li>1-范数 ：<spanclass="math inline">\(||x||_1=\sum_{i=1}^m|x_i|\)</span>，向量元素绝对值之和</li><li>2-范数：<span class="math inline">\(||x||_1=\sqrt{\sum_{i=1}^mx_i^2}\)</span>，向量元素平方和开方</li><li>p-范数：<spanclass="math inline">\(||x||_p=(\sum_{i=1}^m|x_i|^p)^{\frac{1}{p}}\)</span>，到0点的闵可夫斯基距离</li><li><span class="math inline">\(\infty\)</span>-范数： <spanclass="math inline">\(||x||_{\infty}=\max\limits_{i}|x_i|\)</span></li></ol></li><li><p><strong>矩阵范数</strong></p><ol type="1"><li>1-范数：<spanclass="math inline">\(||A||_1=\max\limits_{j}\sum_{i=1}^m|a_{i,j}|\)</span>，列和范数，所有矩阵列向量绝对值之和的最大值</li><li>2-范数：<spanclass="math inline">\(||A||_2=\sqrt{\lambda_1}\)</span>, <spanclass="math inline">\(\lambda_1\)</span>表示<spanclass="math inline">\(A^TA\)</span>的最大特征数，称为谱范数</li><li><span class="math inline">\(\infty\)</span>-范数：<spanclass="math inline">\(||A||_{\infty}=\max\limits_{j}\sum\limits_{j=1}^{m}|a_{i,j}|\)</span>,行和范数，即所有矩阵行向量绝对值之和的最大值</li><li>F-范数：<spanclass="math inline">\(||A||_F=(\sum_{i=1}^m\sum_{j=1}^na_{i,j}^2)^{\frac{1}{2}}\)</span>,矩阵元素绝对值平方和再开方</li></ol></li><li><p><strong>线性方程组解的情况</strong></p><ol type="1"><li>无解：系数矩阵秩&lt;增广矩阵的秩</li><li>唯一解：系数矩阵的秩=增广矩阵的秩=列数n</li><li>无穷解：系数矩阵的秩=增广矩阵的秩&lt;列数n</li></ol></li><li><p><strong>合同矩阵</strong></p><p>若存在可逆矩阵C，使得<spanclass="math inline">\(C^TAC=B\)</span>则称矩阵A与B合同</p></li><li><p><strong>正交矩阵</strong></p><p>满足<span class="math inline">\(A^T=A^{-1}\)</span>的矩阵</p><p>行向量均正交的矩阵</p></li></ol><h2 id="概率论">概率论</h2><ol type="1"><li><p><strong>古典概型</strong></p><p>样本空间只有有限个样本点且每个样本点发生的可能性都一样</p></li><li><p><strong>几何概型</strong></p><p>样本空间是可度量的有界区域，每个样本点发生的可能性都相同</p></li><li><p><strong>条件概率</strong></p><p>在已知A发生的条件下，事件B发生的概率为条件概率，有<spanclass="math inline">\(P(B|A)=\frac{P(AB)}{P(A)}\)</span></p></li><li><p><strong>全概率公式</strong></p><p>把<span class="math inline">\(B_i\)</span>看作是事件<spanclass="math inline">\(A\)</span>发生的一种“可能途径”，<spanclass="math inline">\(P ( A ∣ B 1 )\)</span> 则是通过这种途径得到<spanclass="math inline">\(A\)</span>的可能性，而途径的选择是随机的，因此可以把<spanclass="math inline">\(P(A)\)</span>看作不同途径概率的和。</p><p><span class="math inline">\(P(A) =\sum_{i=1}^nP(B_i)P(A/B_i)\)</span></p></li><li><p><strong>贝叶斯公式</strong></p><p><spanclass="math inline">\(P(A_j|B)=\frac{P(A_j)P(B|A_j)}{\sum_{i-1}^{n}P(A_i)P(B|A_i)}\)</span></p><p>以手写数字识别为例：识别目标<spanclass="math inline">\(P(A_j|B)\)</span>代表在给定的图片(B)的基础上，是0/1/.../9的的概率，取其中的最大值作为预测结果即可</p><p>先验概率<spanclass="math inline">\(P(A_j)\)</span>即为每个数字的样本数量占比；类条件概率<spanclass="math inline">\(P(B|A_j)\)</span>为对于数字为j的所有样本，第1,2,...,28*28个特征中颜色为白色的概率相乘的值。</p><p>分母是事件B发生的全概率</p></li><li><p>常见的随机变量分布类型</p><ol type="1"><li><p><strong>0-1分布</strong>：<spanclass="math inline">\(P\{x=1\}=p,P\{x=0\}=1-p\)</span></p></li><li><p><strong>伯努利分布</strong>：n次0-1分布</p></li><li><p><strong>二项分布</strong>：<spanclass="math inline">\(P\{X=k\}=C_n^kp^k(1-p)^{n-k}\)</span>，在只有两个结果的n次独立伯努利实验中，所期望的结果出现次数的概率</p></li><li><p><strong>泊松分布</strong>：<spanclass="math inline">\(P\{X=k\}=\frac{\lambda^k}{k!}e^{-\lambda}\)</span>,称X服从参数为<spanclass="math inline">\(\lambda\)</span>的泊松分布</p><p>为了预测在固定时间间隔内发生<strong>指定数量</strong>事件的概率,常用于对小概率事件进行建模</p><p>例子：1.已知某家小杂货店，平均每周售出2个水果罐头。请问该店水果罐头的最佳库存量是多少2. 一个月内某条路上出现车祸的概率</p><p><ahref="https://zhuanlan.zhihu.com/p/146951852">如何深刻理解二项式分布到泊松分布？- 知乎 (zhihu.com)</a></p><p>参数 λ是单位时间(或单位面积)内随机事件的<strong>平均发生次数</strong>，满足线性相加（2倍单位时间内…服从 2λ分布）。</p></li><li><p><strong>几何分布</strong>：<spanclass="math inline">\(P\{X=k\}=(1-p)^{k-1}p\)</span>,即前k-1次都失败，第k次成功了</p></li><li><p><strong>超几何分布</strong>：<spanclass="math inline">\(P(X=k)=\frac{C_m^k\timesC_{N-m}^{n-k}}{C_N^n}\)</span></p><p>假设有限总体包含N个样本，其中质量合格的为m个，则剩余的N-m个为不合格样本，如果从该有限总体中抽取出n个样本，其中有k个是质量合格的概率</p></li><li><p><strong>均匀分布</strong>：U(a,b)：在一个区间内为定值，除了这个区间都是0</p></li><li><p><strong>指数分布</strong>：<spanclass="math inline">\(E(\lambda)=\lambda e^{-\lambdax},x&gt;0\)</span></p></li><li><p><strong>正态分布</strong>：<spanclass="math inline">\(f(x)=\frac{1}{\sqrt{2\pi}\sigma}\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)\)</span></p></li></ol></li><li><p><strong>边缘分布</strong>：多维随机变量中只包含其中部分变量的概率分布。如对(X,Y)分布只研究X的分布。</p></li><li><p><strong>期望</strong></p><p>对于离散型随机变量，若级数<spanclass="math inline">\(\sum^{\infty}_{i=1}x_ip_i\)</span>绝对收敛，则期望即为该值</p><p>对于连续型随机变量，若对xf(x)dx在负无穷到正无穷的积分绝对收敛，则数学期望为该值</p><p>数学期望称为概率平均值，是描述随机变量平均取值状况特征的指标</p></li><li><p><strong>方差</strong></p><p><spanclass="math inline">\(DX=E[(X-EX)^2]=E(X^2)-(EX)^2\)</span></p></li><li><p><strong>切比雪夫不等式</strong></p><p><span class="math inline">\(P(|X-\mu|\geqk)\leq\frac{\sigma^2}{k^2}或P(|X-\mu|&lt;k)\geq1-\frac{\sigma^2}{k^2}\)</span></p><p>方差越小，X的值越接近均值，说明方差是<strong>刻画随机变量与其期望值偏离程度的指标</strong></p></li><li><p><strong>协方差</strong></p><p>随机变量XY的协方差<spanclass="math inline">\(Cov(X,Y)=E[(X-EX)(Y-EY)]=E(XY)-EXEY\)</span></p><p>用于衡量两个变量的相关性</p></li><li><p><strong>皮尔逊相关系数</strong></p><p><spanclass="math inline">\(\frac{Cov(X,Y)}{\sqrt{DX}\sqrt{DY}}\)</span>,若值为0则不相关</p></li><li><p><strong>大数定理</strong></p><ol type="1"><li><p>当样本量足够大时，能用频率近似代替概率；能用样本均值近似代替总体均值。</p></li><li><p><strong>伯努利大数定理</strong>：</p><p>从定义概率的角度，<strong>揭示了概率与频率的关系</strong>，当N很大的时候，事件A发生的概率等于A发生的频率。</p><p><spanclass="math inline">\(\lim\limits_{n\to\infty}P\left\{\left|\frac{f_A}{n}-p\right|&lt;\epsilon\right\}=1\)</span></p></li><li><p><strong>切比雪夫大数定理</strong></p><p><strong>揭示了样本均值和真实期望的关系</strong></p><p><spanclass="math inline">\(\lim\limits_{n\to+\infty}P\left\{\left|\frac{1}{n}\sum_{i=1}^{n}X_i-\frac{1}{n}\sum_{i=1}^{n}\mu_i\right|&lt;\xi\right\}=1\)</span></p></li><li><p>辛钦大数定律</p><p><strong>揭示了算术平均值和数学期望的关系</strong></p><p><spanclass="math inline">\(\lim\limits_{n\to\infty}P\left\{\left|\frac{1}{n}\sum_{i=1}^{n}X_i-\frac{1}{n}\sum_{i=1}^{n}E\left(X_{\mathbb{i}}\right)\right|\leq\varepsilon\right\}=1\)</span></p></li></ol></li><li><p><strong>中心极限定理</strong></p><p>对于一系列独立同分布的离散随机变量来说，当样本量足够大时，样本均值的分布呈现正态分布</p><p>要求一系列离散随机变量独立同分布且存在均值方差</p><p>样本数量无穷大的时候，<strong>样本均值的分布</strong>呈现<strong>正态分布</strong>，其对原总体的分布不做任何要求，意味着无论总体是什么分布，其抽样样本的均值的频数的分布都随着抽样数的增多而趋于正态分布。</p></li><li><p><strong>事件的独立性</strong></p><p>某一事件发生的概率完全不受到其他事件的影响。 用公式表示就是<spanclass="math inline">\(P(A,B)=P(A)*P(B)\)</span></p></li><li><p><strong>马尔科夫链</strong></p><p>马尔可夫链描述的是随机变量的一个状态序列，在这个状态序列里未来信息只与当前信息有关，而与过去的信息无关。它有两个很重要的假设：</p><ol type="1"><li>t+1时刻的状态的概率分布只与t时刻有关</li><li>t到t+1时刻状态转移与t值无关</li></ol></li></ol><p><a href="https://www.zhihu.com/question/36214010">(90 封私信 / 68条消息) 二项分布、泊松分布和正态分布的区别及联系? - 知乎(zhihu.com)</a></p><h2 id="离散数学">离散数学</h2><ol type="1"><li><p>幂集</p><p>集合的全体子集</p></li><li><p>笛卡尔乘积</p><p>用两个集合AB中的元素组成有序对，以A的元素作为第一个分量，B的元素作为第二个分量。这些有序对的集合称为A和B的笛卡尔乘积</p></li><li><p>单射：任给x1,x2属于X,若x1!=x2,则f(x1)!=f(x2)</p></li><li><p>满射：任给y属于Y，存在x属于X使得f(x)=y</p></li><li><p>双射：同时满足单射和满射</p></li><li><p>自反：对任意x，有R(x,x)</p></li><li><p>反自反：对任意x，没有R(x,x)</p></li><li><p>对称：有R(x,y)则有R(y,x)</p></li><li><p>反对称：有R(x,y)则没有R(y,x)</p></li><li><p>传递：有R(x,y)和R(y,z)则有R(x,z)</p></li><li><p>相容关系: R是自反、对称的</p></li><li><p>等价关系：R是自反、对称、传递的</p><ol type="1"><li><p>等价类：对于所有属于集合A的元素x,<spanclass="math inline">\([x]_R\)</span>为所有满足xRy的y元素集合</p></li><li><p><strong>商集</strong>：设 R 是集合 A 上的等价关系，由 R确定的<strong>所有等价类</strong>组成的集合，称为集合 A 上关于 R的商集，记为 <strong>A/R，是集合 A 的一个划分。</strong></p></li></ol></li><li><p>偏序关系：R是自反、反对称、传递的</p></li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230626185200.png" /></p><ol type="1"><li><p>最大元：在都可比的情况下最大的，有可能有好几个极大元没有最大元</p></li><li><p>最小元：在都可比的情况下最小的</p></li><li><p>极大元：在可比的那条链中最大的</p></li><li><p>极小元：在可比的那条链中最小的</p></li><li><p>上界：两个集合AB,B包含于A，对于任意的B中的x，有A中的y，x&lt;=y,则y为B的上界</p></li><li><p>下界：两个集合AB,B包含于A，对于任意的B中的x，有A中的y，y&lt;=x,则y为B的下界</p></li><li><p>上确界：上界中最小的</p></li><li><p>下确界：下届中最小的</p></li><li><p>逆序关系：R是反自反、反对称、传递的</p></li><li><p>哈密顿图：能走出一条通过<strong>每个节点</strong>仅一次的回路</p></li><li><p>欧拉图：能走出一条通过<strong>每条边</strong>仅一次的回路</p></li><li><p>任意命题公式都可由仅含有 <span class="math inline">\(\{\lnot,\lor\}\)</span>或<span class="math inline">\(\{\lnot, \land\}\)</span>的命题公式来等价表示,这两个集合就是完备集</p></li><li><p>自反闭包：R 的<strong>自反闭包</strong> r（R）是包含 R的最小的、自反的关系集合</p></li><li><p>代数系统</p><ol type="1"><li>&lt;S,*&gt;,代表非空集合和运算</li><li>幺元e:对任意x属于S，e*x=x则为左幺元，x*e=x则为右幺元</li><li>零元0：对任意x属于S，0*x = 0则为左零元</li><li>逆元<span class="math inline">\(x^{-1}\)</span>：对x属于S，<spanclass="math inline">\(x^{-1}*x=e\)</span>则为左逆元</li><li>广群：S非空，*运算封闭</li><li>半群：S非空，*运算封闭可结合</li><li>群：S非空，*封闭可结合存在幺元，每个元素均存在s逆元</li><li>有限群：S为有限集的群</li><li>阿贝尔群：S非空，*运算可以交换的群</li><li>循环群：阿贝尔群，其内任意元素均可由a的幂组成，a称为生成元</li></ol></li></ol><h2 id="数据结构">数据结构</h2><h3 id="参数传递的方式">参数传递的方式</h3><ol type="1"><li>值传递：生成一个临时变量作为形参传递给函数</li><li>指针传递：直接把地址传过去</li><li>引用传递：在栈中开辟一个空间，空间里面存的是地址，对引用的操作都是间接寻址的过程</li></ol><h3 id="p问题np问题np完全问题">P问题、NP问题、NP完全问题</h3><ol type="1"><li>P问题：存在多项式时间算法的问题</li><li>NP问题：能在多项式时间内验证得出一个正确解的问题，也就是不好求解，但是能验证一个答案是否正确</li><li>NP完全问题：所有的NP问题都可以规约到他，只要解决了这个问题，所有的NP问题都能得到解决，他本身也是个NP问题</li><li>NP难问题：所有的NP问题都能约化到它，但是它不一定是一个NP问题。</li></ol><h3 id="稳定性">稳定性</h3><p>如果两个具有相同键的对象以相同的顺序出现在排序输出中，则排序算法是<strong>稳定的</strong>。</p><p>稳定性的好处：<strong>排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。</strong>基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。</p><p>稳定的排序算法：<strong>冒泡排序、插入排序、归并排序和基数排序</strong></p><p>不是稳定的排序算法：<strong>选择排序、快速排序、希尔排序、堆排序</strong></p><h3 id="改进冒泡排序">改进冒泡排序</h3><p>设置一标志性变量pos，用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位，故在进行下一趟排序时只要扫描到pos位置即可。</p><h3 id="改进快排">改进快排</h3><p>只对长度大于 k kk的子序列递归调用快速排序，让原序列基本有序，然后再对整个基本有序序列用插入排序算法排序</p><h3 id="判断图中是否有环">判断图中是否有环</h3><ol type="1"><li>拓扑排序</li><li>深搜出现重复结点</li></ol><h3 id="g数据1g内存如何排序">10G数据，1G内存如何排序</h3><p><strong>分别排序</strong>：根据内存1G，数据10G，我们将10G数据切分成10份，通过内存调用磁盘的方式，每1G进行排序，排序结束后，我们会得到10个有序的数据数组。<strong>归并</strong>：多路归并过程可以使用最小堆。内存中开辟一个大小为10的最小堆，和一个缓冲区（小于1G，不要太小）。取10份排序好的数据的首位进入最小堆。则最小的数位于堆顶，移除堆顶元素并写入缓冲区，然后从移除元素的元素所属数组中的下一位进入最小堆，在次移除堆顶进入缓冲区...直到缓冲区满，缓冲区回写磁盘，清空缓冲区，再次将数据置入最小堆...直到10份数据全部写完，然后将最小堆的元素按顺序回写磁盘即可。</p><h3 id="堆栈区别">堆栈区别</h3><ol type="1"><li>栈：存放函数的参数值、局部变量，由编译器自动分配释放。</li><li>堆 ：是由 new 分配的内存块，由应用程序控制，需要程序员手动利用delete 释放，如果没有，程序结束后，操作系统自动回收。</li></ol><h3 id="数组名数组首地址">数组名、数组首地址</h3><ol type="1"><li>&amp;array是整个数组的首地址，array是数组首元素的首地址</li><li>&amp;array加一之后移动一整个数组，array加一后移动一个数组元素</li></ol><h3 id="内存的分配方式">内存的分配方式</h3><ol type="1"><li>从静态存储区域分配，如全局变量</li><li>在栈上创建，函数内局部变量的存储单元都在栈上创建</li><li>从堆上分配，动态内存分配</li></ol><h3id="函数名函数指针函数的入口地址">函数名，函数指针，函数的入口地址</h3><ol type="1"><li>函数名：一个指向其函数入口指针常量</li><li>函数指针：向函数的指针变量</li><li>函数入口地址：</li></ol><h2 id="计组">计组</h2><h3 id="为什么要设计多级缓存">为什么要设计多级缓存</h3><ol type="1"><li>L1 Cache用的晶体管比较多，同样的制程都给L1会导</li><li>Cache容量上升后期对命中率的提升并不明显，边际效用递减</li><li>L1如果太大，始终频率就做不了太大，影响处理器处理速度</li></ol><h3 id="单周期和多周期cpu的区别">单周期和多周期CPU的区别</h3><p>一个程序的不同指令所需要的执行时间是不同的，所以如果按照单周期处理的话，无论什么指令我都按照最长的那条指令去处理，对CPU资源是有浪费的</p><h3 id="自旋锁和互斥锁">自旋锁和互斥锁</h3><ol type="1"><li>互斥锁加锁失败后，线程释放CPU,给其他线程</li><li>自旋锁加锁失败后，线程会忙等待，知道拿到锁</li><li>看起来自旋锁效率低，但是互斥锁会在加锁失败后让线程进入睡眠状态，资源释放后会唤醒该进程，这就导致了两次的上下文切换，如果程序较短效率就会比较低</li></ol><h2 id="计网">计网</h2><p><ahref="https://blog.csdn.net/weixin_42369760/article/details/100008786">(135条消息)网络中主机通信过程_网络中的主机通信流程_Cold_Johnsnow的博客-CSDN博客</a></p><h3 id="数据链路层流量控制的方式">数据链路层流量控制的方式</h3><ol type="1"><li><p><strong>停止-等待</strong></p><p>发送方每发一帧，都要等待接收方回应，如果没收到就一直等待</p></li><li><p><strong>滑动窗口</strong></p><p>发送方维持一组连续的允许发送的帧的序号，称为发送窗口：同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。发送窗口用来对发送方进行流量控制，发送窗口的大小W代表在还未收到对方确认信息的情况下发送方最多还可以发送多少个数据帧。同理，在接收端设置接收窗口是为了控制可以接收哪些数据帧和不可以接收哪些帧。在接收方，只有收到的数据帧的序号落入接收窗口内时，才允许将该数据帧收下。若接收到的数据帧落在接收窗口之外，则一律将其丢弃。</p></li><li><p><strong>后退N帧</strong></p><p>发送方可以连续发送帧，当接收方检测出失序的信息帧或者发送方之前发送的某个帧超时后，发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧，接收方只允许按顺序接收帧</p></li><li><p><strong>选择重传.</strong></p><p>先收下发送序号不连续但是在接收窗口的那些数据帧，等待所缺序号的数据帧收到后再一并交给主机</p></li></ol><h3 id="交换机能替代路由器吗">交换机能替代路由器吗</h3><ol type="1"><li>同构网络可以</li></ol><h2 id="操作系统">操作系统</h2><h3 id="进程和线程">进程和线程</h3><ol type="1"><li>进程是资源分配的基本单位，线程是调度的基本单位</li><li>在操作系统的发展过程中，为了提高CPU利用率提出了多道程序的并发执行，并发执行就涉及到了程序之间的切换，当一个程序去做IO了，我得能找到一个对象让他来执行，为了表示这个对象就提出了进程。但是进程的在上下文切换时的代价较大，为了进一步提高并行性，提出线程的概念。一个进程可以创建多个线程，线程只保留一些必要的堆栈，共享进程的内存空间。</li></ol><h2 id="编译原理">编译原理</h2><h3 id="程序的编译执行过程">程序的编译执行过程</h3><ol type="1"><li>预处理：处理头文件、宏定义、条件编译指令</li><li>编译：词法分析、语法分析、语义分析、中间代码生成、目标代码生成、目标代码优化</li><li>汇编：将编译产生的源码转化为object file</li><li>链接：将一些object file链接成一个可执行文件</li></ol><h3 id="文法句型句子语言">文法、句型、句子、语言</h3><ol type="1"><li>文法：文法是一个四元组(<spanclass="math inline">\(V_N,V_T,P,S\)</span>)，分别代表非终结符集、终结符集、产生式集合、开始符号</li><li>句型：由开始符号推导出的符号串</li><li>句子：只由终结符组成的句型</li><li>语言：所有句子的集合</li><li>等价文法：文法的语言相同</li></ol><h3 id="文法的四种类型">文法的四种类型</h3><ol type="1"><li>0型文法：所有文法</li><li>1型文法(上下文有关文法)：对于所有a-&gt;b,均有|b|&gt;=|a|</li><li>2型文法(上下文无关文法)：|b|&gt;=|a|且a为非终结符</li><li>3型文法(正规文法)：对任意a-&gt;b,都有A-&gt;w或A-&gt;wB</li></ol><h3 id="ll1文法">LL(1)文法</h3><ol type="1"><li>对于A的所有产生式，FIRST子集不能有交集</li><li>如果A能推出空，则所有非空产生式的FIRST子集和FOLLOW(A)不能有交集</li><li>消除左递归、提取左因子</li></ol><h2 id="数据库">数据库</h2><h3 id="范式">范式</h3><ol type="1"><li><strong>第一范式</strong>：所有属性不可再分，强调表的原子性</li><li><strong>第二范式</strong>：若某关系R属于第一范式，且每一个非主属性完全函数依赖于任何一个候选码，则关系R属于第二范式。<ol type="1"><li><strong>候选码</strong>：能唯一标识元组的属性或属性组</li><li><strong>主属性</strong>：所有候选码的属性称为主属性</li><li><strong>函数依赖</strong>：设R(U)是属性集U上的关系模式，X、Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称Y函数依赖于X或X函数确定Y。</li><li><strong>完全函数依赖</strong>：如果Y函数依赖于X，且对于X的任何一个真子集X’，都有Y不函数依赖于X’，则称Y对X完全函数依赖。</li><li><strong>部分函数依赖</strong>：如果Y函数依赖于X，但Y不完全函数依赖于X，则称Y对X部分函数依赖。</li><li>第二范式理解：每个表必须有一个（有且仅有一个）数据项作为关键字或主键（primarykey），其他数据项与关键字或者主键一一对应，即其他数据项完全依赖于关键字或主键</li></ol></li><li><strong>第三范式</strong>：非主属性既不传递依赖于码，也不部分依赖于码。<ol type="1"><li><strong>传递函数依赖</strong>：在R(U)中，若X函数依赖于Y，Y不函数依赖于X，Y函数依赖于Z。则称Z对X传递函数依赖</li></ol></li><li><strong>BCNF范式</strong>：关系模式R&lt;U,F&gt;中，若每一个决定因素都包含码，则R&lt;U,F&gt;属于BCFN。<ol type="1"><li>理解：<ol type="1"><li>所有非主属性对每一个码都是完全函数依赖；</li><li>所有主属性对每一个不包含它的码也是完全函数依赖；</li><li>没有任何属性完全函数依赖于非码的任何一组属性。</li></ol></li></ol></li></ol><h3 id="事务的四大特性acid">事务的四大特性ACID</h3><ol type="1"><li>原子性：要么都做要么都不做</li><li>一致性：事务必须使数据库从一个一致性状态变换到另一个一致性状态</li><li>隔离性：事务之间不互相干扰，多个并发事务之间互相隔离</li><li>持久性：一个事务一旦被提交，对数据的改变就是永久的</li></ol><h3 id="机器学习">机器学习</h3><h3 id="pca">PCA</h3><p>PCA (Principal ComponentAnalysis)是最常用的<strong>线性降维</strong>方法，它的目标是通过某种线性投影，将高维的数据映射到低维的空间中表示，并期望在所投影的维度上数据的<strong>方差最大</strong>，以此使用较少的数据维度，同时保留住较多的原数据点的特性。</p><h3 id="k-means">K-means</h3><p>聚类算法，事先确定常数 k代表着聚类类别数。首先随机选取k个初始点为质心，并通过计算每一个样本与质心之间的相似度（可以采用欧式距离），将样本点归到最相似的类中，接着重新计算每个类的质心（该类中所有点的平均值），重复这样的过程直到质心不再改变，最终就确定了每个样本所属的类别以及每个类的质心。</p><h3 id="牛顿法和梯度下降法">牛顿法和梯度下降法</h3><p>从本质上去看，牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。更通俗地说，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大（二阶导数信息）。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。（牛顿法目光更加长远，所以少走弯路；相对而言，梯度下降法只考虑了局部的最优，没有全局思想。）</p><p>从几何上说，牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230628102018.png" style="zoom:50%;" /></p><h2 id="项目">项目</h2><h3 id="yolov4">Yolov4</h3><ol type="1"><li><p>输入端</p><ol type="1"><li><strong>Mosaic数据增强</strong>：随机使用<strong>4张图片</strong>，随机缩放，再随机分布进行拼接，大大丰富了检测数据集，特别是随机缩放增加了很多小目标，让网络的鲁棒性更好。</li></ol></li><li><p>BackBone</p><ol type="1"><li><strong>CSPDarknet53</strong>：CSPNet的作者认为推理计算过高的问题是由于网络优化中的<strong>梯度信息重复</strong>导致的。因此采用CSP模块先将基础层的特征映射划分为两部分，然后通过跨阶段层次结构将它们合并，在减少了计算量的同时可以保证准确率。</li><li><strong>Dropblock</strong>：Dropout的方式会随机的删减丢弃一些信息，但<strong>Dropblock的研究者</strong>认为，卷积层对于这种随机丢弃并不敏感，因为卷积层通常是三层连用：<strong>卷积+激活+池化层</strong>，池化层本身就是对相邻单元起作用。而且即使随机丢弃，卷积层仍然可以从相邻的激活单元学习到<strong>相同的信息</strong>。因此，在全连接层上效果很好的Dropout在卷积层上<strong>效果并不好</strong>。</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625131008.png" style="zoom: 67%;" /></p><ol start="3" type="1"><li>Neck<ol type="1"><li><strong>SPP</strong>：使用k={1<em>1,5</em>5,9<em>9,13</em>13}的最大池化的方式，再将不同尺度的特征图进行Concat操作。比单纯的使用<strong>k*k最大池化</strong>的方式，更有效的增加主干特征的接收范围，显著的分离了最重要的上下文特征。</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625131645.png" style="zoom: 50%;" /></p><p>​ 2.<strong>FPN+PAN</strong>:FPN层自顶向下传达<strong>强语义特征</strong>，而特征金字塔则自底向上传达<strong>强定位特征</strong>，两两联手，从不同的主干层对不同的检测层进行参数聚合</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625132401.png" /></p><ol start="4" type="1"><li><p>输出端</p><ol type="1"><li><p>IOU_loss：1-交集/并集。当预测框和目标框不相交时无法衡量；当相交但相交的位置不同时无法衡量</p></li><li><p>GIOU_Loss</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625134108.png" style="zoom:50%;" /></p></li><li><p>DIOU_Loss</p><p><img src="https://pic1.zhimg.com/80/v2-029f094658e87f441bf30c80cb8d07d0_1440w.webp" alt="img" style="zoom:50%;" /></p></li><li><p>CIOU_Loss</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625134312.png" style="zoom:50%;" /></p></li><li><p><strong>DIOU_nms</strong>：Nms主要用于预测框的筛选</p></li></ol></li></ol><h3 id="yolov5">Yolov5</h3><ol type="1"><li><p>输入端</p><ol type="1"><li>Mosaic数据增强</li><li>自适应锚框计算</li><li>letterbox统一尺寸</li></ol></li><li><p>Backbone</p><ol type="1"><li><p>Focus结构：将<spanclass="math inline">\(608*608*3\)</span>切片为<spanclass="math inline">\(304*304*12\)</span>,再经过32个卷积核的卷积操作得到<spanclass="math inline">\(304*304*32\)</span>的特征图</p></li><li><p>CSP结构</p><p><img src="https://pic4.zhimg.com/80/v2-1da2f1a93c888dfe7c9002de56cff02b_1440w.webp" alt="img" style="zoom:50%;" /></p></li></ol></li><li><p>Neck</p><ol type="1"><li>FPN_PAN</li></ol></li><li><p>输出端</p><ol type="1"><li>CIOU_Loss</li><li>加权nms</li></ol></li></ol><h2 id="英文面">英文面</h2><h3 id="分钟自我介绍">2分钟自我介绍</h3><p>Good afternoon professors. I am honored to be here for thisinterview. Now i will give a brief introduction about myself. My name isChenLibiao and I am studying Computer Science at Beijing University ofTechnology.</p><p>First of all, for my in-class studies, you can see that I achievedhigh grade points and high ranking. And outside of class, I am alsoresponsible for tutoring advanced mathematics at our school, so I have astrong ability to communicate with others.</p><p>In terms of competitions, I have received some awards in many fieldssuch as mathematics, algorithms and data analysis So I think I havecomprehensive knowledge.</p><p>In terms of scientific research, under the guidance of my tutor, Ihave completed a paper on deep neural network as the first author andyou can see that paper in the middle of my materials. In addition tothat, I also have several other research projects so I believe that Ican complete high-level research work under the guidance of teachers andresearch team.</p><p>Beihang university has been my dream school for a long time. If Ihave the honor of being selected as an excellent camper, I will surelychoose Beihang University in September. Ok that's all, thanks forlistening</p><h3 id="项目介绍">项目介绍</h3><p>This project is about using deep neural networks for the diagnosis ofASD. ASD is a complex neurodevelopmental disorder that severely impactssocial abilities. In this project, we employed sliding windows andpearson rank correlation coefficient to collect dynamic functionalconnectivity (dFC) data and applied Kendall's rank correlationcoefficient to extract features. We then introduced self-attentionmechanism in our DNN architecture to efficiently extract high-orderspatial features across consecutive windows. By stacking multi-headself-attention layers with feed-forward neural networks, our modeleffectively extracts rich information in multiple dimensions andintegrates them together. We conducted systematic experiments on thelarge-sacle ABIDE dataset to validate the performance of our model.Moreover, our study revealed that the middle frontal gyrus and middletemporal gyrus exhibit significant alterations in ASD patients,highlighting their diagnostic value and potential relevance as targetsfor intervention. Our model provides an effective approach to assist inthe diagnosis of ASD.</p>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/06/23/School/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/06/23/School/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>计算机网络复习</p><span id="more"></span><h2 id="计算机网络体系结构">计算机网络体系结构</h2><ol type="1"><li><p>局域网基本都使用广播式通信技术，广域网中的无线、卫星通信也采用广播式通信</p></li><li><p>是否采用分组存储转发与路由选择机制是点对点网络与广播式网络的重要区别</p></li><li><p>计算机网络的组成</p><ol type="1"><li>按组成部分：硬件+软件+协议</li><li>按功能：通信子网（交换机、路由器等）+资源子网（计算机设备、软件）</li><li>按工作方式：边缘部分（主机）+核心部分（路由器等）</li></ol></li><li><p>计算机网络的交换技术</p><ol type="1"><li><p>电路交换网络</p><p>建立专用的通路用于传送数据，包括建立连接、传输数据、断开链接三个阶段。连接建立后则该线路被独占</p><p>数据直接传送、时延小；线路利用率低、不能充分利用线路容量、不便于进行差错控制</p></li><li><p>报文交换网络</p><p>用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文。<strong>整个报文</strong>传送到相邻结点，全部存储后再转发给下一个节点，又称为存储-转发网络。报文交换对报文的大小没有限制。</p><p>可以较为充分地利用线路容量；增大了资源开销、时延</p></li><li><p>分组交换网络</p><p>也称为包交换网络。将数据分成较短的<strong>固定长度</strong>的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包)，以存储-转发方式传输。</p><p>除具备报文交换网络的优点外，分组交换网络还具有自身的优点：缓冲易于管理；包的平均时延更小，网络占用的平均缓冲区更少；更易于标准化；更适合应用。现在的主流网络基本上都可视为分组交换网络。</p></li></ol></li><li><p>协议是控制两个或多个对等实体进行通信的规则的集合，是水平的；服务是指下层为紧邻的上层提供的功能调用，是垂直的</p></li><li><p>服务的分类</p><ol type="1"><li><p>面向连接服务与无连接服务</p><p>面向连接服务：连接建立、数据传输、连接释放</p></li><li><p>可靠服务和不可靠服务</p><p>可靠服务指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地</p></li><li><p>有应答服务和无应答服务</p><p>有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统内部自动实现，而不由用户实现。所发送的应答既可以是肯定应答，也可以是否定应答，通常在接收到的数据有错误时发送否定应答。</p></li></ol></li><li><p>OSI（开放系统互连参考模型）</p><p>低三层为通信子网，高三层为资源子网</p><ol type="1"><li>物理层：传输单位为比特，在物理媒体上为数据端设备透明地传输原始比特流</li><li>数据链路层：传输单位是帧，任务是将网络层传来的IP数据报组装成帧。有成帧、差错控制、流量控制和传输管理的功能</li><li>网络层：传输单位是数据报，关心的是通信子网的运行控制。主要任务是把网络层的协议数据单元从源端传送到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互连等</li><li>传输层：传输单位是报文段（TCP）或用户数据报（UDP），负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为<strong>端到端连接</strong>提供流量控制、差错控制、服务质量、数据传输管理等服务。高层使用传输层的服务而忽略通信子网的存在</li><li>会话层：允许不同主机上的各个进程之间进行会话。利用传输层端到端的服务为表示层实体或用户进程建立连接并传输数据</li><li>表示层：处理在两个通信系统中交换信息的表示方式，可以进行数据压缩、加密解密等</li><li>应用层：用户与网络的界面</li></ol></li><li><p>OSI和TCP/IP</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010617.png" style="zoom:50%;" /></p></li></ol><h2 id="物理层">物理层</h2><ol type="1"><li><p>数据报与虚电路</p><p><strong>分组交换</strong>根据其通信子网向端点系统提供的服务，可以分为面向连接的虚电路方式和无连接的数据报方式，这两种方式都由<strong>网络层</strong>提供</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010638.png" /></p></li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010654.png" /></p><p>​虚电路试图结合数据报方式和电路交换方式，每次建立虚电路时就确定一条固定线路，以后数据传输都从这条线路走，但是并不独占线路。</p><ol start="2" type="1"><li>中继器：将信号整形并放大再转发出去，消除信号的失真和衰减，扩大网络传输的距离</li><li>集线器：多端口的中继器</li></ol><h2 id="数据链路层">数据链路层</h2><h3 id="功能">功能</h3><ol type="1"><li>为网络提供服务：无确认的无连接服务、有确认的无连接服务、有确认的面向连接服务</li><li>链路管理：连接的建立、维持和释放</li><li>帧定界：确定开始结束位格式；帧同步：接收方能够从比特流中识别出开始结束标志</li><li>流量控制：防止发送方发送能力大于接收方接受能力而导致淹没现象</li><li>差错控制：检错码（奇偶校验码、循环冗余码），纠错编码（海明码）</li></ol><h3 id="流量控制的方式">流量控制的方式</h3><ol type="1"><li><p><strong>停止-等待</strong></p><p>发送方每发一帧，都要等待接收方回应，如果没收到就一直等待</p></li><li><p><strong>滑动窗口</strong></p><p>发送方维持一组连续的允许发送的帧的序号，称为发送窗口：同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。发送窗口用来对发送方进行流量控制，发送窗口的大小W代表在还未收到对方确认信息的情况下发送方最多还可以发送多少个数据帧。同理，在接收端设置接收窗口是为了控制可以接收哪些数据帧和不可以接收哪些帧。在接收方，只有收到的数据帧的序号落入接收窗口内时，才允许将该数据帧收下。若接收到的数据帧落在接收窗口之外，则一律将其丢弃。</p></li><li><p><strong>后退N帧</strong></p><p>发送方可以连续发送帧，当接收方检测出失序的信息帧或者发送方之前发送的某个帧超时后，发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧，接收方只允许按顺序接收帧</p></li><li><p><strong>选择重传.</strong></p><p>先收下发送序号不连续但是在接收窗口的那些数据帧，等待所缺序号的数据帧收到后再一并交给主机</p></li></ol><h3 id="介质访问控制">介质访问控制</h3><ol type="1"><li><p>信道划分介质访问控制</p><ol type="1"><li>频分多路复用：共享时间</li><li>时分多路复用：共享空间</li><li>波分多路复用：光的频分多路复用</li><li>码分多路复用：采用不同编码区分各路原始信号</li></ol></li><li><p>随机访问介质访问控制</p><p>不采用<strong>集中控制</strong>的方式解决发送信息的次序问题</p><ol type="1"><li><p>纯ALOHA协议：不检测直接发，如果没收到确认帧随机等一段时间后再发</p></li><li><p>时隙ALOHA协议：将时间划分为一段段等长的时隙，只能在每个时隙开始时才能发送一个帧</p></li><li><p>CSMA（载波监听多路访问）</p><ol type="1"><li>1-坚持CSMA：发送数据前监听信道，若空闲则发送，若不空闲则一直等待</li><li>非坚持CSMA：若不空闲则等待一个随机时间后再发送</li><li>p-坚持CSMA：如果空闲，则以p概率发送，以1-p概率下一个时隙再发送，如果忙则一直监听</li></ol></li><li><p>CSMA/CD：载波监听+碰撞检测。先听后发，边听边发，冲突停发，随机重发。适用于有线连接的半双工通信</p><p>CSMA/CD算法的归纳如下：①准备发送：适配器从网络层获得一个分组，封装成帧，放入适配器的缓存。②检测信道：若检测到信道空闲，它就开始发送这个帧。若检测到信道忙，它就持续检测直至信道上没有信号能量，然后开始发送这个帧。③在发送过程中，适配器仍持续检测信道。这里只有两种可能：发送成功：在争用期内一直未检测到碰撞，这个帧肯定能发送成功。发送失败：在争用期内检测到碰撞，此时立即停止发送，适配器执行指数退避算法，等待一段随机时间后返回到步骤②。若重传16次仍不能成功，则停止重传并向上报错。</p></li><li><p>CSMA/CA：载波监听+碰撞避免，适用于无线局域网（接收信号强度弱、存在隐蔽站，不能进行碰撞检测）</p><p>CSMA/CA算法的归纳如下：</p><ol type="1"><li>若站点最初有数据要发送（而不是发送不成功再进行重传)，且检测到信道空闲，在等待时间DIFS后，就发送整个数据帧。</li><li>否则，站点执行CSMA/CA退避算法，选取一个随机回退值。一旦检测到信道忙，退避计时器就保持不变。只要信道空闲，退避计时器就进行倒计时。</li><li>当退避计时器减到0时（这时信道只可能是空闲的），站点就发送整个帧并等待确认。</li><li>发送站若收到确认，就知道已发送的帧被目的站正确接收。这时如果要发送第二帧，就要从步骤2开始，执行CSMA/CA退避算法，随机选定一段退避时间。若发送站在规定时间（由重传计时器控制）内没有收到确认帧ACK,就必须重传该帧，再次使用CSMA/CA协议争用该信道，直到收到确认，或经过若干次重传失败后放弃发送。</li></ol></li></ol></li><li><p>轮询访问</p><p>主机在逻辑上形成环，令牌在环上移动，拿到令牌才能发送</p></li></ol><h3 id="局域网">局域网</h3><ol type="1"><li><p>局域网现在由以太网垄断，以太网采用无连接的工作方式，不对发送的数据帧编号，也不要求接收方发送确认，提供的是不可靠服务，对于差错的纠正由高层完成。</p></li><li><p>以太网发送的数据都是用曼彻斯特编码的信号，每个码元的中间出现一次电压转换，接收端利用这种电压转换方便地把位同步信号提取出来</p></li><li><p>计算机与外界局域网的连接是通过主机箱内插入的一块网络接口板[又称网络适配器(Adapter)或网络接口卡(NetworkInterfaceCard,NIC)]实现的。<strong>网卡</strong>上装有处理器和存储器，是工作在<strong>数据链路层</strong>的网络组件。<strong>网卡和局域网</strong>的通信是通过电缆或双绞线以串行方式进行的，而<strong>网卡和计算机</strong>的通信则是通过计算机主板上的/O总线以并行方式进行的。因此，网卡的重要功能就是进行数据的串并转换。网卡不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码及数据缓存功能等。</p></li><li><p>每一个网卡都有一个唯一的介质访问控制（MAC）地址</p></li><li><p>MAC帧，802.3帧格式用长度域替代了类型域</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010713.png" /></p></li><li><p>无线局域网分为有固定基础设施无线局域网和无固定基础设施移动自组织网络</p></li><li><p>通用虚拟局域网，可以把一个较大的局域网分割为一些较小的与地理位置无关的逻辑上的VLAN</p></li><li><p>VLAN在以太网帧中插入一个四字节的标识符，用来指明发送该帧的计算机属于哪个虚拟局域网</p></li></ol><h3 id="广域网">广域网</h3><ol type="1"><li>广域网中的一个重要问题是<strong>路由选择</strong>和<strong>分组转发</strong>。路由选择协议负责搜索分组从某个结点到目的结点的最佳传输路由，以便构造路由表，然后从路由表再构造出转发分组的转发表。分组是通过转发表进行转发的。</li></ol><p>2.PPP协议：点对点协议是使用串行线路通信的面向字节的协议，应用在直接连接的两个节点的链路上(找不到就广播)</p><h3 id="数据链路层设备">数据链路层设备</h3><ol type="1"><li><strong>网桥</strong>：两个以上以太网通过网桥连接后可以成为一个覆盖范围更广的以太网，原来每个以太网称为一个网段</li><li><strong>局域网交换机</strong>：多端口的网桥，每个端口都直接与单台主机或另一个交换机连接，通常都工作在全双工模式。具有自学习能力，能够方便的扩展以太网。</li></ol><h2 id="网络层">网络层</h2><h3 id="功能-1">功能</h3><h3id="异构网络互连用路由器进行网络互联和路由选择来将多个网络连接在一起"><strong>异构网络互连</strong>：用路由器进行网络互联和路由选择来将多个网络连接在一起</h3><ol start="2" type="1"><li><p><strong>路由与转发</strong>：路由器的两个功能：路由选择（确定哪一条道路）、分组转发（当一个分组到达时所采取的动作）</p><p>路由选择按照复杂的分布式算法动态改变所选择的路由，生成路由表；转发表通过路由表生成。</p></li><li><p><strong>软件定义网络（SDN）</strong>：分为数据平面和控制平面。采用集中式的控制平面和分布式的数据平面。路由器不需要路由选择软件，路由器之间不再需要交换路由信息。</p></li><li><p><strong>拥塞控制</strong>：因出现过量的分组而引起网络性能下降的现象称为拥塞</p></li></ol><h3 id="路由算法">路由算法</h3><ol type="1"><li><p>静态路由算法：人工指定</p></li><li><p>距离-向量路由算法(RIP)：</p><p>所有结点都定期地将他们的整个路由选择表传送给所有与之直接相邻的结点。当出现新的路由或者距离某个已有路由距离有更近路径时更新自身路由表。</p><p>RIP使用跳数来衡量到达目的网络的距离</p></li><li><p>链路状态路由算法（OSPF）：</p><p>要求每个参与该算法的结点都具有完全的网络拓扑信息，他们执行以下两项任务:(1)主动测试所有邻接结点的状态.(2)定期将链路状态传播给所有其他结点</p><p>当别的结点的状态报文发送来时，如果对自身状态有更新，则使用Dijkstra算法更新到各个目标节点的最短路径</p></li><li><p>层次路由</p><p>将互联网划分为许多较小的自治系统。每个自治系统内部决定采用何种路由选择协议（内部网关协议），自治系统之间采用相同协议（外部网关协议）。</p></li></ol><h3 id="ipv4">IPv4</h3><ol type="1"><li><p>早期IP地址</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/image-20230624125348468.png" style="zoom:67%;" /></p></li><li><p>网络地址转换（NAT）</p><ol type="1"><li><p>将专用网络地址转化为公用地址，从而对外隐藏内部管理的IP地址。</p></li><li><p>每个NAT路由器至少有一个有效的外部全球IP地址，本地地址的主机和外界通信时，NAT路由器使用NAT转换表进行本地IP地址和全球IP地址的转换。</p></li></ol></li><li><p>子网划分</p><p>从主机号借用若干比特作为子网号，不改变网络号，属于单位内部的事情，对外仍表现为没有划分的网络</p></li><li><p>子网掩码</p><ol type="1"><li><p>使用子网掩码表达对原网络中主机号的借位</p></li><li><p>子网掩码是一个与IP地址相对应的、长32bt的二进制串，它由一串1和跟随的一串0组成。其中，1对应于P地址中的网络号及子网号，而0对应于主机号。计算机只需将IP地址和其对应的子网掩码逐位“与”，就可得出相应子网的网络地址。</p></li><li><p>一台主机在设置IP地址信息的同时，必须设置子网掩码</p></li><li><p>同属于一个子网的所有主机及路由器的相应端口必须设置相同的子网掩码</p></li><li><p>路由器的路由表中所包含的主要内容有目的网络地址、子网掩码、下一跳地址</p></li></ol></li><li><p>无分类编址CIDR</p><ol type="1"><li>在变长子网掩码的基础上提出一种消除传统ABC类网络划分，并可以在软件支持下实现超网构造的一种IP地址划分方法</li><li>IP::={<网络前缀>,<主机号>}，其中网络前缀的长度不定，使用IP/前缀比特数的方式得到网络前缀</li><li>使用网络前缀都相同的连续IP地址组成“CIDR地址块”，一个CIDR地址块可以表示很多地址，这种地址的聚合称为路由聚合，或称构成超网。路由聚合使得路由表中的一个项目可以表示多个原来传统分类地址的路由，有利于减少路由器之间的信息的交换，从而提高网络性能</li><li>路由表中的每个项目由网络前缀和下一跳地址组成，在查找路由表时应该从匹配结果中选择具有最长网络前缀的路由</li></ol></li><li><p>网络层转发分组的过程</p><ol type="1"><li>从收到的IP分组的首部提取目的主机的P地址D(即目的地址)。</li><li>若查找到特定主机路由（目的地址为D),就按照这条路由的下一跳转发分组；否则从转发表中的下一条（即按前缀长度的顺序）开始检查，执行步骤3)。</li><li>将这一行的子网掩码与目的地址D进行按位与运算。若运算结果与本行的前缀匹配，则查找结束，按照“下一跳”指出的进行处理（或者直接交付本网络上的目的主机，或通过指定接口发送到下一跳路由器)。否则，若转发表还有下一行，则对下一行进行检查，重新执行步骤3)。否则，执行步骤4)。</li><li>若转发表中有一个默认路由，则把分组传送给默认路由；否则，报告转发分组出错。</li></ol></li><li><p>地址解析协议（ARP）</p><ol type="1"><li><p>实现IP地址到MAC地址的映射</p></li><li><p>每台主机都设有一个ARP高速缓存用来存放本局域网上各主机和路由器的IP地址到MAC地址的映射表，称为ARP表</p></li><li><p>工作原理</p><p>主机A向B发送IP数据报时，先在ARP高速缓存中查找有无B的IP地址，如果有就可以查出其对应的硬件地址，再将此硬件地址写入MAC帧通过局域网发过去。如果没有就使用MAC地址为FFFF-FF-FF-FF-FF的帧来封装并广播ARP请求分组，B收到后通过单播向A发送响应分组，包含B的IP与MAC地址的对应关系。</p></li><li><p>当主机想要发数据给另一个网络的主机时，本地主机查找路由器硬件地址并发送数据，由路由器完成后续操作</p></li></ol></li><li><p>动态主机配置协议（DHCP）</p><ol type="1"><li><p>是应用层协议，基于UDP，用于给主机动态的分配IP地址</p></li><li><p>DHCP的工作原理</p><p>使用客户/服务器模式。需要IP地址的主机在启动时就向DHCP服务器广播发送发现报文，这时该主机就成为DHCP客户。本地网络上所有主机都能收到此广播报文，但只有DHCP服务器才回答此广播报文。DHCP服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的P地址池中取一个地址分配给该计算机。DHCP服务器的回答报文称为提供报文。</p></li></ol></li><li><p>网际控制报文协议</p><p>为了提高IP数据报交付成功的机会，在网络层使用了网际控制报文协议(InternetControl MessageProtocol,ICMP)来让主机或路由器报告差错和异常情况。</p></li></ol><h3 id="ipv6">IPv6</h3><ol type="1"><li>解决IP地址耗尽的措施<ol type="1"><li>采用无类别编址CIDR，使IP地址分配更加合理</li><li>采用网络地址转换NAT节省全球IPI地址</li><li>采用更大地址空间的IPv6</li></ol></li></ol><h3 id="路由协议">路由协议</h3><ol type="1"><li><p>内部网关协议</p><ol type="1"><li><p>路由信息协议（RIP）</p><ol type="1"><li>基于距离向量的路由选择协议</li><li>直连路由器跳数为1，随后每多一个加1跳，大于15跳认为不可达</li><li>每个路由器和直接相连的路由器交换自身路由表，一段时间后每个路由器都将知道全部的路由器信息，称为RIP收敛</li><li>是应用层协议，使用UDP传送数据</li></ol></li><li><p>开放最短路径优先协议（OSPF）</p><ol type="1"><li><p>分布式链路状态路由算法的代表</p></li><li><p>采用洪泛法向本自治系统中所有路由器发送信息，信息为自己和相邻路由器的度量</p></li><li><p>只有当链路状态改变时才发送信息</p></li><li><p>是网络层协议，直接用IP数据报传送</p></li><li><p>所有路由器最终都能建立一个链路状态数据库，采用Dijkstra算法计算从自己到各目的网络的最优路径以构造自己的路由表</p></li></ol></li></ol></li><li><p>外部网关协议</p><ol type="1"><li>边界网关协议（BGP）<ol type="1"><li>采用路径向量路由选择协议，是应用层协议，基于TCP</li><li>每个自治系统选择一个或多个BGP发言人，发言人要与其他BGP发言人建立TCP连接并交换路由信息</li><li>找的是较好的路径，并非最佳路径</li></ol></li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010842.png" style="zoom: 50%;" /></p><h3 id="ip组播">IP组播</h3><ol type="1"><li>缘由：有的应用程序要把一个分组发送给多个目的地主机，只发送一次但是可以发送到多个主机</li><li>每个组都有一个地址，要给该组发送的计算机将使用这个地址作为分组的目标地址</li><li>仅应用于UDP，地址采用D类地址</li><li>使用因特网组管理协议（IGMP）使路由器知道组播组成员的信息</li></ol><h3 id="移动ip">移动IP</h3><ol type="1"><li>移动站在归属网络时，按传统的TCP/IP方式进行通信。</li><li>移动站漫游到外地网络时，向外地代理进行登记，以获得一个临时的转交地址。外地代理要向移动站的归属代理登记移动站的转交地址。</li><li>归属代理知道移动站的转交地址后，会构建一条通向转交地址的隧道，将截获的发送给移动站的P分组进行再封装，并通过隧道发送给被访网络的外地代理。</li><li>外地代理把收到的封装的数据报进行拆封，恢复成原始的P分组，然后发送给移动站，这样移动站在被访网络就能收到这些发送给它的P分组。</li><li>移动站在被访网络对外发送数据报时，仍然使用自己的永久地址作为数据报的源地址，此时显然无须通过A的归属代理来转发，而是直接通过被访网络的外部代理。</li><li>移动站移动到另一外地网络时，在新外地代理登记后，然后新外地代理将移动站的新转交地址告诉其归属代理。无论如何移动，移动站收到的数据报都是由归属代理转发的。</li><li>移动站回到归属网络时，移动站向归属代理注销转交地址。</li></ol><h2 id="传输层">传输层</h2><h3 id="服务">服务</h3><ol type="1"><li><p>功能</p><ol type="1"><li><p>为运行在不同主机上的<strong>进程</strong>之间提供逻辑通信</p></li><li><p>复用和分用：复用指发送方不同的应用进程都可使用同一个传输层协议传送数据；分用指接收方的传输层在剥去报文首部后能够把这些数据正确交付到目的应用进程</p></li><li><p>对收到的报文进行差错检测（首部和数据部分），网络层只检查IP数据报的首部</p></li><li><p>提供两种不同的传输协议（TCP和UDP）</p></li></ol></li><li><p>套接字Socket：IP地址：端口号,唯一标识一台主机上的一个进程</p></li></ol><h3 id="udp">UDP</h3><ol type="1"><li><p>UDP在IP数据报服务的基础上提供复用和分用以及差错检测服务</p></li><li><p>优点</p><ol type="1"><li>无需建立连接，因此不会引入建立连接的时延</li><li>无连接状态。不需要维护连接状态，也不跟走这些参数，因此一般可以支持更多的活动客户机</li><li>分组首部开销小，只有8B</li><li>没有拥塞控制，应用层能更好的控制要发送的数据和发送时间</li><li>支持一对一、一对多、多对一的通信</li></ol></li><li><p>面向报文，对应用层交下来的报文在添加首部后就向下交付给IP层，保留报文边界。报文是UDP数据报处理的最小单位。</p></li></ol><h3 id="tcp">TCP</h3><ol type="1"><li><p>每条TCP连接只能有两个端点，每一条TCP连接只能是点到点的</p></li><li><p>TCP面向字节流，应用程序和TCP的交互是大小不一的数据块，但TCP把应用程序交下来的数据仅视为一连串的无结构字节流</p></li><li><p>TCP连接的两端为套接字或插口</p></li><li><p>三次握手</p><p>连接建立前，服务器进程处于LISTEN(收听)状态，等待客户的连接请求。</p><ol type="1"><li>客户机的TCP首先向服务器的TCP发送连接请求报文段。这个特殊报文段的首部中的<strong>同步位SYN置1</strong>，同时选择一个初始序号<strong>seq=x</strong>。TCP规定，SYN报文段不能携带数据，但要消耗掉一个序号。这时，TCP客户进程进入SYN-SENT(同步已发送)状态。</li><li>服务器的TCP收到连接请求报文段后，如同意建立连接，则向客户机发回确认，<strong>并为该TCP连接分配缓存和变量</strong>，在确认报文段中，把<strong>SYN位和ACK位都置1</strong>，确认号是ack=x+1,同时也为自己选择一个初始序号seq=y。注意，确认报文段不能携带数据，但也要消耗掉一个序号。这时，TCP服务器进程进入SYN-RCVD(同步收到).状态。</li><li>当客户机收到确认报文段后，还要向服务器给出确认，<strong>并为该TCP连接分配缓存和变量</strong>。确认报文段的ACK位置1，确认号ack=y+l,序号seq=x+1。该报文段<strong>可以携带数据</strong>，若不携带数据则不消耗序号。这时，TCP客户进程进入ESTABLISHED'(已建立连接)状态。</li></ol><p>成功进行以上三步后，就建立了TCP连接，接下来就可以传送应用层数据。TCP提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据。另外，值得注意的是，服务器端的资源是在完成第二次握手时分配的，.而客户端的资源是在完成第三次握手时分配的，这就使得服务器易于受到SYN洪泛攻击。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010903.png" style="zoom: 50%;" /></p><ol start="5" type="1"><li>四次挥手<ol type="1"><li>客户机打算关闭连接时，向其TCP发送连接释放报文段，并停止发送数据，主动关闭TCP连接，该报文段的终止位FN置1，序号sq=u,它等于前面已传送过的数据的最后一个字节的序号加1，FN报文段即使不携带数据，也消耗掉一个序号。这时，TCP客户进程进入FNWAIT-1(终止等待1)状态。TCP是全双工的，即可以想象为一条TCP连接上有两条数据通路，发送FN的-一端不能再发送数据，即关闭了其中一条数据通路，但对方还可以发送数据。</li><li>服务器收到连接释放报文段后即发出确认，确认号ack=u+1,序号seq=v,等于它前面已传送过的数据的最后一个字节的序号加1。然后服务器进入CLOSE-WAIT(关闭等待)状态。此时，<strong>从客户机到服务器这个方向的连接就释放了</strong>，·T℃P连接处于半关闭状态。但服务器若发送数据，客户机仍要接收，即从服务器到客户机这个方向的连接并未关闭。</li><li>若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时，其发出FN=1的连接释放报文段。设该报文段的序号为w(在半关闭状态服务器可能又发送了一些数据)，还须重复上次已发送的确认号ck=u+1。这时服务器进入LAST-ACK(最后确认)状态。</li><li>客户机收到连接释放报文段后，必须发出确认。把确认报文段中的确认位ACK置1,确认号ack=w+1,序号seq=u+1。此时TCP连接还未释放，必须经过时间等待计时器设置的时间2MSL（最长报文段寿命)后，客户机才进入CLOSED(连接关闭)状态。</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010954.png" style="zoom:50%;" /></p><ol start="6" type="1"><li><p>TCP的可靠传输</p><ol type="1"><li>校验</li><li>序号：用来保证数据能够有序提交给应用层</li><li>确认：TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号</li><li>重传<ol type="1"><li>超时重传：计时器设置的重传时间到期但还未收到确认就重传</li><li>冗余ACK：基于上述“确认”，多次收到ACK中同样的序号则认为丢失，进行重传</li></ol></li></ol></li><li><p>TCP流量控制</p><ol type="1"><li>接收方根据自己接收缓存的大小动态调整发送发发送窗口大小，称为接收窗口rwnd</li><li>发送方根据其对当前网络拥塞程度的估计而确定的窗口值称为拥塞窗口cwnd</li><li>A的发送窗口取rwnd和cwnd的最小值</li></ol></li><li><p>TCP拥塞控制</p><ol type="1"><li>流量控制是防止发送的过快导致接收方无法接收；拥塞控制是防止网络链路压力过大。二者都对发送方的发送速率进行控制</li><li>慢开始和拥塞避免<ol type="1"><li>慢开始：连接建立时cwnd为1，此后每收到一个确认cwnd加一直到到达阈值，随后采用拥塞避免算法</li><li>拥塞避免：每经过一个往返时延RTT就把cwnd加一</li><li>网络拥塞的处理：当判断网络出现拥塞（未按时收到确认），把慢开始阈值设置为此时cwnd的一半并置cwnd为1</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625011022.png" style="zoom:50%;" /></p></li><li><p>快重传和快恢复</p><pre><code class="hljs">1. 快重传：当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。    2. 快恢复：当发送方连续收到三个冗余ACK时，把阈值设置为此时cwnd的一半并置cwnd为当前的阈值</code></pre><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625011039.png" style="zoom: 50%;" /></p></li></ol><h2 id="应用层">应用层</h2><h3 id="网络应用模型">网络应用模型</h3><ol type="1"><li>C/S模型</li><li>P2P模型：每个结点都同时具有下载、上传的功能</li></ol><h3 id="域名系统dns">域名系统（DNS）</h3><ol type="1"><li>域名服务器：因特网的域名系统被设计成一个联机分布式的数据库系统，采用C/S模型。每个域名服务器保存一个区内所有主机的域名到IP地址的映射，同时具有连向其他域名服务器的信息。</li><li>域名服务器是分层结构，分为根域名服务器、顶级域名服务器、授权域名服务器、本地域名服务器</li><li>域名解析过程：<ol type="1"><li>递归查询：本地域名服务器向根域名服务器查询一次，后面几次查询都递归的在其他几个域名服务器之间进行。</li><li>迭代查询：<ol type="1"><li>主机向本地域名服务器采用递归查询</li><li>如果查不到，向根域名服务器发起请求，根域名服务器告诉本地域名服务器去哪个顶级域名服务器查询，迭代上述过程直到找到目标服务器</li></ol></li></ol></li></ol><h3 id="文件传输协议ftp">文件传输协议（FTP）</h3><ol type="1"><li>FTP使用两个并行的TCP连接，一个是控制连接（带外传送）一个是数据连接。</li><li>数据连接分为两种：主动模式PORT和被动模式PASV。PORT是服务器连接到客户端的某个端口，PASV是客户端连接到服务器的某个端口。</li></ol><h3 id="电子邮件">电子邮件</h3><ol type="1"><li>发信人调用用户代理来撰写和编辑要发送的邮件。用户代理用SMTP把邮件传送给发送端邮件服务器。</li><li>发送端邮件服务器将邮件放入邮件缓存队列中，等待发送。</li><li>运行在发送端邮件服务器的SMTP客户进程，发现邮件缓存中有待发送的邮件，就向运行在接收端邮件服务器的SMTP服务器进程发起建立TCP连接。</li><li>TCP连接建立后，SMTP客户进程开始向远程SMTP服务器进程发送邮件。当所有待发送邮件发完后，SMTP就关闭所建立的TCP连接。</li><li>运行在接收端邮件服务器中的SMTP服务器进程收到邮件后，将邮件放入收信人的用户邮箱，等待收信人在方便时进行读取。</li><li>收信人打算收信时，调用用户代理，使用POP3(或IMAP)协议将自己的邮件从接收端邮件服务器的用户邮箱中取回（如果邮箱中有来信的话）。</li></ol><h3 id="万维网">万维网</h3><p>用户单击鼠标后所发生的事件按顺序如下（以访问清华大学的网站为例）：</p><ol type="1"><li>浏览器分析链接指向页面的URL(http://www.tsinghua.edu.cn/chn/index.htm)。</li><li>浏览器向DNS请求解析www.tsinghua.edu.cn的IP地址。</li><li>域名系统DNS解析出清华大学服务器的P地址。</li><li>浏览器与该服务器建立TCP连接（默认端口号为80）。</li><li>浏览器发出HTTP请求：GET/chn/index.htm。</li><li>服务器通过HTTP响应把文件index.htm发送给浏览器。</li><li>释放TCP连接。</li><li>浏览器解释文件index.htm,并将Web页显示给用户。</li></ol>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2023/06/22/School/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/06/22/School/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>数据结构复习</p><span id="more"></span><ol type="1"><li><p>数据的逻辑结构：线性结构（栈、队列）、非线性结构（树、图）</p></li><li><p>数据的存储结构：顺序存储、链式存储、索引存储、散列存储</p></li><li><p>满二叉树：就是都满了</p><p>完全二叉树：除了最后一层都满，最后一层从左到右排列</p><p>二叉排序树：左子树的值小于根节点的值，右子树的值大于根节点的值</p><p>平衡二叉树：任意节点左右子树的深度差不大于1</p></li><li><p>二叉树遍历</p><ol type="1"><li>先序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ol></li><li><p>树的遍历</p><ol type="1"><li>先根遍历：先访问根节点，再依次遍历每棵子树</li><li>后根遍历：先依次遍历每棵子树，再访问根节点</li></ol></li><li><p>在无向图中若任意两个顶点是联通的则称为连通图；在有向图中若任意两个顶点双向可达则称为强连接图</p></li><li><p>最小生成树</p><ol type="1"><li><p>Prim算法<span class="math inline">\(O(n^2)\)</span></p><p>初始时从图中任取一个点加入T集合，之后每次选择一个与集合T距离最近的顶点加入</p><p><img src="C:\Users\chenl\AppData\Roaming\Typora\typora-user-images\image-20230622205421669.png" alt="image-20230622205421669" style="zoom:67%;" /></p></li><li><p>Kruskal算法<span class="math inline">\(O(n^2)\)</span></p><p>将边按权值排序，不断选择权值最小的边，使用并查集判断如果边的两个端点ab已经在一类中了则跳过，否则加入</p><p><img src="C:\Users\chenl\AppData\Roaming\Typora\typora-user-images\image-20230622205745004.png" alt="image-20230622205745004" style="zoom: 67%;" /></p></li></ol></li><li><p>最短路径</p><ol type="1"><li><p>Dijkstra单源最短路<span class="math inline">\(O(n^2)\)</span></p><p>初始时把源点放入S，寻找距离原点最近的顶点并入，然后更新原点到所有点的距离，重复上述过程直到到达目标点</p></li><li><p>Floyd多源最短路<span class="math inline">\(O(n^3)\)</span></p><p>基于动态规划，初始时对于任意两个点，如果他们之间存在边则边权值作为最短路径，若不存在则置无穷。之后每次尝试加入一个顶点k，看看每两个点之间增加k后得到的距离是否更短，若更短则进行更新。</p></li></ol></li><li><p>二叉排序树的删除：</p><ol type="1"><li>叶子节点直接删</li><li>只有一个子树直接替代</li><li>左右子树都有，找右子树中序遍历第一个结点替代（即右子树中的最小值）</li></ol></li><li><p>平衡二叉树（AVL）：在二叉排序树基础上规定任意顶点左右子树高度差不超过1.插删如果破坏了平衡则对最近不平衡结点进行旋转</p></li><li><p>排序算法</p><ol type="1"><li>直接插入排序<spanclass="math inline">\(O(n^2)\)</span>：遍历数组，对于某个值，遍历他前面的有序序列找到插入的地方并插入</li><li>折半插入排序<spanclass="math inline">\(O(n^2)\)</span>：在上述基础上用二分法找插入位置<spanclass="math inline">\(O(n(logn+n))\)</span></li><li>冒泡排序<spanclass="math inline">\(O(n^2)\)</span>：遍历两边，若逆序则调整顺序</li><li>快排<span class="math inline">\(O(nlogn)\)</span>：最坏<spanclass="math inline">\(O(n^2)\)</span>，最好<spanclass="math inline">\(O(nlogn)\)</span>，是平均性能最优的算法</li><li>选择排序<spanclass="math inline">\(O(n^2)\)</span>：每次在后面序列中选一个最大的和前面的交换</li><li>堆排序<span class="math inline">\(O(nlogn)\)</span></li><li>归并排序<spanclass="math inline">\(O(nlogn)\)</span>：将序列不断二分直到只有一个或两个元素，然后进行排序，然后再原路合并回去，合并时采用双指针遍历一遍存入新数组即可，需要O(n)的空间</li><li>桶排序：划分多个范围相同的区间，每个子区间内部进行排序，然后再合并</li><li>基数排序$O(d(n+r))：d代表分配回收的趟数，n代表长度，r代表基数</li></ol></li></ol><p><img src="C:\Users\chenl\AppData\Roaming\Typora\typora-user-images\image-20230622221713048.png" alt="image-20230622221713048" style="zoom:67%;" /></p><ol start="12" type="1"><li><p>外部排序</p><p>主要思路为减少访存次数.常用归并排序.将外存上的文件划分为若干长度为l的子文件,依次读入内存使用内部排序算法进行排序并写回外存.随后逐渐进行归并操作.</p></li><li><p>查找算法</p><ol type="1"><li><p>顺序查找</p></li><li><p>二分查找</p></li><li><p>插值查找：<span class="math inline">\(mid = low + \frac{(key -a[low])*(high-low)}{a[high]-a[low]}\)</span>,时间复杂度O(lglgn)</p></li><li><p>二叉排序树</p></li><li><p>平衡二叉树</p></li><li><p>红黑树：平衡二叉树调整太多了，红黑树稍微放宽了限制</p></li><li><p>B树:除根节点的非叶节至少有m/2上取整棵子树，最多有m棵子树</p></li><li><p>B+树：叶节点包含了全部关键字，非叶节点的关键字也会出现在叶结点中，叶子节点按大小顺序链接起来</p><p>B+树有两种查找运算：一种从最小关键词开始查找，一种从根节点开始查找，查找到最底层cai'jie'shu</p></li><li><p>散列表</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件工程导论</title>
    <link href="/2023/06/07/School/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/07/School/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>软件工程导论期末复习 <span id="more"></span></p><h2 id="第一章-概述">第一章 概述</h2><ol type="1"><li><p>软件定义</p><ol type="1"><li>软件是计算机系统中与硬件相互依存的另一部分，它是包括<strong>程序</strong>，<strong>数据</strong>及其<strong>相关文档</strong>的完整集</li><li>一种具有<核心功能>，能够实现<目标>的<事物></li></ol></li><li><p>软件分类</p><p>系统软件、应用软件、支撑软件、可复用软件(标准函数库)</p></li><li><p>软件工程定义</p><ol type="1"><li>建立并使用完善的工程化原则 ,以较经济的手段获得能在实际机器上有效运行的可靠软件的一系列方法</li><li>软件工程是开发，运行 , 维护和修复软件的系统方法</li><li>"软件工程是：①把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程，也就是把工程应用于软件；②研究①中提到的途径。</li></ol></li><li><p>软件工程三个要素</p><p>过程、方法、工具</p></li></ol><h2 id="第二章-软件生存期模型">第二章 软件生存期模型</h2><h3 id="软件生存期">软件生存期</h3><ol type="1"><li><p>软件生存期由<strong>软件定义</strong>、<strong>软件开发</strong>和<strong>运行维护</strong>三个时期组成，每个时期会包含一系列活动（Activity）和任务（Task）</p><ol type="1"><li><p><strong>活动</strong>：实现某个目的而采取的步骤或执行的责任。可行性分析，软件需求分析，软件体系结构设计等</p></li><li><p><strong>任务</strong>：构成活动的基本元素，一项活动往往有若干任务构成。软件需求分析包含需求抽取，需求分析，需求撰写，需求</p><p>验证等</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607173237.png" style="zoom: 67%;" /></p></li></ol><h3 id="软件过程模型">软件过程模型</h3><h4 id="瀑布模型">瀑布模型</h4><ol type="1"><li><p>介绍</p><ol type="1"><li><p>各项活动按自上而下，相互衔接的固定次序，如同瀑布逐级下落</p></li><li><p>每个阶段必须完成规定的文档；每个阶段结束前完成文档审查</p></li><li><p>阶段间具有顺序性和依赖性</p></li><li><p>质量保证与推迟实现的观点</p></li></ol></li><li><p>优缺点</p><ol type="1"><li>强迫进行规范化、每个阶段都有文档、每个阶段都验证过</li><li>很有可能没法一遍过，不能真正满足用户需求（到后面阶段了发现前面设计的有问题)，不适用于大型软件开发</li></ol></li></ol><h4 id="快速原型模型">快速原型模型</h4><ol type="1"><li><p>介绍</p><p>先开发一个‘原型’软件，完成部分主要功能，展示给用户并征求意见，然后逐步完善，最终获得满意的软件产品</p></li><li><p>分类</p><p>抛弃式原型：为了引出需求方便客户看，之后抛弃</p><p>进化式原型：在这个基础上继续做出成品</p></li><li><p>优缺点</p><ol type="1"><li><p>有助于满足用户的真实需求；</p><p>开发过程的后续阶段不会因为发现规格说明文档的错误而进行较大的返工</p></li><li><p>（进化式原型）系统结构较差</p><p>给用户造成项目已经（接近）完成的错觉</p></li></ol></li></ol><h4 id="增量模型">增量模型</h4><ol type="1"><li><p>介绍</p><p>增量模型把软件产品分解成一系列的增量构件，在增量开发迭代中逐步加入</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607182914.png" style="zoom:67%;" /></p></li><li><p>优缺点</p><ol type="1"><li><p>能在较短时间内向用户提交可完成一些有用的工作产品</p><p>项目失败的风险较低</p><p>最重要的系统服务将接受最多的测试</p></li><li><p>增量构件的划分比较困难</p><p>难以将客户的需求映射到适当规模的增量上</p></li></ol></li></ol><h4 id="螺旋模型">螺旋模型</h4><ol type="1"><li><p>介绍</p><p>将瀑布模型与快速原型模型结合起来，并且加入两种模型均忽略了的<strong>风险分析</strong></p><p>包含四个阶段：制定计划；<strong>风险分析</strong>；开发与验证（实施工程）；评审（评价开发工作）</p></li><li><p>优缺点</p><ol type="1"><li><p>对可选方案和约束条件的强调，有利构件的重用和软件质量的提升</p><p>通过风险分析，最大程度地降低软件彻底失败的可能性</p></li><li><p>螺旋模型是风险驱动的，对软件开发人员要求高，必须具有丰富的风险评估经验和专门知识</p><p>通常只适用大型软件，过大的风险管理支出会影响客户的最终收益</p></li></ol></li></ol><h4 id="统一过程模型">统一过程模型</h4><ol type="1"><li><p>介绍</p><p>包含四个过程阶段和六个核心过程流</p><p>四个阶段：初始阶段、细化阶段、构造阶段、移交阶段</p><p>六个工作流：业务建模工作流、需求工作流、分析和设计工作流、实现工作流、测试工作流、部署工作流</p></li></ol><h2 id="第三章-软件需求工程">第三章 软件需求工程</h2><h3 id="需求分类">需求分类</h3><p>用户需求和软件需求</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607190026.png" style="zoom:67%;" /></p><h3 id="软件需求工程">软件需求工程</h3><p>需求工程通过工程化的过程，方法和工具实现软件需求的获取、分析、文档化、确认和管理。</p><p>前四个是需求开发，最后一个是需求管理</p><h4 id="需求开发">需求开发</h4><ol type="1"><li><p>需求获取</p><p>分析任务：获取系统干系人的原始需求，建立对待开发软件所要解决问题的初步理解，收集软件开发所需的领域知识</p><p>确定需求来源：系统干系人、现有文档、现有系统</p><p><strong>需求获取方法</strong></p><p>​ • 访谈：访谈后使用扎根理论（GroundedTheory）等方法对访谈结果进行<strong>定性</strong>分析</p><p>​ • 专题小组</p><p>​ •问卷调查：所收集数据用于<strong>定量</strong>分析，具有统计学意义</p><p>​ •民族志研究：彻底置身于研究对象的文化和日常生活中，以观察者的身份获取领域知识和用户需求</p><p>​ • 系统原型</p><p>​ • 文档学习</p><p>​ • 同类系统调研</p><p>​ • 用户评论挖掘</p></li><li><p>需求分析</p><ol type="1"><li>问题框架分析</li><li>目标建模分析</li><li>结构化分析：<strong>数据流图</strong>、实体关系图、状态转换图、数据字典等</li><li>面向对象分析：<strong>用例图</strong>、<strong>类图</strong>、时序图、协作图、状态图等</li></ol></li><li><p>文档化</p><p>需求规格说明：精确地阐述一个软件系统必须提供的功能和性能以及它所要考虑的限制条件</p><ol type="1"><li>只描述“做什么”而无须描述“怎么做”</li><li>确保需求是可验证的</li></ol></li><li><p>需求确认</p><ol type="1"><li>需求评审：针对<strong>需求文档</strong>的评审活动</li><li>需求原型：通过动画、界面原型等方式向利益相关者展示开发团队当前对于系统软件需求的理解，从而获取反馈</li></ol></li></ol><h4 id="需求管理">需求管理</h4><p>需求管理贯穿上述四个过程</p><ol type="1"><li><p><strong>需求跟踪管理</strong>：维护需求文档与前继和后续工作成果之间的对应关系，确保产品满足用户需求</p><p>向前追踪、向后追踪</p><p>辅助理解，变更管理，软件复用，项目管理</p></li><li><p><strong>需求优先级管理</strong>：保证重要的需求优先被实现</p><p>优先级分类（KANO）：基本需求、期望需求、兴奋性需求</p></li><li><p><strong>需求变更控制</strong>：对依据规范处理需求变更，防止需求变更失去控制而导致项目混乱</p><p>基本流程：分析评估、变更决策、变更实施、变更发布</p></li></ol><h2 id="第四章-结构化分析方法">第四章 结构化分析方法</h2><h3 id="介绍">介绍</h3><ol type="1"><li><p>定义</p><p>针对用户需求建立抽象的分析模型</p></li><li><p>核心思想</p><p>自顶向下，逐步求精</p></li></ol><h3 id="功能建模">功能建模</h3><h4 id="数据流图">数据流图</h4><ol type="1"><li><p>定义</p><p>从数据传递和加工的角度，以图形的方式刻画数据流从输入到输出的移动变换过程</p></li><li><p>组成</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607192455.png" style="zoom: 67%;" /></p><ol start="3" type="1"><li><p>分层</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607192705.png" style="zoom: 67%;" /></p></li><li><p>例题</p></li></ol><p>​ PPT4 13~14面</p><h3 id="数据建模">数据建模</h3><h4 id="实体关系图">实体关系图</h4><ol type="1"><li>组成</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607193003.png" style="zoom:67%;" /></p><ol start="2" type="1"><li><p>关系类型</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607193927.png" style="zoom:67%;" /></p></li><li><p>例题</p><p>PPT4 p18</p></li></ol><h3 id="行为建模">行为建模</h3><h4 id="状态转换图">状态转换图</h4><ol type="1"><li><p>组成</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607194146.png" /></p></li></ol><h3 id="数据字典">数据字典</h3><ol type="1"><li><p>定义</p><p>对于分析模型中出现的所有数据对象给出准确的定义,三种分析模型的“粘合剂”</p></li><li><p>数据结构定义式</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607194547.png" style="zoom:67%;" /></p></li><li><p>例题</p><p>PPT4 p25~p27</p></li></ol><h2 id="第五章-软件设计">第五章 软件设计</h2><h3 id="软件设计任务和过程">软件设计任务和过程</h3><ol type="1"><li><p>软件设计的目标</p><ol type="1"><li><p>满足所有分析模型中涵盖的需求</p></li><li><p>从实现的角度展示软件在数据、功能、行为等方面的全景图</p></li><li><p>具有可读性，能够被软件开发人员准确地理解性</p></li></ol></li><li><p>软件设计的阶段</p><ol type="1"><li>从工程管理角度: 概要设计阶段和详细设计阶段</li><li>从设计目标维度: 体系结构设计、数据设计、接口设计和过程设计</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607195829.png" style="zoom:67%;" /></p></li><li><p>软件设计的任务</p><ol type="1"><li>体系结构设计: 定义软件系统的各主要成份以及它们之间的关系</li><li>数据设计: 确定数据的组织、彼此的关联、存取方式以及处理方法</li><li>接口设计：在用户和目标系统之间（界面设计）、目标系统内部各模块间（内部接口）、目标系统和其他系统之间（外部接口）构建有效地交流媒介</li><li>过程设计：描述各模块的实现算法</li></ol></li></ol><h3 id="软件设计原则">软件设计原则</h3><ol type="1"><li><p>分而治之</p><ol type="1"><li><p>解决大型复杂问题时通常采用的策略</p></li><li><p>不是越小越好</p></li></ol></li><li><p>模块独立性</p><ol type="1"><li><p>软件系统中每个模块只涉及软件要求的具体的子功能，而和软件系统中其他的模块的接口是简单的</p></li><li><p>独立性比较强的模块应是<strong>高内聚</strong>，<strong>低耦合</strong>的模块</p></li><li><p>两个准则:</p><ol type="1"><li><p>耦合性</p><p>模块之间耦合性越强，功能独立性越差，这样形成的模块结构界面不好</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607200555.png" style="zoom: 80%;" /></p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607200405.png" style="zoom: 67%;" /></p><ol start="2" type="1"><li><p>内聚性</p><p>模块内聚性越强，功能独立性越好，对于形成的模块结构有比较好的作用</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607202734.png" style="zoom:67%;" /></p></li><li><p>信息隐藏: 与正确使用无关的细节信息都应当被隐藏</p></li><li><p>复用性设计: 将复用的思想用于软件开发，称为软件复用</p></li><li><p>灵活性设计:保证软件灵活性设计的关键是<strong>抽象</strong></p></li></ol></li></ol></li></ol><h3 id="软件体系结构">软件体系结构</h3><ol type="1"><li><p>定义</p><p>系统在某种环境下的一组最基本的概念和属性，包括了元素、关系以及设计和演化的原则</p></li><li><p>分类</p><ol type="1"><li>管道和过滤器</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607201341.png" style="zoom: 67%;" /></p><ol start="2" type="1"><li>主程序-子进程体系结构</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607201413.png" style="zoom: 67%;" /></p><ol start="3" type="1"><li>分层体系结构</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607201821.png" style="zoom:67%;" /></p><ol start="4" type="1"><li>客户机/服务器体系结构<ol type="1"><li>瘦客户机模型:所有的应用处理和数据管理都在服务器上执行，客户机只负责表示部分</li><li>胖客户机模型:服务只负责对数据的管理，客户机实现应用逻辑和与用户的交互</li></ol></li></ol><p>### 用户界面设计</p></li><li><p>基于分层框架的设计方法</p><p>逐层进行设计，每一个层关注界面设计的一个特定方面</p></li></ol><p>​ 功能层、架构层、导航层、形式层、细节层</p><ol start="2" type="1"><li><p>界面布局模式</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607202301.png" /></p></li></ol><h2 id="第六章-面向对象方法概述">第六章 面向对象方法概述</h2><h3 id="面向对象">面向对象</h3><ol type="1"><li><p>对象</p><p>系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位，由一组<strong>属性</strong>和对这组属性进行操作的一组<strong>服务</strong>组成</p></li><li><p>类图</p><ol type="1"><li><p>概念类图</p><p>描述<strong>现实世界</strong>的实体与概念，重点反映现实世界问题域，与具体实现技术无关</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607203650.png" style="zoom: 50%;" /></p></li><li><p>分析类图</p><p>与系统实现相关的对象的抽象，由系统设计师绘制，其作用是描述系统的架构结构、指导程序员编码(实体类，边界类，控制类)</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607203712.png" style="zoom: 50%;" /></p></li><li><p>实现类图</p><p>真正考虑程序实现，揭示<strong>软件开发细节</strong></p></li></ol></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607203759.png" style="zoom:50%;" /></p><h3 id="uml">UML</h3><ol type="1"><li>特点<ol type="1"><li>统一标准</li><li>面向对象</li><li>可视化,表达能力强</li><li>独立于过程: UML是系统建模的语言，不依赖特定的开发过程</li><li>容易掌握使用</li><li>与编程语言紧密关联: 可以根据 UML所建立的系统模型自动产生Java、C++等代码框架</li></ol></li></ol><h2 id="第八章-软件构建">第八章 软件构建</h2><ol type="1"><li><p>交互方式</p><p>命令式编程: 做什么,怎么做</p><p>声明式编程:做什么,机器决定怎么做(如数据库查询语言,正则表达式等)</p></li><li><p>逻辑组织</p><p>• 结构化编程</p><p>• 面向对象编程</p><p>• 函数式编程: 结果唯一取决于输入参数</p><p>• 逻辑编程: 事实+规则=结果</p></li></ol><h2 id="第九章-软件测试">第九章 软件测试</h2><p>软件测试是使用人工和自动手段来运行或检测某个系统的过程，其目的在于检验系统是否满足规定的需求并找出与预期结果之间的差别.</p><h3 id="软件测试阶段">软件测试阶段</h3><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607205503.png" style="zoom:67%;" /></p><h4 id="单元测试">单元测试</h4><ol type="1"><li>测试模块接口保证被测程序单元的信息能够正常地流入和流出</li><li>走遍控制结构中的所有独立路径（基本路径）以确保模块中的所有语句至少执行一次</li><li>对所有的错误处理进行测试</li></ol><h4 id="集成测试">集成测试</h4><ol type="1"><li><p><strong>大爆炸集成测试</strong>指在软件开发过程中，先编写各个模块的代码，然后将这些代码一次性地集成到整个系统中进行测试的方法。这种方法的优点是适用于紧急项目和初步设计差异不大的项目，但缺点是容易发现问题，难以定位问题。</p></li><li><p><strong>自顶向下集成测试</strong>指从软件系统的最高层开始，逐步添加和测试下层的模块或组件，直到整个系统被完整集成并测试的方法。这种方法的优点是能够更早地发现整体性问题，但缺点是对底层模块进行测试时需要模拟上层模块的行为。</p></li><li><p><strong>自底向上集成测试</strong>指从底层的模块或组件开始，逐步添加和测试上层的模块或组件，直到整个系统被完整集成并测试的方法。这种方法的优点是对底层模块进行测试比较彻底，但缺点是对于整体性问题可能会晚于自顶向下集成测试发现。</p></li></ol><h4 id="系统测试">系统测试</h4><p>基于软件需求说明书的黑盒测试</p><p>分类: 功能测试, 性能测试(负载测试,压力测试)</p><h4 id="验收测试">验收测试</h4><p>确保软件准备就绪，让最终用户将其用于执行软件的既定功能和任务，测试其需求是否被满足</p><ol type="1"><li>α测试：由一个用户在受控环境下进行的测试</li><li>β测试：由软件的多个用户在实际使用环境下进行的测试</li></ol><h4 id="回归测试">回归测试</h4><p>错误被修正后或软件功能、环境发生变化后进行的重新测试</p><h3 id="主要软件测试技术">主要软件测试技术</h3><h4 id="白盒测试">白盒测试</h4><h5 id="基本路径测试法">基本路径测试法</h5><ol type="1"><li><p>语句覆盖</p><p>使得每个可执行<strong>语句</strong>至少要执行一次</p></li><li><p>判定覆盖(分支覆盖)</p><p>使得程序中每个判断的<strong>取真分支</strong>和<strong>取假分支</strong>至少经历一次</p></li><li><p>条件覆盖</p></li></ol><p>​使得程序中每个判断的每个<strong>条件</strong>的可能取值至少执行一次</p><ol start="4" type="1"><li><p>判定/条件覆盖</p><p>同时满足判定覆盖和条件覆盖的要求</p></li><li><p>条件组合覆盖</p><p>求出判定中所有条件的各种可能组合值</p></li></ol><h5 id="程序控制流图">程序控制流图</h5><p>​ 例题: PPT9 P60</p><h4 id="黑盒测试">黑盒测试</h4><h5 id="等价类划分法">等价类划分法</h5><ol type="1"><li><p>定义</p><p>等价类是某个输入域的子集，在该子集中每个输入数据的作用是等效的</p></li><li><p>分类</p><ol type="1"><li>有效等价类: 可以检查程序是否实现了规格说明中所规定的功能和性能</li><li>无效等价类: 用于检查程序能否妥善处理异常输入数据</li></ol></li><li><p>例题</p><p>PPT9 P78</p></li></ol><h5 id="边界值分析法">边界值分析法</h5><p>确定边界情况(输入或输出等价类的边界).选取正好等于、刚刚大于或刚刚小于边界值作为测试数</p><h4 id="静态测试">静态测试</h4><p>不通过执行被测软件而进行测试的技术</p><h4 id="组合测试">组合测试</h4><p>对部分参数的所有取值组合进行验证，即可有效地发现软件的缺陷——降低测试复杂度</p><p>被测试软件能够抽象为一个受到多个因素（参数）影响的系统，且该因素应当是离散且有限的</p>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式操作系统</title>
    <link href="/2023/05/27/School/%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/05/27/School/%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>分布式操作系统期末复习 <span id="more"></span></p><h3 id="名词">名词</h3><ol type="1"><li>autonomous 自治的，自己管理自己</li><li>Concurrency 并发</li><li>Coordination 协调</li><li>Transparency 透明</li><li>Trade-off 权衡</li><li>latency 延迟</li><li>Homogeneous 同构</li><li>Heterogeneous 异构</li><li>Tightly-coupled 紧耦合</li><li>Paradigm 范式</li><li>Tiered Architecture 分层架构</li><li>synchronous 同步</li><li>asynchronous 异步</li><li>Transient Communication 暂时通信</li><li>Persistent Communication 持久通信</li><li>router 路由</li><li>relay 中继</li><li>Primitives 原语</li><li>Message Brokers 消息代理</li><li>Decoupling 解耦</li><li>Processor allocation 处理器分配</li><li>Deterministic Algorithm 确定性算法</li><li>Heuristic Algorithm 启发式算法</li><li>replica 副本</li><li>Mounting 挂载</li><li>recursive name resolution 递归名称解析</li><li>clock skew 时钟偏移</li><li>concurrent 并发</li><li>Mutual Exclusion 互斥</li><li>critical region 临界区</li><li>Transaction 事务</li><li>cascaded aborts 级联终止</li></ol><h3 id="第一章">第一章</h3><ol type="1"><li><p>分布式操作系统定义</p><p>分布式系统是独立计算机的集合，在其用户看来是一个单一的连贯系统。</p><p>由位于<strong>联网</strong>计算机上的<strong>硬件或软件</strong>组件组成的任何系统，这些组件通过<strong>消息传递</strong>来通信和协调它们的操作。</p></li><li><p>特性</p><ol type="1"><li>Hidden ：Hide the difference and the communication among all kindsof computers</li><li>Consistent and Uniform<br /></li><li>Scalability：伸缩性，即使坏了一部分整个系统也不会瘫痪（允许某些功能不可用了）</li><li>Concurrency ：Coordination among different concurrently executingprograms that share resource</li><li>No Global Clock ：</li></ol></li><li><p>目标</p><ol type="1"><li><p>Making Resources Accessible</p></li><li><p>Distribution Transparency 看起来只有一个电脑</p></li><li><p>Openness</p><p>Mechanism : (How to do it)It need cache</p><p>Policy : (What will be done)Size? • Consistency? • Always or only onesession? • Can user control?</p></li><li><p>Scalability</p></li></ol></li></ol><h3 id="第二章-communication">第二章 Communication</h3><ol type="1"><li><p>UDP offers no guarantee of delivery 不可靠的传输 No setup costs不需要建立连接，额外花销小</p></li><li><p>RPC(Remote Procedure Call)</p><p>Problems:</p><ol type="1"><li>Call by Value：异构的计算机对于相同的字符串的解读不同</li><li>Call by Reference：<ol type="1"><li>For array: copy/restore把整个数组发过去，搞完之后再发回本机修改</li><li>For ordinary pointer 接收机器拿着指针回来找</li></ol></li><li>How to Create Stub：Interface Definition Language(IDL)使用统一接口</li></ol></li><li><p>RMI（Remote Method Invocation）</p><p>Client:Proxy</p><p>Server:Skleton</p><p>RMI and RPC are same theoretically.</p></li><li><p>同步通信收发都是堵塞的，异步通信发是非堵塞的收都可以</p></li><li><p>Transient communication:A message is not stored in communicationsystem 瞬时通信不存储信息</p><ol type="1"><li>Sockets Interface<ol type="1"><li>TCP/UDP</li><li>IP Multicast: IP multicast is available only via UDP</li></ol></li><li>MPI(Message Passing Interface standard)</li></ol></li><li><p>Persistent Communication:A message is stored in communicationsystem until it is sent to receiver 持久通信</p><ol type="1"><li>Message Queue Model 保证一定送达但是不保证时间长短<ol type="1"><li>router：进行接收转发</li><li>relay：接收之后进行处理 Relay can build a scalable message-queuingsystem</li><li>Application of Message Queue System<ol type="1"><li>Asynchronization 异步</li><li>Decoupling of application 解耦</li><li>Flow Cutting 流切割</li></ol></li></ol></li></ol></li><li><p>Stream Oriented Communication</p><ol type="1"><li><p>Continuous representation media: Temporal relationship betweendata items is IMPORTANT to explain the meaning of data.</p></li><li><p>Discrete representation media: Temporal relationship between dataitems is NOT IMPORTANT to explain the meaning of data</p></li><li><p>Transmission types</p><ol type="1"><li><p>Asynchronous transmission mode</p><p>Data items are transmitted one by one. No time restriction ontransmission.</p></li><li><p>Synchronous transmission mode</p><p>Every data item has a maximum end-to-end delay defined for each unitin a data stream.</p></li><li><p>Isochronous transmission mode</p><p>Data item must be transmitted on time.</p></li></ol></li><li><p>Interleaving frames 交错帧，减小数据包丢失的影响</p></li><li><p>QoSNegotiation是一种网络协议，用于协商和确定网络中各种流量的优先级、带宽、延迟等服务质量参数。</p></li></ol></li></ol><h3 id="第三章">第三章</h3><ol type="1"><li><p>Server Classification</p><ol type="1"><li>Iterative Server：Server is responsible for dealing with request andreturn the result to client</li><li>Concurrent Server：Server doesn’t deal with request from client. Itsends the request to a thread or a process,then wait for nextrequest</li></ol></li><li><p><strong>Out-of-band</strong> data ： data that is to be processedby the server before any other data from thatclient.优先级很高，需要及时处理</p></li><li><p>Stateless Server：Don’t save any information about client</p><p>Server with state：Maintain information about client</p></li><li><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230606232439.png" style="zoom:50%;" /></p></li><li><p>Code Migration</p><ol type="1"><li><p>Process migration ：An entire process was moved from one machineto another.</p><ol type="1"><li><p>Weak Mobility: Only migrate code segment and some initializationdata</p></li><li><p>Strong Mobility: Migrate the code segment and the executingsegment</p></li></ol></li><li><p>Resource Migration:</p><ol type="1"><li>Process-Resource Binding: ID,Value,Type</li><li>Resource-Machine Binding: Unattached Resource,FastenedResource,Fixed Resource</li></ol></li></ol></li><li><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607005703.png" style="zoom:50%;" /></p></li><li><p>Processor Allocation Algorithm</p><ol type="1"><li>Deterministic Algorithm：Know all information about allprocesses</li><li>Heuristic Algorithm：The load of a system is unpredictable.</li></ol></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607010738.png" style="zoom:50%;" /></p><h3 id="第四章">第四章</h3><ol type="1"><li>Flat Naming</li><li>Struct Naming<ol type="1"><li>Iterative NameResolution:迭代名称解析：每一层都给服务器发，然后服务器返回下一层地址</li><li>Recursive NameResolution：递归名称解析：主机只发一次，服务器之间进行通讯完成工作</li></ol></li><li>Attribute-Based Naming：To describe an entity in terms of(attribute,value) pairs</li></ol><h3 id="第五章">第五章</h3><ol type="1"><li><p>物理时钟</p><ol type="1"><li>Cristian Algorithm<ol type="1"><li>如果有一个有WWV接收器的机器，其他机器都可以向这个机器请求时间</li><li>Time is not allowed to runbackward.如果一个机器的时间在同步时钟之后，时间回溯是不被允许的</li></ol></li><li>Berkeley Algorithm<ol type="1"><li>Time server polls the time of every machine</li><li>Average the results and tell the time to other machine</li></ol></li><li>Averaging Algorithm<ol type="1"><li>Every machine broadcast its time to others in every timeinterval</li><li>After broadcasting,machine collect time response from other machinesin an interval S</li><li>Average all the time values，Discard m highest and m lowest</li><li>Try to add an estimated time delay to correct the time</li></ol></li><li>应用: Network Time Protoc ol (NTP)</li></ol></li><li><p>逻辑时钟</p><ol type="1"><li><p>为什么不用物理时钟</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607101629.png" style="zoom: 50%;" /></p></li><li><p>Lamport’s Logical Clocks</p><pre><code class="hljs">1. If a and b are two events in a **same process**,and a happens before b,then a→b is true    2. If a is a **sending** event of a message in a process,b is receiving event of this message in another process,then a→b is true    3. If a→b is not true,b→ a is not true,a and b is concurrent 并发</code></pre><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607104453.png" style="zoom:50%;" /></p></li></ol></li><li><p>Vector Clocks</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607104716.png" style="zoom:50%;" /></p><ol start="4" type="1"><li><p>Election Algorithm</p><ol type="1"><li>Bully Algorithm</li></ol><p>进程P发现协调员(coordinator)无法工作，发起一个选举，给所有比自己PID大的进程Q发消息，要是应答了则P放弃，Q继续上述过程，直到只剩一个，成为新的协调员</p><ol start="2" type="1"><li><p>Ring Algorithm</p><p>逻辑上的环，每个进程知道自己的后继进程。转一圈之后选PID最大的当新协调员。</p></li></ol></li><li><p>Mutual Exclusion</p><ol type="1"><li><p>Centralized Algorithm</p><p>P是协调者，Q想进去要问P，能进就可以，不能进Q就进等待队列。里面的进程出来之后授权队列头进程</p></li><li><p>Distributed Algorithm</p><p>P想进去，发请求给所有进程Q，要是Q不想进去就发ok回来，要是Q就在里面就不回应，要是Q也想进去就比较时间戳，要是比自己早就回ok</p></li><li><p>Token Ring Algorithm</p><p>一个令牌在环里绕，拿到令牌的可以进去。</p><p>这个算法不是一个fair algorithm，前面俩都是fair algorithm</p></li></ol></li><li><p>Distributed Transaction</p><p>A transaction can • Protect shared resource from concurrent accesses• Permit a process read and write several data items as if it is readand written by a single atomic operation</p><ol type="1"><li><p>Characteristics</p><ol type="1"><li><p>Atomic • A transaction cannot be separated.</p></li><li><p>Consistent • A transaction cannot spoil the consistent item ofsystem.</p></li><li><p>Isolated • Concurrent transaction cannot affect eachother.</p></li><li><p>Durable • Once a transaction is committed,the change will bepermanent.</p></li><li><p>RollBack</p></li><li><p>Private Workspace: Give a private workspace to a transaction whenit begins</p><p>All data are read and written in the private workspace until thetransaction is committed or failed</p></li></ol></li><li><p>Writeahead Log</p><ol type="1"><li><p>Before a file is updated,a record is written in a log</p></li><li><p>Only after write the log successfully,the change can be committedto the file</p><ol start="2" type="1"><li>Serial Equivalence</li></ol></li></ol></li><li><p>Several transactions can be executed at the same time but thefinal result is the same as the situation that all transactions areexecuted one by one</p></li><li><p>Two Concurrent Control Methods</p><ol type="1"><li><p>Pessimistic approaches 不允许可能出现的问题</p><p>Timestamp Ordering</p><ol type="1"><li>A transaction’s request to <strong>write</strong> an object is validonly if that object was last read and written by earliertransactions</li><li>A transaction’s request to <strong>read</strong> an object is validonly if that object was last written by earlier transactions</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607153228.png" style="zoom:50%;" /></p></li><li><p>Optimistic approaches 可以有问题，回滚就行了</p></li></ol></li></ol></li></ol><h3 id="第六章">第六章</h3><ol type="1"><li><p>Replication 副本</p><ol type="1"><li><p>为什么需要副本</p><p>• Reliability</p><p>• Performance</p><p>• Fault tolerance</p></li><li><p>CAP</p><ol type="1"><li>Partition Tolerance 分区容错性<ol type="1"><li>Every subnetwork is called a partition</li><li>The system still work when communication fail</li></ol></li><li>Consistency 一致性<ol type="1"><li>All replica in the system should be consist</li></ol></li><li>Availability 可用性<ol type="1"><li>All nodes in the system can be used when user need it</li></ol></li><li>上述三个不能bingcun<ol type="1"><li>如果想有P，那肯定得有预留的副本，那么一致性和全可用性就不可能实现</li><li>如果想有CA,那P肯定不能实现</li></ol></li></ol></li><li><p>一致性</p><ol type="1"><li>Strict Consistency<ol type="1"><li>Any read operation on data item x can return back the result of lastwrite on x.</li><li>Depend on absolute global time</li></ol></li><li>Sequential Consistency<ol type="1"><li>The result of all process’s read and write operation are the same asif they are executed according to a specific order.</li><li>一个进程内部执行顺序一致就行，俩进程谁先谁后无所谓？</li></ol></li><li>Linearizability<ol type="1"><li>every operation has a timestamp,and satisfies followingcondition</li><li>时间在前的先发生</li></ol></li><li>Causal Consistency<ol type="1"><li>Writes that are potentially causally related must be seen by allprocesses in the same order.</li><li>得分析前面的潜在因果关系，要是俩写操作判断不出来谁前谁后，那读的时候谁前谁后都可以</li></ol></li></ol></li><li><p>修改的传播方法</p><ol type="1"><li><p>Only propagate a notification of an update</p><p>告诉别人我已经改了，别再用那个旧的了</p></li><li><p>Transfer data from one copy to another</p><p>把改了的数据发给别人</p></li><li><p>Propagate the update to other copies</p><p>告诉别人我怎么改的</p></li></ol></li><li><p>传染病模型</p><ol type="1"><li><p>传统的方法是P一个人告诉其他所有人更新消息，传染病模型是P告诉Q之后，PQ一起告诉别人</p></li><li><p>Anti-Entropy Model 反熵模型</p><p>A server P select another server Q randomly and exchangeupdates</p></li><li><p>Gossiping Model 八卦模型</p><p>P拿到更新之后随机再告诉别人要更新</p></li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高数下串讲</title>
    <link href="/2023/05/17/School/%E9%AB%98%E6%95%B0%E4%B8%8B%E4%B8%B2%E8%AE%B2/"/>
    <url>/2023/05/17/School/%E9%AB%98%E6%95%B0%E4%B8%8B%E4%B8%B2%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>朋辈讲师高数下串讲 <span id="more"></span></p><h3 id="多元函数微分">多元函数微分</h3><ol type="1"><li>偏导定义</li><li>判断是否可微 P161</li><li>判断偏导是否连续 P161，P165例1.11.2</li><li>复合函数求偏导 P166 例1.11.3</li><li>隐函数公式证明 P162</li><li>无条件极值、条件极值、拉格朗日乘数法 P165 P168 P169</li><li>例1.11.8</li></ol><h3 id="二重积分">二重积分</h3><ol type="1"><li><p>对称性P176，注例，P178例1.12.2</p></li><li><p>交换积分次序 P180 例1.12.8</p></li><li><p>直角坐标和极坐标的转换 P179 例1.12.5</p></li></ol><h3 id="section"></h3>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基础-小作业</title>
    <link href="/2023/05/07/School/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E5%B0%8F%E4%BD%9C%E4%B8%9A/"/>
    <url>/2023/05/07/School/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E5%B0%8F%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<p>基于华为云平台使用机器学习算法进行鸢尾花数据集分类 <span id="more"></span></p><h3 id="实验环境搭建">实验环境搭建</h3><ol type="1"><li><p>首先访问华为云的modelarts平台：https://console.huaweicloud.com/modelarts/，在左侧找到<strong>开发环境</strong>，选择Notebook并点击创建，如下图所示。</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230508124116.png" /></p></li><li><p>随后在创建界面指定名称，设置自动停止可以保证不会忘记关闭服务器而造成损失，镜像根据需求选择即可。其他默认，点击<strong>立即创建</strong>并提交，等待创建完成即可。</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230508124205.png" /></p></li><li><p>点击<strong>打开</strong>，即可进入服务器操作页面</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230508124525.png" /></p></li><li><p>左上角蓝色箭头可以上传文件到服务器，右侧可以选择交互的平台，本次选择Notebook。打开后即可进入代码编写阶段。</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230508124636.png" /></p></li></ol><h3 id="核心代码">核心代码</h3><p>本文使用<strong>sklearn</strong>实现若干模型对鸢尾花数据集的分类。由于本次实验选择的数据集为鸢尾花的前两类，他们之间是线性可分的，因此理想情况下分类准确率应为100%.</p><ol type="1"><li><p>头文件导入</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.rcParams[<span class="hljs-string">&quot;font.sans-serif&quot;</span>]=[<span class="hljs-string">&quot;SimHei&quot;</span>] <span class="hljs-comment">#设置字体</span><br>plt.rcParams[<span class="hljs-string">&quot;axes.unicode_minus&quot;</span>]=<span class="hljs-literal">False</span> <span class="hljs-comment">#该语句解决图像中的“-”负号的乱码问题</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br></code></pre></td></tr></table></figure></p></li><li><p>数据预处理</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">data = pd.read_csv(<span class="hljs-string">&quot;iris.data&quot;</span>,header=<span class="hljs-literal">None</span>)[:<span class="hljs-number">100</span>]<br>x = data.iloc[:,:<span class="hljs-number">4</span>]<br>y = []<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data.iloc[:<span class="hljs-number">100</span>,<span class="hljs-number">4</span>]:<br>    <span class="hljs-keyword">if</span> item == <span class="hljs-string">&#x27;Iris-setosa&#x27;</span>:<br>        y.append(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">else</span>:<br>        y.append(<span class="hljs-number">1</span>)<br>X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>线性模型</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><br>model = LogisticRegression()<br><br>model.fit(X_train, y_train)<br><br>y_pred = model.predict(X_test)<br><br>accuracy = accuracy_score(y_test, y_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy: &#123;:.2f&#125;%&quot;</span>.<span class="hljs-built_in">format</span>(accuracy * <span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure></p></li><li><p>决策树</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier<br>model = DecisionTreeClassifier()<br><br>model.fit(X_train, y_train)<br><br>y_pred = model.predict(X_test)<br><br>accuracy = accuracy_score(y_test, y_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy: &#123;:.2f&#125;%&quot;</span>.<span class="hljs-built_in">format</span>(accuracy * <span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure></p></li><li><p>其他</p><p>由于sklearn的模型接口一致，除model的定义不同外其他均一致，因此后续只给出头文件以及model定义</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 支持向量机</span><br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC<br>model = SVC()<br><br><span class="hljs-comment"># 贝叶斯</span><br><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB<br>model = GaussianNB()<br><br><span class="hljs-comment"># 神经网络</span><br><span class="hljs-keyword">from</span> sklearn.neural_network <span class="hljs-keyword">import</span> MLPClassifier<br>model = MLPClassifier(hidden_layer_sizes=(<span class="hljs-number">10</span>,), max_iter=<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment"># 集成学习（以随机森林为例）</span><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br>model = RandomForestClassifier()<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="结果和总结">结果和总结</h3><ol type="1"><li>实验结果</li></ol><p>​通过在华为云平台的Notebook运行，所有分类的准确率均为100%，符合预期。</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/result.png" /></p><ol start="2" type="1"><li><p>总结</p><p>通过本次实验，我深入了解了华为云平台具有创建方便、使用方式简洁、资源充足、不占有本机资源等优点，并通过实际操作熟悉了其使用方法，使我能够更加便捷地进行机器学习和数据处理等任务。</p><p>在本次实验中，我们采用了鸢尾花数据集进行二分类任务，通过理论学习和实践操作的结合，我掌握了机器学习中数据预处理、模型训练和评估等基本流程，提升了我的数据分析和模型建立能力。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛打印</title>
    <link href="/2023/05/04/Algorithm/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%B0/"/>
    <url>/2023/05/04/Algorithm/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%B0/</url>
    
    <content type="html"><![CDATA[<p>经典的算法题 <span id="more"></span></p><h3 id="背包问题">背包问题</h3><p>给定 N 个正整数 A1,A2,…，从中选出若干个数，使它们的和为M，求有多少种选择方案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[<span class="hljs-number">110</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">110</span>][<span class="hljs-number">10010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(a[i]&lt;=j) dp[i][j] = dp[i][j] + dp[i<span class="hljs-number">-1</span>][j-a[i]];<span class="hljs-comment">// 两个方案加起来</span><br>        &#125;<br>    &#125;<br>    <br>    cout&lt;&lt;dp[n][m];<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="判断闰年">判断闰年</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(x%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;x%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span> || x%<span class="hljs-number">400</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="蛇形数组">蛇形数组</h3><p>注意算a[20,20]要满足j&gt;=20 &amp;&amp; i-j+1 &gt;=20,i要算到40多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">300</span>][<span class="hljs-number">300</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> reverse = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">50</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(reverse)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++) &#123;<br>                a[j][i - j + <span class="hljs-number">1</span>] = cnt++;<br>                cout&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;i-j+<span class="hljs-number">1</span>&lt;&lt;endl;<br>            &#125;<br>            reverse = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++) &#123;<br>                a[i - j + <span class="hljs-number">1</span>][j] = cnt++;<br>                cout&lt;&lt;i-j+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;endl;<br>            &#125;<br>            reverse = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;a[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="正方形内的z字数组">正方形内的Z字数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> a[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            cin &gt;&gt; a[i][j];<br><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(x != n || y != n)&#123;<br>        <span class="hljs-keyword">if</span>(x &lt; n &amp;&amp; y &lt; n)<br>            cout &lt;&lt; a[x][y] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">if</span>(flag) x--, y++;<br>        <span class="hljs-keyword">else</span> x++, y--;<br><br>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>) &#123;<br>            x = <span class="hljs-number">0</span>;<br>            flag = !flag;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(y &lt; <span class="hljs-number">0</span>)&#123;<br>            y = <span class="hljs-number">0</span>;<br>            flag = !flag;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维涂色差分">二维涂色差分</h3><p>给定两个点(x1,y1),(x2,y2)，对其中间的格子进行涂色，问最后有多少个格子被涂色</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> map[N][N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;<br>        x1++;<span class="hljs-comment">// 注意区分点和格子</span><br>        y1++;<br>        map[x1][y1] ++;<br>        map[x1][y2+<span class="hljs-number">1</span>] --;<br>        map[x2+<span class="hljs-number">1</span>][y1] --;<br>        map[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]++;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;N;j++)&#123;<br>            map[i][j] = map[i<span class="hljs-number">-1</span>][j] + map[i][j<span class="hljs-number">-1</span>] - map[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + map[i][j];<br>            <span class="hljs-keyword">if</span>(map[i][j] &gt; <span class="hljs-number">0</span>) res++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串子串查找">字符串子串查找</h3><p>给出一个字符串和多行文字，在这些文字中找到字符串出现的那些行。你的程序还需支持大小写敏感选项：当选项打开时，表示同一个字母的大写和小写看作不同的字符；当选项关闭时，表示同一个字母的大写和小写看作相同的字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function">string <span class="hljs-title">to_lower</span><span class="hljs-params">(string s)</span></span>&#123;<br>    string temp = s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temp.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(temp[i]&gt;=<span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; temp[i]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>) temp[i] = temp[i] -<span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-string">&#x27;a&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string refer;<br>    cin&gt;&gt;refer;<br>    <span class="hljs-type">int</span> sign;<br>    cin&gt;&gt;sign;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">if</span>(!sign) refer = <span class="hljs-built_in">to_lower</span>(refer);<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        string s;<br>        cin&gt;&gt;s;<br>        string temp = s;<br>        <span class="hljs-keyword">if</span>(!sign) temp = <span class="hljs-built_in">to_lower</span>(s);<br><br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">find</span>(refer)!=string::npos)&#123;<br>            cout&lt;&lt;s&lt;&lt;endl;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统复习</title>
    <link href="/2023/05/03/School/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/05/03/School/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>操作系统基础知识复习 <span id="more"></span></p><h2 id="计算机系统概述">计算机系统概述</h2><ol type="1"><li><p>计算机自下而上的四个部分：硬件、操作系统、应用程序、用户。</p></li><li><p>操作系统定义：指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。</p></li><li><p>操作系统的四个特征:<strong>并发</strong>、<strong>共享</strong>、虚拟、异步(P2)。前两者必须实现。</p></li><li><p>操作系统为用户提供了两种接口：命令接口和程序接口。前者分为联机命令接口（交互式命令接口，在终端一问一答）和脱机命令接口（批处理系统，用户无法干预过程）。后者由一组系统调用组成。</p></li><li><p>操作系统发展历程</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230503155929.png" style="zoom:67%;" /></p></li><li><p>计算机通过硬件完成操作系统由用户态到核心态的转换。</p></li><li><p>操作系统主要的四种结构</p><ol type="1"><li><p>分层法：自底向上逐层验证</p><ol type="1"><li>优点：便于系统的调试和验证，简化了系统的设计和实现；易扩充和易维护</li><li>缺点：合理定义各层比较困难；效率差（需要穿越多层）</li></ol></li><li><p>模块化：按功能分为若干个模块，向外提供接口</p><ol type="1"><li>优点：提高操作系统的正确性、可解释性和可维护性；增强了操作系统的可适应性；加速了操作系统的开发过程</li><li>缺点：接口规定难以满足对接口的实际需求；无法可靠的决定开发顺序</li></ol></li><li><p>宏内核：将系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为用户程序提供高性能的系统服务。</p></li><li><p>微内核：将内核中最基本的功能保留在内核，将不需要在和心态执行的功能移到用户态执行</p><p>操作系统中绝大部分功能都放在微内核外的一组服务器（进程）中实现，只有微内核运行在内核态，是C/S模式。</p><p>优点：扩展性和灵活性；可靠性和安全性；可移植性；分布式计算</p></li></ol></li><li><p>操作系统的<strong>引导过程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625005915.png" style="zoom: 50%;" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625005955.png" /></p></li></ol><h2 id="进程与线程">进程与线程</h2><h3 id="进程与线程-1">进程与线程</h3><ol type="1"><li><p>进程的组成：PCB、程序段、数据段</p></li><li><p>进程的<strong>创建过程</strong>（原语）</p><ol type="1"><li>为新进程分配一个唯一的进程标识号，并申请一个空白PCB(PCB是有限的)。若PCB申请失败，则创建失败。</li><li>为进程分配其运行所需的资源，如内存、文件、I/O设备和CPU时间等（在PCB中体现)。这些资源或从操作系统获得，或仅从其父进程获得。如果资源不足（如内存），则并不是创建失败，而是处于创建态，等待内存资源。</li><li>初始化PCB,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</li><li>若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。</li></ol></li><li><p>进程的<strong>终止过程</strong>（原语）</p><ol type="1"><li>根据被终止进程的标识符，检索出该进程的PCB,从中读出该进程的状态。</li><li>若被终止进程处于运行状态，立即终止该进程的执行，将处理机资源分配给其他进程。</li><li>若该进程还有子孙进程，则应将其所有子孙进程终止。</li><li>将该进程所拥有的全部资源，.或归还给其父进程，或归还给操作系统。</li><li>将该PCB从所在队列（链表）中删除。</li></ol></li><li><p><strong>进程的通信</strong>包含三种：共享存储、消息传递（直接通信、间接通信）、管道通信</p></li><li><p>为什么<strong>引入进程</strong></p><p>在多道程序同时运行的背景下，进程之间需要共享系统资源，因此会导致各程序在执行过程中出现相互制约的关系，程序的执行会表现出间断性的特征。这些特征都是在程序的执行过程中发生的，是动态的过程，而传统的程序本身是一组指令的集合，是一个静态的概念，无法描述程序在内存中的执行情况，即我们无法从程序的字面上看出它何时执行、何时停顿，也无法看出它与其他执行程序的关系，因此，程序这个静态概念己不能如实反映程序并发执行过程的特征。为了深刻描述程序动态执行过程的性质乃至更好地支持和管理多道程序的并发执行，人们引入了进程的概念。</p></li></ol><h3 id="处理机调度">处理机调度</h3><ol type="1"><li><p>调度的层次</p><ol type="1"><li><p>高级调度（作业调度）</p><p>按照一定原则从外存上处于后备队列的作业中挑选一个分配资源建立相应进程使他们获得竞争处理机的权利。是内存与辅存之间的调度</p></li><li><p>中级调度（内存调度）</p><p>为了提高内存利用率和系统吞吐量，将暂时不能运行的进程调至外存等待，将状态改为挂起态。当运行条件具备且内存有空闲时再调入内存</p></li><li><p>低级调度（进程调度）</p><p>从就绪队列中选择一个进程执行</p></li></ol></li><li><p>评价指标</p><ol type="1"><li>CPU利用率：有效工作时间/总时间</li><li>系统吞吐量：单位时间CPU完成作业的数量</li><li>周转时间：作业完成时间-作业提交时间</li><li>等待时间：进程处于等处理机的时间之和</li><li>响应时间：从用户提交请求到系统首次响应所用的时间</li></ol></li><li><p>上下文切换过程</p><ol type="1"><li>挂起一个进程，保存CPU上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>跳转到新进程PCB中的程序计数器所指向的位置执行。</li><li>恢复处理机上下文。</li></ol></li></ol><h3 id="同步与互斥">同步与互斥</h3><ol type="1"><li><p>等待时间：等待CPU的时间；周转时间：作业完成时间-作业提交时间；响应比：<spanclass="math inline">\(\frac{等待时间+要求服务时间}{要求服务时间}\)</span></p></li><li><p>同步与互斥</p><ol type="1"><li><p>同步：同步是指多个进程或线程之间的协作，按照一定的顺序执行，保证数据的正确性和一致性。通常使用信号量、事件等机制实现。</p></li><li><p>互斥：互斥是指多个进程或线程之间的竞争，保证同一时间只有一个进程或线程能够访问共享资源，避免数据的竞争和冲突。通常使用互斥锁、读写锁等机制实现。</p></li><li><p>区别：同步和互斥都是为了保证多个进程或线程之间的正确性和一致性，但它们侧重点不同。同步主要关注不同进程或线程之间的协作和顺序执行，而互斥则主要关注共享资源的竞争和访问控制。同时，同步可以用于实现互斥，但互斥不能实现同步。</p></li></ol></li></ol><h3 id="死锁">死锁</h3><ol type="1"><li><p>死锁产生的必要条件</p><ol type="1"><li>互斥:对资源进行排他性使用</li><li>不剥夺:进程的资源在未使用完之前,不能被其他进程夺走</li><li>请求并保持:进程已经保持了至少一个资源,但又提出了新的资源请求,而该资源已被其他进程占有</li><li>循环等待:存在一个资源的循环等待链</li></ol></li><li><p>死锁预防</p><ol type="1"><li>破坏互斥条件:比如打印机,肯定不可行</li><li>破坏不剥夺条件:确实可以,但是会增加系统开销,可以用于易于保存和恢复的资源比如CPU的寄存器和内存资源</li><li>破坏请求并保持条件:进程在运行前申请所有需要的资源,如果资源不足就等待,资源足够后一次性分配.</li><li>破坏循环等待条件:采用顺序资源分配法,给每个资源一个编号,每个进程必须按照编号递增的顺序请求资源,同类资源一次申请完.</li></ol></li><li><p>死锁避免</p><ol type="1"><li><p>银行家算法</p><p>要求每个进程给出最大的资源请求量MAX,已知每个进程的现在资源占有量ALLO.对于一个新的资源请求NEW,首先检查NEW+ALLO是否大于MAX,若大于则不予分配.然后检查如果分配了,系统是否还是安全状态(找到一个安全序列),如果是就可以进行分配.</p></li></ol></li><li><p>死锁检测和<strong>解除</strong></p><ol type="1"><li>资源剥夺法:挂起某些死锁进程并抢占他的资源,将这些资源分配给其他死锁进程.</li><li>撤销进程法:撤销部分或者全部死锁进程并剥夺资源</li><li>进程回退法:让一个/多个进程回退到足以回避死锁的地步</li></ol></li></ol><h2 id="内存管理">内存管理</h2><h3 id="内存管理概念">内存管理概念</h3><ol type="1"><li><p>交换与覆盖：覆盖是在同一个程序或者进程中进行的，交换是在不同进程之间进行的。</p></li><li><p>连续分配管理方式</p><ol type="1"><li>单一连续分配：内存分为系统区和用户区，用户区中只有一道用户程序</li><li>固定分区分配：分区大小可以相同也可以不同，会产生内部碎片</li><li>动态分区分配：分配策略：首次适应、邻近适应、最佳适应、最坏适应，会产生外部碎片</li></ol></li><li><p>基本分页存储管理</p><ol type="1"><li><p>系统为每个进程建立一个页表，他记录页面在内存中对应的物理块号</p></li><li><p>基本地址变换</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010241.png" style="zoom:67%;" /></p></li><li><p>快表（TLB）：由页号+块号组成，是高速缓冲存储器</p><p>基本的分页存储需要先到页表查找对应的物理块号然后再去访存，需要经过两次访存。快表根据局部性原理将最近访问过的页面存储起来，直接建立页号+块号的结构，可以快速定位到物理块号</p></li></ol></li><li><p>基本分段存储管理</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230504213228.png" /></p><p>段的共享是通过两个作业的段表中相应表项指向被共享的段的统一物理副本实现的</p></li><li><p>段页式管理</p><ol type="1"><li><p>分页存储能够有效提高内存利用率，分段存储能够反映程序的逻辑结构并有利于段的共享和保护</p></li><li><p>系统为贝格进程建立一张段表，每个分段有一张页表。段表表项至少包含段号、页表长度和页表始址，页表表项至少包括页号和块号</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010326.png" style="zoom: 50%;" /></p></li></ol></li></ol><h3 id="虚拟内存管理">虚拟内存管理</h3><ol type="1"><li><p>基于局部性原理，在程序装入时，仅须将程序当前要运行的少数页面或段先装入内存，而将其余部分暂留在外存，便可启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存容量大得多的存储器，称为虚拟存储器。</p></li><li><p>程序局部性原理</p><ol type="1"><li>时间局部性：由于程序中存在大量的循环操作，程序中的某条指令一旦执行，不久后该指令可能再次执行；某数据被访问过，不久后该数据可能再次被访问。</li><li>空间局部性：一旦程序访问了某个存储单元，不久后其附近的存储单元也会被访问，即程序在一段时间内所访问的地址可能集中在一定的范围之内，因为指令通常是顺序存放、执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li><li>时间局部性通过将近来使用的指令和数据保存到高速缓存中，并使用高速缓存的层次结构实现。空间局部性通常使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上建立了“内存-外存”的两级存储器结构，利用局部性原理实现高速缓存。</li></ol></li><li><p>置换算法</p><ol type="1"><li>最佳置换算法（OPT）：淘汰最长时间内不再被访问的页面</li><li>先进先出算法(FIFO)：淘汰最早进入内存的页面</li><li>最近最久未使用算法（LRU）：淘汰最近最长时间未访问过的页面</li><li><strong>Belady异常</strong>：分配的物理块数增大但缺页率不减反增。只有FIFO有这种现象</li></ol></li></ol><h2 id="文件管理">文件管理</h2><ol type="1"><li><p>文件系统的<strong>逻辑结构</strong>分为无结构文件（流式文件）和有结构文件</p></li><li><p>文件分配磁盘块方式（物理结构）</p><ol type="1"><li><p>连续分配</p></li><li><p>链接分配</p><ol type="1"><li>隐式链接：目录项中含有文件的第一块的指针和最后一块的指针。每个盘块都含有指向下一个盘块的指针</li><li>显式链接：把指针显式的放在一张表中</li></ol></li><li><p>索引分配：设置索引块记录所有分配的块</p></li><li><p>混合索引分配</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010348.png" style="zoom:50%;" /></p></li></ol></li><li><p>虚拟文件系统（VFS）</p><p>为用户提供了文件系统操作的统一接口，屏蔽了不同文件系统带来的差异和操作细节。</p></li></ol><h2 id="输入输出管理">输入/输出管理</h2><ol type="1"><li>设备可以分为块设备和字符设备</li><li>I/O接口指设备控制器，组成如下</li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010408.png" style="zoom:67%;" /></p><ol start="3" type="1"><li>I/O端口指设备控制器中可被CPU直接访问的寄存器，主要包括数据寄存器、状态寄存器、控制寄存器</li><li>端口可以独立编址采用特殊内核指令，也可以统一编址使用内存空间</li><li>I/O控制分为程序直接控制、中断驱动、DMA，参考计组</li><li>I/O软件层次结构<ol type="1"><li>用户层I/O软件：实现与用户交互的接口，用户可直接调用在用户层提供的库函数</li><li>设备独立性软件：使得应用程序独立于具体使用的物理设备</li><li>设备驱动程序：与硬件直接相关，负责具体实现系统对设备发出的操作指令</li><li>中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完毕后再恢复中断现场返回中断程序</li></ol></li><li>设备独立性：用户在编程序时使用的设备与实际设备无关，一个程序应独立于分配给他的某类设备的具体设备，即在用户程序中只指明I/O使用的设备类型即可</li><li>在磁盘上进行一次读写的时间由寻道时间、延迟时间和传输时间决定。<ol type="1"><li>寻道时间：将磁头移动到指定磁道所需要的时间（时间最长）</li><li>延迟时间：磁头定位到某一磁道的扇区所需要的时间</li><li>传输时间：从磁盘读出或向磁盘写入数据所需要的时间</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法提高课</title>
    <link href="/2023/04/27/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%8F%90%E9%AB%98%E8%AF%BE/"/>
    <url>/2023/04/27/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%8F%90%E9%AB%98%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<p>算法提高课的DP题 <span id="more"></span></p><h3 id="最长上升子序列">最长上升子序列</h3><ol type="1"><li><p><a href="https://www.acwing.com/problem/content/484/">482.合唱队形 - AcWing题库</a></p></li><li><p><a href="https://www.acwing.com/problem/content/1014/">1012.友好城市 - AcWing题库</a></p></li></ol><h3 id="背包">背包</h3><ol type="1"><li><ahref="https://www.acwing.com/problem/content/description/280/">278.数字组合 - AcWing题库</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/2023/04/24/School/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/2023/04/24/School/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>编译原理易错知识点 <span id="more"></span></p><h3 id="文法">文法</h3><ol type="1"><li><p>符号串真前缀、真后缀、真子串要求<strong>非空</strong>且不等于原串</p></li><li><p>终结符与非终结符的交集为空集</p></li><li><p>开始符号S至少必须在某个产生式的左部出现一次</p></li><li><p>高级程序设计语言的语法可以用2型文法描述</p></li><li><p>高级程序设计语言的词法可以用3型文法描述</p></li><li><p>使用<strong>正规式</strong>、<strong>正规文法</strong>描述高级程序设计语言的单词结构</p></li></ol><h4 id="正规式">正规式</h4><ol type="1"><li><p>正规文法是3型文法，左线性表示为A-&gt;w或A-&gt;Bw;右线性表示为A-&gt;w或A-&gt;wB</p></li><li><p><span class="math display">\[A=r_1^*=\varepsilon | r_1^+=\varepsilon|r_1r_1^*=\varepsilon|r_1A\]</span></p><p><span class="math display">\[A=r_1^+=r_1r_1^*=r_1(\varepsilon|r_1^+)=r_1|r_1r_1^+=r_1|r_1A\]</span></p><p><span class="math display">\[A=r_1^*r_2=(\varepsilon|r_1^+)r_2=r_2|r_1^+r_2=r_2|r_1r_1^*r_2=r_2|r_1A\]</span></p></li></ol><h3 id="语法">语法</h3><ol type="1"><li>对于LL(1)文法，A的候选式中最多允许1个可以推导出<spanclass="math inline">\(\varepsilon\)</span></li><li>规范规约要求推导过程是对句柄进行规约，也叫最左规约</li><li>算符优先文法：对于一个算符文法，a==b，a&lt;b,a&gt;b至多只有一个成立</li><li>算符优先分析不是一种严格的规范规约，规约对象不是句柄</li><li><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230511115528.png" style="zoom:50%;" /></li><li>素短语：句型中至少含有一个终结符且不含其他素短语的短语</li><li>消除左递归只在自顶向下分析使用，自底向上不需要</li><li>上下文无关文法并不是都能用LR(0)方法进行分析</li><li>对于SLR(1)分析，A-&gt;a.只将Follow（A）集合中的字符进行规约，别的要么移进要么<strong>空着</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2023/04/24/School/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2023/04/24/School/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>计组复习 <span id="more"></span></p><h3 id="计算机系统概述">计算机系统概述</h3><ol type="1"><li>冯诺依曼提出计算机硬件系统由<strong>运算器、存储器、寄存器、输入设备、输出设备</strong>组成，指令和数据以同等地位存储，都以二进制表示，以<strong>运算器</strong>为核心</li><li>冯诺依曼机基本工作方式是控制流驱动，提出的“存储程序”的基本思想是：将事先编制好的程序和原始数据送入主存后才能执行，一旦程序被启动执行，就无须操作人员的干预，计算机会自动逐条执行指令，直至程序执行结束。</li></ol><h3 id="数据的表示和计算">数据的表示和计算</h3><ol type="1"><li><p><strong>大端方式</strong>按从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节存放在前面；<strong>小端方式</strong>按从最低有效字节到最高有效字节的顺序存储数据，即最低有效字节存放在前面。</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010547.png" style="zoom:50%;" /></p></li><li><p>IEEE754的短浮点数由1位符号位、8位阶码、23位尾数组成，其中阶码采用移码，偏移量为127，尾数采用原码表示</p><p>真值表示为<spanclass="math inline">\((-1)^S*1.M*2^{(E-127)}\)</span></p></li></ol><p>### 存储系统</p><ol type="1"><li><p>CPU可以与Cache和主存交换信息。<strong>主存和Cache</strong>之间的数据调动是由硬件自动完成的，<strong>主存和辅存</strong>之间的数据调动是由硬件和操作系统共同完成的(虚拟存储技术)。</p></li><li><p>静态随机存储器（SRAM）：速度快、不需要刷新、用于高速缓存</p><p>动态随机存储器（DRAM）：速度慢，需要刷新，用于内存</p></li><li><p><strong>高位交叉编址</strong>中高位地址表示体号，低位地址表示体内地址。每次存完一个存储体后才存下一个，并行性差</p><p>低位交叉编址中低位地址表示体号，每次存某一个存储体，下次就存下一个存储体，并行性好</p></li><li><p>主存容量的扩展：</p><ol type="1"><li><strong>位扩展</strong>改变字长，将多个存储芯片的地址端、片选端、读写控制端相应并联，数据端分别引出。</li><li>字扩展增加存储体字的数量，不改变字长，通过片选信号进行选择。</li></ol></li><li><p>Cache和主存的映射</p><ol type="1"><li><p>直接映射</p><p>Cache行号=主存块号 mod Cache总行数</p><p>即主存的第<spanclass="math inline">\(1、2^{c}+1、2^{c+1}+1\)</span>块均映射到第0行。当产生冲突时无条件进行置换</p><p>主存块号的低c位正好是要装入的Cache行号，因此给每个Cache行设置一个长为m-c的标记，就可以知道是哪块主存在cache中了</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010509.png" style="zoom: 50%;" /></p></li><li><p>全相联映射</p><p>主存中的每一块可以装入Cache的任意位置。但是需要一行一行的查找</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230629133704.png" style="zoom:50%;" /></p></li><li><p>组相联映射</p><p>组间直接映射，组内全相联映射</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230629133750.png" style="zoom:50%;" /></p></li></ol></li><li><p>Cache写策略</p><ol type="1"><li>写命中<ol type="1"><li>全写法：把数据同时写入Cache和主存</li><li>回写法：只把数据写入Cache同时标记脏页，当块被换出时若为脏页才写回主存</li></ol></li><li>写不命中<ol type="1"><li>写分配法：加载主存的块到Cache中，然后更新Cache块，常与回写法搭配</li><li>非写分配法：只写入主存，不进行调块，常与全写法搭配</li></ol></li></ol></li></ol><h3 id="指令系统">指令系统</h3><ol type="1"><li><p>数据寻址方式</p><ol type="1"><li><p>隐含寻址：在指令中隐含特定操作数的地址</p></li><li><p>立即数寻址：本身就是操作数</p></li><li><p>直接寻址：指令中的地址是主存中真实的地址</p></li><li><p>间接寻址：指令中的地址是数据所在地址的地址，在此基础上可以进行多级寻址</p></li><li><p>寄存器寻址：给出操作数所在的寄存器编号</p></li><li><p>寄存器间接寻址：指向的寄存器给出操作数所在的地址</p></li><li><p>相对寻址：在PC基础上添加一个偏移量</p></li><li><p>基址寻址：基址寄存器BX加上一个偏移量</p><p>基址寄存器面向操作系统，其内容由操作系统或管理程序确定</p></li><li><p>变址寻址：变址寄存器IX加上一个偏移量</p><p>变址寄存器面向用户，可由用户改变</p></li><li><p>堆栈寻址：通过堆栈指针SP寻址</p></li></ol></li><li><p>复杂指令系统：CISC</p><p>精简指令系统：RISC</p></li></ol><h3 id="中央处理器">中央处理器</h3><ol type="1"><li><p>CPU全周期：取指、译码、执行、访存、写回</p></li><li><p>异常和中断</p><ol type="1"><li>异常：故障（除0、缺页等）、自陷（单步调试）、终止（硬件故障）</li><li>中断：可屏蔽中断、不可屏蔽中断</li><li>响应过程<ol type="1"><li>关中断：防止在保存断点和程序状态时被打断</li><li>保存断点和程序状态</li><li>识别异常和中断并转到相应的处理程序</li></ol></li></ol></li><li><p>数据旁路：在流水线设计中不等待ALU写入寄存器同时下一个读寄存器，而是直接把结果输出到ALU的输入</p></li></ol><h3 id="总线">总线</h3><ol type="1"><li>特点<ol type="1"><li>分时：同一时刻只允许有一个部件向总线发送消息</li><li>共享：总线上可以挂接多个部件，各个部件之间互相交换的信息可以通过这个线路进行分时共享，多个部件可以同时从总线上接收相同的消息</li></ol></li></ol><h3 id="问答题">问答题</h3><ol type="1"><li><p>指令和数据均存放在内存中，计算机如何区分他们是指令还是数据</p><p>从时间上讲，取指令发生在取指阶段，取数据发生在执行阶段。从空间上讲，从内存读出的指令流流向控制器（指令寄存器），从内存读出的数据流流向运算器（通用寄存器）。</p></li><li><p>组合逻辑电路和时序逻辑电路有什么区别？组合逻辑电路是具有一组输出和一组输入的非记忆性逻辑电路，它的基本特点是任何时刻的输出信号状态仅取决于该时刻各个输入信号状态的组合，而与电路在输入信号作用前的状态无关。组合电路不含存储信号的记忆单元，输出与输入之间无反馈通路，信号是单向传输的。时序逻辑电路中任意时刻的输出信号不仅和当时的输入信号有关，而且与电路原来的状态有关，这是时序逻辑电路在逻辑功能上的特点。因而时序逻辑电路必然包含存储记忆单元。</p><p>此外，组合逻辑电路没有统一的时钟控制，而时序逻辑电路则必须在时钟节拍下工作。</p></li><li><p>引入总线结构有什么好处？ ①简化了系统结构，便于系统设计制造。②大大减少了连线数目，便于布线，减小体积，提高系统的可靠性。③便于接口设计，所有与总线连接的设备均采用类似的接口。④便于系统的扩充、更新与灵活配置，易于实现系统的模块化。⑤便于设备的软件设计，所有接口的软件对不同的接口地址进行操作。⑥便于故障诊断和维修，同时也能降低成本。</p></li><li><p>计算机系统的五层层次结构</p><p>微程序机器层、传统机器语言层、操作系统层、汇编语言层、高级语言层</p><p>其中后三层称为虚拟机</p></li><li><p>机器字长、指令字长、存储字长</p><p>机器字长：计算机能直接处理的二进制数据位数，为内部寄存器字长等长</p><p>指令字长：一条指令的二进制位数</p><p>存储字长：一个存储单元所能存储的二进制的位数</p><p>三者都必须是字节的整数倍，彼此之间没有直接的制约关系</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线性代数</title>
    <link href="/2023/04/12/School/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <url>/2023/04/12/School/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>线性代数基础知识复习 <span id="more"></span></p><h3 id="矩阵与方程组">矩阵与方程组</h3><ol type="1"><li><p><strong>超定方程组</strong>：方程个数大于未知数个数</p></li><li><p><strong>亚定方程组</strong>：方程个数小于未知数个数</p></li><li><p><strong>首变量</strong>：增广矩阵每一行第一个非零元对应的变量</p></li><li><p><strong>自由变量</strong>：化简过程中跳过的列对应的变量</p></li><li><p><strong>行最简式</strong>：矩阵是行阶梯形的且每一行的第一个非零元是该列唯一的非零元</p><figure><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230412123644.png"alt="行最简式子" /><figcaption aria-hidden="true">行最简式子</figcaption></figure></li><li><p><strong>齐次方程组</strong>：线性方程组右侧全为0</p></li><li><p><strong>奇异</strong>：一个<span class="math inline">\(n\timesn\)</span>的矩阵若不存在乘法逆元。矩阵A是奇异的当且仅当其行列式为0</p></li><li><p>若A是非奇异的，则<spanclass="math inline">\(Ax=0\)</span>仅有平凡解0，A与I行等价</p><p>证明：假设存在<span class="math inline">\(\barx\)</span>是一个非零解，则有<span class="math inline">\(\bar x=I\barx=(A^{-1}A)\bar x=A^{-1}A\bar x=A^{-1}0=0\)</span>.矛盾，得证。</p></li><li><p><strong>LU分解</strong>：将矩阵A分解为一个单位下三角矩阵L和一个严格上三角矩阵U的乘积的过程。</p><p>如果一个<span class="math inline">\(n\timesn\)</span>的矩阵能够仅利用行运算3化简为严格上三角形的，则A有一个LU分解</p></li><li><p>给定<spanclass="math inline">\(R^n\)</span>中的两个向量x,y.则<spanclass="math inline">\(x^Ty\)</span>为标量积或者<strong>内积</strong>，<spanclass="math inline">\(xy^T\)</span>为<strong>外积</strong></p></li><li><p>矩阵求导<ahref="https://zhuanlan.zhihu.com/p/273729929">矩阵求导公式的数学推导（矩阵求导——基础篇）- 知乎 (zhihu.com)</a></p></li></ol><h3 id="行列式">行列式</h3><ol type="1"><li><p><spanclass="math inline">\(a_{ij}\)</span>的<strong>余子式</strong><spanclass="math inline">\(A{ij}=(-1)^{i+j}|M_{ij}|\)</span>,<spanclass="math inline">\(|A|\)</span>可以表示为任意行或列的余子式展开</p><ol type="1"><li>若A为三角形方阵，则A的行列式等于A的对角线元素的乘积。可以用递归证明。</li><li>若A有一行或一列包含的元素值全为0，则|A|为0.</li></ol></li><li><p>交换矩阵的两行或两列会改变行列式的符号</p></li><li><p>某行的倍数加到另一行上不会改变矩阵的行列式</p></li><li><p>可以通过将行列式转化为三角形求值，若最后一行全为0则行列式值为0，否则为对角线元素的乘积</p></li><li><p><strong>伴随矩阵</strong>：将原矩阵的元素用它们的余子式替换，然后将结果矩阵转置。<spanclass="math inline">\(A^{-1}=\frac{adj(A)}{|A|}\)</span></p></li></ol><p>​ <span class="math inline">\(A(adj(A))=det(A)I\)</span>,则有<spanclass="math inline">\(A\frac{adj(A)}{det(A)} =I\)</span>,即可推出上述表达式</p><ol start="6" type="1"><li><p><strong>克拉默法则</strong>:若A为非奇异矩阵，<spanclass="math inline">\(Ax=b\)</span>，则有<spanclass="math inline">\(x_i=\frac{det(A_i)}{det(A)}\)</span>,其中<spanclass="math inline">\(A_i\)</span>为将矩阵A中第i列用b替换得到的矩阵。<span class="math display">\[x=A^{-1}b=\frac{1}{det(A)}adj(A)b\]</span></p><p><span class="math display">\[x_i=\frac{b_1A_{1i}+b_2A_{2i}+...+b_nA_{ni}}{det(A)}=\frac{det(A_i)}{det(A)}\]</span></p></li></ol><h3 id="正交性">正交性</h3><ol type="1"><li><p><strong>最小二乘法</strong>原理：<ahref="https://zhuanlan.zhihu.com/p/38128785">最小二乘法（least sqauremethod） - 知乎 (zhihu.com)</a></p></li><li><p>$x^Ty = | x | | y | cos$ 用余弦定理证明</p></li><li><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230423122641.png" /></p><p>已知<span class="math inline">\(x\)</span>,<spanclass="math inline">\(y\)</span>,则有</p></li></ol><p><span class="math display">\[\alpha=\left \| x \right \|cos\theta=\frac{\left \| x \right \| \left \|y \right \|  cos\theta}{\left \| y \right \|}=x^Ty\]</span></p><p><span class="math display">\[p=\alpha u=\alpha\frac{1}{\left \| y \right \|}y=\frac{x^Ty}{y^Ty}y\]</span></p><ol start="4" type="1"><li>求过一个定点<span class="math inline">\(p\)</span>且与已知向量<spanclass="math inline">\(l\)</span>垂直的平面：对于任意点x,应有<spanclass="math inline">\(\overrightarrow{xp}·l=0\)</span>，即可求得x表达式</li><li>求给定三个点确定的平面：先求得两个向量，然后根据叉乘求出法向量，然后任取一个给定点按4中方式计算即可</li><li>施密特正交化过程：<ahref="https://zhuanlan.zhihu.com/p/136627868">如何理解施密特（Schmidt）正交化- 知乎 (zhihu.com)</a></li></ol><h3 id="特征值">特征值</h3><ol type="1"><li>一个矩阵A是可对角化的，当且仅当A有n个线性无关的特征向量</li></ol>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux总结</title>
    <link href="/2023/04/09/School/Linux_School/Linux%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/09/School/Linux_School/Linux%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 <span id="more"></span></p><h3 id="第一章-基础知识">第一章 基础知识</h3><ol type="1"><li><p>Linux五个子系统的关系（关系图见1-3）</p><p>·进程调度与内存管理之间的关系：这两个子系统互相依赖。在多道程序环境下，程序要运行必须为之创建进程，而创建进程的第一件事，就是要将程序和数据装入内存。</p><p>·进程间通信与内存管理的关系：进程间通信子系统要依赖内存管理支持共享内存通信机制，这种机制允许两个进程除了拥有自己的私有内存，还可存取共同的内存区域。</p><p>·虚拟文件系统与网络接口之间的关系：虚拟文件系统利用网络接口支持网络文件系统(NFS)，也利用内存管理支持RAMDISK设备。</p><p>· 内存管理与虚拟文件系统之间的关系：内存管理利用虚拟文件系统支持交换，交换进程(swapd)定期地由调度程序调度，这也是内存管理依赖于进程调度的唯一原因。当一个进程存取的内存映射被换出时，内存管理向文件系统发出请求，同时，挂起当前正在运行的进程。</p></li><li><p>华为的OpenEuler操作系统是基于Linux内核的开源操作系统</p></li><li><p>GNU与Linux</p><p>Linux与GNU有很大关系。实际上，通常所说的Linux操作系统其实是由Linux内核和GNU操作系统（包括shell、工具集、库等）共同组成的。Linux操作系统的内核由LinusTorvalds在1991年发起开发，而GNU则在此之前就开始了基础软件和工具的开发。LinusTorvalds将GNU的类Unix系统和他的内核结合起来，形成了我们今天所说的Linux操作系统。</p></li></ol><h3 id="第二章-进程">第二章 进程</h3><ol type="1"><li><p>Linux2.4与2.6在进程堆栈上的区别</p><p>使用thread_info代替了task_struct</p><p>在2.6版本中，内存管理存在SLUB、SLAB等多种机制，可以更加灵活地管理内存。而在2.4版本中，则只支持较为简单的伙伴系统（BuddySystem）来管理内存</p></li></ol><p>​</p><h3 id="第五章">第五章</h3><ol type="1"><li><p>hw_interrupt_type结构中的域都是函数指针，它们指向了一些用来操作中断服务例程的函数，采用的是<strong>面向对象</strong>的方法</p></li><li><p>为什么引入下半部，下半部的组织</p><p>下半部通常使用软中断（Softirq）实现，在内核中被组织为一组可重入的函数队列，并伴随着一个标志位，表示是否有下半部需要处理。当某个中断处理程序需要执行下半部任务时，它只需要将任务添加到下半部队列中，然后向内核中断处理程序返回。当CPU空闲时，内核会检查下半部队列是否有任务需要执行，并按照优先级顺序逐个执行。这种机制使得中断处理程序可以更快地退出，从而提高系统的吞吐量和响应速度。</p></li></ol><h3 id="第六章">第六章</h3><ol type="1"><li><p>为什么要划分VMA</p><p>Linux2.4 将用户地址空间划分成多个 VMA区域的主要原因是为了实现虚拟内存管理机制，即将虚拟地址映射到物理地址，从而提升系统的内存利用率和安全性。由于每个VMA区域都有不同的访问权限和属性，可以灵活地为不同的代码和数据分配合适的内存空间，从而避免了其中一个区域出现问题影响整个系统的情况。</p></li><li><p>以write()为例,VFS是如何与EXT2结合的</p><p>以 ext2 文件系统为例，当应用程序执行 write() 系统调用时，内核会首先在VFS 层进行处理。VFS 会查找并获得要写入文件的 inode结构，并将其缓存到本地内存中，以便之后高效地访问。VFS 层还会根据 inode的地址，找到对应的靠近磁盘缓存中的 buffer_head数据结构，建立起文件系统中每个块和缓存的映射关系，进而实现读写请求与具体物理设备之间的转换。</p><p>接下来，VFS 会将写入数据的请求传递给 ext2文件系统，以处理这个文件系统的特定细节，如块的分配、解析目录等。ext2文件系统首先检查写入数据的可用空间是否足够，如果空间不足，需要进行扩展块的分配和逻辑分区的重分配等操作。如果数据空间足够，则会将数据写入相应的块中，并更新inode结构和超级块等元数据信息。更新元数据时，需要确保在出现断电等异常情况时，文件系统仍然可以保持一致性，并使用日志文件（journal）来记录必要的元数据信息，以备后续恢复。</p><p>最后，当 ext2 文件系统完成数据写入操作后，VFS层会返回相应的结果给应用程序，并清除 inode缓存等临时数据，以便之后更高效地进行访问。整个过程中，VFS层扮演了一个统一接口的角色，将 Linux系统与具体文件系统解耦，并实现了文件读写等基本操作的抽象，从而方便了内核的开发工作</p></li><li><p>什么是设备文件？什么是设备驱动程序？</p><p>在 Linux2.4中，设备文件是一种特殊的文件类型，它用于与系统中的各种物理或虚拟设备进行交互。设备文件一般存储在/dev目录下，其中包括了很多常用设备（如硬盘、显示器、键盘等）的设备文件。</p><p>设备文件可以分为两种类型：块设备文件和字符设备文件。块设备文件通常用于访问磁盘等存储设备，而字符设备文件则用于访问串口、键盘鼠标等非存储类设备。</p><p>而设备驱动程序是指控制设备功能的软件程序，通过设备驱动程序可以控制设备的输入、输出、中断处理等操作。设备驱动程序一般是由操作系统内核或者用户态应用程序所提供的。</p><p>在 Linux2.4中，设备驱动程序通常被编译为模块的形式，称为内核模块。这些模块可以动态地加载到内核中，从而实现对特定设备的控制和管理。当设备文件被打开时，内核将自动使用与该设备相关的设备驱动程序，以实现对设备的操作。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件系统</title>
    <link href="/2023/04/06/School/Linux_School/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/04/06/School/Linux_School/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 第七章.文件系统 <span id="more"></span></p><h3 id="文件系统的特征">文件系统的特征</h3><ol type="1"><li>Linux文件是无结构的字符流式文件</li><li>外部设备也被看作文件</li></ol><h3 id="虚拟文件系统vfs">虚拟文件系统VFS</h3><ol type="1"><li>虚拟文件系统VFS是面向对象的设计</li><li>向上提供给用户接口，向下要求各文件系统分别实现各接口</li><li>四种通用文件模型：超级块对象、索引节点对象、文件对象、目录项对象</li></ol><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230406212830.png" /></p><p>进程和文件系统之间数据结构的关系</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux中断处理</title>
    <link href="/2023/04/05/School/Linux_School/Linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
    <url>/2023/04/05/School/Linux_School/Linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 第五章.中断处理 <span id="more"></span></p><h3 id="快中断与慢中断">快中断与慢中断</h3><ol type="1"><li><p>在中断响应时，OS规定要关闭中断允许位，直到中断处理程序中调用了开中断指令STI为止</p></li><li><p>快中断对应上半部处理程序，慢中断对应下半部处理程序</p></li><li><p>处理慢中断前：需保存所有寄存器的内容,而快中断处理仅要保存部分被修改的寄存器</p></li><li><p>慢中断处理时不屏蔽其它中断信号（开中断）,而快中断处理时会屏蔽所有其它中断（关中断）</p></li><li><p>慢中断处理完毕后，通常不立即返回被中断的进程，而是进入调度程序重新调度，调度结果未必是被中断的原进程运行(是抢先式调度)。快中断处理完毕后，通常恢复现场返回被中断的进程继续执行(是非抢先式调度)。</p></li><li><p>可以将上半部看做是一个用来实现“登记中断”功能的函数，即当一个中断发生时，它就把中断例程的下半部分挂接到该设备的下半部分执行队列中，然后不再做其他事情</p></li></ol><h3 id="中断请求队列">中断请求队列</h3><ol type="1"><li>hw_interrupt_type结构中的域都是函数指针，它们指向了一些用来操作中断服务例程的函数，采用的是<strong>面向对象</strong>的方法。</li><li>几个重要数据结构之间的关系</li><li><img src=https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230405163958.png width="80%"></li></ol><h3 id="中断的注册与安装">中断的注册与安装</h3><ol type="1"><li>中断服务例程在安装之前，需先用函数<strong>request_irq()</strong>进程注册，以向系统申请一个中断描述符结构空间和一个中断号。</li><li>调用函数<strong>setup_irq()</strong>把中断服务例程安装到中断请求队列中。该函数的主要作用是为中断服务例程分配一个irqaction结构，并把指针handler指向中断服务例程的函数。</li><li>在中断结束之后，关闭申请中断的设备时，调用<strong>free_irq()</strong>释放所申请的中断号。</li><li><strong>do_IRQ()</strong>负责处理所有的外部设备中断.在do_IRQ的末尾，调用<strong>iqr_exit()</strong>,它的一项重要工作中就使启动中断的下半部分</li></ol><h3 id="linux的时间系统">Linux的时间系统</h3><ol type="1"><li>Jiffies是一个全局变量，用于存放自系统启动以来产生的总的节拍数。给全局变量jiffies加1这项工作是紧急的，因此它由上半部来完成；而其余各项，则因它们不那么紧急，由下半部分完成</li><li>上半部函数：timer_interrupt() 下半部函数：timer_bh()</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统调用</title>
    <link href="/2023/04/05/School/Linux_School/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2023/04/05/School/Linux_School/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 第四章.系统调用 <span id="more"></span></p><h3 id="系统调用功能">系统调用功能</h3><ol type="1"><li>Linux利用i386体系结构的软件中断实现系统调用，即调用了int$0x80汇编指令。</li><li>系统调用处理程序的入口是system_call()</li></ol><h3 id="系统调用和中断处理的区别">系统调用和中断处理的区别</h3><p>中断必须完成当前指令后才进入中断，而系统调用可以在一条指令中进行</p><h3 id="系统调用的参数传递">系统调用的参数传递</h3><ol type="1"><li>系统调用使用寄存器来传递参数.要传递的参数有：系统调用号、系统调用所需的参数</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树状数组&amp;线段树</title>
    <link href="/2023/04/03/Algorithm/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2023/04/03/Algorithm/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>Acwing蓝桥杯树状数组和线段树内容 <span id="more"></span></p><h3 id="树状数组">树状数组</h3><p>可以实现在增加某个位置一个值的情况下快速求前缀和,时间复杂度O(logn)</p><p>例题：<ahref="https://www.acwing.com/problem/content/description/1267/">1265.数星星 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> a[N],tr[N];<br><span class="hljs-type">int</span> n,m;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;-x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i)) tr[i] += y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i&gt;=<span class="hljs-number">1</span>;i-=<span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-comment">// 初始化操作</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">add</span>(i,a[i]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> k,x,y;<br>        cin&gt;&gt;k&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-built_in">query</span>(y) - <span class="hljs-built_in">query</span>(x<span class="hljs-number">-1</span>)&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(x,y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线段树">线段树</h3><h4 id="求动态区间和">求动态区间和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> l,r;<br>    <span class="hljs-type">int</span> val;<br>&#125;node[<span class="hljs-number">4</span>*N];<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    node[u].val = node[<span class="hljs-number">2</span>*u].val + node[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) node[u] = &#123;l,r,a[l]&#125;;<br>    <span class="hljs-keyword">else</span>&#123;<br>        node[u] = &#123;l,r&#125;;<br>        <span class="hljs-type">int</span> mid = l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u,l,mid);<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>        <span class="hljs-built_in">pushup</span>(u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(node[u].l &gt;= l &amp;&amp; node[u].r &lt;= r) <span class="hljs-keyword">return</span> node[u].val;<br>    <span class="hljs-type">int</span> mid = node[u].l + node[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l&lt;=mid) sum += <span class="hljs-built_in">query</span>(<span class="hljs-number">2</span>*u,l,r);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) sum += <span class="hljs-built_in">query</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>,l,r);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(node[u].l == node[u].r) node[u].val += y;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> mid = node[u].l + node[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(x&lt;=mid) <span class="hljs-built_in">modify</span>(<span class="hljs-number">2</span>*u,x,y);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>,x,y);<br>        <span class="hljs-built_in">pushup</span>(u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> k,x,y;<br>        cin&gt;&gt;k&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,x,y)&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,x,y);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求区间最大值">求区间最大值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> l,r;<br>    <span class="hljs-type">int</span> val;<br>&#125;node[<span class="hljs-number">4</span>*N];<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    node[u].val = <span class="hljs-built_in">max</span>(node[<span class="hljs-number">2</span>*u].val, node[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) node[u] = &#123;l,r,a[l]&#125;;<br>    <span class="hljs-keyword">else</span>&#123;<br>        node[u] = &#123;l,r&#125;;<br>        <span class="hljs-type">int</span> mid = l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u,l,mid);<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>        <span class="hljs-built_in">pushup</span>(u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(node[u].l &gt;= l &amp;&amp; node[u].r &lt;= r) <span class="hljs-keyword">return</span> node[u].val;<br>    <span class="hljs-type">int</span> mid = node[u].l + node[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l&lt;=mid) sum = <span class="hljs-built_in">query</span>(<span class="hljs-number">2</span>*u,l,r);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) sum = <span class="hljs-built_in">max</span>(sum,<span class="hljs-built_in">query</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>,l,r));<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    <br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>        <span class="hljs-comment">// printf(&quot;%d\n&quot;,query(1,x,y));</span><br>        cout&lt;&lt;<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,x,y)&lt;&lt;endl;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>硬件课设</title>
    <link href="/2023/04/02/School/%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/"/>
    <url>/2023/04/02/School/%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/</url>
    
    <content type="html"><![CDATA[<p>记录硬件课设学习过程 <span id="more"></span></p><h3 id="实验一-pl端设计">实验一 PL端设计</h3><ol type="1"><li>新建工程，编写好.v文件</li><li>Synthesis -&gt; Run Synthesis 检查是否具有语法错误</li><li>新建simulation sources，编写仿真文件</li><li>将仿真文件右键设置为top文件，Simulation -&gt; Run Simulation进行仿真</li><li>I/O Ports 设置引脚</li><li>Program and Debug -&gt; Generate Bitstream 产生字节流</li><li>Open Hardware Manager 将程序烧到电路板</li></ol><h3 id="实验二-ps端设计">实验二 PS端设计</h3><ol type="1"><li><p>新建工程，IP Integrator -&gt; Create Block Design</p></li><li><p>查找zynq，选择第一个</p></li><li><p>双击芯片，添加预配置文件</p></li><li><p>MIO Configuration -&gt; I/O Peripherals -&gt; GPIO -&gt; EMIOGPIO (Width) 打勾，选择引脚数量</p></li><li><p>将GPIO_0 DDR FIXED_IO三个引脚右键Make External引出</p></li><li><p>点击Validate Design 审查是否具有错误</p><figure><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/image-20230402143111433.png"alt="审查错误" /><figcaption aria-hidden="true">审查错误</figcaption></figure></li><li><p>右键IP文件选择Generate Output Product, 点击Generate</p><figure><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230402143328.png"alt="生成输出" /><figcaption aria-hidden="true">生成输出</figcaption></figure></li><li><p>右键IP文件点击Create HDL Wrapper进行封装</p></li><li><p>Run Synthesis</p></li><li><p>Add Source -&gt; Add or create constraints新建约束文件并填写</p></li><li><p>Generate Bitstream</p></li><li><p>File-&gt;Export-&gt;Export Hardware-&gt;Includebitstream</p></li><li><p>Launch SDK</p></li><li><p>在SDK中File-&gt;New-&gt;Application Project-&gt;Next-&gt;emptyProject</p></li><li><p>bsp文件夹/system.mss中有一些测试示例，选择gpiops的ImportExamples</p></li><li><p>修改文件逻辑</p></li><li><p>在Vivado中Open Target 连接电路板</p></li><li><p>在SDK中Run as -&gt; Launch on Hardware(System Debugger)烧到电路板上</p></li></ol><h3 id="实验三-ps-pl已有ip">实验三 PS + PL已有IP</h3><ol type="1"><li><p>同实验二的1~3，然后打开AXI总线并在Interrupts勾选FabricInterrupts,展开后在PL-PS InterruptPorts勾选IRQ_F2P[15:0]开启中断</p></li><li><p>添加另一个IP查找GPIO，添加后双击勾选Enable DualChannel开启双使能通道</p></li><li><p>对于两个GPIO宽度都设置为4(LED和按键都是占4个引脚)</p></li><li><p>勾选Enable Interrupt，点击确定</p></li><li><p>引出DDR FIXED_IO GPIO DPIO2</p></li><li><p>点击页面上方的自动连接将IP和ZYNQ连接起来，然后手动将ZYNQ和IP的中断接口连起来</p></li><li><p>同实验二6~12</p></li><li><p>File-&gt;new-&gt;Board Support Package 全默认即可</p></li><li><p>system.mss中勾选gpio的前两个示例代码</p></li><li><p>同实验二后续</p></li></ol><h3 id="实验四-ps-pl自定义ip">实验四 PS + PL自定义IP</h3><ol type="1"><li><p>新建工程编准备好.v文件</p></li><li><p>Tools-&gt;Create and Package New IP-&gt;Create a new AXI4peripheral-&gt;Edit IP</p></li><li><p>添加资源，将需要封装为IP的文件（记作A）引入进来</p></li><li><p>将文件中的module声明复制到自动产生文件（记作B）的末尾 userlogic处，同时指定端口的连接</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230402200933.png" /></p></li><li><p>在Users to add portshere处添加IP的输入输出，注意reg要改为wire</p></li></ol><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230402200643.png" /></p><ol start="6" type="1"><li><p>在top层两处添加端口</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230402201224.png" /></p></li></ol><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230402201255.png" /></p><ol start="7" type="1"><li>Run Synthesis</li><li>在Package IP - AXI_SMG-&gt;File Groups页面点击Merge changes fromFile Grops Wizard,在下面一个页面进行同样的操作</li><li>点击最下面Review and Package完成IP打包</li><li>新建项目，IP Integrator-&gt;Create Block Design打开IP设计界面</li><li>在Project-&gt;Project Setting中的IP页面中添加IP的路径</li><li>预配值Zynq，勾选AXI总线（默认已勾选）</li><li>引出DDR FIXED_IO led_out a_g key_in四个引脚，然后点击自动连接</li><li>同实验三后续</li></ol><h3 id="正点原子">正点原子</h3><ol type="1"><li>嵌入式开发流程</li></ol><p><img src= https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230417123616.png width="50%"></p><ol start="2" type="1"><li>GPIO是一个外设，用来对器件的引脚作观测(input)以及控制(output)。</li><li>MIO(MultiuseI/O),将来自PS外设X和静态存储器接口的访问多路复用到PS的引脚上。</li></ol><h3 id="oled">OLED</h3><ol type="1"><li>引脚：<ol type="1"><li><p>SDA:C17</p></li><li><p>SCLK:D15</p></li><li><p>CS:C15</p></li><li><p>GPIO[0]:D16(DC)</p></li><li><p>GPIO[1]:F17(RES)</p></li></ol></li></ol><h3 id="pm2.5">PM2.5</h3><p>TX u4</p><p>RX v4</p><p>GPIO y4</p><h3 id="asr">ASR</h3><p>UART0_TX Y13</p><p>UART0_RX Y14</p><h3 id="顶层">顶层</h3><h4 id="oled-1">OLED</h4><ol type="1"><li><p>SDA:C17</p></li><li><p>SCLK:D15</p></li><li><p>CS:C15</p></li><li><p>GPIO[0]:D16(DC)</p></li><li><p>GPIO[1]:F17(RES)</p></li></ol><h4 id="asr-1">ASR</h4><ol type="1"><li><p>RX:R15</p><p>"小植"：0x01</p><p>“温湿度”：0x32(50)</p><p>"空气"：0x33(51)</p><p>"甲醛"：0x34(52)</p></li></ol><h4 id="pm">PM</h4><ol type="1"><li>RX:W13</li></ol><h4 id="jq">JQ</h4><ol type="1"><li>RX:V14</li></ol><h4 id="tts">TTS</h4><ol type="1"><li>TX:T16</li></ol><h3 id="dht11">DHT11</h3><ol type="1"><li>dht11_data:AB21</li></ol>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程调度</title>
    <link href="/2023/04/01/School/Linux_School/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <url>/2023/04/01/School/Linux_School/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 第二章.进程调度 <span id="more"></span></p><h4 id="进程调度策略">进程调度策略</h4><ol type="1"><li><p>分为普通进程和实时进程，普通进程的优先级动态变化，实时进程的优先级刚开始就设置好并固定。</p></li><li><p>普通进程采用动态优先级策略，SCHED_OTHER;实时进程采用SCHED_FIFO或者SCHED_RR</p></li><li><p>如果一个进程是实时进程，则其子孙进程也是实时进程</p></li></ol><h4 id="进程调度依据">进程调度依据</h4><ol type="1"><li>依据weight值选择最大的运行<ol type="1"><li>对于普通进程，weight值首先赋值为剩余的时钟数，若上次也是在当前CPU上运行的则weight增加一个常量，若不需要切换内存则weight再加1，然后还受人为控制的nice的影响(weight+=20-nice)</li><li>对于实时进程，weight=1000+rt_priority</li></ol></li><li>在一个单独时期里，每个进程有一个指定时间片，用完就会被抢占，没用完可以多次调度运行</li><li>所有进程用完其时间片，一个时期才结束</li><li>创建新进程时，子进程继承父进程的一半剩余时间片。子进程结束运行时，剩余时间片也将归还给父进程</li></ol><h3 id="进程调度时机">进程调度时机</h3><p>分为被动调度和主动调度</p><ol type="1"><li><p>被动调度：</p><ol type="1"><li>适用情况<ol type="1"><li>当前进程用完CPU时间片</li><li>一个进程被唤醒且优先级高于当前进程</li></ol></li><li>调度时机<ol type="1"><li>调用sched_setscheduler()或sched_yield()系统调用时</li><li>进程用户态进程前</li><li>系统调用执行结束，控制由核心态返回用户态前</li></ol></li></ol></li><li><p>主动调度</p><p>当进程所需资源无法满足而必须立即阻塞时，直接调度schedule()</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搜索与图论</title>
    <link href="/2023/03/30/Algorithm/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
    <url>/2023/03/30/Algorithm/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>树、图 <span id="more"></span></p><h3 id="dfs回溯">DFS(回溯)</h3><p>深度优先搜索，和回溯同模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> select[])</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(满足某条件)&#123;<br>        result.<span class="hljs-built_in">push_back</span>(a);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:select[])&#123;<br>        做出选择;<br>        <span class="hljs-built_in">DFS</span>(a,select);<br>        撤销选择;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓扑排序">拓扑排序</h3><p>本质为宽搜，通过结点的入度判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,M=N*<span class="hljs-number">2</span>;<br><br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx;<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">int</span> n,m;<br>vector&lt;<span class="hljs-type">int</span>&gt;res;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">add</span>(a,b);<br>        d[b] ++;<br>    &#125;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(d[i] == <span class="hljs-number">0</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(i);<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br>            <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=h[t];j!=<span class="hljs-number">-1</span>;j=ne[j])&#123;<br>                <span class="hljs-type">int</span> k = e[j];<br>                d[k]--;<br>                <span class="hljs-keyword">if</span>(d[k] == <span class="hljs-number">0</span>)&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(k);<br>                    q.<span class="hljs-built_in">push</span>(k);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()!=n) cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : res)&#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/image-20230331164952535.png"alt="最短路算法" /><figcaption aria-hidden="true">最短路算法</figcaption></figure><h3 id="dijkstra">Dijkstra</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> st[N];<br><br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;cnt&lt;n<span class="hljs-number">-1</span>;cnt++)&#123;<br><span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!st[i] &amp;&amp; (t == <span class="hljs-number">-1</span> || d[t]&gt;d[i])) t = i;<br>&#125;<br>st[t] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>    d[j] = <span class="hljs-built_in">min</span>(d[j],d[t] + g[t][j]);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">if</span>(d[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> d[n]; <br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>g[a][b] = <span class="hljs-built_in">min</span>(g[a][b],c);<br>&#125;<br><br>cout&lt;&lt;<span class="hljs-built_in">dijkstra</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化的dijkstra">堆优化的Dijkstra</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N],e[N],ne[N],w[N],idx;<br><span class="hljs-type">int</span> st[N];<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; q;<span class="hljs-comment">// 距离并不用于更新，而用于排序</span><br>    <br>q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-keyword">auto</span> mint = q.<span class="hljs-built_in">top</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-type">int</span> t = mint.second;<br>        <span class="hljs-keyword">if</span>(t == n) <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 能快一些</span><br><span class="hljs-keyword">if</span>(st[t]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 可能存在重边</span><br>st[t] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br><span class="hljs-type">int</span> j = e[i];<br><span class="hljs-keyword">if</span>(d[j] &gt; d[t] + w[i]) &#123;<br>d[j] = d[t] + w[i];<br>q.<span class="hljs-built_in">push</span>(&#123;d[j],j&#125;);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(d[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> d[n]; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>e[idx] = b;<br>w[idx] = c;<br>ne[idx] = h[a];<br>h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-built_in">add</span>(a,b,c);<br>&#125;<br><br>cout&lt;&lt;<span class="hljs-built_in">dijkstra</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="belman_fold">belman_fold</h3><p>用于求路径包含不大于k条边且可能包含负权边的单源最短路径</p><p>例题：<ahref="https://ac.nowcoder.com/acm/contest/52244/F?&amp;headNav=acm">F-坐火车_2023年中国高校计算机大赛-团队程序设计天梯赛（GPLT）上海理工大学校内选拔赛（同步赛)(nowcoder.com)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br><span class="hljs-type">int</span> a,b,w;<br><br>&#125;edge[N];<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> d[N],backup[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br><br><span class="hljs-built_in">memcpy</span>(backup,d,<span class="hljs-keyword">sizeof</span> d);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>    <span class="hljs-type">int</span> a = edge[j].a;<br>    <span class="hljs-type">int</span> b = edge[j].b;<br>    <span class="hljs-type">int</span> w = edge[j].w;<br>    <br>d[b] = <span class="hljs-built_in">min</span>(d[b],backup[a] + w);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> d[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>edge[i] = &#123;a,b,c&#125;;<br>&#125;<br><br><span class="hljs-type">int</span> res = <span class="hljs-built_in">bellman_ford</span>();<br><span class="hljs-keyword">if</span>(res &gt; <span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;res;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="spfa">SPFA</h3><p>存在负权边的单源最短路算法，大多数情况下优于dijkstra</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> h[N],w[N],e[N],ne[N],idx;<br><span class="hljs-type">int</span> d[N],used[N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>e[idx] = b;<br>w[idx] = c;<br>ne[idx] = h[a];<br>h[a] = idx++; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>used[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>used[t] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br><span class="hljs-type">int</span> j = e[i];<br><span class="hljs-keyword">if</span>(d[j] &gt; d[t] + w[i])&#123;<br>d[j] = d[t] + w[i];<br><span class="hljs-keyword">if</span>(!used[j])&#123;<br>q.<span class="hljs-built_in">push</span>(j); <br>used[j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> d[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-built_in">add</span>(a,b,c);<br>&#125;<br><br><span class="hljs-built_in">spfa</span>();<br><span class="hljs-keyword">if</span>(d[n] &gt; <span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;d[n];<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="spfa判断负环">SPFA判断负环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> h[N],w[N],e[N],ne[N],idx;<br><span class="hljs-type">int</span> d[N],used[N],cnt[N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>e[idx] = b;<br>w[idx] = c;<br>ne[idx] = h[a];<br>h[a] = idx++; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">// 不一定从1开始，要全加进去</span><br>    used[i] = <span class="hljs-number">1</span>;<br>    q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>used[t] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br><span class="hljs-type">int</span> j = e[i];<br><span class="hljs-keyword">if</span>(d[j] &gt; d[t] + w[i])&#123;<br>d[j] = d[t] + w[i];<br>cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 如果边数为n，则有n+1个点，则必有一个点经过了两次，则必存在负环（若正环则不会走）</span><br><span class="hljs-keyword">if</span>(cnt[j]&gt;=n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(!used[j])&#123;<br>q.<span class="hljs-built_in">push</span>(j); <br>used[j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-built_in">add</span>(a,b,c);<br>&#125;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>()) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="floyd">Floyd</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> g[N][N];<br><br><span class="hljs-type">int</span> n,m,k;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                g[i][j] = <span class="hljs-built_in">min</span>(g[i][j],g[i][k] + g[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(i==j) g[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> g[i][j] = INF;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b],c);<br>    &#125;<br>    <br>    <span class="hljs-built_in">floyd</span>();<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(g[a][b] &gt; <span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;g[a][b]&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="prim">Prim</h3><p>求最小生成树</p><p>注意不事先将1号点放进去所以要特判多处i=0的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> d[N],used[N];<br><br><br><span class="hljs-type">int</span> n,m;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!used[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || d[t] &gt; d[j])) t = j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &amp;&amp; d[t] == INF) <span class="hljs-keyword">return</span> INF;<br>        <br>        <span class="hljs-keyword">if</span>(i) res += d[t];<br>        used[t] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>            <span class="hljs-keyword">if</span>(!used[k])&#123;<br>                d[k] = <span class="hljs-built_in">min</span>(d[k],g[t][k]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b] = g[b][a] = <span class="hljs-built_in">min</span>(g[a][b],c);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">prim</span>();<br>    <span class="hljs-keyword">if</span>(res == INF) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="kruskal">Kruskal</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> p[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>    <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Edge &amp;e)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> w &lt; e.w;<br>    &#125;<br>&#125;edge[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,res=<span class="hljs-number">0</span>;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        edge[i] = &#123;a,b,c&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(edge,edge+m);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        p[i] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a = edge[i].a;<br>        <span class="hljs-type">int</span> b = edge[i].b;<br>        <span class="hljs-type">int</span> w = edge[i].w;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a) != <span class="hljs-built_in">find</span>(b))&#123;<br>            res += w;<br>            p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>            cnt++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(cnt != n<span class="hljs-number">-1</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程管理</title>
    <link href="/2023/03/30/School/Linux_School/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2023/03/30/School/Linux_School/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 第三章.进程管理 <span id="more"></span></p><h4 id="进程的类别">进程的类别</h4><ol type="1"><li><p>TASK_RUNNING: 正在运行/就绪</p></li><li><p>TASK_TRACED: 供调试使用</p></li><li><p>TASK_INTERRUPTIBLE: 可被信号或中断唤醒进入就绪队列（）</p></li><li><p>TASK_UNINTERRUPTIBLE：等待资源不可被其他进程中断，例如在等待打印机资源，则在获得之前不可进入就绪状态</p></li><li><p>TASK_STOPPED: 被调试暂停，或收到SIGSTOP信号</p></li><li><p>TASK_ZOMBIE:正在终止（已经释放内存、文件等资源，但是父进程还未收到通知，描述符未释放）</p></li><li><p>TASK_DEAD:已退出且不需要父进程回收的进程的状态</p></li></ol><p><img src=https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/image-20230330143205241.png width="80%"></p><h4 id="进程的系统堆栈">进程的系统堆栈</h4><ol type="1"><li><p>Linux2.4的PCB于所属进程的内核堆栈放在一起，为每个进程分配8KB大小的内存区域。</p></li><li><p>进程描述符task_struct位于8k低端，内核堆栈位于8k高端</p></li></ol><p><img src=https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/image-20230331205455782.png width="80%"></p><ol start="3" type="1"><li>操作系统可以使用current宏通过esp指针获得PCB的指针，具体方式为将低13位清零得到起始空间地址</li></ol><p>current = (struct task_struct*) STACK_POINTE &amp; 0xFFFE000</p><h4 id="进程的链表结构">进程的链表结构</h4><ol type="1"><li><p>Linux进程通过双向链表连接。</p></li><li><p>对于TASK_RUNNING状态的进程，引入运行队列(runningqueue)，使用list_head实现，本质为双链表</p></li><li><p>对于非TASK_RUNNING状态的进程，引入等待队列，其可以细分很多种分别维护，本质为双循环链表</p></li><li><p>为了快速定位进程，以PID为关键字建立了哈希表，可以通过PID快速找到进程</p></li></ol><h4 id="进程控制">进程控制</h4><ol type="1"><li><p>sys_fork() sys_vfork() sys_clone()均可创建新进程</p></li><li><p>对于sys_fork()，除了代码段外父子进程不共享任何东西</p></li><li><p>对于sys_clone(),有选择地对父进程进行赋值，如果不提供标志则和fork()一样。</p></li><li><p>对于sys_vfork(),子进程能够共享父进程的内存地址空间，使用复制指针的方法使子进程与父进程资源实现共享。父进程在子进程运行时会被堵塞，保证子进程先运行。出现COW后就基本不再用了。</p></li><li><p>wait()wait_pid()用于检测子进程是否终止。如果子进程仍在运行则父进程堵塞，如果子进程终止则返回子进程的终止状态，如果没有子进程则出错返回</p></li><li><p>exit()释放大部分进程占用的资源，终止进程。进程进入ZOMBIE状态后内核调用exit_notify()通知父进程调用wait()判断子进程状态并通过release()回收子进程的task_struct，#### 进程与线程</p></li><li><p>进程是资源分配的基本单位，线程是处理器调度的独立单位，但是在Linux中弱化了这样的关系，不明确区分进程线程。</p></li><li><p>Linux认为线程是一组共享资源的进程</p></li><li><p>clone()可以创建内核支持的用户线程，对内核可见且由内核调度</p></li><li><p>pthread_create()由基于POSIX标准的线程库创建的用户线程</p></li><li><p>对于多线程进程，组内所有线程的tgid都相等且等于父进程的pid</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法中的数学</title>
    <link href="/2023/03/22/Algorithm/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    <url>/2023/03/22/Algorithm/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>算法竞赛中常用的数学知识 <span id="more"></span></p><h3 id="判断质数">判断质数</h3><p>若d能够整除n，则<spanclass="math inline">\(\frac{n}{d}\)</span>也能整除n，因此只需要枚举到<spanclass="math inline">\(d\leq\frac{n}{d}\)</span>即可，时间复杂度<spanclass="math inline">\(O(\sqrt{n})\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_Prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=x/i;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分解质因数">分解质因数</h3><p>定义：不考虑排列顺序的情况下，每个正整数都能够以唯一的方式表示成它的质因数的乘积。<span class="math inline">\(n=p_1^{a_1} * p_2^{a_2}*p_3^{a_3}.....p_n^{a_n}\)</span></p><p>其中<span class="math inline">\(p_i\)</span>为质数</p><p>大于根号n的质因数最多只有一个，因为如果有两个，他们的乘积就大于n了。因此只需要判断到x/i即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<span class="hljs-comment">// 满足此条件的一定是质数</span><br>        &#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, s ++ ;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="埃筛质数">埃筛质数</h3><p>思路为从前往后枚举，将所有当前值的倍数筛掉即可，时间复杂度约为<spanclass="math inline">\(O(n)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> used[N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!used[i])&#123;<br>            cnt++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+i;j&lt;=n;j+=i)&#123;<br>                used[j] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125; <br>    &#125;    <br>    <br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin&gt;&gt;n;<br>    cout&lt;&lt;<span class="hljs-built_in">work</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线性筛质数">线性筛质数</h3><p>没懂，比埃筛效率高</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求所有约数">求所有约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=x/i;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span>(i!=x/i) res.<span class="hljs-built_in">push_back</span>(x/i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求约数个数约数之和">求约数个数&amp;约数之和</h3><p>假设$x=p_1<sup>{<em>{1}}p_2^{</em>{2}}...p_n</sup>{_{n}} $,则</p><p>约数个数为<spanclass="math inline">\((\alpha_1+1)(\alpha_2+1)...(\alpha_n+1)\)</span>，因为每个约数都可以表示为<spanclass="math inline">\(p_1^{\beta_{1}}p_2^{\beta_{2}}...p_n^{\beta_{n}}\)</span>,则所有个数即为所有<spanclass="math inline">\(\beta\)</span>的组合数</p><p>约数之和为<spanclass="math inline">\((P_1^0+P_1^1+...P_1^{\alpha_1})(P_2^0+P_2^1+...P_2^{\alpha_2})...(P_n^0+P_n^1+...P_n^{\alpha_n})\)</span>，因为这些展开即是上述的各个组合</p><p><a href="https://www.acwing.com/problem/content/872/">870. 约数个数 -AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; primes;<br><br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                x /= i;<br>                primes[i] ++ ;<br>            &#125;<br><br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) primes[x] ++ ;<br>    &#125;<br><br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : primes) res = res * (p.second + <span class="hljs-number">1</span>) % mod;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/873/">871. 约数之和 -AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;primes;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=x/i;i++)&#123;<br>            <span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>)&#123;<br>                x/=i;<br>                primes[i]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) primes[x]++;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:primes)&#123;<br>        <span class="hljs-type">int</span> a = t.first;<br>        <span class="hljs-type">int</span> b = t.second;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> temp = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(b--) temp = (a*temp+<span class="hljs-number">1</span>)%mod;<br>        res = res*temp%mod;<br>    &#125;<br>    <br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大公约数">最大公约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最小公倍数">最小公倍数</h3><p>在#include&lt;algorithm&gt;后可以使用__gcd(a,b)求最小公倍数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a*b/<span class="hljs-built_in">gcd</span>(a,b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="欧拉函数">欧拉函数</h3><p><span class="math inline">\(1-N\)</span>中与<spanclass="math inline">\(N\)</span>互质的数的个数称为欧拉函数</p><p>若<spanclass="math inline">\(N=P_1^{a_1}P_2^{a_2}...P_m^{a_m}\)</span>,则<spanclass="math inline">\(f(N)=N*\frac{p_1-1}{p1}*\frac{p_2-1}{p2}*...*\frac{p_m-1}{pm}\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res = res / i * (i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) res = res / x * (x - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>筛法求欧拉函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">int</span> euler[N];           <span class="hljs-comment">// 存储每个数的欧拉函数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_eulers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    euler[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            primes[cnt ++ ] = i;<br>            euler[i] = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> t = primes[j] * i;<br>            st[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>)<br>            &#123;<br>                euler[t] = euler[i] * primes[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            euler[t] = euler[i] * (primes[j] - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速幂">快速幂</h3><p>求 m^k mod p，时间复杂度 O(logk)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k)&#123;<br>        <span class="hljs-keyword">if</span>(k&amp;<span class="hljs-number">1</span>)&#123;<br>            res = (LL) res*a%p;<br>        &#125;<br>        k&gt;&gt;=<span class="hljs-number">1</span>;<br>        a=(LL)a*a%p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求组合数">求组合数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j ++ )<br>            <span class="hljs-keyword">if</span> (!j) c[i][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % mod;<br></code></pre></td></tr></table></figure><h3 id="龟速乘">龟速乘</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LL <span class="hljs-title">qadd</span><span class="hljs-params">(LL a, LL b, LL p)</span></span>&#123;<br>    LL res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res = (res+a)%p;<br>        a = (a+a) % p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯题集</title>
    <link href="/2023/03/22/Algorithm/LanQiao/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E9%9B%86/"/>
    <url>/2023/03/22/Algorithm/LanQiao/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>蓝桥杯好题 <span id="more"></span></p><h3 id="回溯">回溯</h3><p><ahref="https://www.acwing.com/activity/content/problem/content/1551/">1209带分数</a></p><h3 id="卡尔可夫链式问题">卡尔可夫链式问题</h3><h5 id="砖块---acwing题库"><ahref="https://www.acwing.com/problem/content/3780/">3777. 砖块 -AcWing题库</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string s;<br><span class="hljs-type">int</span> n,t;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(string &amp;temp, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(temp[x] == <span class="hljs-string">&#x27;W&#x27;</span>) temp[x] = <span class="hljs-string">&#x27;B&#x27;</span>;<br>    <span class="hljs-keyword">else</span> temp[x] = <span class="hljs-string">&#x27;W&#x27;</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;<br>    string temp = s;<br>    vector&lt;<span class="hljs-type">int</span>&gt;res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(temp[i] != c)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">update</span>(temp,i);<br>            <span class="hljs-built_in">update</span>(temp,i+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(temp[n<span class="hljs-number">-1</span>] != c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    cout&lt;&lt;res.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!res.<span class="hljs-built_in">empty</span>())&#123;<br>        cout&lt;&lt;res.<span class="hljs-built_in">back</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        res.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        cin&gt;&gt;n;<br>        cin&gt;&gt;s;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">check</span>(<span class="hljs-string">&#x27;W&#x27;</span>) &amp;&amp; !<span class="hljs-built_in">check</span>(<span class="hljs-string">&#x27;B&#x27;</span>)) cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="费解的开关---acwing题库"><ahref="https://www.acwing.com/problem/content/97/">95. 费解的开关 -AcWing题库</a></h5><h5 id="翻硬币---acwing题库"><ahref="https://www.acwing.com/problem/content/1210/">1208. 翻硬币 -AcWing题库</a></h5><h3 id="博弈论">博弈论</h3><p><ahref="https://www.lanqiao.cn/problems/2061/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;difficulty=30&amp;tags=2022">灭鼠先锋</a></p><h3 id="前缀和">前缀和</h3><p><ahref="https://www.lanqiao.cn/problems/2109/learning/?page=2&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;difficulty=30&amp;tags=2022">统计子矩阵</a></p><p>70</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">510</span>][<span class="hljs-number">510</span>],s[<span class="hljs-number">510</span>][<span class="hljs-number">510</span>];<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            s[i][j] = s[i<span class="hljs-number">-1</span>][j] + s[i][j<span class="hljs-number">-1</span>] - s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;x++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;y&lt;=m;y++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y;j&lt;=m;j++)&#123;<br>                    <span class="hljs-type">int</span> x1 = i - x + <span class="hljs-number">1</span>;<br>                    <span class="hljs-type">int</span> y1 = j - y + <span class="hljs-number">1</span>;<br>                    <span class="hljs-type">int</span> sum = s[i][j] - s[x1<span class="hljs-number">-1</span>][j] - s[i][y1<span class="hljs-number">-1</span>] + s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>];<br>                    <span class="hljs-keyword">if</span>(sum &lt;= k) ans++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>100</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">501</span>;<br><span class="hljs-type">int</span> a[maxn][maxn];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 请在此输入您的代码</span><br><span class="hljs-type">int</span> n,m,k;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i++)<br>&#123;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br> &#123;<br>   cin &gt;&gt; a[i][j];<br>   <span class="hljs-comment">//为了后面计算方便，维护纵向前缀和</span><br>   <span class="hljs-comment">//a[i][j]表示前i行第j列之和</span><br>   a[i][j] += a[i<span class="hljs-number">-1</span>][j];<br> &#125;<br>&#125;<br><span class="hljs-comment">//遍历上边界和下边界</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<span class="hljs-comment">//遍历上边界</span><br>&#123;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ii = i; ii &lt;= n; ii++)<span class="hljs-comment">//遍历下边界</span><br> &#123;<br>   <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1</span>;<span class="hljs-comment">//滑动窗口的左右端点</span><br>   <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-comment">//区间前缀和：[l,r]区间的累计和</span><br>   <span class="hljs-keyword">for</span>(r = <span class="hljs-number">1</span>; r &lt;= m; r++)<span class="hljs-comment">//遍历右端点，根据区间和调整左端点</span><br>   &#123;<br>     sum += a[ii][r] - a[i<span class="hljs-number">-1</span>][r];<span class="hljs-comment">//加上右端点处的和</span><br>     <span class="hljs-keyword">while</span>(sum &gt; k)<span class="hljs-comment">//区间和了，左端点右移，区间变小</span><br>     &#123;<br>       sum -= a[ii][l] - a[i<span class="hljs-number">-1</span>][l];<span class="hljs-comment">//减去移出去的左端点处的和</span><br>       l++;<br>     &#125;<br>     ans += r - l + <span class="hljs-number">1</span>;<span class="hljs-comment">//方法数就是找到的区间大小累加</span><br>   &#125;<br> &#125;<br>&#125;<br>cout &lt;&lt; ans &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分应用">二分应用</h3><p><ahref="https://www.acwing.com/problem/content/description/732/">730.机器人跳跃问题 - AcWing题库</a></p><h3 id="空间换时间">空间换时间</h3><p><a href="https://www.acwing.com/problem/content/1223/">1221. 四平方和- AcWing题库</a></p><h3 id="填空">填空</h3><p><ahref="https://www.lanqiao.cn/problems/598/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tags=2022,省赛">冒泡排序次数</a></p><p><ahref="https://www.lanqiao.cn/problems/597/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tags=2022,省赛">跑步锻炼</a></p><p><ahref="https://www.lanqiao.cn/problems/1463/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tags=2022,省赛">货物摆放</a></p><p><ahref="https://www.lanqiao.cn/problems/646/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tags=2022,省赛">等差素数列</a></p><h3 id="动态规划">动态规划</h3><p><a href="https://www.acwing.com/problem/content/1214/">1212. 地宫取宝- AcWing题库</a></p><h3 id="深搜">深搜</h3><p><ahref="https://www.lanqiao.cn/problems/506/learning/?problem_list_id=1&amp;page=1&amp;sort=students_count">作物杂交- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2010</span>;<br><br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q[N];<br><span class="hljs-type">int</span> w[N],have[N],f[N];<br><span class="hljs-type">int</span> n,m,k,t;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;q[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-type">int</span> need1 = q[u][i].first;<br>    <span class="hljs-type">int</span> need2 = q[u][i].second;<br>    <span class="hljs-keyword">if</span>(!have[need1]) <span class="hljs-built_in">dfs</span>(need1);<br>    <span class="hljs-keyword">if</span>(!have[need2]) <span class="hljs-built_in">dfs</span>(need2);<br>    <span class="hljs-keyword">if</span>(have[need1] &amp;&amp; have[need2])&#123;<br>      have[u] = <span class="hljs-number">1</span>;<br>      f[u] = <span class="hljs-built_in">min</span>(f[u],<span class="hljs-built_in">max</span>(f[need1],f[need2]) + <span class="hljs-built_in">max</span>(w[need1], w[need2]));<br>      <span class="hljs-comment">// return f[u];</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> f[u];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> f);<br>  cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;t;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<br>    cin&gt;&gt;w[i];<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>    <span class="hljs-type">int</span> x;<br>    cin&gt;&gt;x;<br>    have[x] = <span class="hljs-number">1</span>;<br>    f[x] = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>    <span class="hljs-type">int</span> a,b,c;<br>    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>    q[c].<span class="hljs-built_in">push_back</span>(&#123;a,b&#125;);<br>  &#125;<br><br>  cout&lt;&lt;<span class="hljs-built_in">dfs</span>(t);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图论">图论</h3><p><a href="https://www.acwing.com/problem/content/1490/">1488. 最短距离- AcWing题库</a></p><h3 id="模拟">模拟</h3><p><a href="https://www.acwing.com/problem/content/3212/">3209. 集合竞价- AcWing题库</a></p><h3 id="暴力">暴力</h3><p><ahref="https://www.acwing.com/problem/content/description/1207/">1205.买不到的数目 - AcWing题库</a></p><p><a href="https://www.acwing.com/problem/content/1212/">1210.连号区间数 - AcWing题库</a></p>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯小知识</title>
    <link href="/2023/03/20/Algorithm/LanQiao/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/03/20/Algorithm/LanQiao/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>总结蓝桥杯常见的小考点 <span id="more"></span></p><h3 id="判断闰年">判断闰年</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(x%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;x%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span> || x%<span class="hljs-number">400</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="蛇形数组">蛇形数组</h3><p>注意算a[20,20]要满足j&gt;=20 &amp;&amp; i-j+1 &gt;=20,i要算到40多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">300</span>][<span class="hljs-number">300</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> reverse = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">50</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(reverse)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++) &#123;<br>                a[j][i - j + <span class="hljs-number">1</span>] = cnt++;<br>                cout&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;i-j+<span class="hljs-number">1</span>&lt;&lt;endl;<br>            &#125;<br>            reverse = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++) &#123;<br>                a[i - j + <span class="hljs-number">1</span>][j] = cnt++;<br>                cout&lt;&lt;i-j+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;endl;<br>            &#125;<br>            reverse = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;a[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用unordered_map">使用unordered_map</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tr1/unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tr1/unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::tr1;<br></code></pre></td></tr></table></figure><h3 id="判断两个日期之间的回文日期">判断两个日期之间的回文日期</h3><p>蓝桥杯的日期很多都是直接遍历两个int类型之间，判断int是否有效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> months[<span class="hljs-number">13</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> date)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> year = date / <span class="hljs-number">10000</span>;<br>    <span class="hljs-type">int</span> month = date % <span class="hljs-number">10000</span> / <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> day = date % <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">if</span> (!month || month &gt;= <span class="hljs-number">13</span> || !day) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (month != <span class="hljs-number">2</span> &amp;&amp; day &gt; months[month]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (month == <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-type">bool</span> leap = year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> || year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (day &gt; <span class="hljs-number">28</span> + leap) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> date1, date2;<br>    cin &gt;&gt; date1 &gt;&gt; date2;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x = i, r = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j ++ ) r = r * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>, x /= <span class="hljs-number">10</span>;<br><br>        <span class="hljs-keyword">if</span> (r &gt;= date1 &amp;&amp; r &lt;= date2 &amp;&amp; <span class="hljs-built_in">check</span>(r)) res ++ ;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遍历ab之间所有日期">遍历AB之间所有日期</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> months[<span class="hljs-number">15</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check_year</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;x%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span> || x%<span class="hljs-number">400</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    string sx = <span class="hljs-built_in">to_string</span>(x);<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=sx.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=j)&#123;<br>        <span class="hljs-keyword">if</span>(sx[i]!=sx[j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        i++;j--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> cur)</span></span>&#123;<br>    <span class="hljs-type">int</span> year = cur / <span class="hljs-number">10000</span>;<br>    <span class="hljs-type">int</span> month = (cur / <span class="hljs-number">100</span>) % <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> day = cur % <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">if</span>(month == <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check_year</span>(year)) months[<span class="hljs-number">2</span>] = <span class="hljs-number">29</span>;<br>        <span class="hljs-keyword">else</span> months[<span class="hljs-number">2</span>] = <span class="hljs-number">28</span>;<br>    &#125; <br>    <br>    <span class="hljs-keyword">if</span>(day+<span class="hljs-number">1</span>&lt;=months[month]) cur++;<br>    <span class="hljs-keyword">else</span>&#123;<br>        day = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(month+<span class="hljs-number">1</span>&lt;=<span class="hljs-number">12</span>) cur = year * <span class="hljs-number">10000</span> + (month+<span class="hljs-number">1</span>) * <span class="hljs-number">100</span> + day;<br>        <span class="hljs-keyword">else</span>&#123;<br>            month = <span class="hljs-number">1</span>;<br>            cur = (year+<span class="hljs-number">1</span>)*<span class="hljs-number">10000</span> + month * <span class="hljs-number">100</span> + day;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&lt;=m;i=<span class="hljs-built_in">update</span>(i))&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(i)) res++;<br>    &#125;<br>    <br>    cout&lt;&lt;res;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长上升子序列">最长上升子序列</h3><p>新建一个 low 数组，low [ i]表示长度为i的LIS结尾元素的最小值。对于一个上升子序列，显然其结尾元素越小，越有利于在后面接其他的元素，也就越可能变得更长。因此，我们只需要维护low 数组，对于每一个a[ i ]，如果a[ i ] &gt; low[当前最长的LIS长度]，就把 a [ i ]接到当前最长的LIS后面，即low[++当前最长的LIS长度] = a [ i ]。 那么，怎么维护 low 数组呢？对于每一个a [ i ]，如果a [ i ]能接到 LIS 后面，就接上去；否则，就用 a [i ] 取更新 low 数组。具体方法是，在low数组中找到第一个大于等于a [ i]的元素low [ j ]，用a [ i ]去更新 low [ j ]。如果从头到尾扫一遍 low数组的话，时间复杂度仍是O(n^2)。我们注意到 low数组内部一定是单调不降的，所有我们可以二分 low数组，找出第一个大于等于a[ i ]的元素。二分一次 low数组的时间复杂度的O(lgn)，所以总的时间复杂度是O(nlogn)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span>  </span><br>  <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-type">int</span> num[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>&#125;;  <br>  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;  <br><span class="hljs-type">int</span> l=<span class="hljs-number">10</span>, g[<span class="hljs-number">100</span>], d[<span class="hljs-number">100</span>];  <br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-built_in">fill</span>(g, g+l, INF);  <br>    <span class="hljs-type">int</span> max_=<span class="hljs-number">-1</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;l; i++)  <br>    &#123;  <br>        <span class="hljs-type">int</span> j = <span class="hljs-built_in">lower_bound</span>(g, g+l, num[i]) - g;  <br>        d[i] = j+<span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span>(max_&lt;d[i])  <br>            max_=d[i];  <br>        g[j] = num[i];  <br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, max_);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125; <br><br></code></pre></td></tr></table></figure><h3 id="异或">异或</h3><p>必要异或运算性质： 归零律：a⊕a三0 结合律：a⊕b⊕c=a⊕(b⊕c)=(a⊕b)⊕c交换律：a⊕b=b⊕a 因此，a⊕b=x→a⊕b⊕x=0→a⊕x=b因此对于一个数a,与a配对的数可以直接计算得出，即为a⊕c</p>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSP 重点</title>
    <link href="/2023/03/14/Algorithm/CCF-CSP/CSP-%E9%87%8D%E7%82%B9/"/>
    <url>/2023/03/14/Algorithm/CCF-CSP/CSP-%E9%87%8D%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 重要题目 <span id="more"></span></p><h3 id="买菜---acwing题库"><ahref="https://www.acwing.com/problem/content/3266/">3263. 买菜 -AcWing题库</a></h3><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230528104827.png" style="zoom: 80%;" /></p><p>两组区间求相交的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2010</span>;<br><br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; a[N],b[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;p,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p.second &lt; q.first || q.second &lt; p.first) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(p.second,q.second) - <span class="hljs-built_in">max</span>(p.first,q.first);<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i].first&gt;&gt;a[i].second;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;b[i].first&gt;&gt;b[i].second;<br>    &#125;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            sum += <span class="hljs-built_in">get</span>(a[i],b[j]);<br>        &#125;<br>    &#125;<br><br>    cout&lt;&lt;sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出行计划---acwing题库">[4455. 出行计划 - AcWing题库</h3><p><a href="https://www.acwing.com/problem/content/4458/"></a></p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230528104748.png" style="zoom:67%;" /></p><p>很隐蔽的差分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,k;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> t,c;<br>        cin&gt;&gt;t&gt;&gt;c;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,t-k-c+<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> r = t-k;<br>        <span class="hljs-keyword">if</span>(r &gt; <span class="hljs-number">0</span>)&#123;<br>            a[l]++;<br>            a[r+<span class="hljs-number">1</span>]--;<br>        &#125;<br>    <br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++) a[i] = a[i] + a[i<span class="hljs-number">-1</span>];<br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        cout&lt;&lt;a[x]&lt;&lt;endl;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="化学方程式---acwing题库"><ahref="https://www.acwing.com/problem/content/description/3287/">3284.化学方程式 - AcWing题库</a></h3><p>String处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> unordered_map&lt;string, <span class="hljs-type">int</span>&gt; MPSI;<br><br><span class="hljs-function">MPSI <span class="hljs-title">dfs</span><span class="hljs-params">(string&amp; str, <span class="hljs-type">int</span>&amp; u)</span></span><br><span class="hljs-function"></span>&#123;<br>    MPSI res;<br>    <span class="hljs-keyword">while</span> (u &lt; str.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">if</span> (str[u] == <span class="hljs-string">&#x27;(&#x27;</span>)<br>        &#123;<br>            u ++ ;  <span class="hljs-comment">// 过滤掉 &#x27;(&#x27;</span><br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(str, u);<br>            u ++ ;  <span class="hljs-comment">// 过滤掉 &#x27;)&#x27;</span><br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>, k = u;<br>            <span class="hljs-keyword">while</span> (k &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(str[k])) k ++ ;<br>            <span class="hljs-keyword">if</span> (k &gt; u)<br>            &#123;<br>                cnt = <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(u, k - u));<br>                u = k;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: t)<br>                res[c.x] += c.y * cnt;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[u] == <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> k = u + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (k &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; str[k] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; str[k] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) k ++ ;<br>            <span class="hljs-keyword">auto</span> key = str.<span class="hljs-built_in">substr</span>(u, k - u);<br>            u = k;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (k &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(str[k])) k ++ ;<br>            <span class="hljs-keyword">if</span> (k &gt; u)<br>            &#123;<br>                cnt = <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(u, k - u));<br>                u = k;<br>            &#125;<br>            res[key] += cnt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">MPSI <span class="hljs-title">work</span><span class="hljs-params">(string str)</span></span><br><span class="hljs-function"></span>&#123;<br>    MPSI res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; str[j] != <span class="hljs-string">&#x27;+&#x27;</span>) j ++ ;<br>        <span class="hljs-keyword">auto</span> item = str.<span class="hljs-built_in">substr</span>(i, j - i);<br>        i = j;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (k &lt; item.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(item[k])) k ++ ;<br>        <span class="hljs-keyword">if</span> (k) cnt = <span class="hljs-built_in">stoi</span>(item.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k));<br>        <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(item, k);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: t)<br>            res[c.x] += c.y * cnt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        string str;<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> k = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;=&#x27;</span>);<br>        <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">work</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k)), right = <span class="hljs-built_in">work</span>(str.<span class="hljs-built_in">substr</span>(k + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">if</span> (left == right) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Y&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;N&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/3212/">3209. 集合竞价- AcWing题库</a></p><p>模拟</p><p><ahref="https://www.acwing.com/problem/content/description/3222/">3219.模板生成系统 - AcWing题库</a></p><p>字符串处理</p><h3 id="日期模拟题">日期模拟题</h3><p>现在，给你 a,b,c 和 y1,y2，希望你输出从公元 y1 年到公元 y2年间的每年的 a月的第 b 个星期 c 的日期。已知 18501年 1 月 1日是星期二。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//日期题套路，12个月，开13个位置，第0个为占位符</span><br><span class="hljs-type">int</span> months[<span class="hljs-number">13</span>] = &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span><br>&#125;;<br><br><span class="hljs-comment">//判断某一年是否是闰年的函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">is_leap</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span> || (year % <span class="hljs-number">4</span>  == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//求某月有多少天的函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_days</span><span class="hljs-params">(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(month == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> months[month] + <span class="hljs-built_in">is_leap</span>(year); <span class="hljs-comment">//如果是2月的话返回天数和是否是闰年，如果是闰年2月份+1天</span><br>    <span class="hljs-keyword">return</span> months[month]; <span class="hljs-comment">//不是2月份则直接返回天数即可</span><br>&#125;<br><br><span class="hljs-comment">//星期一到星期日用0~6表示</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b, c, y1, y2;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; y1 &gt;&gt; y2;<br><br>    <span class="hljs-type">int</span> days = <span class="hljs-number">0</span>; <span class="hljs-comment">//表示过了多少天</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> year = <span class="hljs-number">1850</span>; year &lt;= y2; year ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> month = <span class="hljs-number">1</span>; month &lt;= <span class="hljs-number">12</span>; month ++ )<br>        &#123;<br>            <span class="hljs-keyword">if</span>(year &gt;= y1 &amp;&amp; month == a)<br>            &#123;<br>                <span class="hljs-type">int</span> w = (<span class="hljs-number">1</span> + days) % <span class="hljs-number">7</span>; <span class="hljs-comment">//先算一下这个月的1月1号是星期几,1850年1月1日是星期二，下标为1</span><br>                <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">//统计一下当前是枚举到的第几个星期c</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d = <span class="hljs-number">1</span>; d &lt;= <span class="hljs-built_in">get_days</span>(year, month); d ++ ) <span class="hljs-comment">//枚举一下这个月的所有天</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span>(w == c - <span class="hljs-number">1</span>) <span class="hljs-comment">//星期的下标从0开始，所以要-1，如星期七的下标是6</span><br>                    cnt ++ ;<span class="hljs-comment">//星期c的个数++</span><br>                    <span class="hljs-keyword">if</span>(cnt == b) <span class="hljs-comment">//如果星期c的个数等于b的话，满足条件，输出</span><br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d/%02d/%02d\n&quot;</span>, year, month, d);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    w = (w + <span class="hljs-number">1</span>) % <span class="hljs-number">7</span>; <span class="hljs-comment">//每过一天，星期需要往后错一位</span><br>                &#125;<br>                <span class="hljs-keyword">if</span>(cnt &lt; b) <span class="hljs-comment">//枚举完这个月后，如果星期c出现的次数小于b，说明没有第b个星期c，输出none</span><br>                &#123;<br>                    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;none&quot;</span>);<br>                &#125;<br>            &#125;<br>            days += <span class="hljs-built_in">get_days</span>(year, month); <span class="hljs-comment">//这个月过完之后加上这个月过的天数</span><br>        &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSP 20</title>
    <link href="/2023/03/13/Algorithm/CCF-CSP/CSP-20/"/>
    <url>/2023/03/13/Algorithm/CCF-CSP/CSP-20/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 第20届 <span id="more"></span></p><h3 id="称检测点查询"><ahref="https://www.acwing.com/problem/content/3295/">1.称检测点查询</a></h3><p>pair模板的小根堆 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,px,py;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; q;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;px&gt;&gt;py;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-type">int</span> d = (px-x)*(px-x) + (py-y)*(py-y);<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(d,i));<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>        cout&lt;&lt;q.<span class="hljs-built_in">top</span>().second&lt;&lt;endl;<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>c++重载运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,px,py;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> d;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point&amp; t) <span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">if</span>(d!=t.d) <span class="hljs-keyword">return</span> d&lt;t.d;<br>        <span class="hljs-keyword">return</span> id &lt; t.id;<br>    &#125;<br>&#125;q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (px-x)*(px-x) + (py-y)*(py-y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;px&gt;&gt;py;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        q[i] = &#123;x,y,<span class="hljs-built_in">distance</span>(x,y),i+<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(q,q+n);<br>    <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>        cout&lt;&lt;q[i].id&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="风险人群筛查"><ahref="https://www.acwing.com/problem/content/3296/">2.风险人群筛查</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,k,t,xl,yd,xr,yu;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> res[<span class="hljs-number">2</span>];<br>    cin&gt;&gt;n&gt;&gt;k&gt;&gt;t&gt;&gt;xl&gt;&gt;yd&gt;&gt;xr&gt;&gt;yu;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> max_cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;t;j++)&#123;<br>            <span class="hljs-type">int</span> x,y;<br>            cin&gt;&gt;x&gt;&gt;y;<br>            <span class="hljs-keyword">if</span>(x&gt;=xl &amp;&amp; x&lt;=xr &amp;&amp; y&gt;=yd &amp;&amp; y&lt;=yu)&#123;<br>                cnt++;<br>                <span class="hljs-keyword">if</span>(cnt &gt; max_cnt)&#123;<br>                    max_cnt = cnt;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(cnt &gt; max_cnt)&#123;<br>                    max_cnt = cnt;<br>                &#125;<br>                cnt = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(max_cnt) res[<span class="hljs-number">0</span>]++;<br>        <span class="hljs-keyword">if</span>(max_cnt&gt;=k) res[<span class="hljs-number">1</span>]++;<br>    &#125;<br>    <br>    cout&lt;&lt;res[<span class="hljs-number">0</span>]&lt;&lt;endl&lt;&lt;res[<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL,排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSP 22</title>
    <link href="/2023/03/11/Algorithm/CCF-CSP/CSP-22/"/>
    <url>/2023/03/11/Algorithm/CCF-CSP/CSP-22/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 第22届 <span id="more"></span></p><h3 id="灰度直方图"><ahref="https://www.acwing.com/problem/content/3414/">1.灰度直方图</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">256</span>;<br><br><span class="hljs-type">int</span> h[N];<br><span class="hljs-type">int</span> n,m,l;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;l;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            h[x] ++ ;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<br>        cout&lt;&lt;h[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻域均值"><ahref="https://www.acwing.com/problem/content/3415/">2.邻域均值</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">610</span>;<br><span class="hljs-type">int</span> n,l,r,t;<br><span class="hljs-type">int</span> res;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> sum[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;l,&amp;r,&amp;t);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>        &#125;·<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            sum[i][j] = sum[i<span class="hljs-number">-1</span>][j] + sum[i][j<span class="hljs-number">-1</span>] - sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-type">int</span> left,right,top,bottom;<br>            left = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,i-r);<br>            right = <span class="hljs-built_in">min</span>(n,i+r);<br>            top = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,j-r);<br>            bottom = <span class="hljs-built_in">min</span>(n,j+r);<br>            <span class="hljs-type">int</span> nums = (right-left+<span class="hljs-number">1</span>)*(bottom-top+<span class="hljs-number">1</span>);<br>            <span class="hljs-type">float</span> avg = sum[bottom][right] - sum[top<span class="hljs-number">-1</span>][right] - sum[bottom][left<span class="hljs-number">-1</span>] + sum[top<span class="hljs-number">-1</span>][left<span class="hljs-number">-1</span>];<br>            avg /= nums;<br>            <span class="hljs-keyword">if</span>(avg &lt;= t) res++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二维前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSP 23</title>
    <link href="/2023/03/11/Algorithm/CCF-CSP/CSP-23/"/>
    <url>/2023/03/11/Algorithm/CCF-CSP/CSP-23/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 202212 第23届题目 <span id="more"></span></p><h3 id="收集卡牌"><ahref="https://www.acwing.com/problem/content/4012/">4. 收集卡牌</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">17</span>,M = <span class="hljs-number">1</span>&lt;&lt;N;<span class="hljs-comment">// M代表状态数</span><br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">double</span> p[N];<br><span class="hljs-type">double</span> f[M][N*<span class="hljs-number">5</span>+<span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> state,<span class="hljs-type">int</span> coins,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">double</span>&amp; v = f[state][coins];<br>    <span class="hljs-keyword">if</span>(v&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> v;<br>    <span class="hljs-keyword">if</span>(coins &gt;= m*r) <span class="hljs-keyword">return</span> v = <span class="hljs-number">0</span>;<br>    <br>    v = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(state&gt;&gt;i&amp;<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">// 判断第i位是否为1</span><br>            v += p[i]*(<span class="hljs-built_in">dp</span>(state,coins+<span class="hljs-number">1</span>,r) + <span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            v += p[i]*(<span class="hljs-built_in">dp</span>(state | (<span class="hljs-number">1</span>&lt;&lt;i),coins,r<span class="hljs-number">-1</span>) + <span class="hljs-number">1</span>);<span class="hljs-comment">// 把第i位赋值为1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;p[i]);<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.10lf\n&quot;</span>, <span class="hljs-built_in">dp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n));<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制状态表示</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSP 201312</title>
    <link href="/2023/03/08/Algorithm/CCF-CSP/CSP-0/"/>
    <url>/2023/03/08/Algorithm/CCF-CSP/CSP-0/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 201312 第0届题目 <span id="more"></span></p><h3 id="最大的矩形"><ahref="https://www.acwing.com/problem/content/3197/">3.最大的矩形</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;h[i];<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i - l &gt;= <span class="hljs-number">0</span> &amp;&amp; h[i-l] &gt;= h[i]) l++;<br>        <span class="hljs-keyword">while</span>(i+r&lt;n&amp;&amp;h[i+r]&gt;=h[i]) r++;<br>        res = <span class="hljs-built_in">max</span>(res,h[i]*(l+r<span class="hljs-number">-1</span>));<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有趣的数"><ahref="https://www.acwing.com/problem/content/3198/">4. 有趣的数</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// c&#123;n-1&#125;&#123;k&#125;(k-1)(n-k-1)</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> c[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!j) c[i][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> c[i][j] = (c[i<span class="hljs-number">-1</span>][j] + c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) % N;<br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n<span class="hljs-number">-2</span>;i++)&#123;<br>        sum = (sum + c[n<span class="hljs-number">-1</span>][i]*(i<span class="hljs-number">-1</span>)*(n-i<span class="hljs-number">-1</span>))%N;<br>    &#125;<br>    <br>    cout&lt;&lt;sum;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划(中) 线性DP</title>
    <link href="/2023/02/25/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%AD-%E7%BA%BF%E6%80%A7DP/"/>
    <url>/2023/02/25/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%AD-%E7%BA%BF%E6%80%A7DP/</url>
    
    <content type="html"><![CDATA[<p>动态规划中的线性DP</p><span id="more"></span><h3 id="数字三角形">数字三角形</h3><h5 id="自上而下">自上而下</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">1</span>) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + a[i][j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == i) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][j]) + a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">-1e7</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        res = <span class="hljs-built_in">max</span>(res,dp[n][i]);<br>    &#125;<br><br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="自下而上">自下而上</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j],dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]) + a[i][j];<br>        &#125;<br>    &#125;<br><br>    cout&lt;&lt;dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长上升子序列">最长上升子序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(N,<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[i]&gt;a[j]) dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=n;i++) res = <span class="hljs-built_in">max</span>(res,dp[i]);<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSP 27</title>
    <link href="/2023/02/24/Algorithm/CCF-CSP/CSP-27/"/>
    <url>/2023/02/24/Algorithm/CCF-CSP/CSP-27/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 202212 第27届题目 <span id="more"></span></p><h3 id="如此编码">如此编码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N],c[N],l[N],b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    c[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        c[i] = c[i<span class="hljs-number">-1</span>]*a[i];<br>        l[i] = m%c[i];<br>        l[i] = l[i] - l[i<span class="hljs-number">-1</span>];<br>        b[i] = l[i]/c[i<span class="hljs-number">-1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="何以包邮">何以包邮</h3><h5 id="回溯暴搜">回溯暴搜</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">40</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">100000</span>];<br><span class="hljs-type">int</span> res = <span class="hljs-number">1e9</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> sum)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i==n)&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt;=m)&#123;<br>            res = <span class="hljs-built_in">min</span>(res,sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,sum);<br>    <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,sum+a[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dp">DP</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">40</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">100000</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        sum += a[i];<br>    &#125;<br><br>    <span class="hljs-type">int</span> target = sum - m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=target;j&gt;=a[i];j--)&#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-a[i]]+a[i]);<br>        &#125;<br>    &#125;<br><br>    cout&lt;&lt;sum - dp[target];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSP 28</title>
    <link href="/2023/02/24/Algorithm/CCF-CSP/CSP-28/"/>
    <url>/2023/02/24/Algorithm/CCF-CSP/CSP-28/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 202212 第28届题目 <span id="more"></span></p><h3 id="训练计划"><ahref="http://118.190.20.162/view.page?gpid=T159">2.训练计划</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N],p[N],l[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;p[i];<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">min</span><span class="hljs-params">(m+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]!=<span class="hljs-number">0</span>) min[i] = min[a[i]] + p[a[i]];<br>    &#125;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">max</span>(m+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        max[i] = n - p[i] + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> early = <span class="hljs-number">10</span> - max[i] + <span class="hljs-number">1</span> + l[i];<br>            l[a[i]] = l[a[i]]&gt;early?l[a[i]]:early;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        max[i] -= l[i];<br>        <span class="hljs-keyword">if</span>(max[i]&lt;<span class="hljs-number">0</span>) sign = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cout&lt;&lt;min[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(sign)&#123;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            cout&lt;&lt;max[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常用STL</title>
    <link href="/2023/02/23/Algorithm/%E5%B8%B8%E7%94%A8STL/"/>
    <url>/2023/02/23/Algorithm/%E5%B8%B8%E7%94%A8STL/</url>
    
    <content type="html"><![CDATA[<p>介绍常用的STL <span id="more"></span></p><h3 id="vector">vector</h3><p>变长数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">// 初始化</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(M,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N));<span class="hljs-comment">// 二维vector初始化</span><br>a.<span class="hljs-built_in">size</span>();<br>a.<span class="hljs-built_in">empty</span>();<br>a.<span class="hljs-built_in">front</span>();<br>a.<span class="hljs-built_in">back</span>();<br>a.<span class="hljs-built_in">push_back</span>();<br>a.<span class="hljs-built_in">pop_back</span>();<br><br>vec.<span class="hljs-built_in">erase</span>(a.<span class="hljs-built_in">begin</span>()+i); <span class="hljs-comment">// 删除</span><br></code></pre></td></tr></table></figure><h3 id="pair">pair</h3><p>二元组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br>pair&lt;<span class="hljs-type">int</span>,string&gt; a;<br>a.first; a.second;<br>a = (<span class="hljs-number">20</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>pair&lt;<span class="hljs-type">int</span>,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; b;<span class="hljs-comment">// 三元组</span><br><br><span class="hljs-comment">//按照第一个元素进行排序:</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;a[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;b)</span></span>&#123;<span class="hljs-comment">// 从大到小排序</span><br>    <span class="hljs-keyword">return</span> a.first &gt; b.first;<br>&#125;<br><span class="hljs-built_in">sort</span>(a,a+<span class="hljs-number">10</span>,cmp);<br><span class="hljs-comment">// pair模板的unordered_set</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair_hash</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function">    <span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;T1,T2&gt; <span class="hljs-type">const</span> &amp; pair)</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-type">size_t</span> h1 = <span class="hljs-built_in">hash</span>&lt;T1&gt;()(pair.first);<br>        <span class="hljs-type">size_t</span> h2 = <span class="hljs-built_in">hash</span>&lt;T2&gt;()(pair.second);<br>        <span class="hljs-keyword">return</span> h1^h2;<br>    &#125;<br>&#125;;<br><br>unordered_set&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,pair_hash&gt; pset;<br></code></pre></td></tr></table></figure><h3 id="string">string</h3><p>字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">string a = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>cout&lt;&lt; a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">// &quot;bc&quot; 代表起始下标为1，长度为2的子串</span><br>a.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;cd&quot;</span>) <span class="hljs-comment">// O(n^2)复杂度,如果没找到返回string::npos</span><br>a.<span class="hljs-built_in">replace</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// 将字符串从2开始后面2位替换为空串</span><br><span class="hljs-built_in">stoi</span>(<span class="hljs-string">&quot;123&quot;</span>)<span class="hljs-comment">// string转int</span><br><span class="hljs-built_in">stof</span>(<span class="hljs-string">&quot;1.23&quot;</span>)<span class="hljs-comment">// string转float</span><br><span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">char</span> *ptr = <span class="hljs-built_in">strstr</span>(s,<span class="hljs-string">&quot;cd&quot;</span>);<br>cout&lt;&lt; ptr - s;<span class="hljs-comment">// O(n)复杂度查找子串返回起始位置，需要用#include&lt;cstring&gt;</span><br><span class="hljs-built_in">to_string</span>(<span class="hljs-type">int</span>)<span class="hljs-comment">// int转string</span><br><br></code></pre></td></tr></table></figure><h3 id="queue">queue</h3><p>队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>();<span class="hljs-comment">// 向队尾插入</span><br>q.<span class="hljs-built_in">front</span>();<span class="hljs-comment">// 返回队头元素</span><br>q.<span class="hljs-built_in">back</span>();<span class="hljs-comment">// 返回队尾元素</span><br>q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 弹出对头元素，无返回值</span><br></code></pre></td></tr></table></figure><h3 id="priority_queue">priority_queue</h3><p>优先队列（堆）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">//默认大根堆</span><br><br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap;<span class="hljs-comment">//小根堆定义</span><br><br>q.<span class="hljs-built_in">push</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>q.<span class="hljs-built_in">top</span>();<br><br><span class="hljs-comment">// 使用pair模板</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII<br>priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;<span class="hljs-comment">// 按pair第一个元素排序</span><br>q.<span class="hljs-built_in">push</span>(&#123;d,i&#125;);<span class="hljs-comment">// 插入</span><br><br></code></pre></td></tr></table></figure><p>### deque</p><p>双端队列,效率低，慎用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;<span class="hljs-type">int</span>&gt; d;<br>d.<span class="hljs-built_in">front</span>();<br>d.<span class="hljs-built_in">back</span>();<br>d.<span class="hljs-built_in">push_back</span>();d.<span class="hljs-built_in">pop_back</span>()<br>d.<span class="hljs-built_in">push_front</span>();d.<span class="hljs-built_in">pop_front</span>();<br></code></pre></td></tr></table></figure><h3 id="setmultiset">set/multiset</h3><p>集合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>&gt; s;<br>s.<span class="hljs-built_in">insert</span>();<br>s.<span class="hljs-built_in">find</span>();<br>s.<span class="hljs-built_in">count</span>();<br>s.<span class="hljs-built_in">erase</span>();<span class="hljs-comment">// 删除所有对应的值</span><br>s.<span class="hljs-built_in">lower_bound</span>();<span class="hljs-comment">//大于等于x的最小的数</span><br>s.<span class="hljs-built_in">upper_bound</span>();<span class="hljs-comment">//大于x的最小的数</span><br></code></pre></td></tr></table></figure><h3 id="mapmultimap">map/multimap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">map &lt;string,<span class="hljs-type">int</span>&gt; m;<br>m.<span class="hljs-built_in">insert</span>();<span class="hljs-comment">// 插入的是pair</span><br>a[<span class="hljs-string">&quot;test&quot;</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 插入操作</span><br>m.<span class="hljs-built_in">find</span>();<br>cout&lt;&lt;a[<span class="hljs-string">&quot;test&quot;</span>];<span class="hljs-comment">// 时间复杂度O(logn)</span><br>m.<span class="hljs-built_in">earse</span>();<br></code></pre></td></tr></table></figure><h3id="unordered_setunordered_mapunordermap_multisetunordered_multimap">unordered_set/unordered_map/unordermap_multiset/unordered_multimap</h3><p>和上面操作类似，但是不支持lower_bound()和upper_bound()，但是增插改查时间复杂度为O(1).</p><p>两个同类型之间可以直接判等！</p><h3 id="bitset">bitset</h3><p>压位,每个只占一位。可以认为是bool数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">bitset&lt;10000&gt; s;<br>s.<span class="hljs-built_in">count</span>();<span class="hljs-comment">// 返回有几个1</span><br>s.<span class="hljs-built_in">set</span>(k,v);<span class="hljs-comment">// 将第k位变成v，v的取值[&#x27;true&#x27;,&#x27;false&#x27;]</span><br>s.<span class="hljs-built_in">set</span>();<span class="hljs-comment">// 所有值置1</span><br>s.<span class="hljs-built_in">reset</span>();<span class="hljs-comment">// 所有值置0</span><br>s.<span class="hljs-built_in">flip</span>();<span class="hljs-comment">// 等价于~，全部取反</span><br>s.<span class="hljs-built_in">flip</span>(k);<span class="hljs-comment">// 第k位取反S</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python数据处理小知识</title>
    <link href="/2023/02/13/Python/python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/02/13/Python/python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>日常使用pandas、numpy等数据处理库遇到的问题 <span id="more"></span></p><h3id="将两个dataframe在竖直方向上合并">将两个DataFrame在竖直方向上合并</h3><p>当读取多个源文件，并希望将多个表合并为一个表时，使用类似于以下的结构</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"> entire_data = pd.read_csv(<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>    data = pd.read_csv(<span class="hljs-string">&quot;&quot;</span>)<br>entire_data = pd.concat([entire_data,data])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>小知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础数据结构实现(下)</title>
    <link href="/2023/02/12/Algorithm/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0(%E4%B8%8B)/"/>
    <url>/2023/02/12/Algorithm/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0(%E4%B8%8B)/</url>
    
    <content type="html"><![CDATA[<p>介绍Trie树、并查集、堆、散列表 <span id="more"></span></p><h3 id="trie树">Trie树</h3><p>用于大量字符串的存储与查找.</p><p>同时也可以存储整数的二进制表示，相关题目见<ahref="https://www.acwing.com/problem/content/145/">143. 最大异或对 -AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">100010</span>][<span class="hljs-number">26</span>];<br><span class="hljs-type">int</span> cnt[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string s)</span></span>&#123;<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(!a[cur][s[i]]) a[cur][s[i]] = ++idx;<br>        cur = a[cur][s[i]];<br>    &#125;<br>    cnt[cur] ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string s)</span></span>&#123;<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(!a[cur][s[i]]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        cur = a[cur][s[i]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[cur];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        string op, st;<br>        cin&gt;&gt;op&gt;&gt;st;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;I&quot;</span>) <span class="hljs-built_in">insert</span>(st);<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-built_in">query</span>(st)&lt;&lt;endl;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并查集">并查集</h3><p>初始有<spanclass="math inline">\(N\)</span>个独立的集合，并查集可以方便的合并集合并且查找任意两个元素是否属于同一集合。</p><p>原题链接：<a href="https://www.acwing.com/problem/content/838/">836.合并集合 - AcWing题库</a></p><p>并查集的思路为对每个集合维护一个树，并记录每个结点的父节点（根节点的父节点为自身）。合并两个元素<spanclass="math inline">\(x、y\)</span>所在的集合即令其中一个集合的根节点的父节点为另一个集合的根节点,即<spanclass="math inline">\(p(find(x)) = find(y)\)</span>.其中<spanclass="math inline">\(find()\)</span>为查找指定节点的父节点。查找两个元素是否属于同一集合即判断是否有<spanclass="math inline">\(p[x] == p[y]\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> p[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<span class="hljs-comment">// 同时完成了查找根节点与路径压缩</span><br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        a[i] = i;<br>    &#125;<br>    <span class="hljs-type">char</span> op;<br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;M&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x) != <span class="hljs-built_in">find</span>(y)) a[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>((y));<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y)) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆">堆</h3><h4 id="stl">STL</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        pq.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cout&lt;&lt;pq.<span class="hljs-built_in">top</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        pq.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="手动实现">手动实现</h4><p>维护一个二叉树，父结点总是比两个子节点大，则根节点即为最大值。所有操作的核心是向上&amp;向下整理。</p><p>数组下标从1开始，则对于结点<spanclass="math inline">\(i\)</span>,左孩子为<spanclass="math inline">\(2*i\)</span>,右孩子为<spanclass="math inline">\(2*i+1\)</span>,父节点为<spanclass="math inline">\(i/2\)</span>.注意判断父子结点是否在合法范围内。</p><h5 id="向下整理">向下整理</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> temp = x;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*x &lt;= n &amp;&amp; a[<span class="hljs-number">2</span>*x] &lt; a[x]) x = <span class="hljs-number">2</span>*x;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span> &lt;= n &amp;&amp; a[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>] &lt; a[x]) x = <span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(temp != x)&#123;<br>        <span class="hljs-built_in">swap</span>(a[x],a[temp]);<br>        <span class="hljs-built_in">down</span>(x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="向上整理">向上整理</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x/<span class="hljs-number">2</span> &amp;&amp; a[x/<span class="hljs-number">2</span>]&gt;a[x])&#123;<br>        <span class="hljs-built_in">swap</span>(a[x],a[x/<span class="hljs-number">2</span>]);<br>        <span class="hljs-built_in">up</span>(x/<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插入一个数">插入一个数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在数组尾部插入，并向上整理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    a[++cnt] = x;<br>    <span class="hljs-built_in">up</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="取出最大值">取出最大值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_max</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-built_in">swap</span>(a[<span class="hljs-number">1</span>],a[cnt--]);<br>    <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> a[cnt+<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈希表">哈希表</h3><p>只实现开放寻址法，拉链法采用头插法链表。</p><p>对于插入操作在1e5数量级的，数组应该开2e5,同时质数遇到的冲突较少，因此设置<spanclass="math inline">\(N\)</span>=2e5+3.其次设置空位标识符<spanclass="math inline">\(null\)</span>=0x3f3f3f3f.这个数大于1e9.</p><h6 id="初始化">初始化</h6><p>memset按字节赋值，因此对每个字节赋值为0x3f.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> a);<br></code></pre></td></tr></table></figure><h6 id="常见操作">常见操作</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> t = ((x%N)+N)%N;<span class="hljs-comment">// 保证结果为正数</span><br><span class="hljs-keyword">while</span>(a[t] != nulll &amp;&amp; a[t] != x)&#123;<br>    t++;<br>    <span class="hljs-keyword">if</span>(t == N) temp = <span class="hljs-number">0</span>;<span class="hljs-comment">// 循环数组</span><br>&#125;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    a[<span class="hljs-built_in">find</span>(x)] = x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a[<span class="hljs-built_in">find</span>(x)] == null) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符哈希">字符哈希</h3><p>对字符串进行哈希.</p><p>文字讲解：<ahref="https://www.acwing.com/blog/content/15289/">【新手向】字符串哈希详解 - AcWing</a></p><p><a href="https://www.acwing.com/problem/content/843/">841. 字符串哈希- AcWing题库</a></p><p>对于长度为<span class="math inline">\(n\)</span>的字符串<spanclass="math inline">\(S\)</span>,对应哈希值为<spanclass="math inline">\((\sum S_i*P^{(n-i)})*Q\)</span>.出于经验，<spanclass="math inline">\(P=131\)</span>,<spanclass="math inline">\(Q=2^{64}\)</span>. 此时采用unsigned long long作为数组可以通过自然溢出实现取模运算。</p><p>初始定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br>ULL h[N]; <span class="hljs-comment">// 存储字符串每个前缀的哈希值 </span><br>ULL p[N]; <span class="hljs-comment">// 存储展开式中的权值 ( p^0, p^1 , p^2, p^3 ... ) </span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>获得字符串的所有前缀编码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++ )&#123;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i]; <span class="hljs-comment">// 计算字符串每个 前缀 的哈希值 </span><br>    p[i] = p[i - <span class="hljs-number">1</span>] * P; <span class="hljs-comment">// 计算展开式中的各个权值 ( p^0, p^1 , p^2, p^3 ... ) </span><br> &#125;<br></code></pre></td></tr></table></figure><p>则区间[l,r]对应的字符串哈希值为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l<span class="hljs-number">-1</span>]*P[r-l+<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>比较两个字符串是否相等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>( <span class="hljs-built_in">get</span>( l1, r1 ) == <span class="hljs-built_in">get</span>( l2, r2 ) ) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>); <br><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="kmp">KMP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span><br>求模式串的Next数组：<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    ne[i] = j;<br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    <span class="hljs-keyword">if</span> (j == m)<br>    &#123;<br>        j = ne[j];<br>        <span class="hljs-comment">// 匹配成功后的逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础数据结构实现(上)</title>
    <link href="/2023/02/09/Algorithm/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/"/>
    <url>/2023/02/09/Algorithm/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<p>包含数组模拟单项链表、双向链表、栈、队列 <span id="more"></span></p><h3 id="单向链表">单向链表</h3><p><a href="https://www.acwing.com/problem/content/828/">826. 单链表 -AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> e[<span class="hljs-number">100010</span>], ne[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> head,idx;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin&gt;&gt;n;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        string op;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;H&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            ne[idx] = head;<br>            e[idx] = x;<br>            head = idx++;<br><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;D&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>)&#123;<br>                head = ne[head];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ne[x<span class="hljs-number">-1</span>] = ne[ne[x<span class="hljs-number">-1</span>]];<br>            &#125;<br>            <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;I&quot;</span>)&#123;<br>            cin&gt;&gt;x&gt;&gt;y;<br>            e[idx] = y;<br>            ne[idx] = ne[x<span class="hljs-number">-1</span>];<br>            ne[x<span class="hljs-number">-1</span>] = idx;<br>            idx++;<br>        &#125;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head;i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        cout&lt;&lt;e[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双向链表">双向链表</h3><p><a href="https://www.acwing.com/problem/content/829/">827. 双链表 -AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> e[N], ne[N], pe[N];<br><span class="hljs-type">int</span> head,tail,idx;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_left</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    e[idx] = x;<br>    ne[idx] = head;<br>    pe[idx] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-number">-1</span>)&#123;<br>        head = tail = idx;<br>        idx++;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        pe[head] = idx;<br>        head = idx++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_right</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    e[idx] = x;<br>    pe[idx] = tail;<br>    ne[idx] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(tail==<span class="hljs-number">-1</span>)&#123;<br>        head = tail = idx;<br>        idx++;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        ne[tail] = idx;<br>        tail = idx++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    head = tail = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        string op;<br>        <span class="hljs-type">int</span> x,k;<br>        <br>        cin&gt;&gt;op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;L&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">insert_left</span>(x);<br>            <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;R&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">insert_right</span>(x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;D&quot;</span>)&#123;<br>            cin&gt;&gt;k;<br>            <span class="hljs-keyword">if</span>(k==head) head=ne[head];<br>            <span class="hljs-keyword">if</span>(k==tail) tail=pe[tail];<br>            ne[pe[k]] = ne[k];<br>            pe[ne[k]] = pe[k];<br>            <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;IL&quot;</span>)&#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-keyword">if</span>(k==head) <span class="hljs-built_in">insert_left</span>(x);<br>            <span class="hljs-keyword">else</span>&#123;<br>                e[idx] = x;<br>                pe[idx] = pe[k];<br>                ne[idx] = k;<br>                ne[pe[k]] = idx;<br>                pe[k] = idx++;   <br>            &#125;<br>            <br>            <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;IR&quot;</span>)&#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-keyword">if</span>(k==tail) <span class="hljs-built_in">insert_right</span>(x);<br>            <span class="hljs-keyword">else</span>&#123;<br>                e[idx] = x;<br>                ne[idx] = ne[k];<br>                pe[idx] = k;<br>                pe[ne[k]] = idx;<br>                ne[k] = idx++;<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head;i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        cout&lt;&lt;e[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈">栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> top = <span class="hljs-number">-1</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    cin&gt;&gt;m;<br>    string s;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;s;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;push&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            a[++top] = x;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;pop&quot;</span>)&#123;<br>            top--;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;empty&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(top == <span class="hljs-number">-1</span>) cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;query&quot;</span>)&#123;<br>            cout&lt;&lt;a[top]&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="队列">队列</h3><p>注意数组中左边的是head，右边的是tail。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> head = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tail = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    cin&gt;&gt;m;<br>    string s;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;s;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;push&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            a[tail++] = x;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;pop&quot;</span>)&#123;<br>            head++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;empty&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head == tail) cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;query&quot;</span>)&#123;<br>            cout&lt;&lt;a[head<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单调栈">单调栈</h3><p>给定长度为N的整数数列，输出每个数左边第一个比他小的数，若不存在则输出-1</p><p>原题链接：<a href="https://www.acwing.com/problem/content/832/">830.单调栈 - AcWing题库</a></p><p>思路：常规思路为从第i个数向前遍历找到第一个更小的数。但对于a[i]与a[i-1],若a[i-1]&gt;a[i],则a[i-1]永远不可能作为i及以后数的答案，因此可以维护一个栈，若将进栈元素小于栈顶元素，则将栈顶元素出栈。最后得到的栈为值单调上升栈，第i个数的答案即为当前栈的栈顶元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n;<br>    stack&lt;<span class="hljs-type">int</span>&gt;st;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>()) st.<span class="hljs-built_in">push</span>(x),cout&lt;&lt;<span class="hljs-string">&quot;-1 &quot;</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() &gt;= x) st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>()) cout&lt;&lt;<span class="hljs-string">&quot;-1 &quot;</span>;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;st.<span class="hljs-built_in">top</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            st.<span class="hljs-built_in">push</span>(x);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口">滑动窗口</h3><p>给定长度为n的数组和窗口长度k，步长为1，求每个窗口的最大值与最小值。</p><p>原题链接：<ahref="https://www.acwing.com/problem/content/description/156/">154.滑动窗口 - AcWing题库</a></p><p>思路：常规思路为遍历窗口内所有数找出最大最小值。以最小值为例，滑动窗口思路为若a[i]&lt;a[i-1]，则a[i-1]不可能作为答案输出，因此维护一个双端均可出队的队列，若即将入队元素小于队尾元素，则将队尾元素舍去，即在队列中保证单调递增。同时为了去除离开窗口的元素，令上述队列存储元素下标，若队尾元素下标小于i-k+1则对应元素已离开窗口，舍弃即可。每个窗口的答案即为队尾元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> a[M];<br>deque&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">front</span>() &lt;= i-k) q.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>() &amp;&amp; a[q.<span class="hljs-built_in">back</span>()] &gt;= a[i]) q.<span class="hljs-built_in">pop_back</span>();<br>        q.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout&lt;&lt;a[q.<span class="hljs-built_in">front</span>()]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>    q.<span class="hljs-built_in">clear</span>();<br>    cout&lt;&lt;endl;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">front</span>() &lt;= i-k) q.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>() &amp;&amp; a[q.<span class="hljs-built_in">back</span>()] &lt;= a[i]) q.<span class="hljs-built_in">pop_back</span>();<br>        q.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout&lt;&lt;a[q.<span class="hljs-built_in">front</span>()]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法基础课题集</title>
    <link href="/2023/02/04/Algorithm/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E9%A2%98%E9%9B%86/"/>
    <url>/2023/02/04/Algorithm/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>Acwing算法基础课中不熟练题目 <span id="more"></span></p><h3 id="两个数组的目标和">两个数组的目标和</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/802/">800.数组元素的目标和 - AcWing题库</a></p><p>思路：对于双指针要找到两个指针单调的方向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],b[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,x;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) cin&gt;&gt;b[i];<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=m<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]+b[j]==x)&#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;j;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]+b[j]&gt;x) j--;<br>        <span class="hljs-keyword">else</span> i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="离散化">离散化</h3><p>原题链接：<ahref="https://www.acwing.com/problem/content/description/804/">802.区间和 - AcWing题库</a></p><p>思路：将大范围(-1e9~1e9)但是稀疏(只有1e5的数字非0)的向量进行压缩.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> a[N],s[N];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; add;<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; query;<br>vector&lt;<span class="hljs-type">int</span>&gt; all_index;<span class="hljs-comment">// 存储所有需要占据索引的操作（某位置加、两点之间的和），注意需要排序+去重</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">// 二分查找离散化前的值x在离散化后的索引</span><br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=all_index.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> mid = l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(all_index[mid]&gt;=x) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x,c;<br>        cin&gt;&gt;x&gt;&gt;c;<br>        add.<span class="hljs-built_in">push_back</span>(&#123;x,c&#125;);<br>        all_index.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin&gt;&gt;l&gt;&gt;r;<br>        query.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>        all_index.<span class="hljs-built_in">push_back</span>(l);<br>        all_index.<span class="hljs-built_in">push_back</span>(r);<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(all_index.<span class="hljs-built_in">begin</span>(), all_index.<span class="hljs-built_in">end</span>());<br>    all_index.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(all_index.<span class="hljs-built_in">begin</span>(), all_index.<span class="hljs-built_in">end</span>()), all_index.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : add)&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(i.first);<br>        a[x] += i.second;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=all_index.<span class="hljs-built_in">size</span>();i++) s[i] = s[i<span class="hljs-number">-1</span>] + a[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : query)&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">find</span>(i.first);<br>        <span class="hljs-type">int</span> r = <span class="hljs-built_in">find</span>(i.second);<br>        cout&lt;&lt;s[r] - s[l<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="走迷宫bfs">走迷宫(BFS)</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/846/">844.走迷宫 - AcWing题库</a></p><h5 id="做法1">做法1</h5><p>个人做法,采用哈希集合存储已途径的点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> a[N][N];<br><br># unordered_set不能以pair作为模板，需要自己定义相关规则<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair_hash</span><br>&#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(pair&lt;T1, T2&gt; <span class="hljs-type">const</span> &amp;pair)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">size_t</span> h1 = <span class="hljs-built_in">hash</span>&lt;T1&gt;()(pair.first); <span class="hljs-comment">//用默认的 hash 处理 pair 中的第一个数据 X1</span><br>        <span class="hljs-type">size_t</span> h2 = <span class="hljs-built_in">hash</span>&lt;T2&gt;()(pair.second);<span class="hljs-comment">//用默认的 hash 处理 pair 中的第二个数据 X2</span><br>        <span class="hljs-keyword">return</span> h1 ^ h2;<br>    &#125;<br>&#125;;<br># 定义方式<br>unordered_set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, pair_hash&gt; map;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>    q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        ans++;<br>        <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br>            <span class="hljs-keyword">auto</span> temp = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> x = temp.first;<br>            <span class="hljs-type">int</span> y = temp.second;<br>            <span class="hljs-keyword">if</span>(x == n - <span class="hljs-number">1</span> &amp;&amp; y == m - <span class="hljs-number">1</span>) cout&lt;&lt;ans;<br>            <span class="hljs-keyword">if</span>(x+<span class="hljs-number">1</span>&lt;n &amp;&amp; !a[x+<span class="hljs-number">1</span>][y] &amp;&amp; !map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x+<span class="hljs-number">1</span>,y)))&#123;<br>                q.<span class="hljs-built_in">emplace</span>(x+<span class="hljs-number">1</span>,y);<br>                map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x+<span class="hljs-number">1</span>,y));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(x<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; !a[x<span class="hljs-number">-1</span>][y] &amp;&amp; !map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x<span class="hljs-number">-1</span>,y)))&#123;<br>                q.<span class="hljs-built_in">emplace</span>(x<span class="hljs-number">-1</span>,y);<br>                map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x<span class="hljs-number">-1</span>,y));<br><br>            &#125;<br>            <span class="hljs-keyword">if</span>(y+<span class="hljs-number">1</span>&lt;m &amp;&amp; !a[x][y+<span class="hljs-number">1</span>] &amp;&amp; !map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x,y+<span class="hljs-number">1</span>)))&#123;<br>                q.<span class="hljs-built_in">emplace</span>(x,y+<span class="hljs-number">1</span>);<br>                map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x,y+<span class="hljs-number">1</span>));<br><br>            &#125;<br>            <span class="hljs-keyword">if</span>(y<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; !a[x][y<span class="hljs-number">-1</span>] &amp;&amp; !map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x,y<span class="hljs-number">-1</span>)))&#123;<br>                q.<span class="hljs-built_in">emplace</span>(x,y<span class="hljs-number">-1</span>);<br>                map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x,y<span class="hljs-number">-1</span>));<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化做法如下,适用于所有在二维空间进行移动的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>    q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        ans++;<br>        <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br>            <span class="hljs-keyword">auto</span> temp = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> x = temp.first;<br>            <span class="hljs-type">int</span> y = temp.second;<br>            <span class="hljs-keyword">if</span>(x == n - <span class="hljs-number">1</span> &amp;&amp; y == m - <span class="hljs-number">1</span>) cout&lt;&lt;ans;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;u&lt;<span class="hljs-number">4</span>;u++)&#123;<br>                <span class="hljs-type">int</span> xx = x+dx[u];<br>                <span class="hljs-type">int</span> yy = y+dy[u];<br>                <span class="hljs-keyword">if</span>(xx&lt;n&amp;&amp;xx&gt;=<span class="hljs-number">0</span>&amp;&amp;yy&lt;m&amp;&amp;yy&gt;=<span class="hljs-number">0</span>&amp;&amp;!a[xx][yy]&amp;&amp;!map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(xx,yy)))&#123;<br>                    q.<span class="hljs-built_in">emplace</span>(xx,yy);<br>                    map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(xx,yy));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="做法2">做法2</h5><p>采用d数组记录到达每个点的最短距离，核心思路和做法1相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>    q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br>            <span class="hljs-keyword">auto</span> temp = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> x = temp.first;<br>            <span class="hljs-type">int</span> y = temp.second;<br>            <span class="hljs-keyword">if</span>(x == n - <span class="hljs-number">1</span> &amp;&amp; y == m - <span class="hljs-number">1</span>) cout&lt;&lt;d[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;<span class="hljs-number">4</span>;u++)&#123;<br>            <span class="hljs-type">int</span> xx = x+dx[u];<br>                <span class="hljs-type">int</span> yy = y+dy[u];<br>                <span class="hljs-keyword">if</span>(xx&lt;n&amp;&amp;xx&gt;=<span class="hljs-number">0</span>&amp;&amp;yy&lt;m&amp;&amp;yy&gt;=<span class="hljs-number">0</span>&amp;&amp;!a[xx][yy]&amp;&amp;!d[xx][yy])&#123;<br>                    q.<span class="hljs-built_in">emplace</span>(xx,yy);<br>                    d[xx][yy] = d[x][y] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列">最长公共子序列</h3><p>给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B的子序列的字符串长度最长是多少。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">char</span> a[N],b[N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;a+<span class="hljs-number">1</span>&gt;&gt;b+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>            <span class="hljs-keyword">if</span>(a[i] == b[j])&#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><p><ahref="https://www.acwing.com/activity/content/problem/content/884/">AcWing143. 最大异或对 - AcWing</a></p><p><ahref="https://www.acwing.com/activity/content/problem/content/885/">AcWing836. 合并集合 - AcWing</a></p><p><ahref="https://www.acwing.com/activity/content/problem/content/907/">AcWing844. 走迷宫 - AcWing</a></p><p><a href="https://www.acwing.com/problem/content/97/">95. 费解的开关 -AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br>vector&lt;string&gt; vs;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>    vs[i][j] = vs[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>?<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>) vs[i<span class="hljs-number">-1</span>][j] = vs[i<span class="hljs-number">-1</span>][j] == <span class="hljs-string">&#x27;0&#x27;</span>?<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>) vs[i][j<span class="hljs-number">-1</span>] = vs[i][j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;0&#x27;</span>?<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;<span class="hljs-number">5</span>) vs[i+<span class="hljs-number">1</span>][j] = vs[i+<span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;0&#x27;</span>?<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;<span class="hljs-number">5</span>) vs[i][j+<span class="hljs-number">1</span>] =  vs[i][j+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0&#x27;</span>?<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        vs.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            string s;<br>            cin&gt;&gt;s;<br>            vs.<span class="hljs-built_in">push_back</span>(s);<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1e9</span>;<br>        <br>        vector&lt;string&gt;temp = vs;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> op=<span class="hljs-number">0</span>;op&lt;<span class="hljs-number">32</span>;op++)&#123;<br>            vs = temp;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(op&gt;&gt;i&amp;<span class="hljs-number">1</span>)&#123;<br>                    cnt++;<br>                    <span class="hljs-built_in">change</span>(<span class="hljs-number">0</span>,i);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">5</span>;j++)&#123;<br>                    <span class="hljs-keyword">if</span>(vs[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                        <span class="hljs-built_in">change</span>(i+<span class="hljs-number">1</span>,j);<br>                        cnt++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-type">int</span> vaild = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(vs[<span class="hljs-number">4</span>][i] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                    vaild = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(vaild &amp;&amp; cnt&lt;=<span class="hljs-number">6</span>) res = <span class="hljs-built_in">min</span>(res,cnt);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(res==<span class="hljs-number">1e9</span>) cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;res&lt;&lt;endl;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><ahref="https://www.acwing.com/problem/content/description/732/">730.机器人跳跃问题 - AcWing题库</a></p><p>注意边界问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> max_height;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x)</span></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> temp = x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        temp = <span class="hljs-number">2</span>*temp - a[i];<br>        <span class="hljs-keyword">if</span>(temp&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(temp &gt; max_height) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )&#123;<br>        cin&gt;&gt;a[i];<br>        max_height = <span class="hljs-built_in">max</span>(max_height, a[i]);<br>    &#125;<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> l=<span class="hljs-number">0</span>,r=max_height;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    cout&lt;&lt;l;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2023/02/03/Algorithm/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <url>/2023/02/03/Algorithm/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>前缀和与差分</p><span id="more"></span><h3 id="一维前缀和">一维前缀和</h3><p>主要作用：可以快速求出大量[l,r]之间所有数的和。注意两个数组都是从1开始。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i] = b[i<span class="hljs-number">-1</span>] +a[i];<br>cout&lt;&lt;b[r] - b[l<span class="hljs-number">-1</span>];<span class="hljs-comment">// 输出[l,r]之间所有数的和</span><br></code></pre></td></tr></table></figure><h3 id="二维前缀和">二维前缀和</h3><p>作用同一维前缀和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            s[i][j] = s[i<span class="hljs-number">-1</span>][j] + s[i][j<span class="hljs-number">-1</span>] - s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<span class="hljs-comment">// 计算前缀和</span><br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[x2][y2] - s[x1<span class="hljs-number">-1</span>][y2] - s[x2][y1<span class="hljs-number">-1</span>] + s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]);<span class="hljs-comment">// 计算矩形内所有数的和</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="一维差分">一维差分</h3><p>主要作用:对于在[l,r]区间内所有数加上c这类题目较快.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> m,n;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i] = a[i] - a[i<span class="hljs-number">-1</span>];<span class="hljs-comment">// 求差分</span><br><span class="hljs-keyword">while</span>(m--)&#123;<br>    <span class="hljs-type">int</span> l,r,c;<br>    cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>    b[r+<span class="hljs-number">1</span>] -= c;<br>    b[l] += c;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) a[i] = a[i<span class="hljs-number">-1</span>] + b[i]; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br></code></pre></td></tr></table></figure><h3 id="二维差分">二维差分</h3><p>作用同上.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> a[N][N],b[N][N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span>&#123;<span class="hljs-comment">//插入的规则,用图辅助理解</span><br>    b[x1][y1] += c;<br>    b[x1][y2+<span class="hljs-number">1</span>] -=c;<br>    b[x2+<span class="hljs-number">1</span>][y1] -=c;<br>    b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] +=c;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,q;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">insert</span>(i,j,i,j,a[i][j]);<span class="hljs-comment">//相当于对每个1*1的矩阵插入一个数</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2,c;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;<br>        <span class="hljs-built_in">insert</span>(x1,y1,x2,y2,c);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            a[i][j] = a[i<span class="hljs-number">-1</span>][j] + a[i][j<span class="hljs-number">-1</span>] - a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + b[i][j];<span class="hljs-comment">// 求前缀和</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/4458/">4455. 出行计划- AcWing题库</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高精度计算</title>
    <link href="/2023/02/03/Algorithm/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/"/>
    <url>/2023/02/03/Algorithm/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>高精度加法、减法、乘法、除法 <span id="more"></span></p><h3 id="高精度加法">高精度加法</h3><p>基本思路和列竖式相同，对于两个大数，使用string读入，在vector中倒排。对于两个vector的加法有c[i]= a[i] + b[i] +t.其中t是上一位的进位。计算完毕后，若t为1说明最高位有进位，再补上一个1即可。在输出时要记得反相输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span>(i &lt; a.<span class="hljs-built_in">size</span>() || i &lt; b.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>()) t += a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>()) t += b[i];<br>        result.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) result.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-type">int</span>&gt;aa,bb;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) aa.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//记得字符转化为对应数字要-&#x27;0&#x27;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) bb.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">add</span>(a,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>();i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        cout&lt;&lt;c[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度减法">高精度减法</h3><p>思路和高精度加法类似，以string读入，用vector倒排。对于减法，有c[i] =(a[i] - b[i] - t + 10) %10.在读数据时要注意判断a和b的大小。如果b大于a则需要先print出'-'然后再输b-a的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()!=b.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &gt; b.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-type">int</span> i=a,<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]!=b[i])&#123;<br>            <span class="hljs-keyword">return</span> a[i] &gt; b[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;result;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++)&#123;<br>        t = a[i] - t;<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>()) t = t - b[i];<br>        result.<span class="hljs-built_in">push_back</span>((t+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(result.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; result.back == <span class="hljs-number">0</span>) result.<span class="hljs-built_in">pop_back</span>();<br>   <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt;aa,bb;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) aa.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//记得字符转化为对应数字要-&#x27;0&#x27;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) bb.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">compare</span>(a,b))&#123;<br>        <span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">sub</span>(a,b);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-built_in">print</span>(c[i]);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>        <span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">sub</span>(b,a);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-built_in">print</span>(c[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="高精度乘法">高精度乘法</h3><p>对于大数A和小数b，结果的第i位可表示为c[i] =(a[i]<em>b+t)/10,其中t为第i-1位的进位。对第i+1位的进位t=(a[i]</em>b+t)%10.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>() || t;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>()) t = t + a[i]*b;<br>        result.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(result.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; result.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) result.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度除法">高精度除法</h3><p>思路可以正着做，记余数为r，则c[i] = (r*10+a[i])/b,r=r%b.为了在输入输出方面和加减乘保持一致，除法在形式上也采用倒排。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;r)</span></span>&#123;<br>    r = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt;result;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        r = r*<span class="hljs-number">10</span>+a[i];<br>        result.<span class="hljs-built_in">push_back</span>(r/b)<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(),result.<span class="hljs-built_in">end</span>());<br>   <span class="hljs-keyword">while</span>(result.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; result.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) result.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分算法</title>
    <link href="/2023/01/15/Algorithm/%E4%BA%8C%E5%88%86/"/>
    <url>/2023/01/15/Algorithm/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>整数二分、浮点数二分及例题 <span id="more"></span></p><h3 id="整数二分">整数二分</h3><p>整数二分有两种情况，取决于check()函数的逻辑。</p><p>第一种情况，假设check()函数判断的是“右侧是否满足”，则如果满足，说明mid处于右侧区间，则边界点应处于[l,mid]，因此更新r=mid；如果不满足，说明mid处于左侧区间且mid点本身并不是边界点，则边界点应处于(mid+1,r],因此更新l= mid + 1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<span class="hljs-comment">// 以整个数列为例</span><br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>    <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>&#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但考虑如下情况：若l = r - 1,此时mid = (l + r) &gt;&gt; 1 = (2l + 1)&gt;&gt; 1 =l,若此时check()返回true，执行l=mid，会导致l、r均未得到更新，程序陷入死循环，因此此时应赋值mid= (l + r + 1) &gt;&gt; 1.</p><p><strong>简便记法</strong>：出现mid - 1 的时候使用该情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例题</strong>：<ahref="https://www.acwing.com/problem/content/description/791/">789.数的范围 - AcWing题库</a></p><h3 id="浮点数二分">浮点数二分</h3><p>和整数二分类似，但无需考虑mid的取整问题。其中的eps代表精度，经验来看若题目要求保留n位小数则eps精度为n+2即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-type">double</span> l,<span class="hljs-type">double</span> r)</span></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br>    <span class="hljs-keyword">while</span>(r-l&gt;eps)&#123;<br>        <span class="hljs-type">double</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例题</strong>：<ahref="https://www.acwing.com/problem/content/792/">790. 数的三次方根 -AcWing题库</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2023/01/14/Algorithm/%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/01/14/Algorithm/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>快排、归并排序 <span id="more"></span></p><h3 id="快排">快排</h3><p>维护左右两个指针，左边指针向右走直到遇到大于x的值停下，右边指针向左走直到遇到小于x的值停下，随后两个指针指向的值进行交换。</p><p>快排是不稳定的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> x=q[l],i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i&lt;j)&#123;<br><span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i]&lt;x);<br><span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j]&gt;x);<br><span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(q[i],q[j]);<br>&#125;<br><span class="hljs-built_in">quick_sort</span>(q,l,j);<br><span class="hljs-built_in">quick_sort</span>(q,j+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure><p>先对两侧的子序列排序，再对两个有序子序列进行合并，合并思路为双指针。</p><h4 id="归并排序">归并排序</h4><p>归并排序是稳定的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">merge_sort</span>(q,l,mid);<br><span class="hljs-built_in">merge_sort</span>(q,mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;<br><span class="hljs-keyword">if</span>(q[i]&lt;q[j]) temp[k++] = q[i++];<br><span class="hljs-keyword">else</span> temp[k++] = q[j++];<br>&#125;<br><span class="hljs-keyword">while</span>(i&lt;=mid) temp[k++] = q[i++];<br><span class="hljs-keyword">while</span>(j&lt;=r) temp[k++] = q[j++];<br><span class="hljs-keyword">for</span>(i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++)&#123;<br>q[i] = temp[j];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2023/01/14/School/%E6%9C%8B%E8%BE%88%E7%AD%94%E7%96%91/"/>
    <url>/2023/01/14/School/%E6%9C%8B%E8%BE%88%E7%AD%94%E7%96%91/</url>
    
    <content type="html"><![CDATA[<p>朋辈讲师企业微信答疑 <span id="more"></span> 想必你清楚如何通过if-else 或者switch-case将0-9输出，主要问题在于如何将整数从高到低处理</p><p>如果直接按整数读入，会发现很难从高位到低位获得每个数字，自然很难处理</p><p>但如果是一个字符串，我们似乎就可以通过索引获得0~n的数字</p><p>如果学过c++，string自然是最好的选择，</p><p>如果只是学了c，可以通过下面的代码依次读入每个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> f[<span class="hljs-number">10</span>][<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&quot;ling&quot;</span>,<span class="hljs-string">&quot;yi&quot;</span>,<span class="hljs-string">&quot;er&quot;</span>,<span class="hljs-string">&quot;san&quot;</span>,<span class="hljs-string">&quot;si&quot;</span>,<span class="hljs-string">&quot;wu&quot;</span>,<span class="hljs-string">&quot;liu&quot;</span>,<span class="hljs-string">&quot;qi&quot;</span>,<span class="hljs-string">&quot;ba&quot;</span>,<span class="hljs-string">&quot;jiu&quot;</span>&#125;;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">do</span>&#123;<br>        c = getchar();<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fu&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,f[<span class="hljs-type">int</span>(c-<span class="hljs-string">&#x27;0&#x27;</span>)]);<span class="hljs-comment">// 注意ASCII码到实际整数的转化</span><br>        &#125;<br><br>    &#125;<span class="hljs-keyword">while</span>(c!=<span class="hljs-string">&#x27;\n&#x27;</span>);<br></code></pre></td></tr></table></figure><p>print的东西可以改为if-else或者switch-case，不再赘述了。</p><p>下面给出一个递归解决的方法~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><br><span class="hljs-type">char</span> f[<span class="hljs-number">10</span>][<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&quot;ling&quot;</span>,<span class="hljs-string">&quot;yi&quot;</span>,<span class="hljs-string">&quot;er&quot;</span>,<span class="hljs-string">&quot;san&quot;</span>,<span class="hljs-string">&quot;si&quot;</span>,<span class="hljs-string">&quot;wu&quot;</span>,<span class="hljs-string">&quot;liu&quot;</span>,<span class="hljs-string">&quot;qi&quot;</span>,<span class="hljs-string">&quot;ba&quot;</span>,<span class="hljs-string">&quot;jiu&quot;</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">high_to_low</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">10</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, f[<span class="hljs-built_in">high_to_low</span>(x/<span class="hljs-number">10</span>)]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> x%<span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fu&quot;</span>);<br>        x = -x;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,f[<span class="hljs-built_in">high_to_low</span>(x)]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>) <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));   <span class="hljs-comment">// 写法有些小问题</span><br>    <span class="hljs-type">int</span> a=<span class="hljs-built_in">rand</span>()%<span class="hljs-number">100</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//随机数字a</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a);<br>    <span class="hljs-type">int</span> d,b,n,i;<span class="hljs-comment">//输入数字b,n      // 没理解错的话n是最大的猜测次数吧，用int存储即可，n[100]代表有100个int</span><br>    d=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;b,&amp;n);    <span class="hljs-comment">// 确定题目是先读入b再读入n吗？</span><br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123; <span class="hljs-comment">// [0,n)是n个数，[0,n]是n+1个数了</span><br>        <span class="hljs-keyword">if</span>(b&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">// 每次读入b都要判断正负，原代码只判断了第一个b的正负</span><br>            <span class="hljs-keyword">if</span> (b &gt; a)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Too big\n&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b &lt; a)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Too small\n&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == a)&#123;   <span class="hljs-comment">//等真的的猜出来再判断输出什么</span><br>                <span class="hljs-keyword">if</span>(d==<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Bingo!\n&quot;</span>); <span class="hljs-comment">// 判等是两个=</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;<span class="hljs-number">1</span>&amp;&amp;d&lt;=<span class="hljs-number">3</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Lucky You!\n&quot;</span>);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;<span class="hljs-number">3</span>&amp;&amp;d&lt;=n)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Good Guess!\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果最后一次没猜对会先显示too small/big然后显示game over，</span><br>            <span class="hljs-comment">// 这个地方要按照题意，如果只需要输出game over 要把下面的if放在循环的开始</span><br>            <span class="hljs-keyword">if</span>(d&gt;=n)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Game Over\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            d++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Game Over\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10000</span>];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&lt;=m;i++)&#123;<br>        cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;       <span class="hljs-comment">// 获得i这个数的所有约数</span><br>            <span class="hljs-keyword">if</span>(i%j==<span class="hljs-number">0</span>) a[cnt++] = j;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt;j++)&#123;     <span class="hljs-comment">// 把约数都加起来</span><br>            sum += a[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum == i)&#123;       <span class="hljs-comment">// 要是加起来等于i，说明符合条件</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d = &quot;</span>,i);  <span class="hljs-comment">// 先把开头print出来</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt;j++)&#123;     <span class="hljs-comment">// 循环打印约数</span><br>                <span class="hljs-keyword">if</span>(j!=cnt<span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d + &quot;</span>,a[j]);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[j]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><span class="math display">\[d(e^{i\theta })=ie^{i\theta}d\theta=i(cos\theta+isin\theta)d\theta\]</span></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于脑功能连接矩阵的Kendall特征提取实现</title>
    <link href="/2023/01/11/DeepLearning/%E5%9F%BA%E4%BA%8E%E8%84%91%E5%8A%9F%E8%83%BD%E8%BF%9E%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84Kendall%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/01/11/DeepLearning/%E5%9F%BA%E4%BA%8E%E8%84%91%E5%8A%9F%E8%83%BD%E8%BF%9E%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84Kendall%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>基于脑功能连接矩阵的Kendall特征提取实现 <span id="more"></span>原论文如下图所示</p><div data-align="center"><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230111170705.png" width="  "></div><p>基本思路为将样本分为患病组和未患病组，对于患病组的每一个样本的每一个特征，将其和未患病组的每一个样本的对应特征进行相减运算，若结果为正则记为一组concordant，若结果为负则记为一组discordant,对于每一个特征，总的concordant数记为nc,总的discordant数记为nd，随后使用abs((nc-nd)/(m*n))代表每一个特征的Kendall系数，用该系数进行排序即可。</p><p>程序最基础的代码结构如下，我们使用上Pearson矩阵上三角展开后（1，6670）的数据当作每个样本的输入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> fc <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6670</span>):<br>nc = <span class="hljs-number">0</span><br>nd = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> file_asd <span class="hljs-keyword">in</span> files_asd:<br>ref = pd.read_csv(file_asd,header=<span class="hljs-literal">False</span>)[fc]<br>        <span class="hljs-keyword">for</span> file_hc <span class="hljs-keyword">in</span> files_hc:<br>        comp = pd.read_csv(file_hc,header=<span class="hljs-literal">False</span>)[fc]<br>        <span class="hljs-keyword">if</span> ref - comp &gt; <span class="hljs-number">0</span>:<br>        nc += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>        nd += <span class="hljs-number">1</span><br>tau[fc] = <span class="hljs-built_in">abs</span>(nc - nd)/(m*n)<br></code></pre></td></tr></table></figure><p>上述代码是对原论文思路的直接实现，逻辑清晰，但是由于大量的IO以及运算，效率十分低下。因此做如下改进：</p><p>为了避免大量重复IO，将所有数据提前读入内存中,后续根据索引直接取数即可,同时为了提高这一步的读取效率，将csv文件改为pkl文件在这一步带来了上千倍的速度提升。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">all_asd_data = []<br>all_hc_data = []<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files_asd:<br>    all_asd_data.append(pd.read_pickle(file))<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files_hc:<br>    all_hc_data.append(pd.read_pickle(file))<br>all_asd_data = pd.DataFrame(np.array(all_asd_data).reshape(<span class="hljs-built_in">len</span>(all_asd_data), -<span class="hljs-number">1</span>))<br>all_hc_data = pd.DataFrame(np.array(all_hc_data).reshape(<span class="hljs-built_in">len</span>(all_hc_data), -<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>即使如此，由于原运算架构采用三层for循环，三层的循环次数分别为6670、306、368，时间复杂度太高，并行度太差，该程序需要<strong>五个多小时</strong>才能完全跑完。后续在并行度上继续改进：</p><p>首先想到对于未患病组可以不逐个计算，取出所有未患病样本的第fc列，将该array直接减去ref的值，随后统计其中大于0的个数加到nc上，小于0的个数加到nd上即可。这样的改进可以让程序在<strong>10分钟</strong>内完成全部运算。</p><p>更进一步的，我们可以不区分fc，对于全部未患病样本all_hc_data，直接减去每一个患病样本（即利用广播机制将（368，6670）减去（1，6670）），随后以列进行统计大于0的数量，得到（1，6670）的数组，直接加到nc数组上即可，nd数组同理操作。这样程序只有一层for循环，在<strong>5秒</strong>内即可完成全部运算，代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(all_asd_data)),desc=<span class="hljs-string">&quot;running&quot;</span>,file=sys.stdout):<br>    ref = <span class="hljs-built_in">list</span>(all_asd_data.iloc[i, :])<br>    bool_res = all_hc_data - ref &gt; <span class="hljs-number">0</span><br>    total_true = np.array(np.<span class="hljs-built_in">sum</span>(bool_res, axis=<span class="hljs-number">0</span>))<br>    nc += total_true<br>    nd += <span class="hljs-built_in">len</span>(all_hc_data) - total_true<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6670</span>):<br>    tau_t = (nc[i] - nd[i])/(m*n)<br>    tau = pd.DataFrame(np.insert(tau.values, <span class="hljs-built_in">len</span>(tau.index), values=[<span class="hljs-built_in">int</span>(i), <span class="hljs-built_in">abs</span>(tau_t)], axis=<span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><p>完整代码如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python">root_path = <span class="hljs-string">&quot;../../raw_data/rois_aal_pkl_pearson_static_expand/&quot;</span><br>files = os.listdir(root_path)<br>files.sort()<br><br>label_temp = pd.read_csv(<span class="hljs-string">&quot;label_674.csv&quot;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> CheckOrder(files, label_temp):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;error&quot;</span>)<br>    exit()<br>label_temp = label_temp.group_1.values<br><br>m = <span class="hljs-built_in">sum</span>(label_temp)  <span class="hljs-comment"># 患病人数</span><br>n = <span class="hljs-built_in">len</span>(label_temp) - m  <span class="hljs-comment"># 未患病人数</span><br><br>files_asd = []<br>files_hc = []<br><span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(label_temp):<br>    <span class="hljs-keyword">if</span> item == <span class="hljs-number">1</span>:<br>        files_asd.append(root_path + files[i])<br>    <span class="hljs-keyword">else</span>:<br>        files_hc.append(root_path + files[i])<br><br><span class="hljs-comment"># 预加载所有数据，避免频繁IO</span><br>all_asd_data = []<br>all_hc_data = []<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files_asd:<br>    all_asd_data.append(pd.read_pickle(file))<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files_hc:<br>    all_hc_data.append(pd.read_pickle(file))<br>all_asd_data = pd.DataFrame(np.array(all_asd_data).reshape(<span class="hljs-built_in">len</span>(all_asd_data), -<span class="hljs-number">1</span>))<br>all_hc_data = pd.DataFrame(np.array(all_hc_data).reshape(<span class="hljs-built_in">len</span>(all_hc_data), -<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(all_asd_data.shape, all_hc_data.shape)<br><br>tau = pd.DataFrame(columns=[<span class="hljs-string">&#x27;ROI&#x27;</span>, <span class="hljs-string">&#x27;tau&#x27;</span>])<br>nc = np.zeros((<span class="hljs-number">6670</span>,), dtype=<span class="hljs-built_in">int</span>)<br>nd = np.zeros((<span class="hljs-number">6670</span>,), dtype=<span class="hljs-built_in">int</span>)<br><br><span class="hljs-comment"># 利用广播机制批量运算</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(all_asd_data)),desc=<span class="hljs-string">&quot;running&quot;</span>,file=sys.stdout):<br>    ref = <span class="hljs-built_in">list</span>(all_asd_data.iloc[i, :])<br>    bool_res = all_hc_data - ref &gt; <span class="hljs-number">0</span><br>    total_true = np.array(np.<span class="hljs-built_in">sum</span>(bool_res, axis=<span class="hljs-number">0</span>))<br>    nc += total_true<br>    nd += <span class="hljs-built_in">len</span>(all_hc_data) - total_true<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6670</span>):<br>    tau_t = (nc[i] - nd[i])/(m*n)<br>    tau = pd.DataFrame(np.insert(tau.values, <span class="hljs-built_in">len</span>(tau.index), values=[<span class="hljs-built_in">int</span>(i), <span class="hljs-built_in">abs</span>(tau_t)], axis=<span class="hljs-number">0</span>))<br><br>tau.columns = [<span class="hljs-string">&#x27;ROI&#x27;</span>, <span class="hljs-string">&#x27;tau&#x27;</span>]<br>tau = tau.sort_values(by=<span class="hljs-string">&#x27;tau&#x27;</span>, ascending=<span class="hljs-literal">False</span>)<br>tau = tau.reset_index(drop=<span class="hljs-literal">True</span>)<br>tau.to_csv(<span class="hljs-string">&quot;sort.csv&quot;</span>,index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微软官方开源工具PowerToys</title>
    <link href="/2023/01/10/Tools/%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7PowerToys/"/>
    <url>/2023/01/10/Tools/%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7PowerToys/</url>
    
    <content type="html"><![CDATA[<p>具有窗口置顶、查看文件被什么进程占用、批量重命名文件、alt+space全盘检索、OCR等实用功能<span id="more"></span></p><p>Github地址：<ahref="https://github.com/microsoft/PowerToys">microsoft/PowerToys:Windows system utilities to maximize productivity (github.com)</a></p><p>所有功能见文末。下面记录一些感兴趣工具的使用方法</p><h4 id="始终置顶">始终置顶</h4><p>​ 快捷键：win+ctrl+T,固定所选的窗口，使其始终位于所有窗口的顶部</p><h4 id="文件locksmith">文件Locksmith</h4><p>​在文件资源管理器中选择一个或多个文件，右键选择<strong>使用此文件的进程</strong>即可展示出所有使用中的进程并提供了结束进程的选项。十分实用！再也不用担心因为进程占用删不掉文件夹。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBed/20230110190258.png"alt="Locksmith" /><figcaption aria-hidden="true">Locksmith</figcaption></figure><h4 id="文件资源管理器加载项">文件资源管理器加载项</h4><p>在文件资源管理器中选择视图中的<strong>预览窗格</strong>，可以在文件资源管理器右侧预览md、pdf、svg等文件格式。</p><p>感觉不如quicklook好，但内嵌在资源管理器中看起来还不错。</p><h4 id="powerrename">PowerRename</h4><p>选定多个文件右键选择PowerRename，会弹出独立窗口，可以使用正则表达式来搜索文件进行批量重命名。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBed/20230110191047.png"alt="PowerRename" /><figcaption aria-hidden="true">PowerRename</figcaption></figure><h4 id="powertoys-run">PowerToys Run</h4><p>按下alt+space进行搜索，似乎有wox团队参加，和wox功能十分类似但看起来更简洁、美观。</p><p>在设置-&gt;隐私和安全性-&gt;搜索Windows中可以选择建立索引的目录范围以及索引存放的位置。</p><p>图中提示警告是因为还没编制完索引，编制完之后便可正常实用。</p><p>但wox支持拼音首字母检索，PowerToys Run似乎并不支持。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBed/20230110191344.png" /></p><h4 id="ocr文本提取器">OCR文本提取器</h4><p>快捷键：win+shift+T</p><p>自动复制到剪切板，很方便。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBed/20230110184744.png"alt="PowerToys" /><figcaption aria-hidden="true">PowerToys</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决批处理程序中文乱码问题</title>
    <link href="/2023/01/07/Tools/%E8%A7%A3%E5%86%B3%E6%89%B9%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/01/07/Tools/%E8%A7%A3%E5%86%B3%E6%89%B9%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>通过修改cmd编码格式解决批处理程序中文乱码问题 <span id="more"></span></p><p>参考链接：<ahref="https://blog.csdn.net/qq_43553082/article/details/125902114?spm=1001.2014.3001.5501">如何修改cmd的编码格式即当前活动代码页编号（比如修改为utf-8、GBK2312）_Interfrog的博客-CSDN博客_cmd编码</a></p>]]></content>
    
    
    <categories>
      
      <category>小知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pake自动化脚本</title>
    <link href="/2023/01/07/Tools/pake%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/"/>
    <url>/2023/01/07/Tools/pake%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>基于rust打包网页应用 <span id="more"></span></p><p>本文使用开源项目工具Pake：<ahref="https://github.com/tw93/Pake">tw93/Pake: 🤱🏻 Simply make any webpage a desktop application using Rust. 🤱🏻 很简单的用 Rust打包网页生成很小的桌面 App (github.com)</a></p><p>在使用前需要先安装VS相关tool以及rust，随后使用npm安装pake包，教程参见上述链接</p><p>下表给出使用命令行安装的常用命令：</p><table><tr><th align="center">参数</th><th align="center">说明</th><th align="center">用法</th></tr><tr><td align="center">url</td><td>打包的网页链接,必须提供</td><td>pake &amp;lt url &amp;gt</td></tr><tr><td align="center">name</td><td>应用名称</td><td>--name &amp;lt value &amp;gt</td></tr><tr><td align="center">icon</td><td>应用图标，支持本地/远程文件,Windows必须为.ico,MacOS必须为.icns,Linux必须为.png</td><td>--icon &amp;lt path &amp;gt</td><p>在本人使用过程中发现必须在nodejs/node_global/node_modules/pake-cli目录下以管理员方式打开才可以使用，十分不便，因此编写批处理程序简化操作。</p><p>在bat中获取管理员权限有多种方法，代码参考链接：<ahref="https://blog.csdn.net/oShuangYue12/article/details/106055253">bat以管理员运行</a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">setlocal<br><span class="hljs-built_in">set</span> uac=~uac_permission_tmp_%random%<br>md <span class="hljs-string">&quot;%SystemRoot%\system32\%uac%&quot;</span> 2&gt;nul<br><span class="hljs-keyword">if</span> %errorlevel%==0 ( rd <span class="hljs-string">&quot;%SystemRoot%\system32\%uac%&quot;</span> &gt;nul 2&gt;nul ) <span class="hljs-keyword">else</span> (<br>    <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> uac = CreateObject^(<span class="hljs-string">&quot;Shell.Application&quot;</span>^)&gt;<span class="hljs-string">&quot;%temp%\%uac%.vbs&quot;</span><br>    <span class="hljs-built_in">echo</span> uac.ShellExecute <span class="hljs-string">&quot;%~s0&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;runas&quot;</span>,1 &gt;&gt;<span class="hljs-string">&quot;%temp%\%uac%.vbs&quot;</span><br>    <span class="hljs-built_in">echo</span> WScript.Quit &gt;&gt;<span class="hljs-string">&quot;%temp%\%uac%.vbs&quot;</span><br>    <span class="hljs-string">&quot;%temp%\%uac%.vbs&quot;</span> /f<br>    del /f /q <span class="hljs-string">&quot;%temp%\%uac%.vbs&quot;</span> &amp; <span class="hljs-built_in">exit</span> )<br>endlocal<br></code></pre></td></tr></table></figure> 随后给出需要的三个参数即可 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /d D:\nodejs\node_global\node_modules\pake-cli<br><span class="hljs-built_in">set</span> /p url=please input the url: <br><span class="hljs-built_in">set</span> /p title=please input the title: <br><span class="hljs-built_in">set</span> /p ico=please input the ico path: <br>pake %url% --name %title% --icon %ico%<br>pause<br></code></pre></td></tr></table></figure></p><p>由于pake-cli文件夹权限较高，未找到直接打开其中msi文件的方法，为了简化安装流程，给出打开文件夹的脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br>start explorer <span class="hljs-string">&quot;D:\nodejs\node_global\node_modules\pake-cli&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo自动化脚本</title>
    <link href="/2023/01/06/Tools/hexo%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/"/>
    <url>/2023/01/06/Tools/hexo%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>Windows一键完成新建博客、提交next更新、启动本地service<span id="more"></span></p><h4 id="新建博客">新建博客</h4><p>创建.bat文件，cd后路径改为blog根目录</p><p><span class="citation" data-cites="echo">@echo</span> off会取消后续命令的显示</p><p>pause会使命令执行完之后不关闭脚本界面，以便查看是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br> <span class="hljs-built_in">cd</span> /d D:\Blog\GreaterChen.github.io\myblog<br> call hexo new <span class="hljs-string">&quot;new post&quot;</span><br> pause<br></code></pre></td></tr></table></figure><h4 id="自动提交">自动提交</h4><p>思路同上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">cd</span> /d  D:\Blog\GreaterChen.github.io\myblog<br>call hexo clean<br>call hexo g<br>call hexo d<br>pause<br></code></pre></td></tr></table></figure><h4 id="启动本地service">启动本地service</h4><p>思路同上 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">cd</span> /d  D:\Blog\GreaterChen.github.io\myblog<br>call hexo s<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Typora下载激活</title>
    <link href="/2023/01/06/Tools/Typore%E4%B8%8B%E8%BD%BD%E6%BF%80%E6%B4%BB/"/>
    <url>/2023/01/06/Tools/Typore%E4%B8%8B%E8%BD%BD%E6%BF%80%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<p>Typora最新版本激活</p><span id="more"></span><h2 id="typora">Typora</h2><ul><li>参考网址：<ahref="https://www.cnblogs.com/hackettt/p/16335288.html">typora下载和破解（仅供学习）- hackettt - 博客园 (cnblogs.com)</a></li></ul><p>​ 评价：版本较低（1.0）</p><ul><li>参考网址：<ahref="https://www.bilibili.com/video/BV1HG4y1171i/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&amp;vd_source=1455a4be36d2913a951945519501ede2">Typora激活，任意版本，最新版也可以，巨简单_哔哩哔哩_bilibili</a></li></ul><p>​ 下载地址：https://wweb.lanzoum.com/iOTy30jxhfxi</p><p>​ 使用方法：把解压出的文件放到typora根目录即可</p><p>​ 评价：任意版本，使用方便</p>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
