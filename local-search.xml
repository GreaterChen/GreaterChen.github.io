<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>KL散度计算探究</title>
    <link href="/2024/08/15/BUAA/%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0/"/>
    <url>/2024/08/15/BUAA/%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>探究如何合理的进行KL散度计算</p><span id="more"></span><h2 id="基本情况">基本情况</h2><h3 id="改进后分布sigma_1sigma_2klce">改进后分布（<spanclass="math inline">\(\sigma_1=\sigma_2\)</span>）(KL+CE)</h3><h4 id="sigmas_32d">3sigmas_32d</h4><p>/mnt/chenlb/Six_Tumor_Classification/Exp34/results/model_3sigmas_32d</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">23</span>:<span class="hljs-number">53</span>,020 - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">23</span>:<span class="hljs-number">53</span>,020 - INFO: 验证集总体精度为: <span class="hljs-number">0.6367713212966919</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">23</span>:<span class="hljs-number">53</span>,020 - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.8571</span>, <span class="hljs-number">0.8413</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">23</span>:<span class="hljs-number">53</span>,021 - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">23</span>:<span class="hljs-number">53</span>,044 - INFO: 先验分布KL散度矩阵:<br>tensor([[   <span class="hljs-number">0.0000</span>,  <span class="hljs-number">119.1124</span>,  <span class="hljs-number">230.2428</span>],<br>        [ <span class="hljs-number">236.9537</span>,    <span class="hljs-number">0.0000</span>,   <span class="hljs-number">59.9016</span>],<br>        [<span class="hljs-number">1217.2224</span>,  <span class="hljs-number">244.4084</span>,    <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">23</span>:<span class="hljs-number">53</span>,045 - INFO: 后验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.6462</span>, <span class="hljs-number">39.8160</span>],<br>        [ <span class="hljs-number">0.7577</span>,  <span class="hljs-number">0.0000</span>, <span class="hljs-number">32.6805</span>],<br>        [<span class="hljs-number">72.8971</span>, <span class="hljs-number">50.2652</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">23</span>:<span class="hljs-number">53</span>,046 - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">25.6441</span>, <span class="hljs-number">117.5962</span>, <span class="hljs-number">216.2999</span>],<br>        [ <span class="hljs-number">36.8577</span>, <span class="hljs-number">103.1570</span>, <span class="hljs-number">198.0281</span>],<br>        [<span class="hljs-number">343.6498</span>,  <span class="hljs-number">37.3701</span>,  <span class="hljs-number">52.5826</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">23</span>:<span class="hljs-number">53</span>,046 - INFO: 混合类KL散度矩阵:<br>tensor([[ <span class="hljs-number">18.0833</span>,  <span class="hljs-number">11.8677</span>,  <span class="hljs-number">14.7421</span>],<br>        [ <span class="hljs-number">86.8271</span>,  <span class="hljs-number">33.7350</span>, <span class="hljs-number">119.0850</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><ol type="1"><li><p>先验分布中三个类别都有一定的区分度</p></li><li><p>真实数据分布能看出来符合次序约束</p><p><img src="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240516195059942.png" alt="image-20240516195059942" style="zoom: 50%;" /></p></li><li><p>后验分布相较于先验分布能看出来拟合效果不好</p></li></ol><p><img src="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240518145752955.png" alt="image-20240518145752955" style="zoom:50%;" /></p><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240516195556695.png"alt="image-20240516195556695" /><figcaption aria-hidden="true">image-20240516195556695</figcaption></figure><h2 id="仅kl">仅KL</h2><h3 id="改进后分布sigma_1sigma_2">改进后分布（<spanclass="math inline">\(\sigma_1=\sigma_2\)</span>）</h3><h4 id="sigmas_32d-1">3sigmas_32d</h4><p>/mnt/chenlb/Six_Tumor_Classification/Exp34/results/model_3sigmas_32d_kl</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">15</span>:<span class="hljs-number">46</span>,<span class="hljs-number">770</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">15</span>:<span class="hljs-number">46</span>,<span class="hljs-number">771</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.5650224089622498</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">15</span>:<span class="hljs-number">46</span>,<span class="hljs-number">772</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">15</span>:<span class="hljs-number">46</span>,<span class="hljs-number">772</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">15</span>:<span class="hljs-number">46</span>,<span class="hljs-number">795</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[  <span class="hljs-number">0.0000</span>, <span class="hljs-number">105.6981</span>, <span class="hljs-number">196.1740</span>],<br>        [<span class="hljs-number">210.1252</span>,   <span class="hljs-number">0.0000</span>,  <span class="hljs-number">43.9986</span>],<br>        [<span class="hljs-number">794.0599</span>, <span class="hljs-number">128.3555</span>,   <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">15</span>:<span class="hljs-number">46</span>,<span class="hljs-number">796</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[  <span class="hljs-number">0.0000</span>,   <span class="hljs-number">2.2582</span>,  <span class="hljs-number">45.8844</span>],<br>        [  <span class="hljs-number">3.2480</span>,   <span class="hljs-number">0.0000</span>,  <span class="hljs-number">33.5982</span>],<br>        [<span class="hljs-number">108.1262</span>,  <span class="hljs-number">51.1045</span>,   <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">15</span>:<span class="hljs-number">46</span>,<span class="hljs-number">796</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">10.9276</span>, <span class="hljs-number">117.2147</span>, <span class="hljs-number">202.3913</span>],<br>        [ <span class="hljs-number">26.3985</span>,  <span class="hljs-number">98.0496</span>, <span class="hljs-number">176.6510</span>],<br>        [<span class="hljs-number">270.5133</span>,  <span class="hljs-number">26.6114</span>,  <span class="hljs-number">40.1647</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">14</span>:<span class="hljs-number">15</span>:<span class="hljs-number">46</span>,<span class="hljs-number">797</span> - INFO: 混合类KL散度矩阵:<br>tensor([[ <span class="hljs-number">25.0501</span>,  <span class="hljs-number">11.9111</span>,  <span class="hljs-number">16.5483</span>],<br>        [ <span class="hljs-number">56.7255</span>,  <span class="hljs-number">34.6895</span>, <span class="hljs-number">104.0605</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><p>情况完全相同</p><h4 id="sigmas_32d-2">6sigmas_32d</h4><p>/mnt/chenlb/Six_Tumor_Classification/Exp34/results/model_6sigmas_32d_kl</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">16</span>:01:<span class="hljs-number">11</span>,<span class="hljs-number">562</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">16</span>:01:<span class="hljs-number">11</span>,<span class="hljs-number">563</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.5650224089622498</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">16</span>:01:<span class="hljs-number">11</span>,<span class="hljs-number">563</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">16</span>:01:<span class="hljs-number">11</span>,<span class="hljs-number">563</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">16</span>:01:<span class="hljs-number">11</span>,<span class="hljs-number">586</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[    <span class="hljs-number">0.0000</span>,   <span class="hljs-number">385.9037</span>,   <span class="hljs-number">557.1141</span>],<br>        [  <span class="hljs-number">770.5362</span>,     <span class="hljs-number">0.0000</span>,   <span class="hljs-number">212.7720</span>],<br>        [<span class="hljs-number">27217.2305</span>, <span class="hljs-number">10737.3115</span>,     <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">16</span>:01:<span class="hljs-number">11</span>,<span class="hljs-number">587</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[  <span class="hljs-number">0.0000</span>,   <span class="hljs-number">1.5150</span>,  <span class="hljs-number">40.6348</span>],<br>        [  <span class="hljs-number">2.0867</span>,   <span class="hljs-number">0.0000</span>,  <span class="hljs-number">31.2550</span>],<br>        [<span class="hljs-number">109.4591</span>,  <span class="hljs-number">59.4697</span>,   <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">16</span>:01:<span class="hljs-number">11</span>,<span class="hljs-number">588</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">50.8937</span>, <span class="hljs-number">369.3052</span>, <span class="hljs-number">524.6594</span>],<br>        [<span class="hljs-number">100.8817</span>, <span class="hljs-number">338.9379</span>, <span class="hljs-number">487.3156</span>],<br>        [<span class="hljs-number">914.5201</span>, <span class="hljs-number">140.8511</span>, <span class="hljs-number">240.0404</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">16</span>:01:<span class="hljs-number">11</span>,<span class="hljs-number">588</span> - INFO: 混合类KL散度矩阵:<br>tensor([[ <span class="hljs-number">24.3777</span>,  <span class="hljs-number">12.3357</span>,  <span class="hljs-number">15.0670</span>],<br>        [<span class="hljs-number">237.6790</span>, <span class="hljs-number">137.0445</span>, <span class="hljs-number">346.1130</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><ol type="1"><li>先验分布中类间距确实增大了</li><li>后验分布变化很小</li></ol><h3 id="全数据kl">全数据(KL)</h3><p>/mnt/chenlb/Six_Tumor_Classification/Exp35/results/model_3deltas_32d_kl_all</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">15</span>:<span class="hljs-number">59</span>:<span class="hljs-number">45</span>,<span class="hljs-number">145</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">15</span>:<span class="hljs-number">59</span>:<span class="hljs-number">45</span>,<span class="hljs-number">146</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.5650224089622498</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">15</span>:<span class="hljs-number">59</span>:<span class="hljs-number">45</span>,<span class="hljs-number">147</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">15</span>:<span class="hljs-number">59</span>:<span class="hljs-number">45</span>,<span class="hljs-number">147</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">15</span>:<span class="hljs-number">59</span>:<span class="hljs-number">45</span>,<span class="hljs-number">170</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[   <span class="hljs-number">0.0000</span>,  <span class="hljs-number">135.5512</span>,  <span class="hljs-number">311.1958</span>],<br>        [ <span class="hljs-number">390.7813</span>,    <span class="hljs-number">0.0000</span>,   <span class="hljs-number">57.8827</span>],<br>        [<span class="hljs-number">1208.4690</span>,   <span class="hljs-number">77.8000</span>,    <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">15</span>:<span class="hljs-number">59</span>:<span class="hljs-number">45</span>,<span class="hljs-number">171</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">2.4692</span>, <span class="hljs-number">46.5681</span>],<br>        [ <span class="hljs-number">3.3380</span>,  <span class="hljs-number">0.0000</span>, <span class="hljs-number">30.8526</span>],<br>        [<span class="hljs-number">81.5376</span>, <span class="hljs-number">38.8405</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">15</span>:<span class="hljs-number">59</span>:<span class="hljs-number">45</span>,<span class="hljs-number">172</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[  <span class="hljs-number">2.4993</span>, <span class="hljs-number">135.1824</span>, <span class="hljs-number">311.1886</span>],<br>        [ <span class="hljs-number">10.2938</span>, <span class="hljs-number">108.3547</span>, <span class="hljs-number">274.9334</span>],<br>        [<span class="hljs-number">135.8775</span>,  <span class="hljs-number">23.8753</span>, <span class="hljs-number">139.2465</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">15</span>:<span class="hljs-number">59</span>:<span class="hljs-number">45</span>,<span class="hljs-number">173</span> - INFO: 混合类KL散度矩阵:<br>tensor([[ <span class="hljs-number">18.6348</span>,   <span class="hljs-number">8.4113</span>,  <span class="hljs-number">17.6999</span>],<br>        [ <span class="hljs-number">25.9541</span>,  <span class="hljs-number">75.6845</span>, <span class="hljs-number">227.3778</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="全数据klce">全数据(KL+CE)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">43</span>:<span class="hljs-number">14</span>,<span class="hljs-number">139</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">43</span>:<span class="hljs-number">14</span>,<span class="hljs-number">140</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.6502242088317871</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">43</span>:<span class="hljs-number">14</span>,<span class="hljs-number">140</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.4727</span>, <span class="hljs-number">0.3810</span>, <span class="hljs-number">0.8175</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">43</span>:<span class="hljs-number">14</span>,<span class="hljs-number">140</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">43</span>:<span class="hljs-number">14</span>,<span class="hljs-number">164</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[   <span class="hljs-number">0.0000</span>,  <span class="hljs-number">137.9016</span>,  <span class="hljs-number">312.4508</span>],<br>        [ <span class="hljs-number">411.2517</span>,    <span class="hljs-number">0.0000</span>,   <span class="hljs-number">56.4776</span>],<br>        [<span class="hljs-number">1244.7804</span>,   <span class="hljs-number">75.2528</span>,    <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">43</span>:<span class="hljs-number">14</span>,<span class="hljs-number">164</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">1.7104</span>, <span class="hljs-number">45.6986</span>],<br>        [ <span class="hljs-number">2.1531</span>,  <span class="hljs-number">0.0000</span>, <span class="hljs-number">32.1397</span>],<br>        [<span class="hljs-number">70.2883</span>, <span class="hljs-number">38.5202</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">43</span>:<span class="hljs-number">14</span>,<span class="hljs-number">165</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[  <span class="hljs-number">5.1066</span>, <span class="hljs-number">124.5901</span>, <span class="hljs-number">295.3791</span>],<br>        [ <span class="hljs-number">15.3946</span>, <span class="hljs-number">101.9502</span>, <span class="hljs-number">264.1716</span>],<br>        [<span class="hljs-number">164.5990</span>,  <span class="hljs-number">19.5029</span>, <span class="hljs-number">128.0492</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">43</span>:<span class="hljs-number">14</span>,<span class="hljs-number">165</span> - INFO: 混合类KL散度矩阵:<br>tensor([[ <span class="hljs-number">16.1470</span>,   <span class="hljs-number">8.2812</span>,  <span class="hljs-number">17.3734</span>],<br>        [ <span class="hljs-number">36.4932</span>,  <span class="hljs-number">68.4556</span>, <span class="hljs-number">214.7057</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240516162157278.png"alt="image-20240516162157278" /><figcaption aria-hidden="true">image-20240516162157278</figcaption></figure><p><strong>现有的训练过程中计算KL散度的方法并不能有效的拟合两个分布</strong></p><p><img src="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240518150531083.png" alt="image-20240518150531083" style="zoom: 67%;" /></p><h3 id="全数据ce">全数据(CE)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">40</span>:<span class="hljs-number">40</span>,<span class="hljs-number">556</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">40</span>:<span class="hljs-number">40</span>,<span class="hljs-number">557</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.7354260087013245</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">40</span>:<span class="hljs-number">40</span>,<span class="hljs-number">560</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.6727</span>, <span class="hljs-number">0.4286</span>, <span class="hljs-number">0.8651</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">40</span>:<span class="hljs-number">40</span>,<span class="hljs-number">560</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">40</span>:<span class="hljs-number">40</span>,<span class="hljs-number">585</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[   <span class="hljs-number">0.0000</span>,  <span class="hljs-number">300.7314</span>,  <span class="hljs-number">783.2631</span>],<br>        [ <span class="hljs-number">657.7589</span>,    <span class="hljs-number">0.0000</span>,  <span class="hljs-number">190.2540</span>],<br>        [<span class="hljs-number">2527.8254</span>,  <span class="hljs-number">287.3747</span>,    <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">40</span>:<span class="hljs-number">40</span>,<span class="hljs-number">586</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">5.1478</span>, <span class="hljs-number">22.3570</span>],<br>        [ <span class="hljs-number">4.5641</span>,  <span class="hljs-number">0.0000</span>, <span class="hljs-number">24.0716</span>],<br>        [<span class="hljs-number">32.4316</span>, <span class="hljs-number">27.1986</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">40</span>:<span class="hljs-number">40</span>,<span class="hljs-number">586</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">275.2747</span>,  <span class="hljs-number">806.8140</span>, <span class="hljs-number">1373.0902</span>],<br>        [ <span class="hljs-number">289.0464</span>,  <span class="hljs-number">821.3883</span>, <span class="hljs-number">1388.6962</span>],<br>        [ <span class="hljs-number">237.1945</span>,  <span class="hljs-number">763.7601</span>, <span class="hljs-number">1325.9968</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">20</span>:<span class="hljs-number">40</span>:<span class="hljs-number">40</span>,<span class="hljs-number">587</span> - INFO: 混合类KL散度矩阵:<br>tensor([[   <span class="hljs-number">9.5112</span>,   <span class="hljs-number">11.5490</span>,    <span class="hljs-number">9.4548</span>],<br>        [ <span class="hljs-number">247.0998</span>,  <span class="hljs-number">781.9989</span>, <span class="hljs-number">1347.6392</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><p>即使采用全类别数据，也会出现：</p><ol type="1"><li>真实分布的第一类和第二类分布很接近，即使先验分布里距离很远</li><li>真实分布和先验分布拟合的非常不好</li></ol><h2 id="理论回顾">理论回顾</h2><h3 id="论文中的理论部分">论文中的理论部分</h3><p>通过论文可以得知，<spanclass="math inline">\(\hat\mu_1\)</span>和<spanclass="math inline">\(\hat\sigma_1，\hat\sigma_2，\hat\sigma_3\)</span>这四个变量是从网络学习到的；然后第二类均值是由<spanclass="math inline">\(\hat\mu _1\)</span>偏移<spanclass="math inline">\(\Delta_2\)</span>得到的，<spanclass="math inline">\(\Delta _2\)</span>是由网络学习得到的<spanclass="math inline">\(\hat\sigma_2\)</span>得到，具体为<spanclass="math inline">\(\Delta_2 &gt; 3 \times\hat\sigma_2\)</span>（这个和上次通话确认的有区别，上次通话说的是<spanclass="math inline">\(\Delta\)</span>由真实分布的方差得到，但是论文中是由期望方差得到，有待确认）</p><p><img src="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240503144718803.png" alt="image-20240503144718803" style="zoom:50%;" /></p><p><img src="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240503144732302.png" alt="image-20240503144732302" style="zoom:50%;" /></p><h3 id="现有的实现方式">现有的实现方式</h3><p><img src="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240516202633896.png" alt="image-20240516202633896" style="zoom:67%;" /></p><p>首先定义了三个可学习的矩阵，并进行初始化。可以看出<code>self.mus</code>即为上述<spanclass="math inline">\(\mu_1\)</span>,共128维（可调整），<code>self.sigmas</code>为<spanclass="math inline">\(\hat\sigma_1，\hat\sigma_2，\hat\sigma_3\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">self.mus = nn.Parameter(torch.rand((<span class="hljs-number">1</span>, <span class="hljs-number">128</span>)), requires_grad=<span class="hljs-literal">True</span>)<br>self.deltas = nn.Parameter(torch.rand((<span class="hljs-number">3</span>, <span class="hljs-number">128</span>)), requires_grad=<span class="hljs-literal">True</span>)<br>self.sigmas = nn.Parameter(torch.rand((<span class="hljs-number">3</span>, <span class="hljs-number">128</span>)), requires_grad=<span class="hljs-literal">True</span>)<br><br>nn.init.kaiming_uniform_(self.mus, a=math.sqrt(<span class="hljs-number">5</span>))  <span class="hljs-comment"># He initialization</span><br>nn.init.kaiming_uniform_(self.deltas, a=math.sqrt(<span class="hljs-number">5</span>))<br>nn.init.kaiming_uniform_(self.sigmas, a=math.sqrt(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><p>随后获得先验分布的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_joint_priors</span>(<span class="hljs-params">mus, deltas, sigmas, num_classes</span>):<br>    <span class="hljs-comment"># 得到先验分布的 mu 和 covariance matrix</span><br>    <span class="hljs-comment"># 得到上三角部分为 1 的矩阵</span><br>    <span class="hljs-comment"># 通过矩阵相乘来得到 joint distribution 中的 mu 和 sigma</span><br>    <span class="hljs-comment"># 将 nablas 和 sigmas 转换为有效的值</span><br>    <br>    <span class="hljs-comment"># [clb] 将nalbas转化为正值</span><br>    deltas = torch.exp(deltas)<br>    <span class="hljs-comment"># [clb] 将sigmas缩放到（0，1）同时保持方差与类别间偏移量的比例关系</span><br>    sigmas = (torch.sigmoid(sigmas) * deltas / <span class="hljs-number">3</span>) ** <span class="hljs-number">2</span><br>    <span class="hljs-comment"># [clb] 最终triu是一个下三角矩阵</span><br>    triu = torch.triu(torch.ones(num_classes, num_classes)).T.cuda()<br>    <span class="hljs-comment"># [clb] 假设nablas表示为[[n1],[n2],[n3]],操作后为[[n1],[n1+n2],[n1+n2+n3]]</span><br>    joint_nablas = torch.matmul(triu, deltas) <span class="hljs-comment"># (K, d)</span><br>    <span class="hljs-comment"># [clb] 得到论文中的均值分布，即为[[u1+n1],[u1+n1+n2],[u1+n1+n2+n3]]</span><br>    joint_mus = mus + joint_nablas  <span class="hljs-comment"># (K, d)</span><br>    <br>    mat = torch.zeros(num_classes, num_classes, num_classes).cuda()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_classes):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_classes):<br>            mat[i, j][:<span class="hljs-built_in">min</span>(i,j)+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>            <br>    <span class="hljs-comment"># [clb] 循环之后的mat:</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        tensor([[[1., 0., 0.],</span><br><span class="hljs-string">                [1., 0., 0.],</span><br><span class="hljs-string">                [1., 0., 0.]],</span><br><span class="hljs-string"></span><br><span class="hljs-string">                [[1., 0., 0.],</span><br><span class="hljs-string">                [1., 1., 0.],</span><br><span class="hljs-string">                [1., 1., 0.]],</span><br><span class="hljs-string"></span><br><span class="hljs-string">                [[1., 0., 0.],</span><br><span class="hljs-string">                [1., 1., 0.],</span><br><span class="hljs-string">                [1., 1., 1.]]])</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <br>    <span class="hljs-comment"># [clb] 得到论文中的协方差分布</span><br>    joint_sigmas = torch.matmul(mat, sigmas)<br><br>    <span class="hljs-keyword">return</span> joint_mus.<span class="hljs-built_in">type</span>(torch.cuda.FloatTensor), joint_sigmas.<span class="hljs-built_in">type</span>(torch.cuda.FloatTensor)<br><br></code></pre></td></tr></table></figure><p>先验分布: <span class="math display">\[\mathcal{N}\left(\begin{bmatrix}\hat{\mu}_1\\\hat{\mu}_1+\Delta_2\\\hat{\mu}_1+\Delta_2+\Delta_3\end{bmatrix},\begin{bmatrix}\hat{\sigma}_1^2&amp;\hat{\sigma}_1^2&amp;\hat{\sigma}_1^2\\\hat{\sigma}_1^2&amp;\hat{\sigma}_1^2+\hat{\sigma}_2^2&amp;\hat{\sigma}_1^2+\hat{\sigma}_2^2\\\hat{\sigma}_1^2&amp;\hat{\sigma}_1^2+\hat{\sigma}_2^2&amp;\hat{\sigma}_1^2+\hat{\sigma}_2^2+\hat{\sigma}_3^2\end{bmatrix}\right),\]</span> 后验分布:</p><p><span class="math display">\[\mathcal{N}\left(\begin{bmatrix}\mu_1\\\mu_2\\\mu_3\end{bmatrix},\begin{bmatrix}\sigma_1^2&amp;0&amp;0\\0&amp;\sigma_2^2&amp;0\\0&amp;0&amp;\sigma_3^2\end{bmatrix}\right),\]</span>似乎将这两个分布进行拟合并不合理，尝试采用Normal分三个KL散度计算</p><h2 id="改进后情况">改进后情况</h2><h3 id="原分布全样本kl">原分布、全样本、KL：</h3><p>/mnt/chenlb/Six_Tumor_Classification/Exp37/results/model_3deltas_32d_all</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">23</span>:<span class="hljs-number">30</span>:<span class="hljs-number">38</span>,<span class="hljs-number">611</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">23</span>:<span class="hljs-number">30</span>:<span class="hljs-number">38</span>,<span class="hljs-number">611</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.5650224089622498</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">23</span>:<span class="hljs-number">30</span>:<span class="hljs-number">38</span>,<span class="hljs-number">612</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">23</span>:<span class="hljs-number">30</span>:<span class="hljs-number">38</span>,<span class="hljs-number">612</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">23</span>:<span class="hljs-number">30</span>:<span class="hljs-number">38</span>,<span class="hljs-number">639</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>, <span class="hljs-number">13.3532</span>, <span class="hljs-number">66.1137</span>],<br>        [<span class="hljs-number">13.7833</span>,  <span class="hljs-number">0.0000</span>, <span class="hljs-number">20.8047</span>],<br>        [<span class="hljs-number">71.2934</span>, <span class="hljs-number">21.7507</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">23</span>:<span class="hljs-number">30</span>:<span class="hljs-number">38</span>,<span class="hljs-number">639</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">1.9351</span>, <span class="hljs-number">31.9998</span>],<br>        [ <span class="hljs-number">2.4101</span>,  <span class="hljs-number">0.0000</span>, <span class="hljs-number">19.6424</span>],<br>        [<span class="hljs-number">46.1147</span>, <span class="hljs-number">22.4444</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">23</span>:<span class="hljs-number">30</span>:<span class="hljs-number">38</span>,<span class="hljs-number">640</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">1.6579</span>,  <span class="hljs-number">6.6793</span>, <span class="hljs-number">49.6588</span>],<br>        [ <span class="hljs-number">5.8834</span>,  <span class="hljs-number">1.6310</span>, <span class="hljs-number">33.6489</span>],<br>        [<span class="hljs-number">52.5145</span>, <span class="hljs-number">12.1990</span>,  <span class="hljs-number">1.4529</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">16</span> <span class="hljs-number">23</span>:<span class="hljs-number">30</span>:<span class="hljs-number">38</span>,<span class="hljs-number">641</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">10.5228</span>,  <span class="hljs-number">4.0938</span>, <span class="hljs-number">11.0211</span>],<br>        [<span class="hljs-number">17.6744</span>,  <span class="hljs-number">1.6430</span>, <span class="hljs-number">19.7515</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>合理的分布情况！</strong></p><h3 id="sigma_1sigma_2全样本kl"><spanclass="math inline">\(\sigma_1=\sigma_2\)</span>​、全样本、KL</h3><p>/mnt/chenlb/Six_Tumor_Classification/Exp38/results/model_3sigmas_32d_kl</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">17</span> <span class="hljs-number">00</span>:<span class="hljs-number">42</span>:<span class="hljs-number">16</span>,<span class="hljs-number">307</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">17</span> <span class="hljs-number">00</span>:<span class="hljs-number">42</span>:<span class="hljs-number">16</span>,<span class="hljs-number">307</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.5650224089622498</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">17</span> <span class="hljs-number">00</span>:<span class="hljs-number">42</span>:<span class="hljs-number">16</span>,<span class="hljs-number">308</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">17</span> <span class="hljs-number">00</span>:<span class="hljs-number">42</span>:<span class="hljs-number">16</span>,<span class="hljs-number">308</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">17</span> <span class="hljs-number">00</span>:<span class="hljs-number">42</span>:<span class="hljs-number">16</span>,<span class="hljs-number">330</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[  <span class="hljs-number">0.0000</span>, <span class="hljs-number">113.8020</span>, <span class="hljs-number">186.5514</span>],<br>        [<span class="hljs-number">226.3330</span>,   <span class="hljs-number">0.0000</span>,   <span class="hljs-number">9.7336</span>],<br>        [<span class="hljs-number">378.9963</span>,   <span class="hljs-number">9.9251</span>,   <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">17</span> <span class="hljs-number">00</span>:<span class="hljs-number">42</span>:<span class="hljs-number">16</span>,<span class="hljs-number">331</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">3.6247</span>, <span class="hljs-number">30.3788</span>],<br>        [ <span class="hljs-number">5.7156</span>,  <span class="hljs-number">0.0000</span>, <span class="hljs-number">17.2604</span>],<br>        [<span class="hljs-number">88.6521</span>, <span class="hljs-number">30.5168</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">17</span> <span class="hljs-number">00</span>:<span class="hljs-number">42</span>:<span class="hljs-number">16</span>,<span class="hljs-number">332</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">34.1595</span>,  <span class="hljs-number">45.0543</span>,  <span class="hljs-number">93.6794</span>],<br>        [ <span class="hljs-number">56.2025</span>,  <span class="hljs-number">28.6504</span>,  <span class="hljs-number">70.6779</span>],<br>        [<span class="hljs-number">203.9038</span>,   <span class="hljs-number">1.5658</span>,  <span class="hljs-number">15.6994</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">17</span> <span class="hljs-number">00</span>:<span class="hljs-number">42</span>:<span class="hljs-number">16</span>,<span class="hljs-number">333</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">18.1251</span>,  <span class="hljs-number">5.7314</span>, <span class="hljs-number">12.7729</span>],<br>        [<span class="hljs-number">96.8231</span>, <span class="hljs-number">16.4908</span>, <span class="hljs-number">48.1649</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="原分布一三类kl">原分布、一三类、KL：</h3><h4 id="sigmas_64d">6sigmas_64d</h4><p>/mnt/chenlb/Six_Tumor_Classification/Exp39/results/model_6sigmas_64d_kl</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">54</span>,<span class="hljs-number">980</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">54</span>,<span class="hljs-number">980</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.23766815662384033</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">54</span>,<span class="hljs-number">981</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.9636</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">54</span>,<span class="hljs-number">981</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">55</span>,004 - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">1.5258</span>, <span class="hljs-number">5.9365</span>],<br>        [<span class="hljs-number">1.5697</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">1.4873</span>],<br>        [<span class="hljs-number">6.2767</span>, <span class="hljs-number">1.5293</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">55</span>,005 - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0975</span>, <span class="hljs-number">1.7020</span>],<br>        [<span class="hljs-number">0.1415</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">1.0807</span>],<br>        [<span class="hljs-number">2.1316</span>, <span class="hljs-number">0.8853</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">55</span>,005 - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.1065</span>, <span class="hljs-number">1.1745</span>, <span class="hljs-number">5.1524</span>],<br>        [<span class="hljs-number">0.6081</span>, <span class="hljs-number">0.7324</span>, <span class="hljs-number">3.8158</span>],<br>        [<span class="hljs-number">4.3318</span>, <span class="hljs-number">0.7583</span>, <span class="hljs-number">0.3409</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">55</span>,006 - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.5979</span>, <span class="hljs-number">0.3041</span>, <span class="hljs-number">0.5467</span>],<br>        [<span class="hljs-number">1.2400</span>, <span class="hljs-number">0.0239</span>, <span class="hljs-number">1.8391</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><p>之前提出一个观点是一二类很像可能是因为先验分布中第二类方差没有得到训练，导致一二类的先验很接近，进而导致一二类的真实分布很接近。但是目前来看可以看到先验分布中方差其实还是有一定的区别的，是后验拟合的不好</p><p><img src="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240518151727210.png" alt="image-20240518151727210" style="zoom:50%;" /></p><h4 id="sigmas_32d-3">6sigmas_32d</h4><p>/mnt/chenlb/Six_Tumor_Classification/Exp39/results/model_6sigmas_32d_kl</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">312</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">313</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.39751553535461426</span><br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">313</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>])<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">313</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">336</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.6765</span>, <span class="hljs-number">2.5768</span>],<br>        [<span class="hljs-number">0.6859</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.6240</span>],<br>        [<span class="hljs-number">2.6426</span>, <span class="hljs-number">0.6314</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">337</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0371</span>, <span class="hljs-number">1.4147</span>],<br>        [<span class="hljs-number">0.0469</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">1.0820</span>],<br>        [<span class="hljs-number">1.7969</span>, <span class="hljs-number">1.0472</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">338</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0088</span>, <span class="hljs-number">0.5483</span>, <span class="hljs-number">2.3199</span>],<br>        [<span class="hljs-number">0.0978</span>, <span class="hljs-number">0.3596</span>, <span class="hljs-number">1.8697</span>],<br>        [<span class="hljs-number">2.1856</span>, <span class="hljs-number">0.4345</span>, <span class="hljs-number">0.0478</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">338</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.5122</span>, <span class="hljs-number">0.3298</span>, <span class="hljs-number">0.4766</span>],<br>        [<span class="hljs-number">0.6539</span>, <span class="hljs-number">0.0586</span>, <span class="hljs-number">0.7601</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">805</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">806</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.4409937858581543</span><br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">806</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.4909</span>, <span class="hljs-number">0.1905</span>, <span class="hljs-number">0.5625</span>])<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">806</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">839</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0573</span>, <span class="hljs-number">0.2288</span>],<br>        [<span class="hljs-number">0.0574</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0572</span>],<br>        [<span class="hljs-number">0.2293</span>, <span class="hljs-number">0.0572</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">839</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0889</span>, <span class="hljs-number">0.3920</span>],<br>        [<span class="hljs-number">0.1060</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.1093</span>],<br>        [<span class="hljs-number">0.4369</span>, <span class="hljs-number">0.1016</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">840</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0071</span>, <span class="hljs-number">0.0727</span>, <span class="hljs-number">0.2525</span>],<br>        [<span class="hljs-number">0.0727</span>, <span class="hljs-number">0.0009</span>, <span class="hljs-number">0.0438</span>],<br>        [<span class="hljs-number">0.3466</span>, <span class="hljs-number">0.1222</span>, <span class="hljs-number">0.0129</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">841</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.1915</span>, <span class="hljs-number">0.1301</span>, <span class="hljs-number">0.2074</span>],<br>        [<span class="hljs-number">0.2081</span>, <span class="hljs-number">0.1290</span>, <span class="hljs-number">0.1645</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="sigmas_16d">6sigmas_16d</h4><p>/mnt/chenlb/Six_Tumor_Classification/Exp39/results/model_6sigmas_16d_kl</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">876</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">876</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.18834081292152405</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">877</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">877</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">901</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.3387</span>, <span class="hljs-number">1.2581</span>],<br>        [<span class="hljs-number">0.3414</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.2978</span>],<br>        [<span class="hljs-number">1.2755</span>, <span class="hljs-number">0.2997</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">901</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0642</span>, <span class="hljs-number">0.7351</span>],<br>        [<span class="hljs-number">0.0719</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.3961</span>],<br>        [<span class="hljs-number">1.0095</span>, <span class="hljs-number">0.4858</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">902</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0048</span>, <span class="hljs-number">0.3036</span>, <span class="hljs-number">1.1855</span>],<br>        [<span class="hljs-number">0.0804</span>, <span class="hljs-number">0.0925</span>, <span class="hljs-number">0.7085</span>],<br>        [<span class="hljs-number">0.9556</span>, <span class="hljs-number">0.1641</span>, <span class="hljs-number">0.0351</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">902</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.3024</span>, <span class="hljs-number">0.1310</span>, <span class="hljs-number">0.3139</span>],<br>        [<span class="hljs-number">0.3350</span>, <span class="hljs-number">0.0924</span>, <span class="hljs-number">0.4718</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="sigma_1sigma_2一三类kl"><spanclass="math inline">\(\sigma_1=\sigma_2\)</span>​​、一三类、KL</h3><h4 id="sigmas">3sigmas</h4><p>/mnt/chenlb/Six_Tumor_Classification/Exp38/results/model_3sigmas_32d_kl_13</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">53</span>,<span class="hljs-number">266</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">53</span>,<span class="hljs-number">266</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.5650224089622498</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">53</span>,<span class="hljs-number">267</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">53</span>,<span class="hljs-number">267</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">53</span>,<span class="hljs-number">290</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">4.0059</span>,  <span class="hljs-number">6.1636</span>],<br>        [ <span class="hljs-number">7.9721</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.2515</span>],<br>        [<span class="hljs-number">12.4871</span>,  <span class="hljs-number">0.2557</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">53</span>,<span class="hljs-number">290</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0403</span>, <span class="hljs-number">1.1791</span>],<br>        [<span class="hljs-number">0.0529</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.9209</span>],<br>        [<span class="hljs-number">2.8587</span>, <span class="hljs-number">1.6144</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">53</span>,<span class="hljs-number">291</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.4083</span>, <span class="hljs-number">2.4020</span>, <span class="hljs-number">4.1445</span>],<br>        [<span class="hljs-number">0.7179</span>, <span class="hljs-number">2.0362</span>, <span class="hljs-number">3.6728</span>],<br>        [<span class="hljs-number">6.4565</span>, <span class="hljs-number">0.1324</span>, <span class="hljs-number">0.6311</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">53</span>,<span class="hljs-number">292</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.6447</span>, <span class="hljs-number">0.3596</span>, <span class="hljs-number">0.4552</span>],<br>        [<span class="hljs-number">2.3451</span>, <span class="hljs-number">0.8712</span>, <span class="hljs-number">2.0029</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240517114501918.png" alt="image-20240517114501918" style="zoom:50%;" /></p><h3 id="删除模糊类别">删除模糊类别</h3><p>训练集分布： {0: 206, 1: 53, 2: 244, 3: 0, 4: 0, 5: 0} 测试集分布：{0: 40, 1: 9, 2: 83, 3: 0, 4: 0, 5: 0} 验证集分布： {0: 54, 1: 15, 2:126, 3: 0, 4: 0, 5: 0}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:07,<span class="hljs-number">954</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:07,<span class="hljs-number">955</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.07692307978868484</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:07,<span class="hljs-number">956</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:07,<span class="hljs-number">956</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:07,<span class="hljs-number">980</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.2763</span>, <span class="hljs-number">1.2608</span>],<br>        [<span class="hljs-number">0.2828</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.3669</span>],<br>        [<span class="hljs-number">1.3228</span>, <span class="hljs-number">0.3765</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:07,<span class="hljs-number">981</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0615</span>, <span class="hljs-number">0.4477</span>],<br>        [<span class="hljs-number">0.0662</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.2141</span>],<br>        [<span class="hljs-number">0.6737</span>, <span class="hljs-number">0.2951</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:07,<span class="hljs-number">981</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0990</span>, <span class="hljs-number">0.0762</span>, <span class="hljs-number">0.7291</span>],<br>        [<span class="hljs-number">0.2676</span>, <span class="hljs-number">0.0086</span>, <span class="hljs-number">0.3990</span>],<br>        [<span class="hljs-number">0.9887</span>, <span class="hljs-number">0.2141</span>, <span class="hljs-number">0.0307</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:07,<span class="hljs-number">982</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.2013</span>, <span class="hljs-number">0.0821</span>, <span class="hljs-number">0.2486</span>],<br>        [<span class="hljs-number">0.5040</span>, <span class="hljs-number">0.1137</span>, <span class="hljs-number">0.3576</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="mixup结果">mixup结果</h2><h3 id="sigmas_16d-1">6sigmas_16d</h3><p>/mnt/chenlb/Six_Tumor_Classification/Exp39/results/model_6sigmas_16d_kl</p><h4 id="kl">KL</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">876</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">876</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.18834081292152405</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">877</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">877</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">901</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.3387</span>, <span class="hljs-number">1.2581</span>],<br>        [<span class="hljs-number">0.3414</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.2978</span>],<br>        [<span class="hljs-number">1.2755</span>, <span class="hljs-number">0.2997</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">901</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0642</span>, <span class="hljs-number">0.7351</span>],<br>        [<span class="hljs-number">0.0719</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.3961</span>],<br>        [<span class="hljs-number">1.0095</span>, <span class="hljs-number">0.4858</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">902</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0048</span>, <span class="hljs-number">0.3036</span>, <span class="hljs-number">1.1855</span>],<br>        [<span class="hljs-number">0.0804</span>, <span class="hljs-number">0.0925</span>, <span class="hljs-number">0.7085</span>],<br>        [<span class="hljs-number">0.9556</span>, <span class="hljs-number">0.1641</span>, <span class="hljs-number">0.0351</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">20</span>,<span class="hljs-number">902</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.3024</span>, <span class="hljs-number">0.1310</span>, <span class="hljs-number">0.3139</span>],<br>        [<span class="hljs-number">0.3350</span>, <span class="hljs-number">0.0924</span>, <span class="hljs-number">0.4718</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="kl后ce不固定前面参数">KL后CE（不固定前面参数）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">46</span>:<span class="hljs-number">30</span>,<span class="hljs-number">963</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">46</span>:<span class="hljs-number">30</span>,<span class="hljs-number">963</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.5874439477920532</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">46</span>:<span class="hljs-number">30</span>,<span class="hljs-number">964</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.3818</span>, <span class="hljs-number">0.6905</span>, <span class="hljs-number">0.6429</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">46</span>:<span class="hljs-number">30</span>,<span class="hljs-number">964</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">46</span>:<span class="hljs-number">30</span>,<span class="hljs-number">989</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.3387</span>, <span class="hljs-number">1.2581</span>],<br>        [<span class="hljs-number">0.3414</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.2978</span>],<br>        [<span class="hljs-number">1.2755</span>, <span class="hljs-number">0.2997</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">46</span>:<span class="hljs-number">30</span>,<span class="hljs-number">990</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0447</span>, <span class="hljs-number">0.8289</span>],<br>        [<span class="hljs-number">0.0509</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.5993</span>],<br>        [<span class="hljs-number">1.0993</span>, <span class="hljs-number">0.6740</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">46</span>:<span class="hljs-number">30</span>,<span class="hljs-number">990</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.2471</span>, <span class="hljs-number">0.8537</span>, <span class="hljs-number">2.0403</span>],<br>        [<span class="hljs-number">0.1937</span>, <span class="hljs-number">0.6783</span>, <span class="hljs-number">1.7436</span>],<br>        [<span class="hljs-number">0.3290</span>, <span class="hljs-number">0.0790</span>, <span class="hljs-number">0.4404</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">46</span>:<span class="hljs-number">30</span>,<span class="hljs-number">991</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.3353</span>, <span class="hljs-number">0.2165</span>, <span class="hljs-number">0.3286</span>],<br>        [<span class="hljs-number">0.2832</span>, <span class="hljs-number">0.4640</span>, <span class="hljs-number">1.2401</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="kl后klce不固定前面参数">KL后KL+CE（不固定前面参数）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">50</span>,<span class="hljs-number">859</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">50</span>,<span class="hljs-number">859</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.4304932653903961</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">50</span>,<span class="hljs-number">860</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.4000</span>, <span class="hljs-number">0.6667</span>, <span class="hljs-number">0.3651</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">50</span>,<span class="hljs-number">860</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">50</span>,<span class="hljs-number">884</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.2663</span>, <span class="hljs-number">1.0168</span>],<br>        [<span class="hljs-number">0.2680</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.2458</span>],<br>        [<span class="hljs-number">1.0280</span>, <span class="hljs-number">0.2470</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">50</span>,<span class="hljs-number">885</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0657</span>, <span class="hljs-number">0.7211</span>],<br>        [<span class="hljs-number">0.0733</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.3941</span>],<br>        [<span class="hljs-number">1.0432</span>, <span class="hljs-number">0.5079</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">50</span>,<span class="hljs-number">886</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0560</span>, <span class="hljs-number">0.4890</span>, <span class="hljs-number">1.4010</span>],<br>        [<span class="hljs-number">0.0281</span>, <span class="hljs-number">0.2171</span>, <span class="hljs-number">0.8968</span>],<br>        [<span class="hljs-number">0.5847</span>, <span class="hljs-number">0.0750</span>, <span class="hljs-number">0.0885</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">50</span>,<span class="hljs-number">886</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.3046</span>, <span class="hljs-number">0.1257</span>, <span class="hljs-number">0.3124</span>],<br>        [<span class="hljs-number">0.1913</span>, <span class="hljs-number">0.1557</span>, <span class="hljs-number">0.6207</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="kl三类ce">KL（三类）+CE</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">805</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">806</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.4409937858581543</span><br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">806</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.4909</span>, <span class="hljs-number">0.1905</span>, <span class="hljs-number">0.5625</span>])<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">806</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">839</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0573</span>, <span class="hljs-number">0.2288</span>],<br>        [<span class="hljs-number">0.0574</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0572</span>],<br>        [<span class="hljs-number">0.2293</span>, <span class="hljs-number">0.0572</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">839</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0889</span>, <span class="hljs-number">0.3920</span>],<br>        [<span class="hljs-number">0.1060</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.1093</span>],<br>        [<span class="hljs-number">0.4369</span>, <span class="hljs-number">0.1016</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">840</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0071</span>, <span class="hljs-number">0.0727</span>, <span class="hljs-number">0.2525</span>],<br>        [<span class="hljs-number">0.0727</span>, <span class="hljs-number">0.0009</span>, <span class="hljs-number">0.0438</span>],<br>        [<span class="hljs-number">0.3466</span>, <span class="hljs-number">0.1222</span>, <span class="hljs-number">0.0129</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">841</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.1915</span>, <span class="hljs-number">0.1301</span>, <span class="hljs-number">0.2074</span>],<br>        [<span class="hljs-number">0.2081</span>, <span class="hljs-number">0.1290</span>, <span class="hljs-number">0.1645</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">570</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">571</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.44720497727394104</span><br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">573</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.5091</span>, <span class="hljs-number">0.2381</span>, <span class="hljs-number">0.5312</span>])<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">573</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">627</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0684</span>, <span class="hljs-number">0.2801</span>],<br>        [<span class="hljs-number">0.0685</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0717</span>],<br>        [<span class="hljs-number">0.2808</span>, <span class="hljs-number">0.0718</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">629</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0573</span>, <span class="hljs-number">0.3616</span>],<br>        [<span class="hljs-number">0.0610</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.1255</span>],<br>        [<span class="hljs-number">0.3421</span>, <span class="hljs-number">0.1118</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">630</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0013</span>, <span class="hljs-number">0.0687</span>, <span class="hljs-number">0.2794</span>],<br>        [<span class="hljs-number">0.0567</span>, <span class="hljs-number">0.0006</span>, <span class="hljs-number">0.0851</span>],<br>        [<span class="hljs-number">0.3238</span>, <span class="hljs-number">0.0962</span>, <span class="hljs-number">0.0053</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">631</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.2408</span>, <span class="hljs-number">0.1336</span>, <span class="hljs-number">0.1353</span>],<br>        [<span class="hljs-number">0.2514</span>, <span class="hljs-number">0.1310</span>, <span class="hljs-number">0.1496</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="有问题部分">有问题部分</h2><h4 id="sigmas-1">3sigmas</h4><p>/mnt/chenlb/Six_Tumor_Classification/Exp39/results/model_3sigmas_32d_kl</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">55</span>:<span class="hljs-number">36</span>,<span class="hljs-number">236</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">55</span>:<span class="hljs-number">36</span>,<span class="hljs-number">237</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.5650224089622498</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">55</span>:<span class="hljs-number">36</span>,<span class="hljs-number">237</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">55</span>:<span class="hljs-number">36</span>,<span class="hljs-number">237</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">55</span>:<span class="hljs-number">36</span>,<span class="hljs-number">260</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.6677</span>, <span class="hljs-number">2.4525</span>],<br>        [<span class="hljs-number">0.7038</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.5912</span>],<br>        [<span class="hljs-number">2.6935</span>, <span class="hljs-number">0.6175</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">55</span>:<span class="hljs-number">36</span>,<span class="hljs-number">261</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0350</span>, <span class="hljs-number">1.1423</span>],<br>        [<span class="hljs-number">0.0418</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.8241</span>],<br>        [<span class="hljs-number">1.5488</span>, <span class="hljs-number">0.9215</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">55</span>:<span class="hljs-number">36</span>,<span class="hljs-number">261</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0164</span>, <span class="hljs-number">0.4833</span>, <span class="hljs-number">2.0915</span>],<br>        [<span class="hljs-number">0.1110</span>, <span class="hljs-number">0.2785</span>, <span class="hljs-number">1.6242</span>],<br>        [<span class="hljs-number">1.9690</span>, <span class="hljs-number">0.3205</span>, <span class="hljs-number">0.0761</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">55</span>:<span class="hljs-number">36</span>,<span class="hljs-number">262</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.4396</span>, <span class="hljs-number">0.2629</span>, <span class="hljs-number">0.4146</span>],<br>        [<span class="hljs-number">0.6232</span>, <span class="hljs-number">0.0678</span>, <span class="hljs-number">0.7778</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="sigmas-2">6sigmas</h4><p>/mnt/chenlb/Six_Tumor_Classification/Exp39/results/model_6sigmas_32d_kl</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">25</span>:<span class="hljs-number">17</span>,<span class="hljs-number">410</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">25</span>:<span class="hljs-number">17</span>,<span class="hljs-number">410</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.5650224089622498</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">25</span>:<span class="hljs-number">17</span>,<span class="hljs-number">411</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">25</span>:<span class="hljs-number">17</span>,<span class="hljs-number">411</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">25</span>:<span class="hljs-number">17</span>,<span class="hljs-number">434</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.6765</span>, <span class="hljs-number">2.5768</span>],<br>        [<span class="hljs-number">0.6859</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.6240</span>],<br>        [<span class="hljs-number">2.6426</span>, <span class="hljs-number">0.6314</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">25</span>:<span class="hljs-number">17</span>,<span class="hljs-number">434</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0371</span>, <span class="hljs-number">1.3433</span>],<br>        [<span class="hljs-number">0.0469</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">1.0230</span>],<br>        [<span class="hljs-number">1.8677</span>, <span class="hljs-number">1.0851</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">25</span>:<span class="hljs-number">17</span>,<span class="hljs-number">435</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0088</span>, <span class="hljs-number">0.5483</span>, <span class="hljs-number">2.3199</span>],<br>        [<span class="hljs-number">0.0978</span>, <span class="hljs-number">0.3596</span>, <span class="hljs-number">1.8697</span>],<br>        [<span class="hljs-number">2.2689</span>, <span class="hljs-number">0.4812</span>, <span class="hljs-number">0.0601</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">25</span>:<span class="hljs-number">17</span>,<span class="hljs-number">436</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.5152</span>, <span class="hljs-number">0.3232</span>, <span class="hljs-number">0.4669</span>],<br>        [<span class="hljs-number">0.6609</span>, <span class="hljs-number">0.0477</span>, <span class="hljs-number">0.7323</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="sigmas-3">10sigmas</h4><p>/mnt/chenlb/Six_Tumor_Classification/Exp39/results/model_10sigmas_32d_kl</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">10</span>,<span class="hljs-number">575</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">10</span>,<span class="hljs-number">575</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.5650224089622498</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">10</span>,<span class="hljs-number">576</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">10</span>,<span class="hljs-number">576</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">10</span>,<span class="hljs-number">599</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.5731</span>, <span class="hljs-number">2.2032</span>],<br>        [<span class="hljs-number">0.5758</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.5340</span>],<br>        [<span class="hljs-number">2.2217</span>, <span class="hljs-number">0.5361</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">10</span>,<span class="hljs-number">600</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0668</span>, <span class="hljs-number">0.7586</span>],<br>        [<span class="hljs-number">0.0771</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.4145</span>],<br>        [<span class="hljs-number">1.1163</span>, <span class="hljs-number">0.5305</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">10</span>,<span class="hljs-number">600</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0261</span>, <span class="hljs-number">0.3652</span>, <span class="hljs-number">1.7701</span>],<br>        [<span class="hljs-number">0.1805</span>, <span class="hljs-number">0.1243</span>, <span class="hljs-number">1.1494</span>],<br>        [<span class="hljs-number">1.4162</span>, <span class="hljs-number">0.2120</span>, <span class="hljs-number">0.1365</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span>:<span class="hljs-number">10</span>,<span class="hljs-number">601</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.3171</span>, <span class="hljs-number">0.1348</span>, <span class="hljs-number">0.3257</span>],<br>        [<span class="hljs-number">0.4990</span>, <span class="hljs-number">0.0689</span>, <span class="hljs-number">0.7358</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="sigmas_2deltas">6sigmas_2deltas</h4><p>/mnt/chenlb/Six_Tumor_Classification/Exp39/results/model_2deltas_16d_kl</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">17</span>:<span class="hljs-number">41</span>:<span class="hljs-number">12</span>,<span class="hljs-number">819</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">17</span>:<span class="hljs-number">41</span>:<span class="hljs-number">12</span>,<span class="hljs-number">819</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.18834081292152405</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">17</span>:<span class="hljs-number">41</span>:<span class="hljs-number">12</span>,<span class="hljs-number">820</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">17</span>:<span class="hljs-number">41</span>:<span class="hljs-number">12</span>,<span class="hljs-number">820</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">17</span>:<span class="hljs-number">41</span>:<span class="hljs-number">12</span>,<span class="hljs-number">845</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.2708</span>, <span class="hljs-number">1.3820</span>],<br>        [<span class="hljs-number">0.2733</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.4361</span>],<br>        [<span class="hljs-number">1.4083</span>, <span class="hljs-number">0.4406</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">17</span>:<span class="hljs-number">41</span>:<span class="hljs-number">12</span>,<span class="hljs-number">845</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0530</span>, <span class="hljs-number">0.8760</span>],<br>        [<span class="hljs-number">0.0599</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.5261</span>],<br>        [<span class="hljs-number">1.1574</span>, <span class="hljs-number">0.6134</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">17</span>:<span class="hljs-number">41</span>:<span class="hljs-number">12</span>,<span class="hljs-number">846</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0241</span>, <span class="hljs-number">0.1936</span>, <span class="hljs-number">1.1804</span>],<br>        [<span class="hljs-number">0.0977</span>, <span class="hljs-number">0.0503</span>, <span class="hljs-number">0.7657</span>],<br>        [<span class="hljs-number">1.0834</span>, <span class="hljs-number">0.2685</span>, <span class="hljs-number">0.0219</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">17</span>:<span class="hljs-number">41</span>:<span class="hljs-number">12</span>,<span class="hljs-number">846</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.3460</span>, <span class="hljs-number">0.1688</span>, <span class="hljs-number">0.3456</span>],<br>        [<span class="hljs-number">0.4460</span>, <span class="hljs-number">0.1272</span>, <span class="hljs-number">0.5018</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="sigmas_0.5deltas">6sigmas_0.5deltas</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">18</span>:<span class="hljs-number">56</span>:<span class="hljs-number">21</span>,<span class="hljs-number">752</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">18</span>:<span class="hljs-number">56</span>:<span class="hljs-number">21</span>,<span class="hljs-number">752</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.18834081292152405</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">18</span>:<span class="hljs-number">56</span>:<span class="hljs-number">21</span>,<span class="hljs-number">754</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">18</span>:<span class="hljs-number">56</span>:<span class="hljs-number">21</span>,<span class="hljs-number">754</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">18</span>:<span class="hljs-number">56</span>:<span class="hljs-number">21</span>,<span class="hljs-number">777</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.2419</span>, <span class="hljs-number">1.2212</span>],<br>        [<span class="hljs-number">0.2431</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.3790</span>],<br>        [<span class="hljs-number">1.2344</span>, <span class="hljs-number">0.3814</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">18</span>:<span class="hljs-number">56</span>:<span class="hljs-number">21</span>,<span class="hljs-number">777</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0648</span>, <span class="hljs-number">0.8512</span>],<br>        [<span class="hljs-number">0.0699</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.5070</span>],<br>        [<span class="hljs-number">1.2476</span>, <span class="hljs-number">0.7149</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">18</span>:<span class="hljs-number">56</span>:<span class="hljs-number">21</span>,<span class="hljs-number">778</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0466</span>, <span class="hljs-number">0.1948</span>, <span class="hljs-number">1.0583</span>],<br>        [<span class="hljs-number">0.1226</span>, <span class="hljs-number">0.0680</span>, <span class="hljs-number">0.6804</span>],<br>        [<span class="hljs-number">0.9786</span>, <span class="hljs-number">0.2469</span>, <span class="hljs-number">0.0171</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">18</span>:<span class="hljs-number">56</span>:<span class="hljs-number">21</span>,<span class="hljs-number">779</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.3503</span>, <span class="hljs-number">0.1498</span>, <span class="hljs-number">0.3480</span>],<br>        [<span class="hljs-number">0.4449</span>, <span class="hljs-number">0.1551</span>, <span class="hljs-number">0.4744</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="delta">2delta</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">20</span>:<span class="hljs-number">42</span>:<span class="hljs-number">57</span>,<span class="hljs-number">957</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">20</span>:<span class="hljs-number">42</span>:<span class="hljs-number">57</span>,<span class="hljs-number">957</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.18834081292152405</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">20</span>:<span class="hljs-number">42</span>:<span class="hljs-number">57</span>,<span class="hljs-number">958</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">20</span>:<span class="hljs-number">42</span>:<span class="hljs-number">57</span>,<span class="hljs-number">958</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">20</span>:<span class="hljs-number">42</span>:<span class="hljs-number">57</span>,<span class="hljs-number">985</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.5918</span>, <span class="hljs-number">1.9982</span>],<br>        [<span class="hljs-number">0.6060</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.4564</span>],<br>        [<span class="hljs-number">2.0647</span>, <span class="hljs-number">0.4641</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">20</span>:<span class="hljs-number">42</span>:<span class="hljs-number">57</span>,<span class="hljs-number">986</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0693</span>, <span class="hljs-number">1.3903</span>],<br>        [<span class="hljs-number">0.0964</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.9519</span>],<br>        [<span class="hljs-number">1.9164</span>, <span class="hljs-number">0.8877</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">20</span>:<span class="hljs-number">42</span>:<span class="hljs-number">57</span>,<span class="hljs-number">986</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0027</span>, <span class="hljs-number">0.5976</span>, <span class="hljs-number">2.0077</span>],<br>        [<span class="hljs-number">0.0705</span>, <span class="hljs-number">0.3353</span>, <span class="hljs-number">1.4631</span>],<br>        [<span class="hljs-number">1.7196</span>, <span class="hljs-number">0.3197</span>, <span class="hljs-number">0.0272</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">18</span> <span class="hljs-number">20</span>:<span class="hljs-number">42</span>:<span class="hljs-number">57</span>,<span class="hljs-number">987</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.5289</span>, <span class="hljs-number">0.2986</span>, <span class="hljs-number">0.4780</span>],<br>        [<span class="hljs-number">0.5042</span>, <span class="hljs-number">0.1152</span>, <span class="hljs-number">0.6829</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="自实现3sigmas">自实现3sigmas</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">12</span>:09:<span class="hljs-number">33</span>,<span class="hljs-number">395</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">12</span>:09:<span class="hljs-number">33</span>,<span class="hljs-number">396</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.18834081292152405</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">12</span>:09:<span class="hljs-number">33</span>,<span class="hljs-number">398</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">12</span>:09:<span class="hljs-number">33</span>,<span class="hljs-number">398</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">12</span>:09:<span class="hljs-number">33</span>,<span class="hljs-number">430</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">2.3466</span>,  <span class="hljs-number">5.4760</span>],<br>        [ <span class="hljs-number">4.6534</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">1.0370</span>],<br>        [<span class="hljs-number">14.5220</span>,  <span class="hljs-number">1.4446</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">12</span>:09:<span class="hljs-number">33</span>,<span class="hljs-number">431</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0483</span>, <span class="hljs-number">1.0680</span>],<br>        [<span class="hljs-number">0.0633</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.7878</span>],<br>        [<span class="hljs-number">3.1680</span>, <span class="hljs-number">1.7479</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">12</span>:09:<span class="hljs-number">33</span>,<span class="hljs-number">431</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.3395</span>, <span class="hljs-number">1.4037</span>, <span class="hljs-number">3.4232</span>],<br>        [<span class="hljs-number">0.5201</span>, <span class="hljs-number">1.0773</span>, <span class="hljs-number">2.9596</span>],<br>        [<span class="hljs-number">4.0475</span>, <span class="hljs-number">0.0211</span>, <span class="hljs-number">0.7556</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">12</span>:09:<span class="hljs-number">33</span>,<span class="hljs-number">432</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.6637</span>, <span class="hljs-number">0.3037</span>, <span class="hljs-number">0.4288</span>],<br>        [<span class="hljs-number">1.5965</span>, <span class="hljs-number">0.5473</span>, <span class="hljs-number">1.9794</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="自实现6sigmas">自实现6sigmas</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">13</span>:<span class="hljs-number">18</span>:<span class="hljs-number">43</span>,<span class="hljs-number">761</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">13</span>:<span class="hljs-number">18</span>:<span class="hljs-number">43</span>,<span class="hljs-number">762</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.18834081292152405</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">13</span>:<span class="hljs-number">18</span>:<span class="hljs-number">43</span>,<span class="hljs-number">765</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">13</span>:<span class="hljs-number">18</span>:<span class="hljs-number">43</span>,<span class="hljs-number">765</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">13</span>:<span class="hljs-number">18</span>:<span class="hljs-number">43</span>,<span class="hljs-number">797</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">9.0966</span>, <span class="hljs-number">17.8626</span>],<br>        [<span class="hljs-number">18.1534</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">3.0291</span>],<br>        [<span class="hljs-number">47.4098</span>,  <span class="hljs-number">4.4731</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">13</span>:<span class="hljs-number">18</span>:<span class="hljs-number">43</span>,<span class="hljs-number">798</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0515</span>, <span class="hljs-number">1.1501</span>],<br>        [<span class="hljs-number">0.0668</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.8324</span>],<br>        [<span class="hljs-number">2.8963</span>, <span class="hljs-number">1.5915</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">13</span>:<span class="hljs-number">18</span>:<span class="hljs-number">43</span>,<span class="hljs-number">799</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">1.9369</span>, <span class="hljs-number">4.1442</span>, <span class="hljs-number">5.9740</span>],<br>        [<span class="hljs-number">2.6208</span>, <span class="hljs-number">3.4994</span>, <span class="hljs-number">5.2066</span>],<br>        [<span class="hljs-number">9.7777</span>, <span class="hljs-number">0.7345</span>, <span class="hljs-number">1.6030</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">13</span>:<span class="hljs-number">18</span>:<span class="hljs-number">43</span>,<span class="hljs-number">799</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.6438</span>, <span class="hljs-number">0.2972</span>, <span class="hljs-number">0.4486</span>],<br>        [<span class="hljs-number">4.9561</span>, <span class="hljs-number">2.1339</span>, <span class="hljs-number">3.4890</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="自实现10sigmas">自实现10sigmas</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">15</span>:<span class="hljs-number">50</span>:<span class="hljs-number">51</span>,<span class="hljs-number">893</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">15</span>:<span class="hljs-number">50</span>:<span class="hljs-number">51</span>,<span class="hljs-number">894</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.18834081292152405</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">15</span>:<span class="hljs-number">50</span>:<span class="hljs-number">51</span>,<span class="hljs-number">895</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">15</span>:<span class="hljs-number">50</span>:<span class="hljs-number">51</span>,<span class="hljs-number">895</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">15</span>:<span class="hljs-number">50</span>:<span class="hljs-number">51</span>,<span class="hljs-number">919</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">25.0966</span>,  <span class="hljs-number">47.0659</span>],<br>        [ <span class="hljs-number">50.1534</span>,   <span class="hljs-number">0.0000</span>,   <span class="hljs-number">8.1720</span>],<br>        [<span class="hljs-number">126.3276</span>,  <span class="hljs-number">12.1709</span>,   <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">15</span>:<span class="hljs-number">50</span>:<span class="hljs-number">51</span>,<span class="hljs-number">920</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0514</span>, <span class="hljs-number">1.2257</span>],<br>        [<span class="hljs-number">0.0687</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.9138</span>],<br>        [<span class="hljs-number">3.2759</span>, <span class="hljs-number">1.7643</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">15</span>:<span class="hljs-number">50</span>:<span class="hljs-number">51</span>,<span class="hljs-number">920</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">3.8568</span>, <span class="hljs-number">13.1958</span>, <span class="hljs-number">15.1707</span>],<br>        [ <span class="hljs-number">5.0922</span>, <span class="hljs-number">11.9641</span>, <span class="hljs-number">13.8473</span>],<br>        [<span class="hljs-number">19.1877</span>,  <span class="hljs-number">4.3346</span>,  <span class="hljs-number">5.4597</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">15</span>:<span class="hljs-number">50</span>:<span class="hljs-number">51</span>,<span class="hljs-number">921</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.7233</span>, <span class="hljs-number">0.3478</span>, <span class="hljs-number">0.4682</span>],<br>        [<span class="hljs-number">9.6102</span>, <span class="hljs-number">7.9507</span>, <span class="hljs-number">9.5023</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">51</span>,<span class="hljs-number">493</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">51</span>,<span class="hljs-number">494</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.18834081292152405</span><br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">51</span>,<span class="hljs-number">498</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>])<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">51</span>,<span class="hljs-number">498</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">51</span>,<span class="hljs-number">531</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">25.0966</span>,  <span class="hljs-number">47.0283</span>],<br>        [ <span class="hljs-number">50.1534</span>,   <span class="hljs-number">0.0000</span>,   <span class="hljs-number">8.1705</span>],<br>        [<span class="hljs-number">126.2516</span>,  <span class="hljs-number">12.1694</span>,   <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">51</span>,<span class="hljs-number">532</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0385</span>, <span class="hljs-number">1.2887</span>],<br>        [<span class="hljs-number">0.0496</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">1.0118</span>],<br>        [<span class="hljs-number">3.0610</span>, <span class="hljs-number">1.7937</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">51</span>,<span class="hljs-number">532</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">3.7921</span>, <span class="hljs-number">13.9223</span>, <span class="hljs-number">15.8855</span>],<br>        [ <span class="hljs-number">5.2695</span>, <span class="hljs-number">12.6750</span>, <span class="hljs-number">14.5414</span>],<br>        [<span class="hljs-number">25.4116</span>,  <span class="hljs-number">3.3705</span>,  <span class="hljs-number">4.2591</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-05-<span class="hljs-number">19</span> <span class="hljs-number">21</span>:<span class="hljs-number">29</span>:<span class="hljs-number">51</span>,<span class="hljs-number">533</span> - INFO: 混合类KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.7013</span>,  <span class="hljs-number">0.3880</span>,  <span class="hljs-number">0.4822</span>],<br>        [<span class="hljs-number">11.2793</span>,  <span class="hljs-number">7.1341</span>,  <span class="hljs-number">8.5624</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>BUAA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>施加约束尝试</title>
    <link href="/2024/08/15/BUAA/%E6%98%9F%E5%9E%8B%E7%BA%A6%E6%9D%9F/"/>
    <url>/2024/08/15/BUAA/%E6%98%9F%E5%9E%8B%E7%BA%A6%E6%9D%9F/</url>
    
    <content type="html"><![CDATA[<p>施加约束尝试</p><span id="more"></span><h3 id="只进行kl散度约束">只进行KL散度约束</h3><p>/mnt/chenlb/Six_Tumor_Classification/Exp39/results/model_6sigmas_32d_kl/checkpoint400.pth</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">312</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">313</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.39751553535461426</span><br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">313</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>])<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">313</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">336</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.6765</span>, <span class="hljs-number">2.5768</span>],<br>        [<span class="hljs-number">0.6859</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.6240</span>],<br>        [<span class="hljs-number">2.6426</span>, <span class="hljs-number">0.6314</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">337</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0371</span>, <span class="hljs-number">1.4147</span>],<br>        [<span class="hljs-number">0.0469</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">1.0820</span>],<br>        [<span class="hljs-number">1.7969</span>, <span class="hljs-number">1.0472</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">338</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0088</span>, <span class="hljs-number">0.5483</span>, <span class="hljs-number">2.3199</span>],<br>        [<span class="hljs-number">0.0978</span>, <span class="hljs-number">0.3596</span>, <span class="hljs-number">1.8697</span>],<br>        [<span class="hljs-number">2.1856</span>, <span class="hljs-number">0.4345</span>, <span class="hljs-number">0.0478</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">23</span>,<span class="hljs-number">338</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.5122</span>, <span class="hljs-number">0.3298</span>, <span class="hljs-number">0.4766</span>],<br>        [<span class="hljs-number">0.6539</span>, <span class="hljs-number">0.0586</span>, <span class="hljs-number">0.7601</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240609132921859.png"alt="image-20240609132921859" /><figcaption aria-hidden="true">image-20240609132921859</figcaption></figure><h3 id="三类kl散度-ce">三类KL散度 + CE</h3><p>/mnt/chenlb/Six_Tumor_Classification/Exp39/results/model_6sigmas_32d_kl/classification/checkpoint400.pth</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">805</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">806</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.4409937858581543</span><br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">806</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.4909</span>, <span class="hljs-number">0.1905</span>, <span class="hljs-number">0.5625</span>])<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">806</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">839</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0573</span>, <span class="hljs-number">0.2288</span>],<br>        [<span class="hljs-number">0.0574</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0572</span>],<br>        [<span class="hljs-number">0.2293</span>, <span class="hljs-number">0.0572</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">839</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0889</span>, <span class="hljs-number">0.3920</span>],<br>        [<span class="hljs-number">0.1060</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.1093</span>],<br>        [<span class="hljs-number">0.4369</span>, <span class="hljs-number">0.1016</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">840</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0071</span>, <span class="hljs-number">0.0727</span>, <span class="hljs-number">0.2525</span>],<br>        [<span class="hljs-number">0.0727</span>, <span class="hljs-number">0.0009</span>, <span class="hljs-number">0.0438</span>],<br>        [<span class="hljs-number">0.3466</span>, <span class="hljs-number">0.1222</span>, <span class="hljs-number">0.0129</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-08 <span class="hljs-number">16</span>:<span class="hljs-number">32</span>:09,<span class="hljs-number">841</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.1915</span>, <span class="hljs-number">0.1301</span>, <span class="hljs-number">0.2074</span>],<br>        [<span class="hljs-number">0.2081</span>, <span class="hljs-number">0.1290</span>, <span class="hljs-number">0.1645</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">570</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">571</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.44720497727394104</span><br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">573</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.5091</span>, <span class="hljs-number">0.2381</span>, <span class="hljs-number">0.5312</span>])<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">573</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">627</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0684</span>, <span class="hljs-number">0.2801</span>],<br>        [<span class="hljs-number">0.0685</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0717</span>],<br>        [<span class="hljs-number">0.2808</span>, <span class="hljs-number">0.0718</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">629</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0573</span>, <span class="hljs-number">0.3616</span>],<br>        [<span class="hljs-number">0.0610</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.1255</span>],<br>        [<span class="hljs-number">0.3421</span>, <span class="hljs-number">0.1118</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">630</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0013</span>, <span class="hljs-number">0.0687</span>, <span class="hljs-number">0.2794</span>],<br>        [<span class="hljs-number">0.0567</span>, <span class="hljs-number">0.0006</span>, <span class="hljs-number">0.0851</span>],<br>        [<span class="hljs-number">0.3238</span>, <span class="hljs-number">0.0962</span>, <span class="hljs-number">0.0053</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">11</span>:<span class="hljs-number">25</span>:<span class="hljs-number">47</span>,<span class="hljs-number">631</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.2408</span>, <span class="hljs-number">0.1336</span>, <span class="hljs-number">0.1353</span>],<br>        [<span class="hljs-number">0.2514</span>, <span class="hljs-number">0.1310</span>, <span class="hljs-number">0.1496</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240609132745960.png"alt="image-20240609132745960" /><figcaption aria-hidden="true">image-20240609132745960</figcaption></figure><h3 id="三类kl散度-ce-增大真实1类和先验0类间距">三类KL散度+ CE +增大真实1类和先验0类间距</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(means[<span class="hljs-number">0</span>])):  <span class="hljs-comment"># feature 的每个 维度 相互独立, 单独考虑</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]:<br>            post = Normal(means[i][d], <span class="hljs-built_in">vars</span>[i][d].sqrt())<br>            prior = Normal(joint_mus[i][d], joint_sigmas[i][i][d].sqrt())<br>            kl_loss += kl_divergence(post, prior).mean()<br><br>        post = Normal(means[<span class="hljs-number">1</span>][d], <span class="hljs-built_in">vars</span>[<span class="hljs-number">1</span>][d].sqrt())<br>        prior_1 = Normal(joint_mus[<span class="hljs-number">0</span>][d], joint_sigmas[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][d].sqrt())<br><br>        dis_kl_loss += kl_divergence(post, prior_1).mean()<br><br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        traceback.print_exc()<br>        <span class="hljs-keyword">continue</span><br><br>loss = kl_loss + ce_loss - <span class="hljs-number">0.5</span> * dis_kl_loss<br></code></pre></td></tr></table></figure><h4 id="权重0.2">权重0.2</h4><p>/mnt/chenlb/Six_Tumor_Classification/Exp39/results/model_6sigmas_32d_kl/classification_01diskl_2/checkpoin183.pth</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">17</span>:<span class="hljs-number">31</span>:01,<span class="hljs-number">128</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">17</span>:<span class="hljs-number">31</span>:01,<span class="hljs-number">129</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.5341615080833435</span><br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">17</span>:<span class="hljs-number">31</span>:01,<span class="hljs-number">129</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.3455</span>, <span class="hljs-number">0.5476</span>, <span class="hljs-number">0.6875</span>])<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">17</span>:<span class="hljs-number">31</span>:01,<span class="hljs-number">129</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">17</span>:<span class="hljs-number">31</span>:01,<span class="hljs-number">152</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.2108</span>, <span class="hljs-number">0.7366</span>],<br>        [<span class="hljs-number">0.2117</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.1598</span>],<br>        [<span class="hljs-number">0.7418</span>, <span class="hljs-number">0.1603</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">17</span>:<span class="hljs-number">31</span>:01,<span class="hljs-number">153</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0878</span>, <span class="hljs-number">0.6756</span>],<br>        [<span class="hljs-number">0.0967</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.2683</span>],<br>        [<span class="hljs-number">0.6796</span>, <span class="hljs-number">0.2449</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">17</span>:<span class="hljs-number">31</span>:01,<span class="hljs-number">154</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">7.7185e-04</span>, <span class="hljs-number">1.8891e-01</span>, <span class="hljs-number">6.9507e-01</span>],<br>        [<span class="hljs-number">1.1202e-01</span>, <span class="hljs-number">1.8688e-02</span>, <span class="hljs-number">2.8104e-01</span>],<br>        [<span class="hljs-number">7.1863e-01</span>, <span class="hljs-number">1.4969e-01</span>, <span class="hljs-number">2.7231e-04</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">17</span>:<span class="hljs-number">31</span>:01,<span class="hljs-number">154</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.3142</span>, <span class="hljs-number">0.1463</span>, <span class="hljs-number">0.2278</span>],<br>        [<span class="hljs-number">0.3376</span>, <span class="hljs-number">0.1006</span>, <span class="hljs-number">0.2383</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240610173230713.png"alt="image-20240610173230713" /><figcaption aria-hidden="true">image-20240610173230713</figcaption></figure><h4 id="权重0.5">权重0.5</h4><p>/mnt/chenlb/Six_Tumor_Classification/Exp39/results/model_6sigmas_32d_kl/classification_01diskl_5/checkpoint400.pth</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">19</span>:<span class="hljs-number">49</span>:<span class="hljs-number">52</span>,<span class="hljs-number">290</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">19</span>:<span class="hljs-number">49</span>:<span class="hljs-number">52</span>,<span class="hljs-number">290</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.6211180090904236</span><br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">19</span>:<span class="hljs-number">49</span>:<span class="hljs-number">52</span>,<span class="hljs-number">291</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.4545</span>, <span class="hljs-number">0.5238</span>, <span class="hljs-number">0.8281</span>])<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">19</span>:<span class="hljs-number">49</span>:<span class="hljs-number">52</span>,<span class="hljs-number">291</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">19</span>:<span class="hljs-number">49</span>:<span class="hljs-number">52</span>,<span class="hljs-number">316</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">4.1097</span>,  <span class="hljs-number">9.0029</span>],<br>        [ <span class="hljs-number">4.4968</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.9845</span>],<br>        [<span class="hljs-number">10.0369</span>,  <span class="hljs-number">1.0032</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">19</span>:<span class="hljs-number">49</span>:<span class="hljs-number">52</span>,<span class="hljs-number">317</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0330</span>, <span class="hljs-number">1.7439</span>],<br>        [<span class="hljs-number">0.0398</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">1.3367</span>],<br>        [<span class="hljs-number">1.6713</span>, <span class="hljs-number">1.0427</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">19</span>:<span class="hljs-number">49</span>:<span class="hljs-number">52</span>,<span class="hljs-number">317</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">1.6412</span>,  <span class="hljs-number">1.0889</span>,  <span class="hljs-number">3.8568</span>],<br>        [ <span class="hljs-number">2.5201</span>,  <span class="hljs-number">0.8460</span>,  <span class="hljs-number">3.1134</span>],<br>        [<span class="hljs-number">10.6156</span>,  <span class="hljs-number">1.3110</span>,  <span class="hljs-number">0.2044</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">19</span>:<span class="hljs-number">49</span>:<span class="hljs-number">52</span>,<span class="hljs-number">318</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.4841</span>, <span class="hljs-number">0.3221</span>, <span class="hljs-number">0.5575</span>],<br>        [<span class="hljs-number">4.6231</span>, <span class="hljs-number">0.0067</span>, <span class="hljs-number">0.9402</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240610195112516.png"alt="image-20240610195112516" /><figcaption aria-hidden="true">image-20240610195112516</figcaption></figure><h4 id="权重1">权重1</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">21</span>:<span class="hljs-number">25</span>:<span class="hljs-number">14</span>,<span class="hljs-number">258</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">21</span>:<span class="hljs-number">25</span>:<span class="hljs-number">14</span>,<span class="hljs-number">258</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.39751553535461426</span><br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">21</span>:<span class="hljs-number">25</span>:<span class="hljs-number">14</span>,<span class="hljs-number">259</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>])<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">21</span>:<span class="hljs-number">25</span>:<span class="hljs-number">14</span>,<span class="hljs-number">259</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">21</span>:<span class="hljs-number">25</span>:<span class="hljs-number">14</span>,<span class="hljs-number">282</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">11.5998</span>,  <span class="hljs-number">18.8348</span>],<br>        [ <span class="hljs-number">95.0915</span>,   <span class="hljs-number">0.0000</span>,   <span class="hljs-number">1.0552</span>],<br>        [<span class="hljs-number">129.1133</span>,   <span class="hljs-number">1.0766</span>,   <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">21</span>:<span class="hljs-number">25</span>:<span class="hljs-number">14</span>,<span class="hljs-number">283</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0141</span>, <span class="hljs-number">0.3145</span>],<br>        [<span class="hljs-number">0.0146</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.2790</span>],<br>        [<span class="hljs-number">0.5257</span>, <span class="hljs-number">0.4567</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">21</span>:<span class="hljs-number">25</span>:<span class="hljs-number">14</span>,<span class="hljs-number">283</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">83.2660</span>,   <span class="hljs-number">0.4627</span>,   <span class="hljs-number">2.3652</span>],<br>        [ <span class="hljs-number">88.1238</span>,   <span class="hljs-number">0.3325</span>,   <span class="hljs-number">2.1358</span>],<br>        [<span class="hljs-number">112.8541</span>,   <span class="hljs-number">0.8359</span>,   <span class="hljs-number">0.8887</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">10</span> <span class="hljs-number">21</span>:<span class="hljs-number">25</span>:<span class="hljs-number">14</span>,<span class="hljs-number">284</span> - INFO: 混合类KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.1608</span>,  <span class="hljs-number">0.1230</span>,  <span class="hljs-number">0.2144</span>],<br>        [<span class="hljs-number">97.0583</span>,  <span class="hljs-number">0.1063</span>,  <span class="hljs-number">1.0538</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240610214341398.png"alt="image-20240610214341398" /><figcaption aria-hidden="true">image-20240610214341398</figcaption></figure><h3 id="两类kl-ce-增大真实1类和先验0类间距">两类KL + CE +增大真实1类和先验0类间距</h3><p>/mnt/chenlb/Six_Tumor_Classification/Exp39/results/model_6sigmas_32d_kl/classification_02kl_01diskl_5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">22</span>:02:<span class="hljs-number">39</span>,<span class="hljs-number">370</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">22</span>:02:<span class="hljs-number">39</span>,<span class="hljs-number">370</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.5962733030319214</span><br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">22</span>:02:<span class="hljs-number">39</span>,<span class="hljs-number">371</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.4182</span>, <span class="hljs-number">0.5714</span>, <span class="hljs-number">0.7656</span>])<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">22</span>:02:<span class="hljs-number">39</span>,<span class="hljs-number">371</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">22</span>:02:<span class="hljs-number">39</span>,<span class="hljs-number">394</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">3.4526</span>, <span class="hljs-number">12.0742</span>],<br>        [ <span class="hljs-number">3.7470</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">2.8456</span>],<br>        [<span class="hljs-number">13.8254</span>,  <span class="hljs-number">3.0301</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">22</span>:02:<span class="hljs-number">39</span>,<span class="hljs-number">395</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0370</span>, <span class="hljs-number">1.5749</span>],<br>        [<span class="hljs-number">0.0438</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">1.1610</span>],<br>        [<span class="hljs-number">1.7534</span>, <span class="hljs-number">1.0764</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">22</span>:02:<span class="hljs-number">39</span>,<span class="hljs-number">395</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">2.1924</span>,  <span class="hljs-number">0.9950</span>,  <span class="hljs-number">5.8012</span>],<br>        [ <span class="hljs-number">3.4535</span>,  <span class="hljs-number">0.9094</span>,  <span class="hljs-number">4.6139</span>],<br>        [<span class="hljs-number">14.7126</span>,  <span class="hljs-number">3.7520</span>,  <span class="hljs-number">0.5985</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-09 <span class="hljs-number">22</span>:02:<span class="hljs-number">39</span>,<span class="hljs-number">396</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.4521</span>, <span class="hljs-number">0.2536</span>, <span class="hljs-number">0.4894</span>],<br>        [<span class="hljs-number">6.1939</span>, <span class="hljs-number">0.4612</span>, <span class="hljs-number">1.5527</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240609220524845.png"alt="image-20240609220524845" /><figcaption aria-hidden="true">image-20240609220524845</figcaption></figure><h3 id="三类别kl散度-ce-增大01真实类间距">三类别KL散度 + CE +增大01真实类间距</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(means[<span class="hljs-number">0</span>])):  <span class="hljs-comment"># feature 的每个 维度 相互独立, 单独考虑</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]:<br>            post = Normal(means[i][d], <span class="hljs-built_in">vars</span>[i][d].sqrt())<br>            prior = Normal(joint_mus[i][d], joint_sigmas[i][i][d].sqrt())<br>            kl_loss += kl_divergence(post, prior).mean()<br><br>        post_0 = Normal(means[<span class="hljs-number">0</span>][d], <span class="hljs-built_in">vars</span>[<span class="hljs-number">0</span>][d].sqrt())<br>        post_1 = Normal(means[<span class="hljs-number">1</span>][d], <span class="hljs-built_in">vars</span>[<span class="hljs-number">1</span>][d].sqrt())<br><br>        dis_kl_loss += kl_divergence(post_0, post_1).mean()<br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        traceback.print_exc()<br>        <span class="hljs-keyword">continue</span><br><br>loss = kl_loss + ce_loss - <span class="hljs-number">0.5</span> * dis_kl_loss<br></code></pre></td></tr></table></figure><h4 id="权重0.5-1">权重0.5</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-06-<span class="hljs-number">12</span> <span class="hljs-number">14</span>:<span class="hljs-number">46</span>:<span class="hljs-number">56</span>,067 - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">12</span> <span class="hljs-number">14</span>:<span class="hljs-number">46</span>:<span class="hljs-number">56</span>,067 - INFO: 验证集总体精度为: <span class="hljs-number">0.5155279636383057</span><br><span class="hljs-number">2024</span>-06-<span class="hljs-number">12</span> <span class="hljs-number">14</span>:<span class="hljs-number">46</span>:<span class="hljs-number">56</span>,068 - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.4727</span>, <span class="hljs-number">0.3333</span>, <span class="hljs-number">0.6719</span>])<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">12</span> <span class="hljs-number">14</span>:<span class="hljs-number">46</span>:<span class="hljs-number">56</span>,068 - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">12</span> <span class="hljs-number">14</span>:<span class="hljs-number">46</span>:<span class="hljs-number">56</span>,091 - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.2749</span>, <span class="hljs-number">1.1189</span>],<br>        [<span class="hljs-number">0.2763</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.2862</span>],<br>        [<span class="hljs-number">1.1309</span>, <span class="hljs-number">0.2877</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">12</span> <span class="hljs-number">14</span>:<span class="hljs-number">46</span>:<span class="hljs-number">56</span>,092 - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0312</span>, <span class="hljs-number">1.2221</span>],<br>        [<span class="hljs-number">0.0290</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.8247</span>],<br>        [<span class="hljs-number">0.8872</span>, <span class="hljs-number">0.6477</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">12</span> <span class="hljs-number">14</span>:<span class="hljs-number">46</span>:<span class="hljs-number">56</span>,092 - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0103</span>, <span class="hljs-number">0.2286</span>, <span class="hljs-number">1.0154</span>],<br>        [<span class="hljs-number">0.0561</span>, <span class="hljs-number">0.0879</span>, <span class="hljs-number">0.6858</span>],<br>        [<span class="hljs-number">1.1353</span>, <span class="hljs-number">0.2935</span>, <span class="hljs-number">0.0073</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">12</span> <span class="hljs-number">14</span>:<span class="hljs-number">46</span>:<span class="hljs-number">56</span>,093 - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.4501</span>, <span class="hljs-number">0.2948</span>, <span class="hljs-number">0.3355</span>],<br>        [<span class="hljs-number">0.5099</span>, <span class="hljs-number">0.1465</span>, <span class="hljs-number">0.3445</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240612144820285.png"alt="image-20240612144820285" /><figcaption aria-hidden="true">image-20240612144820285</figcaption></figure><h3 id="三类别kl散度-ce-增大01真实类间距和先验类间距">三类别KL散度 + CE+ 增大01真实类间距和先验类间距</h3><h4 id="权重0.2-1">权重0.2</h4><p>/mnt/chenlb/Six_Tumor_Classification/Exp39/results/model_6sigmas_32d_kl/classification_01diskl_2_r1r0_p1p0</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">13</span>:<span class="hljs-number">47</span>:<span class="hljs-number">47</span>,<span class="hljs-number">783</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">13</span>:<span class="hljs-number">47</span>:<span class="hljs-number">47</span>,<span class="hljs-number">783</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.5714285969734192</span><br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">13</span>:<span class="hljs-number">47</span>:<span class="hljs-number">47</span>,<span class="hljs-number">784</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.5091</span>, <span class="hljs-number">0.3333</span>, <span class="hljs-number">0.7812</span>])<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">13</span>:<span class="hljs-number">47</span>:<span class="hljs-number">47</span>,<span class="hljs-number">784</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">13</span>:<span class="hljs-number">47</span>:<span class="hljs-number">47</span>,<span class="hljs-number">813</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.7302</span>, <span class="hljs-number">1.5397</span>],<br>        [<span class="hljs-number">0.7407</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.1502</span>],<br>        [<span class="hljs-number">1.5663</span>, <span class="hljs-number">0.1506</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">13</span>:<span class="hljs-number">47</span>:<span class="hljs-number">47</span>,<span class="hljs-number">814</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0545</span>, <span class="hljs-number">0.9583</span>],<br>        [<span class="hljs-number">0.0659</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.5898</span>],<br>        [<span class="hljs-number">1.2887</span>, <span class="hljs-number">0.6496</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">13</span>:<span class="hljs-number">47</span>:<span class="hljs-number">47</span>,<span class="hljs-number">814</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.1068</span>, <span class="hljs-number">0.2888</span>, <span class="hljs-number">0.8522</span>],<br>        [<span class="hljs-number">0.3317</span>, <span class="hljs-number">0.1044</span>, <span class="hljs-number">0.4847</span>],<br>        [<span class="hljs-number">2.1803</span>, <span class="hljs-number">0.3905</span>, <span class="hljs-number">0.0745</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">13</span>:<span class="hljs-number">47</span>:<span class="hljs-number">47</span>,<span class="hljs-number">815</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.4439</span>, <span class="hljs-number">0.2249</span>, <span class="hljs-number">0.3131</span>],<br>        [<span class="hljs-number">0.9647</span>, <span class="hljs-number">0.0623</span>, <span class="hljs-number">0.1398</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="三类别kl散度-ce-增大0112真实类间距和先验类间距">三类别KL散度 +CE + 增大01、12真实类间距和先验类间距</h3><h4 id="section">0.2</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">15</span>,<span class="hljs-number">900</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">15</span>,<span class="hljs-number">900</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.5962733030319214</span><br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">15</span>,<span class="hljs-number">901</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.4545</span>, <span class="hljs-number">0.3571</span>, <span class="hljs-number">0.8750</span>])<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">15</span>,<span class="hljs-number">901</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">15</span>,<span class="hljs-number">924</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.7782</span>, <span class="hljs-number">3.1854</span>],<br>        [<span class="hljs-number">0.7903</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.8271</span>],<br>        [<span class="hljs-number">3.2850</span>, <span class="hljs-number">0.8401</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">15</span>,<span class="hljs-number">925</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0411</span>, <span class="hljs-number">1.1380</span>],<br>        [<span class="hljs-number">0.0496</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.7831</span>],<br>        [<span class="hljs-number">1.3969</span>, <span class="hljs-number">0.7853</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">15</span>,<span class="hljs-number">925</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.4367</span>, <span class="hljs-number">0.1046</span>, <span class="hljs-number">1.3930</span>],<br>        [<span class="hljs-number">0.8545</span>, <span class="hljs-number">0.0987</span>, <span class="hljs-number">0.9605</span>],<br>        [<span class="hljs-number">4.3155</span>, <span class="hljs-number">1.4314</span>, <span class="hljs-number">0.1492</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">15</span>,<span class="hljs-number">926</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.4973</span>, <span class="hljs-number">0.2962</span>, <span class="hljs-number">0.3595</span>],<br>        [<span class="hljs-number">2.0052</span>, <span class="hljs-number">0.2838</span>, <span class="hljs-number">0.1727</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="section-1">0.5</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">18</span>:<span class="hljs-number">28</span>:<span class="hljs-number">59</span>,<span class="hljs-number">730</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">18</span>:<span class="hljs-number">28</span>:<span class="hljs-number">59</span>,<span class="hljs-number">730</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.5403726696968079</span><br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">18</span>:<span class="hljs-number">28</span>:<span class="hljs-number">59</span>,<span class="hljs-number">731</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.6000</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.8438</span>])<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">18</span>:<span class="hljs-number">28</span>:<span class="hljs-number">59</span>,<span class="hljs-number">731</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">18</span>:<span class="hljs-number">28</span>:<span class="hljs-number">59</span>,<span class="hljs-number">755</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">1.4723</span>, <span class="hljs-number">4.9730</span>],<br>        [<span class="hljs-number">1.5230</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">1.1014</span>],<br>        [<span class="hljs-number">5.2363</span>, <span class="hljs-number">1.1269</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">18</span>:<span class="hljs-number">28</span>:<span class="hljs-number">59</span>,<span class="hljs-number">755</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0765</span>, <span class="hljs-number">0.7536</span>],<br>        [<span class="hljs-number">0.1049</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.4174</span>],<br>        [<span class="hljs-number">1.4913</span>, <span class="hljs-number">0.5908</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">18</span>:<span class="hljs-number">28</span>:<span class="hljs-number">59</span>,<span class="hljs-number">756</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">1.6129</span>, <span class="hljs-number">0.0245</span>, <span class="hljs-number">1.0270</span>],<br>        [<span class="hljs-number">2.5152</span>, <span class="hljs-number">0.2055</span>, <span class="hljs-number">0.6113</span>],<br>        [<span class="hljs-number">6.7383</span>, <span class="hljs-number">1.9611</span>, <span class="hljs-number">0.3255</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-06-<span class="hljs-number">13</span> <span class="hljs-number">18</span>:<span class="hljs-number">28</span>:<span class="hljs-number">59</span>,<span class="hljs-number">757</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">0.4581</span>, <span class="hljs-number">0.1830</span>, <span class="hljs-number">0.2739</span>],<br>        [<span class="hljs-number">4.0142</span>, <span class="hljs-number">0.6020</span>, <span class="hljs-number">0.0912</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>BUAA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SoccerNet问题列表</title>
    <link href="/2024/08/11/KNQ/SoccerNet%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8/"/>
    <url>/2024/08/11/KNQ/SoccerNet%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>SoccerNet问题列表 <span id="more"></span></p><ol type="1"><li><p>调试时下面这行代码卡住，无法继续进行</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tracking_dataset = instantiate(cfg.dataset)<br></code></pre></td></tr></table></figure></p><p>猜测是多线程问题，通过修改以下代码解决（设置线程数为1）：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">pool = Pool(processes=<span class="hljs-number">1</span>)<br>args = [&#123;<span class="hljs-string">&quot;dataset_path&quot;</span>: dataset_path, <span class="hljs-string">&quot;video_folder&quot;</span>: video_folder, <span class="hljs-string">&quot;split&quot;</span>: split&#125; <span class="hljs-keyword">for</span> video_folder <span class="hljs-keyword">in</span> video_list]<br><span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> progress(pool.imap_unordered(video_dir_to_dfs, args, chunksize=<span class="hljs-number">1</span>), total=<span class="hljs-built_in">len</span>(args), desc=<span class="hljs-string">f&quot;Loading SoccerNetGS &#x27;<span class="hljs-subst">&#123;split&#125;</span>&#x27; set videos&quot;</span>):<br>    <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        video_metadatas_list.append(result[<span class="hljs-string">&quot;video_metadata&quot;</span>])<br>        image_metadata_list.append(result[<span class="hljs-string">&quot;image_metadata&quot;</span>])<br>        detections_list.append(result[<span class="hljs-string">&quot;detections&quot;</span>])<br>        annotations_pitch_camera_list.append(result[<span class="hljs-string">&quot;annotations_pitch_camera&quot;</span>])<br>        categories_list += result[<span class="hljs-string">&quot;video_level_categories&quot;</span>]<br></code></pre></td></tr></table></figure></p></li><li><p>存在权重文件但是仍需要下载</p><figure><imgsrc="C:\Users\chenl\AppData\Roaming\Typora\typora-user-images\image-20240715185625920.png"alt="image-20240715185625920" /><figcaption aria-hidden="true">image-20240715185625920</figcaption></figure></li></ol><p>​注意看到，文件应该是存在于soccernet2/narrator-pipeline/pretrained_models下，少了一级！！</p><p>​原因是vscode运行时默认运行根目录是当前打开的目录而不是运行程序所在目录，在/home/zyli/soccernet2/narrator-pipeline/sn_gamestate/configs/soccernet.yaml中更改如下即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">project_dir:</span> <span class="hljs-string">&quot;/home/zyli/soccernet2/narrator-pipeline&quot;</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><p>运行流程？</p><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240716140215991.png"alt="image-20240716140215991" /><figcaption aria-hidden="true">image-20240716140215991</figcaption></figure><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240716135214898.png"alt="image-20240716135214898" /><figcaption aria-hidden="true">image-20240716135214898</figcaption></figure><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240716151348554.png"alt="image-20240716151348554" /><figcaption aria-hidden="true">image-20240716151348554</figcaption></figure><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240716151501684.png"alt="image-20240716151501684" /><figcaption aria-hidden="true">image-20240716151501684</figcaption></figure></li></ol><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240716141939160.png"alt="image-20240716141939160" /><figcaption aria-hidden="true">image-20240716141939160</figcaption></figure><ol start="4" type="1"><li>如何增加模块？<ul><li>定义一个类，继承<code>DetectionLevelModuel</code>,<code>ImageLevelModule</code>或者<code>VideoLevelModule</code>(<ahref="https://trackinglaboratory.github.io/tracklab/tutorials/Yolov8_pose_estimation.html">Integratinga new module — TrackLab documentation(trackinglaboratory.github.io)</a>)，重写<code>process</code>方法，在类的属性中指定<code>input_columns</code>和<code>output_columns</code></li><li>定义模块的config文件，指明<code>__target__</code>为上面对应的类</li><li>在总的soccernet.yaml配置文件中<code>default</code>处添加模块config文件所在位置并在<code>pipline</code>处添加模块名</li></ul></li><li>如何删除模块？<ul><li>在总的soccernet.yaml配置文件中<code>pipline</code>处删除模块名</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ADNI处理细节</title>
    <link href="/2024/08/11/BUAA/ADNI%E5%AE%9E%E9%AA%8C%E7%BB%86%E8%8A%82/"/>
    <url>/2024/08/11/BUAA/ADNI%E5%AE%9E%E9%AA%8C%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<p>ADNI处理细节</p><span id="more"></span><h3 id="生成训练数据">生成训练数据</h3><p>我把从dcm转nii文件的功能以及reshape到指定大小的功能封装了一下放到了<ahref="https://github.com/GreaterChen/dcm2niiTools">GreaterChen/dcm2niiTools(github.com)</a>。以后可以直接复用我的代码做。</p><h4 id="dcm转nii">DCM转NII</h4><p>dcm转nii是使用dcm2niix库做的，这个过程首先将dcm文件转化为两个nii文件：imaginary.nii和real.nii，然后通过取模的方式得到magnitude.nii，这就是最终的nii文件。</p><h4 id="统一nii文件大小">统一NII文件大小</h4><p>我收集的ADNI数据的原始大小分布如下</p><table><thead><tr class="header"><th style="text-align: center;">原始大小</th><th style="text-align: center;">出现频次</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">（256，256，52）</td><td style="text-align: center;">535</td></tr><tr class="even"><td style="text-align: center;">（192，192，52）</td><td style="text-align: center;">113</td></tr><tr class="odd"><td style="text-align: center;">（288，288，52）</td><td style="text-align: center;">4</td></tr></tbody></table><p>可以发现大多数的数据都是（256，256，52）的，因此这里考虑将数据统一为（128，128，26）。这样大部分数据都能够保证立体信息不被破坏，当然也会有部分数据的立体信息改变。</p><p>具体在实现来说，首先可以使用平均池化做降采样，但是这只适用于（256，256，52）到（128，128，26），当遇到（192，192，52）时会因为无法整除而无法正确的降采样到（128，128，26）</p><p>因此我使用的是三线性插值（trilinearinterpolation）。三线性插值（TrilinearInterpolation）是一种扩展的一维线性插值方法，用于在三维空间中对数据进行插值。它基于<strong>八个相邻点</strong>的加权平均值，能够在三维空间中平滑地缩放图像或体数据。具体的（192，192，52）转（128，128，26）实现方式如下</p><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240724120133064.png"alt="image-20240724120133064" /><figcaption aria-hidden="true">image-20240724120133064</figcaption></figure><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240724120153145.png"alt="image-20240724120153145" /><figcaption aria-hidden="true">image-20240724120153145</figcaption></figure><p>转化的效果如下图所示</p><ol type="1"><li><p>原始（256，256，52）图像</p><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240724120319744.png"alt="image-20240724120319744" /><figcaption aria-hidden="true">image-20240724120319744</figcaption></figure></li><li><p>采用平均池化转化的（128，128，26）图像</p><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240724120357343.png"alt="image-20240724120357343" /><figcaption aria-hidden="true">image-20240724120357343</figcaption></figure></li><li><p>采用三线性插值转化的（128，128，26）图像</p><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240724120430304.png"alt="image-20240724120430304" /><figcaption aria-hidden="true">image-20240724120430304</figcaption></figure></li></ol><p>可以看到三线性插值和平均池化效果基本相同，由于三线性插值具有从任意shape转到目标shape的功能，因此最终选择三线性插值的方式进行reshape</p><h3 id="特征提取">特征提取</h3><h4 id="输入数据">输入数据</h4><ul><li>输入数据的形状是<code>(32, 1, 128, 128, 26)</code>，表示有32个样本，每个样本是1个通道的3D图像，尺寸为<code>(128, 128, 26)</code>。</li></ul><h4 id="编码器层">编码器层</h4><ul><li>第一层：<ul><li><code>ConvBlock(1, 16)</code>：将输入的通道数从1变为16。</li><li><code>nn.MaxPool3d(2, 2)</code>：对每个维度进行2倍的下采样。</li><li>输出形状为 <code>(32, 16, 64, 64, 13)</code>。</li></ul></li><li>第二层：<ul><li><code>ConvBlock(16, 32)</code>：将输入的通道数从16变为32。</li><li><code>nn.MaxPool3d(2, 2)</code>：对每个维度再次进行2倍的下采样。</li><li>输出形状为 <code>(32, 32, 32, 32, 6)</code>。</li></ul></li><li>第三层：<ul><li><code>ConvBlock(32, 32)</code>：通道数保持不变，仍为32。</li><li><code>nn.AdaptiveAvgPool3d(1)</code>：将所有维度池化为1，输出形状为<code>(32, 32, 1, 1, 1)</code>。</li></ul></li></ul><h3 id="结果">结果</h3><h4 id="train_features">train_features</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-07-<span class="hljs-number">24</span> <span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">41</span>,<span class="hljs-number">637</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">24</span> <span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">41</span>,<span class="hljs-number">638</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.7597402334213257</span><br><span class="hljs-number">2024</span>-07-<span class="hljs-number">24</span> <span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">41</span>,<span class="hljs-number">639</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.9079</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.9600</span>])<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">24</span> <span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">41</span>,<span class="hljs-number">639</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">24</span> <span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">41</span>,<span class="hljs-number">970</span> - INFO: 先验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">1.3936</span>, <span class="hljs-number">5.0489</span>],<br>        [<span class="hljs-number">1.5568</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">1.2711</span>],<br>        [<span class="hljs-number">6.2048</span>, <span class="hljs-number">1.4063</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">24</span> <span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">41</span>,<span class="hljs-number">971</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.1733</span>, <span class="hljs-number">2.5138</span>],<br>        [<span class="hljs-number">0.2044</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">1.4667</span>],<br>        [<span class="hljs-number">3.6257</span>, <span class="hljs-number">1.7814</span>, <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">24</span> <span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">41</span>,<span class="hljs-number">972</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[<span class="hljs-number">0.1105</span>, <span class="hljs-number">0.7867</span>, <span class="hljs-number">3.8495</span>],<br>        [<span class="hljs-number">0.6768</span>, <span class="hljs-number">0.2145</span>, <span class="hljs-number">2.3405</span>],<br>        [<span class="hljs-number">5.7369</span>, <span class="hljs-number">1.2173</span>, <span class="hljs-number">0.0410</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">24</span> <span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">41</span>,<span class="hljs-number">973</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">1.0907</span>, <span class="hljs-number">0.3963</span>, <span class="hljs-number">0.7351</span>],<br>        [<span class="hljs-number">2.0257</span>, <span class="hljs-number">0.1038</span>, <span class="hljs-number">1.0466</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="train_classification">train_classification</h4><ol type="1"><li>no_diskl</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>BUAA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GZSL实验复现</title>
    <link href="/2024/08/11/BUAA/%E5%A4%8D%E7%8E%B0/"/>
    <url>/2024/08/11/BUAA/%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>GZSL实验复现记录</p><span id="more"></span><h2 id="tumor">Tumor</h2><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">seen_acc</th><th style="text-align: center;">unseen_acc</th><th style="text-align: center;">h</th><th>path</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">ICFA</td><td style="text-align: center;">0.7725</td><td style="text-align: center;">0.6667</td><td style="text-align: center;">0.7157</td><td>/home/LAB/chenlb24/ours/results/model_best_checkpoint372.pth</td></tr><tr class="even"><td style="text-align: center;">CE_GZSL</td><td style="text-align: center;">0.7553</td><td style="text-align: center;">0.5556</td><td style="text-align: center;">0.6402</td><td>/home/LAB/chenlb24/compare_model/CE-GZSL/models/testZDFY/results_acc_0.7553_unseen_acc_0.5556_h_0.6402_epoch_202.csv</td></tr><tr class="odd"><td style="text-align: center;">FREE</td><td style="text-align: center;">0.7341</td><td style="text-align: center;">0.6111</td><td style="text-align: center;">0.6670</td><td>/home/LAB/chenlb24/compare_model/FREE/zero-shot-images/result/ZDFY/results_h_0.6670_acc_0.7341_unseen_acc_0.6111_epoch_6.csv</td></tr><tr class="even"><td style="text-align: center;">HSVA</td><td style="text-align: center;">0.6296</td><td style="text-align: center;">0.6111</td><td style="text-align: center;">0.6202</td><td>/home/LAB/chenlb24/compare_model/CE-GZSL/models/testZDFY/results_acc_0.6296_unseen_acc_0.6111_h_0.6202_epoch_258.csv/home/LAB/chenlb24/compare_model/HSVA/model/result/ZDFY/results_h_0.5776_acc_0.5476_unseen_acc_0.6111_epoch_148.csv</td></tr><tr class="odd"><td style="text-align: center;">SDGZSL</td><td style="text-align: center;">0.6217</td><td style="text-align: center;">0.7222</td><td style="text-align: center;">0.6682</td><td>/home/LAB/chenlb24/compare_model/CE-GZSL/models/testZDFY/results_acc_0.6217_unseen_acc_0.7222_h_0.6682_epoch_221.csv</td></tr><tr class="even"><td style="text-align: center;">DFZSL</td><td style="text-align: center;">0.6997</td><td style="text-align: center;">0.5556</td><td style="text-align: center;">0.6194</td><td></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-07-<span class="hljs-number">30</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">28</span>,<span class="hljs-number">187</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">30</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">28</span>,<span class="hljs-number">250</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.8011695742607117</span><br><span class="hljs-number">2024</span>-07-<span class="hljs-number">30</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">28</span>,<span class="hljs-number">381</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.6667</span>, <span class="hljs-number">0.7037</span>, <span class="hljs-number">0.8413</span>])<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">30</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">28</span>,<span class="hljs-number">496</span> - INFO: seen acc: <span class="hljs-number">0.7724868059158325</span>, unseen acc: <span class="hljs-number">0.6666666865348816</span>, h: <span class="hljs-number">0.7156863003053983</span><br><span class="hljs-number">2024</span>-07-<span class="hljs-number">30</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">28</span>,<span class="hljs-number">580</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">30</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">29</span>,011 - INFO: 先验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">3.9912</span>, <span class="hljs-number">13.1403</span>],<br>        [ <span class="hljs-number">4.3708</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">2.8448</span>],<br>        [<span class="hljs-number">15.2764</span>,  <span class="hljs-number">3.0214</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">30</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">29</span>,<span class="hljs-number">110</span> - INFO: 后验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.6789</span>,  <span class="hljs-number">2.8117</span>],<br>        [ <span class="hljs-number">2.0191</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.9711</span>],<br>        [<span class="hljs-number">10.8209</span>,  <span class="hljs-number">1.1441</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">30</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">29</span>,<span class="hljs-number">244</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">1.0949</span>,  <span class="hljs-number">1.0090</span>,  <span class="hljs-number">7.0682</span>],<br>        [ <span class="hljs-number">5.1766</span>,  <span class="hljs-number">0.3825</span>,  <span class="hljs-number">2.9173</span>],<br>        [<span class="hljs-number">16.8698</span>,  <span class="hljs-number">3.9719</span>,  <span class="hljs-number">0.4876</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">30</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">29</span>,<span class="hljs-number">352</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">2.4393</span>, <span class="hljs-number">0.2318</span>, <span class="hljs-number">0.8897</span>],<br>        [<span class="hljs-number">6.3222</span>, <span class="hljs-number">0.1658</span>, <span class="hljs-number">1.6723</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="adni">ADNI</h2><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">seen_acc</th><th style="text-align: center;">unseen_acc</th><th style="text-align: center;">h</th><th>path</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">ICFA</td><td style="text-align: center;">0.6800</td><td style="text-align: center;">0.7632</td><td style="text-align: center;">0.7192</td><td>/home/LAB/chenlb24/ours/adni/results/model_3sigmas_32d_kl_ce_8_16_32/classification_1e-4_diskl1_extend/model_best_checkpoint157.pth</td></tr><tr class="even"><td style="text-align: center;">CE_GZSL</td><td style="text-align: center;">0.5826</td><td style="text-align: center;">0.5714</td><td style="text-align: center;">0.5770</td><td>/home/LAB/chenlb24/compare_model/CE-GZSL/models/testADNI/results_h_0.5770_acc_0.5826_unseen_acc_0.5714_epoch_1114.csv</td></tr><tr class="odd"><td style="text-align: center;">FREE</td><td style="text-align: center;">0.5700</td><td style="text-align: center;">0.7143</td><td style="text-align: center;">0.6340</td><td>/home/LAB/chenlb24/compare_model/FREE/zero-shot-images/result/ADNI/results_h_0.6340_acc_0.5700_unseen_acc_0.7143_epoch_392.csv</td></tr><tr class="even"><td style="text-align: center;">HSVA</td><td style="text-align: center;">0.4300</td><td style="text-align: center;">0.6786</td><td style="text-align: center;">0.5264</td><td>/home/LAB/chenlb24/compare_model/CE-GZSL/models/testADNI/results_h_0.5320_acc_0.4537_unseen_acc_0.6429_epoch_393.csv</td></tr><tr class="odd"><td style="text-align: center;">SDGZSL</td><td style="text-align: center;">0.6466</td><td style="text-align: center;">0.5714</td><td style="text-align: center;">0.6067</td><td>/home/LAB/chenlb24/compare_model/FREE/zero-shot-images/result/ADNI/results_h_0.6067_acc_0.6466_unseen_acc_0.5714_epoch_468.csv</td></tr><tr class="even"><td style="text-align: center;">DFZSL</td><td style="text-align: center;">0.4955</td><td style="text-align: center;">0.6429</td><td style="text-align: center;">0.5597</td><td></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2024</span>-07-<span class="hljs-number">29</span> <span class="hljs-number">16</span>:<span class="hljs-number">20</span>:<span class="hljs-number">10</span>,<span class="hljs-number">646</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">29</span> <span class="hljs-number">16</span>:<span class="hljs-number">20</span>:<span class="hljs-number">10</span>,<span class="hljs-number">728</span> - INFO: 验证集总体精度为: <span class="hljs-number">0.7467532753944397</span><br><span class="hljs-number">2024</span>-07-<span class="hljs-number">29</span> <span class="hljs-number">16</span>:<span class="hljs-number">20</span>:<span class="hljs-number">10</span>,<span class="hljs-number">799</span> - INFO: 验证集各类精度为: tensor([<span class="hljs-number">0.8158</span>, <span class="hljs-number">0.5714</span>, <span class="hljs-number">0.7400</span>])<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">29</span> <span class="hljs-number">16</span>:<span class="hljs-number">20</span>:<span class="hljs-number">10</span>,<span class="hljs-number">856</span> - INFO: seen acc: <span class="hljs-number">0.7778947353363037</span>, unseen acc: <span class="hljs-number">0.5714285969734192</span>, h: <span class="hljs-number">0.6588655017850094</span><br><span class="hljs-number">2024</span>-07-<span class="hljs-number">29</span> <span class="hljs-number">16</span>:<span class="hljs-number">20</span>:<span class="hljs-number">10</span>,<span class="hljs-number">906</span> - INFO: ---------------------<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">29</span> <span class="hljs-number">16</span>:<span class="hljs-number">20</span>:<span class="hljs-number">11</span>,013 - INFO: 先验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">2.7591</span>,  <span class="hljs-number">8.9183</span>],<br>        [ <span class="hljs-number">3.4176</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">2.1373</span>],<br>        [<span class="hljs-number">13.0911</span>,  <span class="hljs-number">2.5388</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">29</span> <span class="hljs-number">16</span>:<span class="hljs-number">20</span>:<span class="hljs-number">11</span>,058 - INFO: 后验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.6667</span>,  <span class="hljs-number">2.6020</span>],<br>        [ <span class="hljs-number">2.0729</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.9587</span>],<br>        [<span class="hljs-number">13.1127</span>,  <span class="hljs-number">1.4213</span>,  <span class="hljs-number">0.0000</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">29</span> <span class="hljs-number">16</span>:<span class="hljs-number">20</span>:<span class="hljs-number">11</span>,<span class="hljs-number">112</span> - INFO: 后验分布相对于先验验分布KL散度矩阵:<br>tensor([[ <span class="hljs-number">0.7162</span>,  <span class="hljs-number">0.9573</span>,  <span class="hljs-number">5.4615</span>],<br>        [ <span class="hljs-number">4.1934</span>,  <span class="hljs-number">0.3739</span>,  <span class="hljs-number">2.2190</span>],<br>        [<span class="hljs-number">16.8364</span>,  <span class="hljs-number">4.4306</span>,  <span class="hljs-number">0.6482</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span>)<br><span class="hljs-number">2024</span>-07-<span class="hljs-number">29</span> <span class="hljs-number">16</span>:<span class="hljs-number">20</span>:<span class="hljs-number">11</span>,<span class="hljs-number">170</span> - INFO: 混合类KL散度矩阵:<br>tensor([[<span class="hljs-number">2.8620</span>, <span class="hljs-number">0.2280</span>, <span class="hljs-number">0.8579</span>],<br>        [<span class="hljs-number">5.6166</span>, <span class="hljs-number">0.2773</span>, <span class="hljs-number">1.1317</span>]], device=<span class="hljs-string">&#x27;cuda:0&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="delong-test">delong test</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">Comparing ICFA_ADNI <span class="hljs-keyword">with</span> CE_GZSL_ADNI.csv<br>z score = <span class="hljs-number">4.45566</span>;<br>p value = <span class="hljs-number">0.00001</span>;<br>There <span class="hljs-keyword">is</span> a significant difference<br>Comparing ICFA_ZDFY <span class="hljs-keyword">with</span> CE_GZSL_ZDFY.csv<br>z score = <span class="hljs-number">3.20610</span>;<br>p value = <span class="hljs-number">0.00135</span>;<br>There <span class="hljs-keyword">is</span> a significant difference<br>Comparing ICFA_ADNI <span class="hljs-keyword">with</span> FREE_ADNI.csv<br>z score = <span class="hljs-number">4.45566</span>;<br>p value = <span class="hljs-number">0.00001</span>;<br>There <span class="hljs-keyword">is</span> a significant difference<br>Comparing ICFA_ZDFY <span class="hljs-keyword">with</span> FREE_ZDFY.csv<br>z score = <span class="hljs-number">3.20610</span>;<br>p value = <span class="hljs-number">0.00135</span>;<br>There <span class="hljs-keyword">is</span> a significant difference<br>Comparing ICFA_ADNI <span class="hljs-keyword">with</span> HSVA_ADNI.csv<br>z score = <span class="hljs-number">4.45566</span>;<br>p value = <span class="hljs-number">0.00001</span>;<br>There <span class="hljs-keyword">is</span> a significant difference<br>Comparing ICFA_ZDFY <span class="hljs-keyword">with</span> HSVA_ZDFY.csv<br>z score = <span class="hljs-number">3.20610</span>;<br>p value = <span class="hljs-number">0.00135</span>;<br>There <span class="hljs-keyword">is</span> a significant difference<br>Comparing ICFA_ADNI <span class="hljs-keyword">with</span> SDGZSL_ADNI.csv<br>z score = <span class="hljs-number">4.45566</span>;<br>p value = <span class="hljs-number">0.00001</span>;<br>There <span class="hljs-keyword">is</span> a significant difference<br>Comparing ICFA_ZDFY <span class="hljs-keyword">with</span> SDGZSL_ZDFY.csv<br>z score = <span class="hljs-number">3.20610</span>;<br>p value = <span class="hljs-number">0.00135</span>;<br>There <span class="hljs-keyword">is</span> a significant difference<br></code></pre></td></tr></table></figure><h2 id="ablation-study">Ablation study</h2><h3 id="adni-1">ADNI</h3><h4 id="cekl">CE+KL</h4><p>/home/LAB/chenlb24/adni/results/model_3sigmas_32d_kl_ce_8_16_32/classification_1e4_no_diskl/model_best_checkpoint289.pth</p><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240807163204327.png"alt="image-20240807163204327" /><figcaption aria-hidden="true">image-20240807163204327</figcaption></figure><h3 id="tumor-1">Tumor</h3><h4 id="cekl-1">CE+KL</h4><p>/mnt/chenlb/Six_Tumor_Classification/Exp40/results/model_6sigmas_32d_kl/classification/model_best_checkpoint326.pth</p><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240807163316050.png"alt="image-20240807163316050" /><figcaption aria-hidden="true">image-20240807163316050</figcaption></figure><table><thead><tr class="header"><th></th><th>训练</th><th>验证</th><th>测试</th><th></th></tr></thead><tbody><tr class="odd"><td>少突</td><td>118</td><td>27</td><td>19</td><td>164</td></tr><tr class="even"><td>星型</td><td>0</td><td>18</td><td>12</td><td>30</td></tr><tr class="odd"><td>胶母</td><td>488</td><td>130</td><td>83</td><td>701</td></tr><tr class="even"><td>总数</td><td>606</td><td>175</td><td>114</td><td>895</td></tr></tbody></table><h2 id="adni-2">ADNI</h2><table><thead><tr class="header"><th></th><th>训练</th><th>测试</th><th>总数</th></tr></thead><tbody><tr class="odd"><td>NC</td><td>326</td><td>76</td><td>403</td></tr><tr class="even"><td>MCI</td><td>0</td><td>28</td><td>28</td></tr><tr class="odd"><td>AD</td><td>172</td><td>50</td><td>222</td></tr><tr class="even"><td>总数</td><td>498</td><td>154</td><td>653</td></tr></tbody></table><h2 id="tumor-2">Tumor</h2><table><thead><tr class="header"><th></th><th>训练</th><th>测试</th><th>总数</th></tr></thead><tbody><tr class="odd"><td>少突(o)</td><td>118</td><td>19</td><td>137</td></tr><tr class="even"><td>星型(a)</td><td>0</td><td>12</td><td>12</td></tr><tr class="odd"><td>胶母(g)</td><td>488</td><td>83</td><td>571</td></tr><tr class="even"><td>总数</td><td>606</td><td>114</td><td>720</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>BUAA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>量化学习</title>
    <link href="/2024/07/27/Other/%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/27/Other/%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>学习过程中的记录 <span id="more"></span></p><ol type="1"><li><p>Binance时时刻刻都在更新资金费率，而okx当期资金费率为固定值，实时更新下一个时间段的预测资金费率</p></li><li><p>多平台资金费率套利：</p><p><ahref="https://www.youtube.com/watch?v=OHb9WEifytU">如何安全低风险套取合约资金费率，日赚20%(youtube.com)</a></p><p><ahref="https://www.youtube.com/watch?v=syeIqSxK69k&amp;t=463s">开对冲单薅资金费率丨什么是资金费率？丨资金费率套利演示丨跨交易所套利教程丨低风险套利策略丨磨平差值最好的方式(youtube.com)</a></p></li><li><p>交割合约-现货套利：</p><p><ahref="https://www.youtube.com/watch?v=x5onVzLnjn0">比特币期现套利和套期保值到底是如何操作的？(youtube.com)</a></p><p><ahref="https://zhuanlan.zhihu.com/p/41277854">【邢不行|量化小讲堂系列27-数字货币篇】数字货币期现套利教程：7天15%无风险收益- 知乎 (zhihu.com)</a></p><p><ahref="https://www.youtube.com/watch?v=FUJrXrnm-38&amp;list=PLTnIlP0WeBM0LsUyyrVpoAI8f1zm4ET7S&amp;index=13">#歐易怎麽賺錢（2）#期現套利：期貨的溢價就是你的利潤！歐易策略交易中的期現套利和期期套利怎麽操作下單。期現套利：期貨和現貨之間的套利；期期套利：期貨交割合約之間的套利(youtube.com)</a></p><p><ahref="https://www.youtube.com/watch?v=MoZEDQuSkO0&amp;list=PLTnIlP0WeBM0LsUyyrVpoAI8f1zm4ET7S&amp;index=12">(27)0风险，资金容量大，几分钟就能操作完的期现套利，睡着挣钱是什么体验？ -YouTube</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>业余</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器</title>
    <link href="/2024/07/11/BUAA/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2024/07/11/BUAA/%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>服务器相关问题记录</p><span id="more"></span><h2 id="服务器连接">服务器连接</h2><p>现在有两种服务器可以使用，一种是实验室的3090，一种是ACT组的V100。</p><h3 id="实验室服务器">实验室服务器</h3><p>目前实验室服务器不可联网且没有理想的解决方案，如果想使用需要离线下载各种python包，十分麻烦。</p><p>连接方式：</p><p>HostName: 192.168.7.232</p><p>User: tzy</p><p>Password: huabing123</p><h3 id="act服务器">ACT服务器</h3><p>ACT服务器需要拥有ACT账号（找汤老师），然后联系相关负责人激活GPU权限（不然无法使用GPU）</p><p>连接方式示例(若校外则需要在北航VPN环境下)：</p><p>HostName: 192.168.5.201</p><p>User: chenlb24</p><p>Password: ClmqffIapcfVKOJ</p><p>连接后会进入chenlb24@dell-mgt-01这个服务器上，不可在这个服务器运行程序，因为这个服务器是组内所有人共用的。在激活GPU权限后，使用如下命令进入新的服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">srun -n16 --gres=gpu:1 --exclude=dell-gpu-06,dell-gpu-22,dell-gpu-23 --pty bash<br></code></pre></td></tr></table></figure><p>其中<code>-n16</code>代表16核CPU，<code>--gres=gpu:1</code>代表申请的GPU数，可以申请多个</p><p>需要注意的是，终端关闭之后GPU随即释放，因此最好在tmux中申请GPU并使用。长时间未使用GPU会自动释放。</p><p>据师兄说ACT的卡IO比服务器要慢两倍不止，可以权衡一下。</p><h2 id="服务器联网">3090服务器联网</h2><p>本身无法联网，需要通过另一个局域网内的电脑开启代理。</p><ol type="1"><li><p>在实验室的台式机上打开clash的系统代理，打开允许局域网（主页第二个选项）</p></li><li><p>在3090服务器上设置转发：</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export http_proxy=&quot;http://192.168.1.104:7890&quot;&#x27;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export https_proxy=&quot;http://192.168.1.104:7890&quot;&#x27;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure></p><p>ip地址为台式机的ip地址，7890为clash中的端口</p></li><li><p>通过curl www.baidu.com测试是否可以联网</p></li></ol><h2 id="遇到的问题">遇到的问题</h2><ol type="1"><li><p>数据在其中一个服务器上，想传到另一个服务器</p><p>我使用的办法是压缩（可以节约非常大空间）之后SFTP传到自己电脑上，然后再SFTP传到目标服务器进行解压，用到的软件是FileZilla。XFTP这个软件似乎可以两个服务器之间传递，但其实本质还是以本机为中介进行传输。也有办法直接从源主机传到目标主机，需要自己尝试。</p></li><li><p>conda activate xxx之后，使用pip安装仍然安装在默认环境</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m pip install x<br></code></pre></td></tr></table></figure></p></li><li><p>3090联网后apt-get似乎还是没网</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/apt/apt.conf.d/proxy.conf<br></code></pre></td></tr></table></figure></p><p>然后添加： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">   Acquire::http::Proxy <span class="hljs-string">&quot;http://&lt;你的本地IP&gt;:&lt;端口号&gt;&quot;</span>;<br>Acquire::https::Proxy <span class="hljs-string">&quot;http://&lt;你的本地IP&gt;:&lt;端口号&gt;&quot;</span>;<br></code></pre></td></tr></table></figure></p></li><li><p>git无法联网</p><p>使用如下命令：</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global http.proxy http://&lt;proxy-ip&gt;:&lt;proxy-port&gt;<br>git config --global https.proxy http://&lt;proxy-ip&gt;:&lt;proxy-port&gt;<br>git config --global http.proxy socks5://&lt;proxy-ip&gt;:&lt;proxy-port&gt;<br>git config --global https.proxy socks5://&lt;proxy-ip&gt;:&lt;proxy-port&gt;<br></code></pre></td></tr></table></figure></p><p>打开或创建<code>~/.ssh/config</code>文件，添加如下信息：</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">Host github.com<br>    HostName github.com<br>    User git<br>    ProxyCommand nc -X 5 -x <span class="hljs-tag">&lt;<span class="hljs-name">proxy-ip</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">proxy-port</span>&gt;</span> %h %p<br></code></pre></td></tr></table></figure></p><p>此时可以尝试</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com<br></code></pre></td></tr></table></figure></p><p>如果成功则配置完成，如果报错X11相关，则需要进一步打开<code>/etc/ssh/ssh_config</code>,将下面两行注释掉</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"># X11Forwarding yes<br># X11DisplayOffset 10<br></code></pre></td></tr></table></figure></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>BUAA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发知识点</title>
    <link href="/2024/07/01/SoftwareDevelopment/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/07/01/SoftwareDevelopment/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>学习过程知识点</p><span id="more"></span><h2 id="spring-security里面每次生成加密后密码都不同怎么做的">SpringSecurity里面每次生成加密后密码都不同怎么做的?</h2><p>在SpringSecurity中，每次对同一个密码进行加密（哈希）都会产生不同的结果，这是因为它使用了一个技术叫做<strong>盐值（Salt）</strong>和<strong>密钥延伸函数（KeyStretching）</strong>。这种技术确保了即使两个用户使用相同的密码，它们的存储哈希值也会不同，从而增强了安全性。</p><h3 id="盐值和密钥延伸函数">盐值和密钥延伸函数</h3><ul><li><strong>盐值（Salt）</strong>：每次对密码进行哈希时，生成一个随机的值并与密码组合在一起进行哈希处理。这使得即使两个用户有相同的密码，它们的哈希值也会不同。</li><li><strong>密钥延伸函数（KeyStretching）</strong>：一种算法，通过多次迭代和复杂计算，延伸密码和盐值的组合，使得暴力破解变得更加困难。常用的密钥延伸函数包括bcrypt、scrypt和Argon2。</li></ul><h3 id="关键点">关键点</h3><ol type="1"><li><strong>密码加密</strong>：在用户注册时，使用<code>passwordEncoder.encode()</code>方法对密码进行加密，并将加密后的密码存储到数据库中。</li><li><strong>密码验证</strong>：在用户登录时，使用<code>passwordEncoder.matches()</code>方法验证用户输入的密码和数据库中存储的加密密码是否匹配。</li></ol><h3 id="bcrypt工作原理">bcrypt工作原理</h3><ul><li><strong>盐值</strong>：bcrypt算法在生成哈希值时会自动生成一个盐值，并将其包含在最终的哈希值中。每次调用<code>encode()</code>方法，生成的盐值都是不同的，因此相同的密码每次生成的哈希值也不同。</li><li><strong>密钥延伸</strong>：bcrypt算法会对密码和盐值进行多次迭代和复杂计算，使得生成哈希值的过程相对较慢，从而增加了暴力破解的难度。</li></ul><h3 id="示例输出">示例输出</h3><p>假设用户注册了两次，使用相同的密码“password123”，每次生成的哈希值将会不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$2a$10$7EqJtq98hPqEX7fNZaFWo.OXdf3YjcFOfKOQhYmSvK8W7P0iF88cK<br>$2a$10$FjfwQyioNdeupRr4Dk5M.ej1QnCf8uNNP0/j5sDh1w6MczKczFE7u<br></code></pre></td></tr></table></figure><p>尽管两次输入的密码相同，但生成的哈希值不同。然而，<code>matches()</code>方法能够正确地识别出相同的密码，因为它会自动提取和使用存储在哈希值中的盐值进行验证。</p><h2id="既然每次生成的密文都不一样怎么match的">既然每次生成的密文都不一样,怎么match的?</h2><p>Spring Security 中的 <code>PasswordEncoder.matches()</code>方法之所以能够比较出两个不同盐值生成的哈希值是否来自同一个密码，是因为bcrypt 算法本身的工作机制。bcrypt算法会在生成的哈希值中包含盐值信息，<code>matches()</code>方法在进行比较时会提取这个盐值并使用它来重新哈希输入的密码。具体步骤如下：</p><ol type="1"><li><strong>生成哈希</strong>：<ul><li>当你调用 <code>passwordEncoder.encode(plainPassword)</code>时，bcrypt会生成一个随机盐值，并将这个盐值与密码结合进行多次迭代的哈希计算。</li><li>生成的哈希值包含盐值和哈希后的密码。</li></ul></li><li><strong>验证哈希</strong>：<ul><li>当你调用<code>passwordEncoder.matches(rawPassword, encodedPassword)</code>时，bcrypt 会从 <code>encodedPassword</code> 中提取出盐值。</li><li>然后使用这个盐值对 <code>rawPassword</code>进行相同的哈希计算。</li><li>最后，将计算得到的哈希值与 <code>encodedPassword</code>进行比较，如果相同，则验证通过。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>项目-黑马点评</title>
    <link href="/2024/05/30/SoftwareDevelopment/%E9%A1%B9%E7%9B%AE-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/"/>
    <url>/2024/05/30/SoftwareDevelopment/%E9%A1%B9%E7%9B%AE-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/</url>
    
    <content type="html"><![CDATA[<p>黑马点评项目</p><span id="more"></span><h3 id="验证码登录">验证码登录</h3><p>普通的登录流程如下，重点在于将用户信息放到了session中，通过cookie的sessonId来获取登陆状态。这在具有好几个tomcat服务器的<strong>集群模式</strong>下会出现不共享session的问题。</p><p><img src="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240530205355234.png" alt="image-20240530205355234" style="zoom: 67%;" /></p><p>因此采取将用户信息放到redis的方式，登陆完成之后生成随机token返回前端，同时以token为key，用户信息为value存到redis中。在校验登录状态的时候，通过cookie中的token去redis中获取用户，如果有用户，就放行并把用户信息存入ThreadLocal中。</p><p><img src="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240530210034752.png" alt="image-20240530210034752" style="zoom: 50%;" /></p><p>同时为了进行redis中用户有效时间的刷新，采用两层拦截器。第一层拦截所有的请求，尝试查找user，如果能够查到，则刷新redis中的过期时间并把信息存到ThreadLocal中放行，如果查不到则直接放行。第二层拦截需要登录的页面，如果用户真的登录了，那么第一层拦截器一定会将信息存到ThreadLocal中，因此第二层直接去ThreadLocal中找就行，如果没找到则拦截。</p><h3 id="商户查询缓存">商户查询缓存</h3><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p><h4 id="cache-aside双写方案">Cache Aside双写方案</h4><p>当对数据库中的数据进行更新时，会涉及对Redis数据的同步更新。</p><ol type="1"><li><p>更新缓存还是删除缓存？</p><p>如果更新缓存，那么多次修改数据库就可能会多次修改缓存，是无效操作，因此选择<strong>删除</strong></p></li><li><p>先删除缓存还是先更新数据库？</p><p>先删除缓存：由于操作数据库速度相较于操作缓存要慢很多，因此如果删除了缓存，在更新数据库的时候有请求访问数据，<strong>就会出现大量请求打到数据库的情况</strong>（可以加锁解决）。同时还有可能会出现<strong>数据不一致</strong>问题，即把还未更新的数据库信息用来重建缓存，这样更新完成后缓存和数据库就不一致了（延迟双删解决）。</p><p>先更新数据库：也有可能会出现数据不一致问题，但是概率极低。一个线程发现缓存中不存在数据，去数据库查询并构建缓存，在这个间隙中另一个线程完成更新数据库+删除缓存操作。</p></li></ol><h4 id="缓存穿透">缓存穿透</h4><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象：可能造成短期的不一致：在访问id为空之后真的建立了这个id</li><li>布隆过滤：可能会误判</li></ul><h4 id="缓存雪崩">缓存雪崩</h4><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><ul><li><strong>给不同的Key的TTL添加随机值</strong></li><li><strong>利用Redis集群提高服务的可用性</strong></li><li><strong>给缓存业务添加降级限流策略</strong>，比如快速失败机制，让请求尽可能打不到数据库上</li><li><strong>给业务添加多级缓存</strong></li></ul><h4 id="缓存击穿">缓存击穿</h4><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><ol type="1"><li><p>互斥锁（SETNX）</p><p>采用tryLock方法 + doublecheck来解决。假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会去执行重建逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p></li><li><p>逻辑过期（线程池）</p><p>异步的构建缓存+返回脏数据。先进行数据预热，将热点数据加载到缓存中，把过期时间设置在redis的value中，不直接作用于redis。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，获得了锁的线程他会开启一个线程2去进行重构，直到新开的线程完成这个逻辑后，才释放锁，而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p></li></ol><h3 id="优惠券秒杀">优惠券秒杀</h3><h4 id="超卖问题">超卖问题</h4><p>一般逻辑是先判断库存是否足够，如果足够下一步就进行购买，这就会产生原子性问题，可以采用加锁的方式解决，一般采取乐观锁。但是对于正常的CAS，会判断当前的数量和之前的数量是否一样，一样才更新，这样效率很低，因此改为原子性的判断库存是否大于0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>            .setSql(<span class="hljs-string">&quot;stock= stock -1&quot;</span>)<br>            .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="hljs-string">&quot;stock&quot;</span>,<span class="hljs-number">0</span>); <span class="hljs-comment">//where id = ? and stock &gt; 0</span><br></code></pre></td></tr></table></figure><h4 id="一人一单">一人一单</h4><h5 id="单机模式">单机模式</h5><p>单机模式下，采用悲观锁synchronized保证一人一单，synchronized锁用户id。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<br>    <span class="hljs-comment">// 创建代理对象，使用代理对象调用第三方事务方法， 防止事务失效</span><br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(userId, voucherId);<br>&#125;<br></code></pre></td></tr></table></figure><p>同一个类中，A方法是非事务性方法，但是B方法是事务性方法，此时A调用B就会导致B的事务失效。事务的实现是基于AOP的，而AOP的实现又是基于动态代理的，而动态代理的本质就算对方法的增强，如果想要使用增强的方法（也就是想要使用事务方法），就必须是通过代理对象去触发目标对象的方法，因此需要通过<code>AopContext.currentProxy()</code>这个API获取当前类的代理对象</p><h5 id="集群模式">集群模式</h5><p>不同机器中JVM肯定是分开的，因此userId.toString().intern()在不同机器中指代并不相同，同样会出问题，需要采用分布式锁</p><p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行</p><p>基础思路为使用setnx实现分布式锁。需要注意的是，key设置为前缀+用户标识，value设置为线程ID，在释放锁的时候需要先判断是否是自己的锁，如果是自己的锁再释放。但是这仍然有原子性问题，因此需要采用Lua脚本来进行原子性操作。</p><p>Lua脚本中的Redis指令出错，会发生回滚以确保原子性，但Lua脚本本身出错就无法保障原子性</p><h4 id="redission">redission</h4><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong>如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><h5 id="可重入锁">可重入锁</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/ed299ba20178d708459f32cf13af7873.png" alt="image-20230714153945450" style="zoom: 67%;" /></p><p>Redisson内部释放锁，并不是直接执行<code>del</code>命令将锁给删除，而是将锁以<code>hash</code>数据结构的形式存储在Redis中，每次获取锁，都将<code>value</code>的值+1，每次释放锁，都将value的值-1，只有锁的value值归0时才会真正的释放锁，从而确保锁的可重入性</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>八股-操作系统</title>
    <link href="/2024/05/23/SoftwareDevelopment/%E5%85%AB%E8%82%A1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/05/23/SoftwareDevelopment/%E5%85%AB%E8%82%A1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>操作系统学习</p><span id="more"></span><h4 id="cache的数据写回">Cache的数据写回</h4><ol type="1"><li>写直达：<strong>把数据同时写入内存和 Cache 中</strong></li><li>写回：<strong>当发生写操作时，新的数据仅仅被写入 Cache Block里，只有当修改过的 CacheBlock「被替换」时才需要写到内存中</strong>，减少了数据写回内存的频率，这样便可以提高系统的性能。</li></ol><h4 id="cache缓存一致性问题">Cache缓存一致性问题</h4><p>MESI协议</p><p>我们举个具体的例子来看看这四个状态的转换：</p><ul><li><em>Modified</em>，已修改</li><li><em>Exclusive</em>，独占</li><li><em>Shared</em>，共享</li><li><em>Invalidated</em>，已失效</li></ul><ol type="1"><li>当 A 号 CPU 核心从内存读取变量 i 的值，数据被缓存在 A 号 CPU核心自己的 Cache 里面，此时其他 CPU 核心的 Cache没有缓存该数据，于是标记 Cache Line 状态为「独占」，此时其 Cache中的数据与内存是一致的；</li><li>然后 B 号 CPU 核心也从内存读取了变量 i 的值，此时会发送消息给其他CPU 核心，由于 A 号 CPU 核心已经缓存了该数据，所以会把数据返回给 B 号CPU 核心。在这个时候， A 和 B 核心缓存了相同的数据，Cache Line的状态就会变成「共享」，并且其 Cache 中的数据与内存也是一致的；</li><li>当 A 号 CPU 核心要修改 Cache 中 i 变量的值，发现数据对应的 CacheLine 的状态是共享状态，则要向所有的其他 CPU核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line标记为「无效」状态，然后 A 号 CPU 核心才更新 Cache 里面的数据，同时标记Cache Line 为「已修改」状态，此时 Cache 中的数据就与内存不一致了。</li><li>如果 A 号 CPU 核心「继续」修改 Cache 中 i 变量的值，由于此时的 CacheLine 是「已修改」状态，因此不需要给其他 CPU核心发送消息，直接更新数据即可。</li><li>如果 A 号 CPU 核心的 Cache 里的 i 变量对应的 Cache Line要被「替换」，发现 Cache Line状态是「已修改」状态，就会在替换前先把数据同步到内存。</li></ol><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/%20MESI%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E8%A1%A8%E6%A0%BC.png" alt="img" style="zoom:50%;" /></p><h4 id="cache伪共享">Cache伪共享</h4><p>假设有一个双核心的 CPU，这两个 CPU核心并行运行着两个不同的线程，它们同时从内存中读取两个不同的数据，分别是类型为<code>long</code> 的变量 A 和B，这个两个数据的地址在物理内存上是<strong>连续</strong>的，如果 CahceLine 的大小是 64 字节，并且变量 A 在 Cahce Line的开头位置，那么这两个数据是位于<strong>同一个 Cache Line中</strong>，又因为 CPU Cache Line 是 CPU 从内存读取数据到 Cache的单位，所以这两个数据会被同时读入到了两个 CPU 核心中各自 Cache中。果这两个不同核心的线程分别修改不同的数据，比如 1 号 CPU核心的线程只修改了 变量 A，或 2 号 CPU 核心的线程的线程只修改了变量B，就会导致伪共享。</p><p>对于多个线程共享的热点数据，即经常会修改的数据，应该避免这些数据刚好在同一个Cache Line 中。避免 Cache 伪共享实际上是用空间换时间的思想，浪费一部分Cache 空间，从而换来性能的提升。</p><h4 id="软中断">软中断</h4><p>Linux系统<strong>为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」</strong>。</p><ul><li><strong>上半部用来快速处理中断</strong>，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。</li><li><strong>下半部用来延迟处理上半部未完成的工作</strong>，一般以「内核线程」的方式运行。</li></ul><p>中断处理程序的上部分和下半部可以理解为：</p><ul><li><strong>上半部直接处理硬件请求，也就是硬中断</strong>，主要是负责耗时短的工作，特点是快速执行；</li><li><strong>下半部是由内核触发，也就说软中断</strong>，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；</li></ul><h4 id="为什么要有虚拟地址">为什么要有虚拟地址</h4><ol type="1"><li><p>为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套<strong>虚拟地址空间</strong>，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。</p></li><li><p>虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的swap 区域。</p></li></ol><h4 id="进程上下文切换">进程上下文切换</h4><p>进程是由内核管理和调度的，所以进程的切换只能发生在内核态。</p><p>所以，<strong>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源</strong></p><p>通常，会把交换的信息保存在进程的 PCB</p><h4 id="什么是线程">什么是线程</h4><p><strong>线程是进程当中的一条执行流程。</strong></p><p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p><p>线程与进程的比较如下：</p><ul><li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU调度的单位；</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li><li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li><li>线程能减少并发执行的时间和空间开销；</li></ul><h4 id="线程上下文切换">线程上下文切换</h4><p>这还得看线程是不是属于同一个进程：</p><ul><li>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；</li><li><strong>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</strong>；</li></ul><p>所以，线程的上下文切换相比进程，开销要小很多</p><h4 id="进程间通信方式">进程间通信方式</h4><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</p><h5 id="管道">管道</h5><p><strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。</p><p><strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p><p><strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p><h5 id="消息队列">消息队列</h5><p><strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</p><h5 id="共享内存">共享内存</h5><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p><h5 id="信号量">信号量</h5><p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。</p><h5 id="信号">信号</h5><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，</p><h4 id="同步问题">同步问题</h4><h5 id="哲学家进餐">哲学家进餐</h5><p><strong>用一个数组 state来记录每一位哲学家的三个状态，分别是在进餐状态、思考状态、饥饿状态（正在试图拿叉子）。</strong></p><p>那么，<strong>一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态。</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/30-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E5%9B%9B%E7%A4%BA%E4%BE%8B.jpg" alt="img" style="zoom: 25%;" /></p><h4 id="死锁">死锁</h4><h5 id="产生条件">产生条件</h5><p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p><ul><li>互斥条件；</li><li>持有并等待条件；</li><li>不可剥夺条件；</li><li>环路等待条件；</li></ul><h5 id="预防死锁">预防死锁</h5><p><strong>1、静态分配策略</strong></p><p>静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。</p><p>静态分配策略逻辑简单，实现也很容易，但这种策略<strong>严重地降低了资源利用率</strong>，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才使用的，这样就可能造成一个进程占有了一些<strong>几乎不用的资源而使其他需要该资源的进程产生等待</strong>的情况。</p><p><strong>2、层次分配策略</strong></p><p>层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略</p><h5 id="避免死锁">避免死锁</h5><p>允许系统中<strong>同时存在四个必要条件</strong>，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出<strong>明智和合理的选择</strong>，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。</p><p>银行家算法用一句话表达就是：当一个进程申请使用资源的时候，<strong>银行家算法</strong>通过先 <strong>试探</strong> 分配给该进程资源，然后通过<strong>安全性算法</strong>判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就<strong>真的分配资源给该进程</strong>。</p><h5 id="检测和接触死锁">检测和接触死锁</h5><p>这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统<strong>定时地运行一个 “死锁检测”</strong>的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p><p>当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：</p><ol type="1"><li><strong>立即结束所有进程的执行，重新启动操作系统</strong>：这种方法简单，但以前所在的工作全部作废，损失很大。</li><li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong>：这种方法能彻底打破<strong>死锁的循环等待</strong>条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li><li><strong>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</strong></li><li><strong>抢占资源</strong>：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li></ol><h4 id="互斥锁">互斥锁</h4><p><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong>，给其他线程；互斥锁是一种「独占锁」，比如当线程 A加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU让给其他线程，<strong>既然线程 B 释放掉了 CPU，自然线程 B加锁的代码就会被阻塞</strong>。</p><h4 id="自旋锁">自旋锁</h4><p><strong>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></p><p>使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用<code>while</code> 循环等待实现，不过最好是使用 CPU 提供的<code>PAUSE</code>指令来实现「忙等待」，因为可以减少循环等待时的耗电量。</p><h4 id="文件的存储方式">文件的存储方式</h4><ol type="1"><li>连续空间存储</li></ol><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F.png" alt="连续空间存放方式" style="zoom:50%;" /></p><p>连续空间存放的方式虽然读写效率高，<strong>但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷。</strong></p><ol start="2" type="1"><li><p>非连续空间存储</p><ol type="1"><li><p>链表方式</p><ol type="1"><li><p>隐式链表：每个数据块末尾存储下一个数据块地址，文件头包含起始块和末尾块</p><figure><imgsrc="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E9%93%BE%E8%A1%A8%E6%96%B9%E5%BC%8F.png"alt="隐式链表" /><figcaption aria-hidden="true">隐式链表</figcaption></figure></li><li><p>显式链表：<strong>把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中</strong>，该表在整个磁盘仅设置一张，<strong>每个表项中存放链接指针，指向下一个数据块号</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E8%A1%A8.png" alt="显式链接" style="zoom:50%;" /></p></li></ol></li><li><p>索引方式</p><p>索引的实现是为每个文件创建一个「<strong>索引数据块</strong>」，里面存放的是<strong>指向文件数据块的指针列表</strong>，说白了就像书的目录一样，要找哪个章节的内容，看目录查就可以。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F.png" alt="索引的方式" style="zoom:50%;" /></p></li></ol></li><li><p>Unix的存储方式</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Unix%20%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95.png" alt="早期 Unix 文件系统" style="zoom:50%;" /></p></li></ol><h4 id="空闲空间存储方式">空闲空间存储方式</h4><ol type="1"><li>空闲表法：为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的</li><li>空闲链表法：每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来</li><li>位图法：利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。当值为0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。</li></ol><h4 id="文件系统的结构">文件系统的结构</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E5%9D%97%E7%BB%84.png" alt="img" style="zoom:50%;" /></p><p>最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：</p><ul><li><em>超级块</em>，包含的是文件系统的重要信息，比如 inode总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。</li><li><em>块组描述符</em>，包含文件系统中各个块组的状态，比如块组中空闲块和inode的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。</li><li><em>数据位图和 inode 位图</em>， 用于表示对应的数据块或 inode是空闲的，还是被使用中。</li><li><em>inode 列表</em>，包含了块组中所有的 inode，inode用于保存文件系统中与各个文件和目录相关的所有元数据。</li><li><em>数据块</em>，包含文件的有用数据。</li></ul><h4 id="硬链接和软链接">硬链接和软链接</h4><p>硬链接是<strong>多个目录项中的「索引节点」指向一个文件</strong>，也就是指向同一个inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode数据结构和列表，所以<strong>硬链接是不可用于跨文件系统的</strong>。由于多个目录项都是指向一个inode，那么<strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</strong></p><p>软链接相当于重新创建一个文件，这个文件有<strong>独立的inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以<strong>软链接是可以跨文件系统的</strong>，甚至<strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</strong></p><h4 id="dma">DMA</h4><p><strong>CPU不再参与「将数据从磁盘控制器缓冲区搬运到内核空间」的工作，这部分工作全程由DMA 完成</strong>。但是 CPU在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要CPU 来告诉 DMA 控制器。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/DRM%20I_O%20%E8%BF%87%E7%A8%8B.png" alt="img" style="zoom:50%;" /></p><h4 id="io多路复用">IO多路复用</h4><h5 id="selectpoll">select/poll</h5><p>select 实现多路复用的方式是，将已连接的 Socket都放到一个<strong>文件描述符集合</strong>，然后调用 select函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此Socket 标记为可读或可写，接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的Socket，然后再对其处理。select 使用固定长度的BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为<code>1024</code>，只能监听 0~1023 的文件描述符。</p><p>poll 不再用 BitsMap来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p><h5 id="epoll">epoll</h5><p>epoll 通过两个方面，很好解决了 select/poll 的问题。</p><p><em>第一点</em>，epoll在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的socket 通过 <code>epoll_ctl()</code>函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是<code>O(logn)</code>。而 select/poll 内核里没有类似 epoll红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll每次操作时都传入整个 socket 集合给内核，而 epoll因为在内核维护了红黑树，可以保存所有待检测的 socket，所以只需要传入一个待检测的socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p><p><em>第二点</em>， epoll使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个socket有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用<code>epoll_wait()</code>函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p><h4 id="僵尸进程孤儿进程">僵尸进程/孤儿进程</h4><p>当一个进程调用exit()系统调用结束自己的生命时，内核会释放该进程的所有资源，包括打开的文件、占用的内存等，但是该进程对应的PCB 依然存在于系统中。这些信息只有在父进程调用 wait()或waitpid()系统调用时才会被释放，以便让父进程得到子进程的状态信息。</p><p><strong>僵尸进程</strong>：子进程已经终止，但是其父进程仍在运行，且父进程没有调用wait()或waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的PCB依然存在于系统中，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用wait()或 waitpid()系统调用来回收子进程。</p><p><strong>孤儿进程</strong>：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用wait()或waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源。</p><h4 id="磁盘调度算法">磁盘调度算法</h4><p><strong>先来先服务算法（First-ComeFirst-Served，FCFS）</strong>：按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS算法实现起来比较简单，不存在算法开销。不过，由于没有考虑磁头移动的路径和方向，平均寻道时间较长。同时，该算法容易出现饥饿问题，即一些后到的磁盘请求可能需要等待很长时间才能得到服务。</p><p><strong>最短寻道时间优先算法（Shortest Seek TimeFirst，SSTF）</strong>：也被称为最佳服务优先（Shortest Service TimeFirst，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。SSTF算法能够最小化磁头的寻道时间，但容易出现饥饿问题，即磁头附近的请求不断被服务，远离磁头的请求长时间得不到响应。实际应用中，需要优化一下该算法的实现，避免出现饥饿问题。<strong>扫描算法（SCAN）</strong>：也被称为电梯（Elevator）算法，基本思想和电梯非常类似。磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界，然后改变移动方向，依此往复。SCAN算法能够保证所有的请求得到服务，解决了饥饿问题。但是，如果磁头从一个方向刚扫描完，请求才到的话。这个请求就需要等到磁头从相反方向过来之后才能得到处理。</p><p><strong>循环扫描算法（Circular Scan，C-SCAN）</strong>：SCAN算法的变体，只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环。</p><p><strong>边扫描边观察算法（LOOK）</strong>：SCAN算法中磁头到了磁盘的边界才改变移动方向，这样可能会做很多无用功，因为磁头移动方向上可能已经没有请求需要处理了。LOOK算法对 SCAN算法进行了改进，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，依此往复。也就是边扫描边观察指定方向上还有无请求，因此叫LOOK。<strong>均衡循环扫描算法（C-LOOK）</strong>：C-SCAN只有到达磁盘边界时才能改变磁头移动方向，并且磁头返回时也需要返回到磁盘起点，这样可能会做很多无用功。C-LOOK算法对 C-SCAN算法进行了改进，如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>八股-Spring</title>
    <link href="/2024/05/05/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Spring/"/>
    <url>/2024/05/05/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Spring/</url>
    
    <content type="html"><![CDATA[<p>Spring学习 <span id="more"></span></p><h2 id="spring">Spring</h2><h3 id="特性">特性</h3><ol type="1"><li><p>支持IOC和DI</p></li><li><p>支持AOP编程</p></li><li><p>支持声明式事务</p></li></ol><h3 id="设计模式">设计模式</h3><ol type="1"><li>工厂模式：Spring 容器本质是一个大工厂,使用工厂模式通过BeanFactory、ApplicationContext 创建 bean 对象。</li><li>代理模式：AOP</li><li>单例模式：Bean默认单例</li><li>模板模式：Spring 中 JdbcTemplate、RestTemplate 等以 Template结尾的对数据库、网络等等进行操作的模板类 ,就使用到了模板模式。</li></ol><h3 id="beanfactory">BeanFactory</h3><p>BeanFactory 是 Spring框架的基础，其作为一个顶级接口定义了容器的基本行为，例如管理 bean的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。BeanFactory接口提供了访问 bean 的方式，例如 getBean() 方法获取指定的 bean实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory还包含很多子类（例如，ApplicationContext接口）提供了额外的强大功能。</p><h3 id="resource-和-autowired"><span class="citation"data-cites="Resource">@Resource</span> 和 <span class="citation"data-cites="Autowired">@Autowired</span></h3><ol type="1"><li><p><span class="citation"data-cites="Resource注解是JDK扩展包中的">@Resource注解是JDK扩展包中的</span>，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。</p><p><span class="citation"data-cites="Autowired注解是Spring框架自己的">@Autowired注解是Spring框架自己的</span>。</p></li><li><p><span class="citation"data-cites="Resource注解默认">@Resource注解默认</span><strong>根据Bean名称装配</strong>，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型装配。</p><p><span class="citation"data-cites="Autowired注解默认">@Autowired注解默认</span><strong>根据类型装配</strong>，如果想根据名称装配，需要配合@Qualifier注解一起用。</p></li></ol><h3 id="bean是线程安全的吗">Bean是线程安全的吗？</h3><p>因为单例 Bean,是全局只有一个 Bean,所有线程共享。如果说单例Bean,是一个无状态的,也就是线程中的操作不会对 Bean中的成员变量执行查询以外的操作,那么这个单例 Bean 是线程安全的。比如Spring mvc 的 Controller、Service、Dao 等,这些 Bean大多是无状态的,只关注于方法本身。假如这个 Bean 是有状态的,也就是会对Bean 中的成员变量进行写操作,那么可能就存在线程安全的问题。</p><p>常见的有这么些解决办法 :</p><ol type="1"><li>将 Bean 定义为多例这样每一个线程请求过来都会创建一个新的 Bean,但是这样容器就不好管理 Bean,不能这么办。</li><li>在 Bean对象中尽量避免定义可变的成员变量削足适履了属于是,也不能这么干。</li><li>将 Bean 中的成员变量保存在 ThreadLocal 中 我们知道 ThredLoca能保证多线程下变量的隔离,可以在类中定义一个 ThreadLocal成员变量,将需要的可变成员变量保存在 ThreadLocal 里,这是推荐的一种方式。</li></ol><h3 id="循环依赖问题">循环依赖问题</h3><p>Spring 通过三级缓存解决了循环依赖：</p><p>一级缓存 : Map&lt;String,Object&gt; singletonObjects, 单例池,用于保存实例化、属性赋值 ( 注入)、初始化完成的 bean 实例</p><p>二级缓存 : Map&lt;String,Object&gt; earlySingletonObjects,早期曝光对象,用于保存实例化完成的 bean 实例</p><p>三级缓存 : Map&lt;String,ObjectFactory&lt;?&gt;&gt;singletonFactories, 早期曝光对象工厂,用于保存 bean创建工厂,以便于后面扩展有机会创建代理对象。</p><p>A 实例的初始化过程:</p><ol type="1"><li>创建 A 实例 ,实例化的时候把 A 对象工厂放入三级缓存,表示 A开始实例化了,虽然我这个对象还不完整,但是先曝光出来让大家知道</li><li>A 注入属性时 ,发现依赖 B, 此时 B 还没有被创建出来,所以去实例化B</li><li>B 注入属性时发现依赖 A, 它就会从缓存里找 A对象。依次从一级到三级缓存查询 A, 从三级缓存通过对象工厂拿到 A,发现 A虽然不太完善 , 但是存在,把 A 放入二级缓存,同时删除三级缓存中的 A, 此时,B 已经实例化并且初始化完成,把 B 放入一级缓存。</li><li>接着 A 继续属性赋值, 顺利从一级缓存拿到实例化且初始化完成的 B 对象,A对象创建也完成,删除二级缓存中的 A, 同时把 A 放入一级缓存</li></ol><p>实例化和属性赋值是分开的，所以里面有操作的空间。如果都是构造器注入的化，那么都得在实例化这一步完成注入，所以自然是无法支持了。</p><h3 id="声明式事务实现原理">声明式事务实现原理</h3><ol type="1"><li><p>在 Bean 初始化阶段创建代理对象: Spring 容器在初始化每个单例 bean的时候, 会遍历容器中的所有 BeanPostProcessor 实现类 ,并执行其postProcessAfterInitialization 方法 ,在执行 AbstractAutoProxyCreator类的 postProcessAfterInitialization方法时会遍历容器中所有的切面,查找与当前实例化 bean匹配的切面,这里会获取事务属性切面,查找@Transactional 注解及其属性值 ,然后根据得到的切面创建一个代理对象,默认是使用 JDK动态代理创建代理,如果目标类是接又 , 则使用 JDK 动态代理,否则使用Cglib。</p></li><li><p>在执行目标方法时进行事务增强操作: 当通过代理对象调用 Bean方法的时候, 会触发对应的 AOP增强拦截器,声明式事务是一种环绕增强,对应接又为 MethodInterceptor,事务增强对该接又的实现为 TransactionInterceptor ,</p></li></ol><h3 id="声明式事务失效情况">声明式事务失效情况</h3><ol type="1"><li><p>应用在非public修饰的方法上</p></li><li><p>注解属性 propagation设置错误</p><p>即事务的传播机制有的会让当前事务失效，比如TransactionDefinition.PROPAGATION_SUPPORTS:如果当前存在事务,则加入该事务;如果当前没有事务,则以非事务的方式继续运行。</p></li><li><p>注解属性 rollbackFor 设置错误</p><p>rollbackFor 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查 unchecked 异常(继承自 RuntimeException 的异常)或者Error 才回滚事务,其他异常不会触发回滚事务。</p></li><li><p>同一个类中方法调用,导致@Transactional 失效</p><p>比如有一个类 Test, 它的一个方法 A, A 再调用本类的方法 B(不论方法 B是用 public 还是 private 修饰),但方法 A 没有声明注解事务,而 B方法有。则外部调用方法 A 之后,方法 B的事务是不会起作用的。因为只有当事务方法被当前类以外的代码调用时，才会由Spring 生成的代理对象来管理。</p></li></ol><h3 id="spring-mvc-的工作流程">Spring MVC 的工作流程</h3><p><imgsrc="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240513144842.png" /></p><ol type="1"><li>客户端向服务端发送一次请求,这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。</li><li>DispatcherServlet 接收到请求后会调用 HandlerMapping处理器映射器。由此得知 , 该请求该由哪个 Controller 来处理(并未调用Controller, 只是得知 )</li><li>DispatcherServlet 调用 HandlerAdapter处理器适配器,告诉处理器适配器应该要去执行哪个 Controller</li><li>HandlerAdapter 处理器适配器去执行 Controller 并得到ModelAndView(数据和视图 ) ,并层层返回给 DispatcherServlet</li><li>DispatcherServlet 将 ModelAndView 交给 ViewReslover 视图解析器解析 ,然后返回真正的视图。</li><li>DispatcherServlet 将模型数据填充到视图中</li><li>DispatcherServlet 将结果响应给客户端</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>八股-Redis</title>
    <link href="/2024/05/02/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Redis/"/>
    <url>/2024/05/02/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Redis/</url>
    
    <content type="html"><![CDATA[<p>Redis学习 <span id="more"></span></p><h2 id="数据类型">数据类型</h2><h3 id="string">String</h3><h4 id="底层实现">底层实现</h4><p>String 类型的底层的数据结构实现主要是 int 和SDS（简单动态字符串）。</p><ol type="1"><li><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用<code>long</code>类型来表示，那么字符串对象会将整数值保存在字符串对象结构的<code>ptr</code>属性里面（将<code>void*</code>转换成long），并将字符串对象的编码设置为<code>int</code>。</p></li><li><p>如果字符串对象保存的是一个字符串，并且这个字符申的长度小于等于 32字节（redis2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为<code>embstr</code>，embstr会通过一次内存分配函数来分配一块连续的内存空间来保存redisObject和SDS。</p></li></ol><figure><imgsrc="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/embstr.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>如果字符串对象保存的是一个字符串，并且这个字符串的长度大于 32字节（redis2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为<code>raw</code>，raw编码会通过调用两次内存分配函数来分别分配两块空间来保存redisObject和SDS</li></ol><figure><imgsrc="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/raw.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="分布式锁">分布式锁</h4><p>SET 命令有个 NX参数可以实现「key不存在才插入」，可以用它来实现分布式锁：</p><ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li><li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li></ul><p>其中key为分布式锁的名称，value为客户端进程id</p><p>而解锁的过程就是将 lock_key键删除，但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。</p><p>可以看到，解锁是有两个操作，这时就需要 Lua脚本来保证解锁的原子性，因为 Redis 在执行 Lua脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。</p><h3 id="list">List</h3><h4 id="底层实现-1">底层实现</h4><p>List类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p><ul><li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由<code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于<code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code>配置），Redis 会使用<strong>压缩列表</strong>作为 List类型的底层数据结构；</li><li>如果列表的元素不满足上面的条件，Redis会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li></ul><p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由quicklist 实现了，替代了双向链表和压缩列表</strong></p><h4 id="消息队列">消息队列</h4><p>List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List作为消息队列保存消息的话，就已经能满足消息保序的需求了</p><ol type="1"><li>堵塞问题</li></ol><p>​ 在生产者往 List 中写入数据时，List并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 <code>RPOP</code>命令（比如使用一个while(1)循环）。如果有新消息写入，RPOP命令就会返回结果，否则，RPOP命令返回空值，再继续循环。所以，即使没有新消息写入List，消费者也要不停地调用 RPOP命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP命令上，带来不必要的性能损失。</p><p>​ 为了解决这个问题，Redis提供了 BRPOP命令。<strong>BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong>。和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。</p><ol start="2" type="1"><li>处理重复的消息</li></ol><p>​<strong>自行为每个消息生成一个全局唯一ID</strong>，生成之后，我们在用LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。</p><ol start="3" type="1"><li>保证消息可靠性</li></ol><p>​ 为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code>命令，这个命令的<strong>作用是让消费者程序从一个 List中读取消息，同时，Redis 会把这 个消息再插入到另一个 List（可以叫作备份List）留存</strong>。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p><h3 id="hash">Hash</h3><p>Hash类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p><ul><li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由<code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code>字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li><li>如果哈希类型元素不满足上面条件，Redis会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack数据结构来实现了</strong>。</p><h3 id="set">Set</h3><h4 id="底层实现-2">底层实现</h4><p>Set类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p><p>Set类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于 <code>512</code>（默认值，<code>set-maxintset-entries</code>配置）个，Redis会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则 Redis使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li></ul><h4 id="应用场景">应用场景</h4><p><strong>Set的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致Redis 实例阻塞</strong>。</p><p>在主从集群中，为了避免主库因为 Set做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p><ol type="1"><li><p>点赞</p><p>Set 类型可以保证一个用户只能点一个赞</p></li><li><p>共同关注</p><p>Set类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p></li></ol><h3 id="zset">Zset</h3><p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性score（分值），对于有序集合 ZSet来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。</p><p>Zset类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p><ul><li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于<code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack数据结构来实现了。</strong></p><h3 id="bitmap">Bitmap</h3><h4 id="底层实现-3">底层实现</h4><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)。由于bit是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。</p><p>Bitmap 本身是用 String类型作为底层数据结构实现的一种统计二值状态的数据类型。String类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit数组。</p><h4 id="应用场景-1">应用场景</h4><ol type="1"><li><p>签到</p><p>在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。</p><p>签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个bit 位，根本不用太复杂的集合类型。</p></li></ol><h2 id="数据结构">数据结构</h2><figure><imgsrc="https://cdn.xiaolincoding.com//mysql/other/9fa26a74965efbf0f56b707a03bb9b7f-20230309232518487.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="压缩列表">压缩列表</h3><p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用CPU缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p><figure><imgsrc="https://cdn.xiaolincoding.com//mysql/other/ab0b44f557f8b5bc7acb3a53d43ebfcb.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>压缩列表在表头有三个字段：</p><ul><li><strong><em>zlbytes</em></strong>，记录整个压缩列表占用对内存字节数；</li><li><strong><em>zltail</em></strong>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li><li><strong><em>zllen</em></strong>，记录压缩列表包含的节点数量；</li><li><strong><em>zlend</em></strong>，标记压缩列表的结束点，固定值0xFF（十进制255）。</li></ul><p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段（zllen）的长度直接定位，复杂度是O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p><p>压缩列表节点包含三部分内容：</p><ul><li><strong><em>prevlen</em></strong>，记录了「前一个节点」的长度，目的是为了实现从后向前遍历；</li><li><strong><em>encoding</em></strong>，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。</li><li><strong><em>data</em></strong>，记录了当前节点的实际数据，类型和长度都由<code>encoding</code> 决定；</li></ul><p>压缩列表里的每个节点中的 prevlen属性都记录了「前一个节点的长度」，而且 prevlen属性的空间大小跟前一个节点长度值有关，比如：</p><ul><li>如果<strong>前一个节点的长度小于 254 字节</strong>，那么 prevlen属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li><li>如果<strong>前一个节点的长度大于等于 254 字节</strong>，那么 prevlen属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li></ul><h4 id="连锁更新">连锁更新</h4><p>压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的prevlen占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降。</p><h3 id="哈希表">哈希表</h3><p><img src="https://cdn.xiaolincoding.com//mysql/other/2fedbc9cd4cb7236c302d695686dd478.png" alt="img" style="zoom:50%;" /></p><p>在正常服务请求阶段，插入的数据，都会写入到「哈希表1」，此时的「哈希表 2 」 并没有被分配空间。</p><p>随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p><ul><li>给「哈希表 2」 分配空间，一般会比「哈希表 1」大一倍（两倍的意思）；</li><li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li><li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次rehash 做准备。</li></ul><p>为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis性能的情况，所以 Redis 采用了<strong>渐进式rehash</strong>，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。</p><p>渐进式 rehash 步骤如下：</p><ul><li>给「哈希表 2」 分配空间；</li><li><strong>在 rehash进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有key-value 迁移到「哈希表 2」 上</strong>；</li><li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。</li></ul><p>触发 rehash 操作的条件，主要有两个：</p><ul><li><strong>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF重写的时候，就会进行 rehash 操作。</strong></li><li><strong>当负载因子大于等于 5时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF重写，都会强制进行 rehash 操作。</strong></li></ul><h3 id="整数集合">整数集合</h3><p>整数集合本质上是一块连续内存空间，保存元素的容器是一个 contents数组，虽然 contents 被声明为 int8_t 类型的数组，但是实际上 contents数组并不保存任何 int8_t 类型的元素，contents 数组的真正类型取决于 intset结构体里的 encoding 属性的值</p><h4 id="升级操作">升级操作</h4><p>整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展contents数组的空间大小，然后才能将新元素加入到整数集合里，当然升级的过程中，也要维持整数集合的有序性。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/e84b052381e240eeb8cc97d6b729968b.png" alt="img" style="zoom:50%;" /></p><h3 id="跳表">跳表</h3><p>zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。Zset对象能支持范围查询（如 ZRANGEBYSCORE操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如ZSCORE 操作），这是因为它同时采用了哈希表进行索引。询。</p><p>跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来</p><figure><imgsrc="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="创建过程">创建过程</h4><p><strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为2 : 1 的情况。</p><p>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于0.25（相当于概率 25%），那么层数就增加 1层，然后继续生成下一个随机数，直到随机数的结果大于 0.25结束，最终确定该节点的层数</strong>。</p><h4 id="查询过程">查询过程</h4><p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p><ul><li>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li><li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li></ul><p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的level数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</p><figure><imgsrc="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.drawio.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如果要查找「元素：abcd，权重：4」的节点，查找的过程是这样的：</p><ul><li>先从头节点的最高层开始，L2指向了「元素：abc，权重：3」节点，这个节点的权重比要查找节点的小，所以要访问该层上的下一个节点；</li><li>但是该层的下一个节点是空节点（leve[2]指向的是空节点），于是就会跳到「元素：abc，权重：3」节点的下一层去找，也就是leve[1];</li><li>「元素：abc，权重：3」节点的 leve[1]的下一个指针指向了「元素：abcde，权重：4」的节点，然后将其和要查找的节点比较。虽然「元素：abcde，权重：4」的节点的权重和要查找的权重相同，但是当前节点的SDS类型数据「大于」要查找的数据，所以会继续跳到「元素：abc，权重：3」节点的下一层去找，也就是leve[0]；</li><li>「元素：abc，权重：3」节点的 leve[0]的下一个指针指向了「元素：abcd，权重：4」的节点，该节点正是要查找的节点，查询结束。</li></ul><h4 id="查找某个元素的排位">查找某个元素的排位</h4><p>查找图中节点 3 在跳表中的排位，从头节点开始查找节点3，查找的过程只经过了一个层（L2），并且层的跨度是 3，所以节点 3在跳表中的排位是 3。</p><h4 id="为什么不用平衡树">为什么不用平衡树？</h4><ul><li><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第1 层链表进行若干步的遍历就可以实现。</li><li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li><li><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。平衡树每个节点包含2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为1/(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取p=1/4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li></ul><h3 id="quicklist">quicklist</h3><p>quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist就是一个链表，而链表中的每个元素又是一个压缩列表。<strong>过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong></p><figure><imgsrc="https://cdn.xiaolincoding.com//mysql/other/f46cbe347f65ded522f1cc3fd8dba549.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="listpack">listpack</h3><figure><imgsrc="https://cdn.xiaolincoding.com//mysql/other/c5fb0a602d4caaca37ff0357f05b0abf.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>listpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack的节点了。</p><p>每个entry主要包含三个方面内容：</p><ul><li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li><li>data，实际存放的数据；</li><li>len，encoding+data的总长度；</li></ul><h2 id="持久化">持久化</h2><h3 id="aof日志">AOF日志</h3><h4 id="实现方式">实现方式</h4><p>下面这种保存写操作命令到日志的持久化方式，就是 Redis 里的<strong>AOF(Append Only File)</strong>持久化功能，<strong>注意只会记录写操作命令，读操作命令是不会被记录的</strong>，因为没意义。</p><figure><imgsrc="https://cdn.xiaolincoding.com//mysql/other/6f0ab40396b7fc2c15e6f4487d3a0ad7.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>但是这么做有两个风险：</p><ol type="1"><li><p>执行写操作命令和记录日志是两个过程，那当 Redis在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有<strong>丢失的风险</strong>。</p></li><li><p>由于写操作命令执行成功后才记录到 AOF日志，所以不会阻塞当前写操作命令的执行，但是<strong>可能会给「下一个」命令带来阻塞风险</strong>。</p></li></ol><h4 id="三种写回策略">三种写回策略</h4><ol type="1"><li><p>Redis 执行完写操作命令后，会将命令追加到<code>server.aof_buf</code> 缓冲区；</p></li><li><p>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 pagecache，等待内核将数据写入硬盘；</p></li><li><p>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</p><p>在 <code>redis.conf</code> 配置文件中的 <code>appendfsync</code>配置项可以有以下 3 种参数可填：</p><ul><li><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将AOF 日志数据写回硬盘；</li><li><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li><li><strong>No</strong>，意味着不由 Redis控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li></ul></li></ol><p><img src="https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a.png" alt="img" style="zoom:50%;" /></p><h4 id="重写机制">重写机制</h4><p>AOF重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF文件。</p><p>这个过程其实是很耗时的，所以重写的操作不能放在主进程里。所以，Redis的<strong>重写 AOF 过程是由后台子进程 *bgrewriteaof*来完成的</strong>，这么做可以达到两个好处：</p><ul><li>子进程进行 AOF重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li><li>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li></ul><p>还有个问题，重写 AOF 日志过程中，如果主进程修改了已经存在key-value，此时这个 key-value数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</p><p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof子进程之后开始使用。</p><p>在重写 AOF 期间，当 Redis执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF缓冲区」和 「AOF 重写缓冲区」</strong>。</p><p>当子进程完成 AOF重写工作后，会向主进程发送一条信号，主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p><ul><li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个AOF 文件所保存的数据库状态一致；</li><li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li></ul><h3 id="rdb快照">RDB快照</h3><p>RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF文件记录的是命令操作的日志，而不是实际的数据。</p><p>因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将RDB 文件读入内存就可以，不需要像 AOF那样还需要额外执行操作命令的步骤才能恢复数据。</p><p>所以可以认为，执行快照是一个比较重的操作，如果频率太频繁，可能会对Redis性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。通常可能设置至少5 分钟才保存一次快照，这时如果 Redis出现宕机等情况，则意味着最多可能丢失 5 分钟数据。这就是 RDB快照的缺点，在服务器发生故障时，丢失的数据会比 AOF持久化的方式更多，因为 RDB快照是全量快照的方式，因此执行的频率不能太频繁，否则会影响 Redis性能，而 AOF日志可以以秒级的方式记录操作命令，所以丢失的数据就相对更少。</p><p>Redis 在使用 bgsave快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB快照都无法写入主线程刚修改的数据，因为此时主线程（父进程）的内存数据和子进程的内存数据已经分离了，子进程写入到RDB 文件的内存数据只能是原本的内存数据。</p><h3 id="混合持久化">混合持久化</h3><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>。</p><p>当开启了混合持久化时，在 AOF 重写日志时，<code>fork</code>出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF格式的 AOF 文件替换旧的的 AOF 文件。</p><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p><h2 id="过期删除">过期删除</h2><p>常见的三种过期删除策略：</p><ul><li>定时删除：<strong>在设置 key的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行key 的删除操作。</strong></li><li>惰性删除：<strong>不主动删除过期键，每次从数据库访问 key 时，都检测key 是否过期，如果过期则删除该 key。</strong></li><li>定期删除：<strong>每隔一段时间「随机」从数据库中取出一定数量的 key进行检查，并删除其中的过期key。</strong></li></ul><p><strong>Redis选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU时间和避免内存浪费之间取得平衡。</p><h2 id="内存淘汰">内存淘汰</h2><p><em>1、不进行数据淘汰的策略</em></p><p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略）：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入，不淘汰任何数据，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。</p><p><em>2、进行数据淘汰的策略</em></p><p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。</p><p>在设置了过期时间的数据中进行淘汰：</p><ul><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li><li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li><li><strong>volatile-lru</strong>（Redis3.0之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li><li><strong>volatile-lfu</strong>（Redis 4.0后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li></ul><p>在所有数据范围内进行淘汰：</p><ul><li><strong>allkeys-random</strong>：随机淘汰任意键值;</li><li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li><li><strong>allkeys-lfu</strong>（Redis 4.0后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li></ul><h3 id="lru算法">LRU算法</h3><p><strong>LRU</strong> 全称是 Least Recently Used翻译为<strong>最近最少使用</strong>，会选择淘汰最近最少使用的数据。</p><p>传统 LRU算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p><p>Redis 实现的是一种<strong>近似 LRU算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。当Redis进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p><p>但是 LRU算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在Redis 缓存中很长一段时间，造成缓存污染。</p><h3 id="lfu算法">LFU算法</h3><p>LFU 全称是 Least Frequently Used翻译为<strong>最近最不常用</strong>，LFU算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p><p>所以， LFU算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于LRU 算法也更合理一些。</p><p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU算法下使用方式并不相同。</p><p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru字段是用来记录 key 的访问时间戳，因此在 LRU模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key的访问时间长，从而淘汰最久未被使用的 key。</p><p><strong>在 LFU 算法中</strong>，Redis对象头的 24 bits 的 lru字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，低 8bit存储 logc(Logistic Counter)。</p><ul><li>ldt 是用来记录 key 的访问时间戳；</li><li>logc 是用来记录 key的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key的logc 初始值为 5。</li></ul><p>注意，logc 并不是单纯的访问次数，而是访问频次（访问频率），因为<strong>logc 会随时间推移而衰减的</strong>。</p><p>在每次 key 被访问时，会先对 logc做一个衰减操作，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的LFU算法是根据<strong>访问频率</strong>来淘汰数据的，而不只是访问次数。访问频率需要考虑key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。</p><p>对 logc 做完衰减操作后，就开始对 logc进行增加操作，增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc越大的 key，它的 logc 就越难再增加。</p><p>所以，Redis 在访问 key 时，对于 logc 是这样变化的：</p><ol type="1"><li>先按照上次访问距离当前的时长，来对 logc 进行衰减；</li><li>然后，再按照一定概率增加 logc 的值</li></ol><p>redis.conf 提供了两个配置项，用于调整 LFU 算法从而控制 logc的增长和衰减：</p><ul><li><code>lfu-decay-time</code> 用于调整 logc的衰减速度，它是一个以分钟为单位的数值，默认值为1，lfu-decay-time值越大，衰减越慢；</li><li><code>lfu-log-factor</code> 用于调整 logc 的增长速度，lfu-log-factor值越大，logc 增长越慢。</li></ul><h2 id="缓存问题">缓存问题</h2><h3 id="缓存雪崩">缓存雪崩</h3><p>当<strong>大量缓存数据在同一时间过期（失效）或者 Redis故障宕机</strong>时，如果此时有大量的用户请求，都无法在 Redis中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是<strong>缓存雪崩</strong>的问题。</p><ol type="1"><li><p>大数据量同时过期:</p><ul><li><p>均匀设置过期时间</p><p>如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</p></li><li><p>互斥锁</p><p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到Redis里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p></li><li><p>后台更新缓存</p></li></ul></li><li><p>Redis故障宕机</p><ul><li><p>服务熔断或请求限流机制</p><p><strong>服务熔断</strong>机制:<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong>，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到Redis 恢复正常后，再允许业务应用访问缓存服务。</p><p><strong>请求限流</strong>机制:<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p></li><li><p>构建 Redis 缓存高可靠集群</p><p>如果 Redis缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于Redis 故障宕机而导致的缓存雪崩问题。</p></li></ul></li></ol><h3 id="缓存击穿">缓存击穿</h3><p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮。</p><ul><li>互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li><li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li></ul><h3 id="缓存穿透">缓存穿透</h3><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p><p>缓存穿透的发生一般有这两种情况：</p><ul><li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li><li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li></ul><p>应对缓存穿透的方案，常见的方案有三种。</p><ul><li><p>第一种方案，非法请求的限制；</p><p>当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</p></li><li><p>第二种方案，缓存空值或者默认值；</p><p>当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</p></li><li><p>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；</p><p>我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。</p><p>即使发生了缓存穿透，大量请求只会查询 Redis和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis自身也是支持布隆过滤器的。</p></li></ul><h4 id="布隆过滤器">布隆过滤器</h4><figure><imgsrc="https://cdn.xiaolincoding.com//mysql/other/86b0046c2622b2c4bda697f9bc0f5b28.png"alt="图片" /><figcaption aria-hidden="true">图片</figcaption></figure><p>在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6位置的值设置为 1。<strong>当应用要查询数据 x是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6位置的值是否全为 1，只要有一个为 0，就认为数据 x不在数据库中</strong>。</p><h3 id="数据一致性">数据一致性</h3><ol type="1"><li><p>先更新数据库 &amp; 先更新缓存</p><p><strong>无论是「先更新数据库，再更新缓存」，还是「先更新缓存，再更新数据库」，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象</strong>。如果非要选一个,就先更新数据库再更新缓存,因为更新缓存比较快,发生并发问题的概率比较小.</p></li><li><p>先更新数据库 &amp; 先删除缓存</p><p>二者也都是会出现并发问题,删除一个数据，相比更新一个数据更加轻量级，出问题的概率更小。<strong>「先更新数据库+再删除缓存」的方案，更好一些,原因同上</strong>.为了确保万无一失，还给缓存数据加上了「<strong>过期时间</strong>」，就算在这期间存在缓存数据不一致，有过期时间来兜底，这样也能达到最终一致。</p><p>如果删除缓存失败了怎么办?</p><p>如果删除缓存失败,会导致缓存和数据库的短期不一致性.我们可以引入<strong>消息队列</strong>，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。</p><ul><li>如果应用<strong>删除缓存失败</strong>，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是<strong>重试机制</strong>。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li><li>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li></ul></li></ol><p>「先更新数据库，再删除缓存」的方案虽然保证了数据库与缓存的数据一致性，但是每次更新数据的时候，缓存的数据都会被删除，这样会对缓存的命中率带来影响。所以，<strong>如果我们的业务对缓存命中率有很高的要求，我们可以采用「更新数据库+更新缓存」的方案，因为更新缓存并不会出现缓存未命中的情况</strong>。</p><p>所以我们得增加一些手段来解决这个问题，这里提供两种做法：</p><ul><li>在更新缓存前先加个<strong>分布式锁</strong>，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就会带来影响。</li><li>在更新完缓存时，给缓存加上较短的<strong>过期时间</strong>，这样即时出现缓存不一致的情况，缓存的数据也会很快过期，对业务还是能接受的。</li></ul><h2 id="高可用">高可用</h2><h3 id="主从复制">主从复制</h3><p><img src="https://cdn.xiaolincoding.com//mysql/other/2b7231b6aabb9a9a2e2390ab3a280b2d-20230309232920063.png" alt="图片" style="zoom:67%;" /></p><h4 id="首次同步">首次同步</h4><figure><imgsrc="https://cdn.xiaolincoding.com//mysql/other/ea4f7e86baf2435af3999e5cd38b6a26.png"alt="图片" /><figcaption aria-hidden="true">图片</figcaption></figure><h4 id="增量复制">增量复制</h4><p>如果主从服务器间的网络连接断开了，那么就无法进行命令传播了，这时从服务器的数据就没办法和主服务器保持一致了，客户端就可能从「从服务器」读到旧的数据。如果此时断开的网络，又恢复正常了，要怎么继续保证主从服务器的数据一致性呢？</p><ul><li>从服务器在恢复网络后，会发送 psync 命令给主服务器，此时的 psync命令里的 offset 参数不是 -1；</li><li>主服务器收到该命令后，然后用 CONTINUE响应命令告诉从服务器接下来采用增量复制的方式同步数据；</li><li>然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</li></ul><p><strong>主服务器怎么知道要将哪些增量数据发送给从服务器呢？</strong></p><p>在主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会将写命令写入到repl_backlog_buffer 缓冲区里，因此这个缓冲区里会保存着最近传播的写命令。</p><p>网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync命令将自己的复制偏移量 slave_repl_offset发送给主服务器，主服务器根据自己的 master_repl_offset 和slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：</p><ul><li>如果判断出从服务器要读取的数据还在 repl_backlog_buffer缓冲区里，那么主服务器将采用<strong>增量同步</strong>的方式；</li><li>相反，如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer缓冲区里，那么主服务器将采用<strong>全量同步</strong>的方式。</li></ul><h3 id="哨兵机制">哨兵机制</h3><p>在 Redis的主从架构中，由于主从模式是读写分离的，如果主节点（master）挂了，那么将没有主节点来服务客户端的写操作请求，也没有主节点给从节点（slave）进行数据同步了。<strong>哨兵（*Sentinel*）机制</strong>的作用是实现<strong>主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p><h4 id="如何判断主节点故障">如何判断主节点故障</h4><p>哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。如果主节点或者从节点没有在规定的时间内响应哨兵的PING命令，哨兵就会将它们标记为「<strong>主观下线</strong>」当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。当这个哨兵的赞同票数达到哨兵配置文件中的quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。</p><p>哨兵判断完主节点客观下线后，哨兵就要开始在多个「从节点」中，选出一个从节点来做新主节点。</p><h4 id="主从故障转移">主从故障转移</h4><ul><li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。</li><li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li><li>第三步：将新主节点的 IP地址和信息，通过「发布者/订阅者机制」通知给客户端；</li><li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li></ul><h4 id="主节点如何选举">主节点如何选举</h4><ol type="1"><li>过滤 :“不健康”( 主观下线、断线)、5 秒内没有回复过 Sentinel节点ping响应、与主节点失联超过 down-after-milliseconds*10秒。</li><li>选择slave-priority( 从节点优先级 )最高的从节点列表,如果存在则返回,不存在则继续。</li><li>选择复制偏移量最大的从节点(复制的最完整),如果存在则返回,不存在则继续。</li><li>选择runid最小的从节点。</li></ol><h3 id="集群">集群</h3><h4 id="好处">好处</h4><ol type="1"><li>数据分区: 数据分区 (或称数据分片)是集群最核心的功能。集群将数据分散到多个节点,一方面突破了 Redis单机内存大小的限制, 存储容量大大增加;另一方面每个主节点都可以对外提供读服务和写服务,大大提高了集群的响应能力。</li><li>高可用: 集群支持主从复制和主节点的自动故障转移 (与哨兵类似),当任一节点发生故障时,集群仍然可以对外提供服务。</li></ol><h4 id="集群分区">集群分区</h4><p>其中的虚拟节点称为槽(slot)。槽是介于数据和实际节点之间的虚拟概念,每个实际节点包含一定数量的槽 , 每个槽包含哈希值在一定范围内的数据。</p><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240513154413.png" style="zoom:50%;" /></p><p>在使用了槽的一致性哈希分区中,槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点之间的关系,增加或删除节点对系统的影响很小。仍以上图为例,系统中有 4 个实际节点,假设为其分配 16 个槽(0-15); 槽 0-3 位于 node1;4-7 位于 node2; 以此类推.... 如果此时删除 node2 , 只需要将槽 4-7重新分配即可,例如槽 4-5 分配给 node1 , 槽 6 分配给 node3 , 槽 7 分配给node4 ,数据在其他节点的分布仍然较为均衡。</p><h2 id="其他问题">其他问题</h2><h3 id="热点key">热点key</h3><h4 id="监视热点key">监视热点key</h4><p>使用monitor命令统计热点 key,monitor命令可以监控到 Redis执行的所有命令</p><h4 id="解决办法">解决办法</h4><ol type="1"><li>把热 key打散到不同的服务器，降低压力</li><li>加入二级缓存，提前加载热 key数据到内存中，如果redis宕机，走内存查询</li></ol><h4 id="热点key重建">热点key重建</h4><p>开发的时候一般使用“缓存+ 过期时间”的策略,既可以加速数据读写,又保证数据的定期更新,这种模式基本能够满足绝大部分需求。但是有两个问题如果同时出现,可能就会出现比较大的问题:</p><ol type="1"><li>当前key是一个热点 key( 例如一个热门的娱乐新闻 ),并发量非常大。</li><li>重建缓存不能在短时间完成,可能是一个复杂计算 , 例如复杂的SQL、多次IO、多个依赖等。在缓存失效的瞬间,有大量线程来重建缓存,造成后端负载加大,甚至可能会让应用崩溃。</li></ol><p>解决办法：</p><ol type="1"><li>互斥锁 ( mutex key)。这种方法只允许一个线程重建缓存,其他线程等待重建缓存的线程执行完 ,重新从缓存获取数据即可。</li><li>永远不过期。从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期后产生的问题，也就是“物理”不过期。从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。</li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>八股-MySQL</title>
    <link href="/2024/04/18/SoftwareDevelopment/%E5%85%AB%E8%82%A1-MySQL/"/>
    <url>/2024/04/18/SoftwareDevelopment/%E5%85%AB%E8%82%A1-MySQL/</url>
    
    <content type="html"><![CDATA[<p>MySQL学习 <span id="more"></span></p><h2 id="mysql执行流程">MySQL执行流程</h2><p><imgsrc="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240418152931.png" /></p><ul><li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在Server 层实现。</li><li><strong>存储引擎层负责数据的存储和提取</strong>。支持InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了MySQL的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如InnoDB 支持索引类型是 B+树，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是B+ 树索引。</li></ul><h3 id="连接器">连接器</h3><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><h3 id="查询缓存">查询缓存</h3><p>如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ QueryCache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL语句查询的结果。只要一个表有更新操作，那么这个表的查询缓存就会被清空，效率不高，所以MySQL8.0 版本直接将查询缓存删掉了</p><h3 id="解析sql">解析SQL</h3><ul><li>词法分析，根据输入的字符串识别出关键字出来</li><li>语法分析，判断输入的 SQL 语句是否满足 MySQL语法，如果没问题就会构建出 SQL 语法树，</li></ul><h3 id="执行sql">执行SQL</h3><h4 id="预处理器">预处理器</h4><ul><li>检查 SQL 查询语句中的表或者字段是否存在；</li><li>将 <code>select *</code> 中的 <code>*</code>符号，扩展为表上的所有列；</li></ul><h4 id="优化器">优化器</h4><p><strong>负责将 SQL查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><h4 id="执行器">执行器</h4><p>在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。</p><ul><li><p>主键索引查询</p><ul><li>执行器第一次查询，会调用 read_first_record函数指针指向的函数，因为优化器选择的访问类型为const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件<code>id = 1</code>交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>。</li><li>存储引擎通过主键索引的 B+ 树结构定位到 id =1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；</li><li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</li><li>执行器查询的过程是一个 while循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用read_record 函数指针指向的函数，因为优化器选择的访问类型为const，这个函数指针被指向为一个永远返回 - 1的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</li></ul></li><li><p>全表扫描</p><ul><li>执行器第一次查询，会调用 read_first_record函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为InnoDB引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</li><li>执行器会判断读到的这条记录的 name 是不是iphone，如果不是则跳过；如果是则将记录发给客户的（是的没错，Server层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用read_record 函数指针指向的函数，因为优化器选择的访问类型为all，read_record 函数指针指向的还是 InnoDB引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</li><li>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层）返回了读取完毕的信息；</li><li>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</li></ul></li><li><p>索引下推</p><p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user  <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> reward <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br></code></pre></td></tr></table></figure></p><ul><li><p>对 age 和 reward 字段建立了联合索引（age，reward）</p></li><li><p>Server层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到age &gt; 20 的第一条记录；</p></li><li><p>存储引擎定位到二级索引后，如果没有索引下推，会进行回表操作，得到全部信息后在Server层判断reward是否等于100000，如果有索引下推，<strong>先不执行回表</strong>操作，而是先判断一下该索引中包含的列（reward列）的条件（reward是否等于100000）是否成立。如果<strong>条件不成立</strong>，则直接<strong>跳过该二级索引</strong>。如果<strong>成立</strong>，则<strong>执行回表</strong>操作，将完成记录返回给Server 层。</p></li><li><p>Server层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。</p></li><li><p>如此往复，直到存储引擎把表中的所有记录读完。</p></li></ul></li></ul><h2 id="mysql一行记录存储">MySQL一行记录存储</h2><h3 id="表空间文件的结构">表空间文件的结构</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" alt="img" style="zoom:50%;" /></p><p><strong>InnoDB的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</p><p>InnoDB 存储引擎是用 B+ 树来组织数据的。B+树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机I/O是非常慢的。解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p><p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为1MB，对于 16KB 的页来说，连续的 64个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序I/O 了</strong>。</p><h3 id="innodb的页格式">InnoDB的页格式</h3><p>在 File Header中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/557d17e05ce90f18591c2305871af665.png" alt="图片" style="zoom:50%;" /></p><p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/261011d237bec993821aa198b97ae8ce.png" alt="图片" style="zoom:50%;" /></p><h3 id="compact行格式">COMPACT行格式</h3><figure><imgsrc="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li><p>变长字段长度列表：对于varchar、TEXT、BLOB等数据格式是变长的，需要存储字段的长度。这些变长字段的真实数据占用的字节数会按照列的顺序<strong>逆序存放</strong>，这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。</p></li><li><p>NULL值列表：如果存在允许 NULL值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p></li><li><p>记录头信息：有很多</p><ul><li>delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的delete_mask 标记为 1。</li><li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li><li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li></ul></li><li><p>真实数据：</p><p>除了每一列的数据还有下面三个额外属性：</p><ol type="1"><li><p>row_id:如果我们建表的时候指定了主键或者唯一约束列，那么就没有row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6个字节。</p></li><li><p>trx_id:事务id，表示这个数据是由哪个事务生成的。trx_id是必需的，占用 6 个字节。</p></li><li><p>roll_pointer:这条记录上一个版本的指针。roll_pointer是必需的，占用 7 个字节。</p></li></ol></li></ol><h3 id="行溢出">行溢出</h3><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是<code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n)类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p><p>对于COMPACT，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p><p>Compressed 和Dynamic采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。</p><h2 id="索引">索引</h2><h3 id="为什么使用b树">为什么使用B+树？</h3><p><strong><em>1、B+Tree vs B Tree</em></strong></p><p>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O次数下，就能查询更多的节点。</p><p>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p><p><strong><em>2、B+Tree vs 二叉树</em></strong></p><p>对于有 N 个叶子节点的B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d表示节点允许的最大子节点个数为 d 个。</p><p>在实际的应用当中， d值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4次的磁盘 I/O 操作就能查询到目标数据。</p><p>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为<code>O(logN)</code>，这已经比 B+Tree高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。</p><p><strong><em>3、B+Tree vs Hash</em></strong></p><p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p><p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree索引要比 Hash 表索引有着更广泛的适用场景的原因</p><p>### 创建索引逻辑</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id列作为聚簇索引的索引键（key）；</li></ul><h3 id="联合索引的最左匹配">联合索引的最左匹配</h3><p>联合索引的最左匹配原则，在遇到范围查询（如&gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于&gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。</p><h3 id="优化索引">优化索引</h3><ol type="1"><li><p>前缀索引优化</p><p>前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，不过，前缀索引有一定的局限性，例如：</p><ul><li>order by 就无法使用前缀索引；</li><li>无法把前缀索引用作覆盖索引；</li></ul></li><li><p>覆盖索引优化</p><p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p></li><li><p>主键索引自增</p><p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p><p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p></li><li><p>索引最好设置为 NOT NULL</p><ul><li>索引列存在 NULL就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count会省略值为NULL 的行。</li><li>NULL值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么<ahref="https://xiaolincoding.com/mysql/base/row_format.html#innodb-行格式有哪些">行格式(opens new window)</a>中<strong>至少会用 1 字节空间存储 NULL值列表</strong>：</li></ul></li></ol><h3 id="索引失效">索引失效</h3><ul><li><p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code>或者 <code>like %xx%</code>这两种方式都会造成索引失效；</p><p>使用左模糊匹配（like"%xx"）并不一定会走全表扫描，关键还是看数据表中的字段。如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)。</p></li><li><p>当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</p><p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。<strong>MySQL在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。</p></li><li><p>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</p><p>比如，如果创建了一个 <code>(a, b, c)</code>联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a=1；</li><li>where a=1 and b=2 and c=3；</li><li>where a=1 and b=2；</li></ul><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b=2；</li><li>where c=3；</li><li>where b=2 and c=3；</li></ul></li><li><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR后的条件列不是索引列，那么索引会失效。</p></li></ul><h2 id="事务">事务</h2><h3 id="四大特性">四大特性</h3><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h3 id="并行事务问题">并行事务问题</h3><h4 id="脏读">脏读</h4><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240418214602.png" style="zoom: 67%;" /></p><p>因为事务 A是还没提交事务的，也就是它随时可能发生回滚操作，<strong>如果在上面这种情况事务A 发生了回滚，那么事务 B刚才得到的数据就是过期的数据，这种现象就被称为脏读。</strong></p><h4 id="不可重复读">不可重复读</h4><p><img src="https://cdn.xiaolincoding.com//mysql/other/f5b4f8f0c0adcf044b34c1f300a95abf.png" alt="图片" style="zoom:67%;" /></p><p><strong>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</strong></p><h4 id="幻读">幻读</h4><p><img src="https://cdn.xiaolincoding.com//mysql/other/d19a1019dc35dfe8cfe7fbff8cd97e31.png" alt="图片" style="zoom:67%;" /></p><p><strong>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</strong></p><h3 id="事务的隔离级别">事务的隔离级别</h3><ul><li><strong>读未提交（*readuncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读提交（*readcommitted*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（*repeatableread*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQLInnoDB 引擎的默认隔离级别</strong>；</li><li><strong>串行化（*serializable*）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><h3 id="mvcc">MVCC</h3><h4 id="readview">ReadView</h4><p>Read View 有四个重要的字段：</p><ul><li>m_ids ：指的是在创建 Read View时，当前数据库中「活跃事务」的<strong>事务 id列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li><li>min_trx_id ：指的是在创建 Read View时，当前数据库中「活跃事务」中事务 <strong>id最小的事务</strong>，也就是 m_ids 的最小值。</li><li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View时当前数据库中应该给下一个事务的 id值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li><li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务id</strong>。</li></ul><p>对于使用 InnoDB存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：</p><ul><li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务id 记录在 trx_id 隐藏列里</strong>；</li><li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到undo日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li></ul><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ul><li><p>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code>值，表示这个版本的记录是在创建 Read View<strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</p></li><li><p>如果记录的 trx_id 值大于等于 Read View 中的<code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View<strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</p></li><li><p>如果记录的 trx_id 值在 Read View的min_trx_id和max_trx_id之间，需要判断 trx_id 是否在 m_ids 列表中：</p><ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id <strong>不在</strong><code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul><p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫MVCC（多版本并发控制）。</strong></p><h4 id="可重复读">可重复读</h4><p>可重复读隔离级别是启动事务时生成一个 ReadView，然后整个事务期间都在用这个 Read View。</p><h4 id="读提交">读提交</h4><p>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。</p><h4 id="能解决幻读问题吗">能解决幻读问题吗</h4><ul><li><p>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过MVCC方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</p></li><li><p>针对<strong>当前读</strong>（select ... for update等语句），是<strong>通过 next-keylock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select ... forupdate 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，直到当前事务提交，所以就很好了避免幻读问题。</p><p>事务 A 执行了这面这条锁定读语句后，就在对表中的记录加上 id 范围为 (2,+∞] 的 next-key lock（next-key lock 是间隙锁+记录锁的组合）。然后，事务B 在执行插入语句的时候，判断到插入的位置被事务 A 加了 next-keylock，于是事物 B 会生成一个插入意向锁，同时进入等待状态，直到事务 A提交了事务。这就避免了由于事务 B 插入新记录而导致事务 A发生幻读的现象。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/3af285a8e70f4d4198318057eb955520.png" alt="img" style="zoom: 67%;" /></p></li></ul><p>发生幻读的情景：</p><ol type="1"><li><p>事务 A 先执行「快照读语句」：select * from t_test where id &gt;100 得到了 3 条记录。事务 B 往插入一个 id= 200 的记录并提交；事务 A再执行「当前读语句」 select * from t_test where id &gt; 100 for update就会得到 4 条记录，此时也发生了幻读现象。</p></li><li><p>事务 A 执行查询 id = 5的记录，此时表中是没有该记录的，所以查询不出来。然后事务 B 插入一条 id =5 的记录，并且提交了事务。<strong>事务 A 更新 id = 5这条记录，然后再次查询 id = 5 的记录，事务 A 就能看到事务 B插入的纪录了</strong></p></li></ol><h2 id="日志">日志</h2><h3 id="undo-log">undo log</h3><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执行了 ROLLBACK 语句，MySQL 可以利用 undo log中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC是通过 ReadView + undo log 实现的。undo log为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log的版本链找到满足其可见性的记录。 undo log和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。</li></ul><h3 id="buffer-pool">Buffer Pool</h3><p>MySQL的数据都是存在磁盘中的，那么我们要更新一条记录的时候，得先要从磁盘读取该记录，然后在内存中修改这条记录。修改完这条记录后会把记录缓存起来，这样下次有查询语句命中了这条记录，直接读取缓存中的记录，就不需要从磁盘获取数据了。为此，Innodb存储引擎设计了一个<strong>缓冲池（BufferPool）</strong>，来提高数据库的读写性能。</p><h3 id="redo-log">redo log</h3><h4 id="redo-log作用">redo log作用</h4><ul><li><p><strong>实现事务的持久性，让 MySQL 有 crash-safe的能力</strong>，能够保证 MySQL在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</p><p>redo log 是物理日志，记录了某个数据页做了什么修改，比如<strong>对 XXX表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><p>在事务提交时，只要先将 redo log持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool里的脏页数据持久化到磁盘。</p><p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p><p>事务提交之前发生了崩溃，重启后会通过 undo log回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log恢复事务.可以看出来， <strong>redo log保证了事务四大特性中的持久性</strong>。</p></li><li><p><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL写入磁盘的性能。</p><p>写入 redo log 的方式使用了追加操作，所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。磁盘的「顺序写」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</p></li></ul><h4 id="redo-log直接写磁盘吗">redo log直接写磁盘吗？</h4><p>redo log 也有自己的缓存—— <strong>redo logbuffer</strong>，每当产生一条 redo log 时，会先写入到 redo logbuffer，后续再持久化到磁盘。</p><p>持久化时机：</p><ul><li><p>MySQL 正常关闭时；</p></li><li><p>当 redo log buffer 中记录的写入量大于 redo log buffer内存空间的一半时，会触发落盘；</p></li><li><p>InnoDB 的后台线程每隔 1 秒，将 redo log buffer持久化到磁盘。</p></li><li><p>每次事务提交时都将缓存在 redo log buffer 里的 redo log直接持久化到磁盘</p><p><code>innodb_flush_log_at_trx_commit</code>参数控制，可取的值有：0、1、2，默认值为1，这三个值分别代表的策略如下：</p><ul><li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时，还是<strong>将 redo log 留在 redo log buffer 中</strong>，该模式下在事务提交时不会主动触发写入磁盘的操作。会把缓存在 redo logbuffer 中的 redo log ，通过调用 <code>write()</code> 写到操作系统的 PageCache，然后调用 <code>fsync()</code> 持久化到磁盘。<strong>所以参数为 0的策略，MySQL 进程的崩溃会导致上一秒钟所有事务数据的丢失</strong>;</li><li>当设置该<strong>参数为 1时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL异常重启之后数据不会丢失。</li><li>当设置该<strong>参数为 2时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redolog <strong>写到 redo log 文件，注意写入到「 redo log文件」并不意味着写入到了磁盘</strong>，因为操作系统的文件系统中有个 PageCache.调用 fsync，将缓存在操作系统中 Page Cache 里的 redo log持久化到磁盘。<strong>所以参数为 2 的策略，较取值为 0 情况下更安全，因为MySQL进程的崩溃并不会丢失数据，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失</strong>。</li></ul></li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/innodb_flush_log_at_trx_commit2.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img" style="zoom:50%;" /></p><h4 id="redo-log文件满了怎么办">redo log文件满了怎么办</h4><p><strong>这时 MySQL 不能再执行新的更新操作，也就是说 MySQL会被阻塞</strong>，此时会停下来将 Buffer Pool中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint就会往后移动，然后 MySQL 恢复正常运行，继续执行新的更新操作。</p><h3 id="binlog">binlog</h3><p>MySQL 在完成一条更新操作后，Server 层还会生成一条binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog统一写 入 binlog 文件。binlog文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如SELECT 和 SHOW 操作。</p><h4 id="redo-log和binlog的区别">redo log和binlog的区别</h4><ol type="1"><li><p>适用对象不同</p><ul><li>binlog 是 MySQL 的 <strong>Server层实现的日志</strong>，所有存储引擎都可以使用；</li><li>redo log 是 Innodb 存储引擎实现的日志；</li></ul></li><li><p>文件格式不同</p><p>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED</p><ul><li><p>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog中（相当于记录了逻辑操作，所以针对这种格式， binlog可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT有动态函数的问题，比如你用了 uuid 或者 now这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</p></li><li><p>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现STATEMENT 下动态函数的问题。但 ROW的缺点是每行数据的变化结果都会被记录，比如执行批量 update语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在STATEMENT 格式下只会记录一个 update 语句而已；</p></li><li><p>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用ROW 模式和 STATEMENT 模式；</p></li></ul><p>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</p></li><li><p>写入方式不同</p><ul><li>binlog是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是<strong>全量的日志。</strong></li><li>redo log是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li></ul></li><li><p>用途不同：</p><ul><li><p>binlog 用于备份恢复、主从复制；</p></li><li><p>redo log 用于掉电等故障恢复。</p></li></ul></li></ol><h4 id="如果数据库数据被删了redo-log能恢复吗">如果数据库数据被删了，redolog能恢复吗</h4><p>不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。因为 redo log文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从redo log 文件里擦除。</p><p>binlog文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在binlog上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用binlog 文件恢复数据。</p><h4 id="主从复制">主从复制</h4><ul><li>MySQL 主库在收到客户端提交事务的请求之后，会先写入binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li><li>从库会创建一个专门的 I/O 线程，连接主库的 log dump线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log的中继日志里，再返回给主库“复制成功”的响应。</li><li>从库会创建一个用于回放 binlog 的线程，去读 relay log中继日志，然后回放 binlog更新存储引擎中的数据，最终实现主从的数据一致性。</li></ul><h4 id="什么时候刷盘">什么时候刷盘</h4><figure><imgsrc="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/binlogcache.drawio.png"alt="binlog cach" /><figcaption aria-hidden="true">binlog cach</figcaption></figure><p>虽然每个线程有自己 binlog cache，但是最终都写到同一个 binlog文件：</p><ul><li>图中的 write，指的就是指把日志写入到 binlog文件，但是并没有把数据持久化到磁盘，因为数据还缓存在文件系统的 pagecache 里，write 的写入速度还是比较快的，因为不涉及磁盘 I/O。</li><li>图中的 fsync，才是将数据持久化到磁盘的操作，这里就会涉及磁盘I/O，所以频繁的 fsync 会导致磁盘的 I/O 升高。</li></ul><p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog刷到磁盘上的频率：</p><ul><li>sync_binlog = 0 的时候，表示每次提交事务都只 write，不fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li><li>sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行fsync；</li><li>sync_binlog =N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N个事务后才 fsync。</li></ul><h3 id="update操作流程">update操作流程</h3><ol type="1"><li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id= 1 这一行记录：<ul><li>如果 id=1 这一行所在的数据页本来就在 buffer pool中，就直接返回给执行器更新；</li><li>如果记录不在 buffer pool，将数据页从磁盘读入到 bufferpool，返回记录给执行器。</li></ul></li><li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul><li>如果一样的话就不进行后续更新流程；</li><li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB层，让 InnoDB 真正的执行更新记录的操作；</li></ul></li><li>开启事务， InnoDB 层<strong>更新记录前，首先要记录相应的 undolog</strong>，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条undo log，undo log 会写入 Buffer Pool 中的 Undo页面，不过<strong>在内存修改该 Undo 页面后，需要记录对应的 redolog。</strong></li><li>InnoDB层开始更新记录，会<strong>先更新内存（同时标记为脏页），然后将记录写到redo log里面</strong>，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是<strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li><li>至此，一条记录更新完了。</li><li><strong>在一条更新语句执行完成后，然后开始记录该语句对应的binlog，</strong>此时记录的 binlog 会被保存到 binlogcache，并没有刷新到硬盘上的 binlog文件，在事务提交时才会统一将该事务运行过程中的所有 binlog刷新到硬盘。</li></ol><h3 id="两阶段提交">两阶段提交</h3><h5 id="为什么要两阶段提交">为什么要两阶段提交？</h5><p>主要解决redo log和bin log的同步问题，因为bin log用于主从辅助。</p><p>举个例子，假设 id = 1 这行数据的字段 name 的值原本是 'jay'，然后执行<code>UPDATE t_user SET name = 'xiaolin' WHERE id = 1;</code>如果在持久化 redo log 和 binlog两个日志的过程中，出现了半成功状态，那么就有两种情况：</p><ul><li><strong>如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而binlog 还没有来得及写入</strong>。MySQL 重启后，通过 redo log 能将Buffer Pool 中 id = 1 这行数据的 name 字段恢复到新值 xiaolin，但是binlog 里面没有记录这条更新语句，在主从架构中，binlog会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行 name字段是旧值 jay，与主库的值不一致性；</li><li><strong>如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redolog 还没有来得及写入</strong>。由于 redo log还没写，崩溃恢复以后这个事务无效，所以 id = 1 这行数据的 name字段还是旧值 jay，而 binlog 里面记录了这条更新语句，在主从架构中，binlog会被复制到从库，从库执行了这条更新语句，那么这一行 name 字段是新值xiaolin，与主库的值不一致性；</li></ul><h4 id="两阶段提交过程">两阶段提交过程</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="时刻 A 与时刻 B" style="zoom:50%;" /></p><p>从图中可看出，事务的提交过程有两个阶段，就是<strong>将 redo log的写入拆成了两个步骤：prepare 和commit，中间再穿插写入binlog</strong>，具体如下：</p><ul><li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）；</li><li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redolog 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</li></ul><p>不管是时刻 A（redo log 已经写入磁盘， binlog 还没写入磁盘），还是时刻B （redo log 和 binlog 都已经写入磁盘，还没写入 commit标识）崩溃，<strong>此时的 redo log 都处于 prepare 状态</strong>。</p><p>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：</p><ul><li><strong>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog完成刷盘，但是 binlog 还没有刷盘，则回滚事务</strong>。对应时刻 A崩溃恢复的情况。</li><li><strong>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和binlog 都已经完成了刷盘，则提交事务</strong>。对应时刻 B崩溃恢复的情况。</li></ul><h2 id="锁">锁</h2><h3 id="全局锁">全局锁</h3><p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p><p>如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC的支持，备份期间业务依然可以对数据进行更新操作。</p><h3 id="表级锁">表级锁</h3><h4 id="表锁">表锁</h4><p>表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p><h4 id="元数据锁mdl">元数据锁（MDL）</h4><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL写锁</strong>；</li></ul><p>当有线程在执行 select 语句（ 加 MDL读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p><p>反之，当有线程对表结构进行变更（ 加 MDL写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p><p>对于下面这个情况：</p><ol type="1"><li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select语句，此时就先对该表加上 MDL 读锁；</li><li>然后，线程 B 也执行了同样的 select语句，此时并不会阻塞，因为「读读」并不冲突；</li><li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li></ol><p>那么在线程 C 阻塞后，后续有对该表的 select语句，就都会被阻塞，如果此时有大量该表的 select语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。这是因为申请MDL锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p><h4 id="意向锁">意向锁</h4><ul><li>在使用 InnoDB引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li></ul><p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p><p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p><p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p><h4 id="auto-inc锁">AUTO-INC锁</h4><p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被<code>AUTO_INCREMENT</code>修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC锁释放掉。</p><p>在 MySQL 5.1.22 版本开始，InnoDB存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。一样也是在插入数据的时候，会为被<code>AUTO_INCREMENT</code>修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p><h3 id="行级锁">行级锁</h3><h4 id="record-lock">Record Lock</h4><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S锁(共享锁)和 X 锁（独占锁）之分的：</p><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X锁不兼容）。</li></ul><h4 id="gap-lock">Gap Lock</h4><p>Gap Lock称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p><p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id =4 这条记录了，这样就有效的防止幻读现象的发生。</p><h4 id="next-key-lock">Next-Key Lock</h4><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock的组合，锁定一个范围，并且锁定记录本身。</p><p>假设，表中有一个范围 id 为（3，5] 的 next-keylock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5这条记录。</p><h4 id="插入意向锁">插入意向锁</h4><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-keylock 也包含间隙锁）。</p><p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p><p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>八股-计算机网络</title>
    <link href="/2024/04/17/SoftwareDevelopment/%E5%85%AB%E8%82%A1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/04/17/SoftwareDevelopment/%E5%85%AB%E8%82%A1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>计算机网络学习</p><span id="more"></span><h3 id="网络分层模型">网络分层模型</h3><p>现在被提起最多的网络模型主要有两个，一个是国际标准化组织提出的OSI7层网络模型，一个是目前被广泛使用的TCP/IP四层网络模型。</p><h4 id="osi七层模型">OSI七层模型</h4><p>OSI七层网络模型自底向上分为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层，由于它比较复杂而且不实用，而且有些功能在多个层中重复出现，所以并没有被广泛使用。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417152617.png" /></p><h4 id="tcpip四层模型">TCP/IP四层模型</h4><p>自底向上分为网络接口层、网络层、传输层、应用层。</p><ol type="1"><li>应用层：主要提供两个终端设备上的<strong>应用程序</strong>之间信息交换的服务，它定义了信息交换的格式。应用层的协议比较丰富，而且和我们日常使用息息相关，比如浏览网页的HTTP，HTTPS，文件传输的FTP，解析域名的DNS等等。</li><li>传输层：传输层的主要任务就是负责向两台终端设备进程之间的通信<strong>提供通用的数据传输服务</strong>。协议主要包括TCP和UDP。</li><li>网络层：负责在若干设备组成的互联网上根据IP地址对数据包进行转发和路由。包含的协议有IP网际协议、ARP地址解析协议、NAT网络地址转换协议等等</li><li>网络接口层：将网络层交下来的 IP数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。包含的协议有点对点协议PPP、帧中继协议</li></ol><h4 id="为什么要分层">为什么要分层</h4><ol type="1"><li>各层之间相互独立，不需要关心其他层是如何实现的，只需要知道如何调用下层提供好的接口即可</li><li>提高整体灵活性，每一层都可以使用最适合的技术实现，只需要确保功能和接口不改变即可。符合高内聚低耦合的设计原则</li></ol><h3 id="网址处理流程">网址处理流程</h3><h4 id="域名解析工作流程">域名解析工作流程</h4><ol type="1"><li><p>首先查看浏览器缓存、操作系统缓存，hosts文件，如果有直接使用</p></li><li><p>客户端首先会发出一个 DNS 请求（UDP），并发给本地 DNS服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。</p><p>当客户端发出DNS查询时，它通常使用UDP协议发送到目标DNS服务器的端口53，当DNS响应数据超过512字节（UDP限制）时，会使用TCP来传输。</p></li><li><p>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到，则它直接返回IP 地址。如果没有，本地 DNS 会去问它的根域名服务器</p></li><li><p>根 DNS 收到来自本地 DNS的请求后，找到顶级域名服务器地址返回</p></li><li><p>本地DNS收到顶级域名服务器地址后再次发送请求</p></li><li><p>顶级域名服务器给出权威DNS服务器地址</p></li><li><p>本地DNS向权威DNS服务器发送请求</p></li><li><p>权威DNS查询后将IP返回</p></li></ol><h4 id="tcp">TCP</h4><h5 id="请求头结构">请求头结构</h5><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417162244.png" style="zoom:80%;" /></p><ol type="1"><li>首先，<strong>源端口号</strong>和<strong>目标端口</strong>号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</li></ol><p>​端口号如何获取？许多网络服务有默认端口号比如HTTP是80，HTTPS是443；其他的需要在URL中明确指出端口号。</p><ol start="2" type="1"><li>接下来有包的<strong>序</strong>号，这个是为了解决包乱序的问题。</li><li><strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。</li><li><strong>状态位</strong>。例如 <code>SYN</code>是发起一个连接，<code>ACK</code> 是回复，<code>RST</code>是重新连接，<code>FIN</code> 是结束连接等。TCP是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</li><li><strong>窗口大小</strong>。TCP要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力</li></ol><h5 id="分割数据">分割数据</h5><p>如果 HTTP 请求消息比较长，超过了 <code>MSS</code> 的长度，这时 TCP就需要把 HTTP的数据拆解成一块块的数据发送，而不是一次性发送所有数据。数据会被以<code>MSS</code>的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上TCP 头信息，然后交给 IP 模块来发送数据。</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417162623.png" style="zoom:67%;" /></p><h4 id="ip">IP</h4><h5 id="ip报文头部格式">IP报文头部格式</h5><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417162744.png" style="zoom:50%;" /></p><ol type="1"><li><p>在 IP 协议里面需要有<strong>源地址 IP</strong> 和<strong>目标地址 IP</strong></p></li><li><p>因为 HTTP 是经过 TCP 传输的，所以在 IP包头的<strong>协议号</strong>，要填写为<code>06</code>（十六进制），表示协议为 TCP。</p></li></ol><h4 id="mac">MAC</h4><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC地址等信息。</p><p>发送方MAC地址在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到MAC 头部就可以了。</p><p>接收方MAC地址需要ARP协议获取。如果对方和自己处于同一个子网中，ARP协议会在以太网中以<strong>广播</strong>的形式询问MAC地址，目标主机即可返回MAC地址。如果对方和自己不处于同一个子网，ARP协议广播获得默认路由的MAC地址并发送，由路由找到目标子网（路由器之间的传输也需要MAC地址）。</p><h3 id="http">HTTP</h3><h4 id="消息头常见字段">消息头常见字段</h4><ol type="1"><li>Host：指定请求将发送到的服务器的域名和端口号</li><li>Content-Length：表明了请求体的大小，解决粘包</li><li>Connection：用于客户端要求服务器使用「HTTP长连接」机制，以便其他请求复用。</li><li>Content-type：用于服务器回应时，告诉客户端，本次数据是什么格式。</li></ol><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417173130.png" style="zoom: 33%;" /></p><h4 id="常见状态码">常见状态码</h4><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417170858.png" style="zoom: 50%;" /></p><ol type="1"><li><strong>200 OK 表示一切正常</strong></li><li>204 No Content 没有响应体body数据</li><li>206 Partial Content应用于分块下载或断点续传，表示body数据是资源的一部分</li><li><strong>301 Moved Permanently表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL再次访问</strong></li><li><strong>302 Found表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL来访问</strong></li><li><strong>304 Not Modified不具有跳转的含义，表示资源未修改，告诉客户端可以继续使用缓存资源，用于缓存控制</strong></li><li>400 Bad request 表示客户端请求的报文有错误</li><li><strong>403 Forbidden表示服务器禁止访问资源，并不是客户端的请求出错</strong></li><li><strong>404 Not Found表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端</strong></li><li><strong>500 Internal Server Error 表示服务器发生错误</strong></li><li>501 Not Implemented 表示客户端请求的功能还不支持</li><li>502 Bad Gateway服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误</li><li><strong>503 Service Unavailable表示服务器当前很忙，暂时无法响应客户端</strong></li></ol><h4 id="粘包问题">粘包问题</h4><p><strong>粘包</strong>问题通常是指在使用基于流的传输协议（如TCP）时，由于TCP是一个面向流的协议，发送的数据段之间没有边界，导致接收端无法区分不同数据段的界限。</p><p><strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过Content-Length 字段作为 HTTP body的边界，这两个方式都是为了解决“粘包”的问题</strong>。</p><h4 id="http缓存">HTTP缓存</h4><h5 id="强制缓存">强制缓存</h5><p>只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边，响应头中Cache-Control存储一个相对时间用来判断是否过期。</p><h5 id="协商缓存">协商缓存</h5><p><strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><p>第一种：请求头部中的 <code>If-Modified-Since</code>字段与响应头部中的 <code>Last-Modified</code>字段实现，这两个字段的意思是：</p><ul><li>响应头部中的<code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li><li>请求头部中的<code>If-Modified-Since</code>：当资源过期了，发现响应头中具有Last-Modified 声明，则再次发起请求的时候带上 Last-Modified的时间，服务器收到请求后发现有 If-Modified-Since则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304走缓存。</li></ul><p>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的<code>ETag</code> 字段，这两个字段的意思是：</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的<code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag的值。服务器收到请求后进行比对，如果资源没有变化返回304，如果资源变化了返回 200。</li></ul><h4 id="https">HTTPS</h4><p>HTTPS 解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS安全协议，使得报文能够加密传输。</p><h5 id="混合加密">混合加密</h5><p>HTTPS采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><h5 id="摘要算法数字签名">摘要算法+数字签名</h5><p>用摘要算法（哈希函数）来计算出内容的哈希值，也就是内容的「指纹」，这个哈希值是唯一的，且无法通过哈希值推导出内容,保证消息的完整性。</p><p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 +哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。那为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决。</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li></ul><p>非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p><h5 id="数字证书">数字证书</h5><p>CA（数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417180053.png" style="zoom:67%;" /></p><h5 id="建立连接">建立连接</h5><p>基于 RSA 算法的 TLS 握手过程需要四次通信。</p><ol type="1"><li><p>首先，由客户端向服务器发起加密通信请求，也就是<code>ClientHello</code> 请求。</p><p>在这一步，客户端主要向服务器发送以下信息：</p><p>（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</p><p>（2）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。</p><p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p></li><li><p>服务器收到客户端请求后，向客户端发出响应，也就是<code>SeverHello</code>。服务器回应的内容有如下内容：</p><p>（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p><p>（2）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</p><p>（3）确认的密码套件列表，如 RSA 加密算法。</p><p>（4）服务器的数字证书。</p></li><li><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p></li></ol><p>​（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</p><p>​（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>​（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、ServerRandom、pre-masterkey），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><ol start="4" type="1"><li><p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）经过公钥加密后的信息之后，使用私钥解密，然后通过协商的加密算法，计算出本次通信的「会话秘钥」。</p><p>然后，向客户端发送最后的信息：</p><p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p></li></ol><p>基于 RSA 算法的 HTTPS存在「前向安全」的问题：如果服务端的私钥泄漏了，过去被第三方截获的所有TLS 通讯密文都会被破解。</p><p>为了解决这个问题，后面就出现了 ECDHE密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法。</p><h5 id="数字证书签发和验证流程">数字证书签发和验证流程</h5><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417180919.png" /></p><h4 id="http演变">HTTP演变</h4><h5 id="http1.1">HTTP1.1</h5><p>改进：</p><ul><li>使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li><li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p>不足：</p><ul><li>请求 /响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩<code>Body</code> 的部分；</li><li>没有请求优先级控制,只能按请求的顺序响应的；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>；</li><li>请求只能从客户端开始，服务器只能被动响应。</li></ul><h5 id="http2">HTTP2</h5><p>改进：</p><ul><li>头部压缩：如果同时发出多个请求，头是一样或相似的，HPACK会消除重复部分（在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了）</li><li>二进制格式：头信息和数据体都采用二进制格式，在HTTP1.1里面采用纯文本（ASCII编码）格式</li><li>并发传输：1 个 TCP 连接包含多个 Stream，<strong>针对不同的 HTTP请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream，也就是 HTTP/2 可以并行交错地发送请求和响应</strong>。</li><li>服务器主动推送资源：客户端和服务器<strong>双方都可以建立Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream必须是奇数号，而服务器建立的 Stream 必须是偶数号。</li></ul><p>不足：</p><p>HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给HTTP 应用，那么当「前 1个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2队头阻塞问题</p><h5 id="http3">HTTP3</h5><ol type="1"><li>无队头堵塞：<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。HTTP/2只要某个流中的数据包丢失了，其他流也会因此受影响。</li><li>更快的建立连接：UDP和TLS1.3合并到一起，只需要1个RTT即可连接</li><li>连接迁移：不使用源地址端口号、目标地址端口号进行连接，而是采用连接ID标记，这样4G切换WIFI就不会产生卡顿</li></ol><h3 id="tcp-1">TCP</h3><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417162244.png" style="zoom: 50%;" /></p><h4 id="特点">特点</h4><ul><li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP都可以保证一个报文一定能够到达接收端；</li><li><strong>字节流</strong>：用户消息通过 TCP协议传输时，消息可能会被操作系统「分组」成多个的 TCP报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且TCP 报文是「有序的」，当「前一个」TCP报文没有收到的时候，即使它先收到了后面的 TCP报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP报文会自动丢弃。</li></ul><h4 id="如何保证传输的可靠性">如何保证传输的可靠性？</h4><ol type="1"><li>基于数据块传输：应用数据被分割成TCP认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li><li>对失序数据包重新排序以及去重：TCP为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li><li>校验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</li><li>重传机制：在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答(ACK)。TCP重传机制主要有：基于计时器的重传（也就是超时重传）、快速重传（基于接收端的反馈信息来引发重传)、SACK(在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了)、D-SACK(重复SACK,在SACK的基础上，额外携带信息，告知发送方有哪些数据包自己重复接收了)。关于重传机制的详细介绍，可以查看详解T℃P超时与重传机制心这篇文章。</li><li>流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议(TCP利用滑动窗口实现流量控制)</li><li>拥塞控制：当网络拥塞时，减少数据的发送。TCP在发送数据的时候，需要考虑两个因素：一是接收方的接收能力，二是网络的拥塞程度。接收方的接收能力由滑动窗口表示，表示接收方还有多少缓冲区可以用来接收数据。网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。</li></ol><h4 id="三次握手">三次握手</h4><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417190236.png" style="zoom:50%;" /></p><h5 id="流程">流程</h5><ol type="1"><li>一开始，客户端和服务端都处于 <code>CLOSE</code>状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li><li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP首部的「序号」字段中，同时把 <code>SYN</code> (Synchronize)标志位置为<code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN报文发送给服务端，表示向服务端发起连接，该报文<strong>不包含应用层数据</strong>，之后客户端处于<code>SYN-SENT</code> 状态。</li><li>服务端收到客户端的 <code>SYN</code>报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入<code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code>标志位置为<code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于<code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文TCP 首部 <code>ACK</code> 标志位置为 <code>1</code>，其次「确认应答号」字段填入 <code>server_isn + 1</code>，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于<code>ESTABLISHED</code> 状态。</li><li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code>状态。</li></ol><h5 id="为什么是三次">为什么是三次？</h5><p>假设是两次，那么服务端收到SYN报文之后发送应答报文，然后就应该一直处于establish状态</p><ol type="1"><li><p>防止旧的重复连接初始化造成混乱</p><p>客户端先发送了 SYN（seq = 90）报文，然后客户端宕机了，而且这个 SYN报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了SYN（seq =100）报文。如果seq=90的报文先到达，那么服务器会发送第二次握手应答，客户端发现并不是自己想要的acknum（101），那么就会发送RST报文终止连接。</p><p>如果是两次握手连接，seq=90的报文到达之后服务器就会建立连接并且可以发送数据，直到收到客户端的RST报文才会停止。因此<strong>服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。</strong></p></li><li><p>同步双方初始序列号</p><p>所以当客户端发送携带「初始序列号」的 <code>SYN</code>报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p></li><li><p>避免资源浪费</p><p>如果客户端发送的 <code>SYN</code> 报文在网络中阻塞了，重复发送多次<code>SYN</code>报文，那么服务端在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p></li></ol><h5id="为什么每次建立连接初始化的序列号都不一样">为什么每次建立连接初始化的序列号都不一样</h5><ol type="1"><li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li></ol><p>​ RFC793 提到初始化序列号 ISN 随机生成算法：ISN = M + F(localhost,localport, remotehost, remoteport)。</p><ul><li><p>M是一个计时器，这个计时器每隔 4 微秒加1。</p></li><li><p>F 是一个 Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值，要保证 hash算法不能被外部轻易推算得出</p><p>如果序列号回绕的时间极短，我们就会再次面临之前延迟的报文抵达后序列号依然有效的问题。</p><p>为了解决这个问题，就需要有 TCP 时间戳。tcp_timestamps参数是默认开启的，开启了 tcp_timestamps 参数，TCP头部就会使用时间戳选项，它有两个好处，<strong>一个是便于精确计算 RTT，另一个是能防止序列号回绕（PAWS）</strong>。</p></li></ul><h5 id="既然-ip-层会分片为什么-tcp-层还需要-mss-呢">既然 IP层会分片，为什么 TCP 层还需要 MSS 呢？</h5><p><strong>如果一个 IP 分片丢失，整个 IP报文的所有分片都得重传</strong>。当某一个 IP 分片丢失后，接收方的 IP层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 +数据）」。</p><h5 id="握手报文丢失">握手报文丢失</h5><ol type="1"><li><p>第一次握手丢失</p><p>如果客户端迟迟收不到服务端的 SYN-ACK报文（第二次握手），就会触发「超时重传」机制，重传 SYN报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</p></li><li><p>第二次握手丢失</p><p>如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传SYN 报文</strong>。</p><p>如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传SYN-ACK 报文</strong>。</p></li><li><p>第三次握手丢失</p><p>服务端超时重传</p></li></ol><h5 id="syn攻击">SYN攻击</h5><p>开启 syncookies 功能就可以在不使用 SYN半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。</p><ul><li>当 「 SYN 队列」满之后，后续服务端收到 SYN包，不会丢弃，而是根据算法，计算出一个 <code>cookie</code> 值；</li><li>将 cookie值放到第二次握手报文的<strong>「序列号」</strong>里，然后服务端回第二次握手给客户端；</li><li>服务端接收到客户端的应答报文时，服务端会检查这个 ACK包的合法性。如果合法，将该连接对象放入到「 Accept 队列」。</li><li>最后应用程序通过调用 <code>accpet()</code> 接口，从「 Accept队列」取出的连接。</li></ul><h4 id="四次挥手">四次挥手</h4><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417213104.png" style="zoom:50%;" /></p><h5 id="三次挥手">三次挥手？</h5><p>当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启TCP_QUICKACK（默认情况就是没有开启，没有开启TCP_QUICKACK，等于就是在使用 TCP延迟确认机制）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p><h5 id="time_wait">TIME_WAIT</h5><ul><li><p>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</p><p>如果发送第四次挥手之后客户端直接关闭，服务端在关闭连接之前发送的<code>SEQ = 301</code>报文，被网络延迟了。接着，服务端以相同的四元组重新打开了新连接，前面被延迟的<code>SEQ = 301</code>这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。</p></li><li><p>保证「被动关闭连接」的一方，能被正确的关闭；</p><p>2MSL时间保证了如果第四次挥手报文丢失，服务端能够超时重传</p></li></ul><h5id="如果已经建立了连接但是客户端突然出现故障了怎么办">如果已经建立了连接，但是客户端突然出现故障了怎么办？</h5><ol type="1"><li>TCP保活机制：定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。默认保活时间是7200 秒。</li><li>心跳机制：keepalive_timeout用来指定 HTTP长连接的超时时间。如果设置了 HTTP 长连接的超时时间是 60 秒，web服务软件就会<strong>启动一个定时器</strong>，如果客户端在完成一个 HTTP请求后，在 60秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></li></ol><h5id="如果已经建立了连接但是服务端突然出现故障了怎么办">如果已经建立了连接，但是服务端突然出现故障了怎么办？</h5><p>TCP的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有TCP 连接资源，于是内核会发送第一次挥手 FIN报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成TCP 四次挥手的过程。</p><h4 id="重传">重传</h4><ol type="1"><li><p>超时重传</p><p>TCP 会在以下两种情况发生超时重传：</p><ul><li>数据包丢失</li><li>确认应答丢失</li></ul></li><li><p>快速重传</p><p>客户端连续三次发现ACK的是2，就会直接重传2号报文</p></li><li><p>SACK方法</p><p>需要在 TCP 头部「选项」字段里加一个 <code>SACK</code>的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p><p><imgsrc="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240417214625.png" /></p></li><li><p>DSACK</p><p><strong>使用了 SACK来告诉「发送方」有哪些数据被重复接收了。</strong></p></li></ol><p>​<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/12.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="ACK 丢包" style="zoom: 67%;" /></p><p>「接收方」发现数据是重复收到的，于是回了一个 SACK =3000~3500，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着<code>D-SACK</code>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/13.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="网络延时" style="zoom:50%;" /></p><p>接收方回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK是 D-SACK，表示收到了重复的包。</p><p>可见，<code>D-SACK</code> 有这么几个好处：</p><ol type="1"><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ol><h4 id="滑动窗口">滑动窗口</h4><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p><p><strong>累计应答</strong>：ACK600丢失了但是收到了ACK700，说明ACK600一定丢失了（不然ACK700这个报文就应该是ACK600）</p><p>TCP 头里有一个字段叫<code>Window</code>，也就是窗口大小。这个字段是<strong>接收端</strong>告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。所以，通常<strong>窗口的大小是由接收方的窗口大小来决定的</strong>。</p><h4 id="流量控制">流量控制</h4><p><strong>TCP提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p><ol type="1"><li>客户端发送 140 字节数据后，可用窗口变为 220 （360 - 140）。</li><li>服务端收到 140字节数据，<strong>但是服务端非常繁忙，应用进程只读取了 40 个字节，还有100 字节占用着缓冲区，于是接收窗口收缩到了 260 （360 -100）</strong>，最后发送确认信息时，将窗口大小通告给客户端。</li><li>客户端收到确认和窗口通告报文后，发送窗口<strong>减少为260</strong>。</li><li>客户端发送 180 字节数据，此时可用窗口减少到 80。</li><li>服务端收到 180 字节数据，<strong>但是应用程序没有读取任何数据，这180 字节直接就留在了缓冲区，于是接收窗口收缩到了 80 （260 -180）</strong>，并在发送确认信息时，通过窗口大小给客户端。</li><li>客户端收到确认和窗口通告报文后，发送窗口减少为 80。</li><li>客户端发送 80 字节数据后，可用窗口耗尽。</li><li>服务端收到 80 字节数据，<strong>但是应用程序依然没有读取任何数据，这80 字节留在了缓冲区，于是接收窗口收缩到了0</strong>，并在发送确认信息时，通过窗口大小给客户端。</li><li>客户端收到确认和窗口通告报文后，发送窗口减少为 0</li></ol><p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP连接一方收到对方的零窗口通知，就启动持续计时器。</strong>如果持续计时器超时，就会发送<strong>窗口探测( Window probe )报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><p><strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。</p><ol type="1"><li><p>让接收方不通告小窗口给发送方</p></li><li><p>让发送方避免发送小数据</p></li></ol><h4 id="拥塞控制">拥塞控制</h4><h5 id="慢启动">慢启动</h5><p>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加1，直到到达阈值（ssthresh）</p><h5 id="拥塞避免">拥塞避免</h5><p>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</p><h5 id="发生超时重传">发生超时重传</h5><ul><li><p><code>ssthresh</code> 设为 <code>cwnd/2</code>，</p></li><li><p><code>cwnd</code> 重置为 初值，进行慢启动</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="拥塞发送 —— 超时重传" style="zoom:50%;" /></p></li></ul><h5 id="发生快速重传">发生快速重传</h5><ul><li><code>cwnd = cwnd/2</code> ;</li><li><code>ssthresh = cwnd</code>;</li><li>进入快速恢复算法</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传和快速恢复" style="zoom:50%;" /></p><h5 id="快速恢复">快速恢复</h5><p>快速恢复算法是认为，你还能收到 3 个重复 ACK说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p><ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><p><strong>为什么收到新的数据后，cwnd 设置回了 ssthresh ？</strong></p><p>首先，快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd来减缓拥塞，所以必然会出现 cwnd从大到小的改变。其次，过程2（cwnd逐渐加1）的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的</p><h4 id="tcp快速连接">TCP快速连接</h4><ul><li>在第一次建立连接的时候，服务端在第二次握手产生一个<code>Cookie</code> （已加密）并通过 SYN、ACK包一起发给客户端，于是客户端就会缓存这个<code>Cookie</code>，所以第一次发起 HTTP Get 请求的时候，还是需要 2 个RTT 的时延；</li><li>在下次请求的时候，客户端在 SYN 包带上 <code>Cookie</code>发给服务端，就提前可以跳过三次握手的过程，因为 <code>Cookie</code>中维护了一些信息，服务端可以从 <code>Cookie</code> 获取 TCP相关的信息，这时发起的 HTTP GET 请求就只需要 1 个 RTT 的时延；</li></ul><h3 id="tcp和udp区别">TCP和UDP区别</h3><p><strong>TCP 和 UDP 区别：</strong></p><p><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<ahref="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP协议实现可靠传输？(opens new window)</a></li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是<code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 MSS大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><h3 id="ip-1">IP</h3><h4 id="ip地址分类">IP地址分类</h4><h5 id="初始分类">初始分类</h5><p>互联网诞生之初，IP地址显得很充裕，于是计算机科学家们设计了<strong>分类地址</strong>。IP地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。其中对于A、B、C 类主要分为两个部分，分别是<strong>网络号和主机号</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/7.jpg" alt="IP 地址分类" style="zoom:50%;" /></p><ul><li>主机号全为 1 指定某个网络下的所有主机，用于广播</li><li>主机号全为 0 指定某个网络</li><li>D类常被用于<strong>多播</strong>,多播用于<strong>将包发送给特定组内的所有主机。</strong></li></ul><p>缺点：</p><ol type="1"><li><strong>同一网络下没有地址层次</strong>，比如一个公司里用了 B类地址，但是可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种IP分类是没有地址层次划分的功能，所以这就<strong>缺少地址的灵活性</strong>。</li><li><strong>不能很好的与现实网络匹配</strong>。多的太多，少的太少</li></ol><h5 id="为什么要分离网络号和主机号">为什么要分离网络号和主机号？</h5><p>因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机。</p><p>路由器寻址工作中，也就是通过这样的方式来找到对应的网络号的，进而把数据包转发给对应的网络内。</p><h5 id="cidr">CIDR</h5><p>表示形式 <code>a.b.c.d/x</code>，其中 <code>/x</code> 表示前 x位属于<strong>网络号</strong>， x 的范围是 <code>0 ~ 32</code>，这就使得IP 地址更加具有灵活性。</p><p><strong>子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址</strong>。</p><p>假设对 C 类地址进行子网划分，网络地址 192.168.1.0，使用子网掩码255.255.255.192 对其进行子网划分。</p><p>C 类地址中前 24 位是网络号，最后 8位是主机号，根据子网掩码可知<strong>从 8 位主机号中借用 2位作为子网号</strong>。</p><h4 id="arp">ARP</h4><p>在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP地址后，就会通过主机「路由表」确定 IP数据包下一跳。然而，网络层的下一层是数据链路层，所以我们还要知道「下一跳」的MAC 地址。由于主机的路由表中可以找到下一跳的 IP 地址，所以可以通过<strong>ARP 协议</strong>，求得下一跳的 MAC 地址。</p><ul><li>主机会通过<strong>广播发送 ARP请求</strong>，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li><li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP地址一致，那么这个设备就将自己的 MAC 地址塞入 <strong>ARP响应包</strong>返回给主机。</li></ul><h4 id="dhcp">DHCP</h4><p>电脑通常都是通过 DHCP 动态获取 IP 地址，大大省去了配 IP信息繁琐的过程。DHCP 交互中，<strong>全程都是使用 UDP广播通信</strong>。</p><ul><li>客户端首先发起 <strong>DHCP 发现报文（DHCP DISCOVER）</strong> 的 IP数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是UDP <strong>广播</strong>通信，其使用的广播目的地址是255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。客户端将该 IP数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</li><li>DHCP 服务器收到 DHCP 发现报文时，用 <strong>DHCP 提供报文（DHCPOFFER）</strong> 向客户端做出响应。该报文仍然使用 IP 广播地址255.255.255.255，该报文信息携带服务器提供可租约的 IP地址、子网掩码、默认网关、DNS 服务器以及 <strong>IP地址租用期</strong>。</li><li>客户端收到一个或多个服务器的 DHCP提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP请求报文（DHCP REQUEST</strong>进行响应，回显配置的参数。</li><li>最后，服务端用 <strong>DHCP ACK 报文</strong>对 DHCP请求报文进行响应，应答所要求的参数。</li></ul><h4 id="nat">NAT</h4><p><strong>把 IP 地址 + 端口号一起进行转换</strong>。外部无法主动与 NAT内部服务器建立连接，因为 NAPT 转换表没有转换记录。</p><p>解决的方法主要有两种方法。</p><p><em>第一种就是<strong>改用 IPv6</strong></em></p><p>IPv6 可用范围非常大，以至于每台设备都可以配置一个公有 IP地址，就不搞那么多花里胡哨的地址转换了，但是 IPv6普及速度还需要一些时间。</p><p><em>第二种 <strong>NAT 穿透技术</strong></em></p><p>NAT 穿越技术拥有这样的功能，它能够让网络应用程序主动发现自己位于 NAT设备之后，并且会主动获得 NAT 设备的公有IP，并为自己建立端口映射条目，注意这些都是NAT设备后的应用程序自动完成的。</p><p>也就是说，在 NAT穿透技术中，NAT设备后的应用程序处于主动地位，它已经明确地知道 NAT设备要修改它外发的数据包，于是它主动配合 NAT设备的操作，主动地建立好映射，这样就不像以前由 NAT设备来建立映射了。</p><p>说人话，就是客户端主动从 NAT 设备获取公有 IP地址，然后自己建立端口映射条目，然后用这个条目对外通信，就不需要 NAT设备来进行转换了。</p><h4 id="icmp">ICMP</h4><p><strong>互联网控制报文协议</strong>。<code>ICMP</code>主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中IP 包被废弃的原因和改善网络设置等。</strong></p><p>ICMP 大致可以分为两大类：</p><ul><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li></ul><h4 id="igmp">IGMP</h4><p>在前面我们知道了组播地址，也就是 D类地址，既然是组播，那就说明是只有一组的主机能收到数据包，不在一组的主机不能收到数组包，怎么管理是否是在一组呢？那么，就需要<code>IGMP</code> 协议了。</p><p><strong>GMP是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间</strong>。</p><ul><li>IGMP报文向路由器申请加入和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除非主机通过IGMP 加入到组播组，主机申请加入到组播组时，路由器就会记录 IGMP路由器表，路由器后续就会转发组播包到对应的主机了。</li></ul><h4 id="ping的工作原理">ping的工作原理</h4><p>ping 命令执行的时候，源主机首先会构建一个 <strong>ICMP回送请求消息</strong>数据包。</p><p>ICMP 数据包内包含多个字段，最重要的是两个：</p><ul><li>第一个是<strong>类型</strong>，对于回送请求消息而言该字段为<code>8</code>；</li><li>另外一个是<strong>序号</strong>，主要用于区分连续 ping的时候发出的多个数据包。</li></ul><p>主机 <code>B</code> 会构建一个 <strong>ICMP回送响应消息</strong>数据包，回送响应数据包的<strong>类型</strong>字段为<code>0</code>，<strong>序号</strong>为接收到的请求数据包中的序号，然后再发送出去给主机A。</p><p>在规定的时候间内，源主机如果没有接到 ICMP的应答包，则说明目标主机不可达；如果接收到了 ICMP回送响应消息，则说明目标主机可达。此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是ICMP 数据包的时间延迟。</p><h4 id="localhost-127.0.0.1-0.0.0.0">localhost 127.0.0.1 0.0.0.0</h4><ul><li><code>127.0.0.1</code>是<strong>回环地址</strong>。<code>localhost</code>是<strong>域名</strong>，但默认等于<code>127.0.0.1</code>。</li><li>如果此时 <code>listen</code> 的是本机的 <code>0.0.0.0</code> ,那么它表示本机上的<strong>所有IPV4地址</strong>。</li><li><code>ping</code> 回环地址和 <code>ping</code>本机地址，是一样的，走的是<strong>lo0"假网卡"</strong>，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前<strong>狠狠拐了个弯</strong>，将数据插入到一个<strong>链表</strong>后就<strong>软中断</strong>通知<strong>ksoftirqd</strong>来进行<strong>收数据</strong>的逻辑，<strong>压根就不出网络</strong>。所以断网了也能<code>ping</code> 通回环地址。</li><li>如果服务器 <code>listen</code> 的是<code>0.0.0.0</code>，那么此时用<code>127.0.0.1</code>和本机地址<strong>都可以</strong>访问到服务。</li></ul><h4 id="ipv4地址不够怎么办">IPv4地址不够怎么办</h4><ol type="1"><li>DHCP:动态主机配置协议,动态分配IP地址,使得空闲的地址能够被充分利用</li><li>NAT:子网内使用私有IP地址</li><li>IPv6</li></ol><h4 id="ipv6">IPv6</h4><ul><li>IPv6 可自动配置，即使没有 DHCP服务器也可以实现自动分配IP地址，真是<strong>便捷到即插即用</strong>啊。</li><li>IPv6 包头包首部长度采用固定的值 <code>40</code>字节，去掉了包头校验和，简化了首部结构，减轻了路由器负荷，大大<strong>提高了传输的性能</strong>。</li><li>IPv6 有应对伪造 IP地址的网络安全功能以及防止线路窃听的功能，大大<strong>提升了安全性</strong>。</li></ul><h3 id="其他">其他</h3><h4 id="get和post">GET和POST</h4><p><strong>GET 的语义是从服务器获取指定的资源</strong>,GET请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以<strong>GET 请求的参数只允许 ASCII 字符</strong> ，而且浏览器会对 URL的长度有限制.<strong>GET方法是安全且幂等的</strong>,「安全」是指请求方法不会「破坏」服务器上的资源.「幂等」意思是多次执行相同的操作，结果都是「相同」的。所以，<strong>可以对GET 请求的数据做缓存，</strong></p><p><strong>POST的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，具体的处理方式视资源类型而不同。会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，**浏览器一般不会缓存POST 请求.</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>八股-JVM</title>
    <link href="/2024/04/16/SoftwareDevelopment/%E5%85%AB%E8%82%A1-JVM/"/>
    <url>/2024/04/16/SoftwareDevelopment/%E5%85%AB%E8%82%A1-JVM/</url>
    
    <content type="html"><![CDATA[<p>JVM学习</p><span id="more"></span><h3 id="运行时数据区域">运行时数据区域</h3><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.7.png" style="zoom: 50%;" /></p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）" style="zoom:50%;" /></p><p><strong>线程私有的：</strong></p><ul><li><p>程序计数器</p></li><li><p>虚拟机栈</p><p>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。</p></li><li><p>本地方法栈</p><p>Java通过JNI调用本地的非Java代码</p></li></ul><p><strong>线程共享的：</strong></p><ul><li><p>堆</p></li><li><p>方法区</p><p>当虚拟机要使用一个类时，它需要读取并解析 Class文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的<strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><figure><imgsrc="https://oss.javaguide.cn/github/javaguide/java/jvm/method-area-implementation.png"alt="HotSpot 虚拟机方法区的两种实现" /><figcaption aria-hidden="true">HotSpot虚拟机方法区的两种实现</figcaption></figure></li><li><p>直接内存 (非运行时数据区的一部分)</p><p>使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在Java 堆和 Native 堆之间来回复制数据。</p></li></ul><h4 id="为什么用元空间代替永久代">为什么用元空间代替永久代</h4><ol type="1"><li>整个永久代有一个 JVM本身设置的固定大小上限，无法进行调整（也就是受到 JVM内存的限制），而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li></ol><h4 id="对象的内存布局">对象的内存布局</h4><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><ol type="1"><li><p><strong>对象头包括两部分信息</strong>:</p><ol type="1"><li>用于存储对象自身的运行时数据<strong>（哈希码、GC分代年龄、锁状态标志等等），</strong></li><li>类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ol></li><li><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p></li><li><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong></p></li></ol><h4 id="java堆中创建对象的过程">Java堆中创建对象的过程</h4><ol type="1"><li><p><strong>类加载检查</strong></p><p>虚拟机遇到一条 new指令时，首先将去检查这个指令的参数是否能在<strong>方法区中的常量池</strong>中定位到<strong>这个类的符号引用</strong>，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p></li><li><p><strong>分配内存</strong></p><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从Java 堆中划分出来。<strong>分配方式</strong>有<strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong>两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p>指针碰撞：</p><ul><li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li><li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul><p>空闲列表：</p><ul><li>适用场合：堆内存不规整的情况下。</li><li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul></li><li><p><strong>初始化零值</strong></p><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p></li><li><p><strong>设置对象头</strong></p><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong>另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p></li><li><p><strong>执行init方法</strong></p><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code>方法还没有执行，所有的字段都还为零。所以一般来说，执行 new指令之后会接着执行 <code>&lt;init&gt;</code>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p></li></ol><h3 id="java垃圾回收">Java垃圾回收</h3><h4 id="堆的基本结构">堆的基本结构</h4><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol type="1"><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>JDK8之后永久代被元空间取代且移动到直接内存，并不存在于堆中</p><h4 id="内存泄漏途径">内存泄漏途径</h4><ol type="1"><li>静态集合类</li><li>单例模式</li><li>连接（IO）未释放</li><li>ThreadLocal使用不当</li></ol><h4 id="内存分配和回收原则">内存分配和回收原则</h4><ol type="1"><li><p><strong>对象优先在Eden区分配</strong>。当 Eden区没有足够空间进行分配时，虚拟机将发起一次 Minor GC（新生代收集）。GC期间虚拟机又发现 <code>allocation1</code> 无法存入 Survivor空间，所以只好通过 <strong>分配担保机制</strong>把新生代的对象提前转移到老年代中去。</p></li><li><p>大对象直接进入老年代</p></li><li><p>长期存活对象进入老年代</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为1)。对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1岁，当它的年龄增加到一定程度（默认为 15岁），就会被晋升到老年代中。</p></li></ol><h4 id="内存回收类型">内存回收类型</h4><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / OldGC）：只对老年代进行垃圾收集。需要注意的是 Major GC在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h4 id="空间分配担保">空间分配担保</h4><p>在发生 Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC 可以确保是安全的。</p><p>如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code>参数的设置值是否允许担保失败(Handle PromotionFailure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者<code>-XX: HandlePromotionFailure</code>设置不允许冒险，那这时就要改为进行一次 Full GC。</p><h4 id="死亡对象判断方法">死亡对象判断方法</h4><ol type="1"><li><p>引用计数法：无法解决两个对象相互引用问题</p></li><li><p>可达性分析</p><p>通过一系列的称为 <strong>“GC Roots”</strong>的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p><strong>GC Roots</strong>：</p><p>​ 虚拟机栈(栈帧中的局部变量表)中引用的对象</p><p>​ 本地方法栈(Native 方法)中引用的对象</p><p>​ 方法区中类静态属性引用的对象</p><p>​ 方法区中常量引用的对象</p><p>​ 所有被同步锁持有的对象</p><p>​ JNI（Java Native Interface）引用的对象</p></li></ol><h4 id="引用类型">引用类型</h4><ol type="1"><li><p>强引用</p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。</p></li><li><p>软引用</p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。<strong>软引用可用来实现内存敏感的高速缓存</strong>。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p></li><li><p>弱引用</p><p>只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p></li><li><p>虚引用</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p></li></ol><h4 id="如何判断一个类是无用的类">如何判断一个类是无用的类</h4><ol type="1"><li><p>该类所有的实例都已经被回收，也就是 Java堆中不存在该类的任何实例。</p></li><li><p>加载该类的 <code>ClassLoader</code> 已经被回收。</p></li><li><p>该类对应的 <code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ol><h4 id="垃圾收集算法">垃圾收集算法</h4><ol type="1"><li><p>标记-清除算法：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。效率不高且标记清除后会产生大量不连续的内存碎片。</p></li><li><p>复制算法：将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p></li><li><p>标记-整理算法：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p></li><li><p>分代收集算法：据对象存活周期的不同将内存分为几块。一般将 Java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p></li><li><p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p></li></ol><h4 id="minor-gcyoung-gc">Minor GC/Young GC</h4><p>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</p><p>新创建的对象优先在新生代 Eden 区进行分配,如果 Eden区没有足够的空间时,就会触发 Young GC 来清理新生代。</p><h4 id="full-gc">Full GC</h4><ol type="1"><li><strong>YoungGC 之前检查老年代</strong>:在要进行 Young GC的时候,发现老年代可用的连续内存空间 &lt; 新生代历次Yo u n g G C后升入老年代的对象总和的平均大小 ,说明本次 Young GC后可能升入老年代的对象大小,可能超过了老年代当前可用内存空间, 那就会触发Full GC。</li><li><strong>Yo u n g G C 之后老年代空间不足</strong>:执行 Young GC之后有一批对象需要放入老年代,此时老年代就是没有足够的内存空间存放这些对象了,此时必须立即触发一次 Full GC</li><li><strong>老年代空间不足</strong>,老年代内存使用率过高,达到一定比例,也会触发 Full GC。</li><li><strong>空间分配担保失败( Promotion Failure)</strong>,新生代的 To区放不下从 Eden 和 From 拷贝过来对象,或者新生代对象 GC年龄到达阈值需要晋升这两种情况, 老年代如果放不下的话都会触发 FullGC。</li><li><strong>方法区内存空间不足</strong>:如果方法区由永久代实现,永久代空间不足 Full GC。</li><li>System.gc()等命令触发: System.gc()、jmap -dump 等命令会触发 fullgc。</li></ol><h4 id="垃圾收集器">垃圾收集器</h4><ol type="1"><li><p>Serial收集器</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong>它的<strong>“单线程”</strong>的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（<strong>"Stop The World"</strong> ），直到它收集结束。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240416222237.png" /></p></li><li><p>ParNew收集器</p><p><imgsrc="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240416222532.png" /></p></li><li><p>Parallel Sacvenge收集器</p><p>JDK1.8默认收集器</p><figure><imgsrc="https://oss.javaguide.cn/github/javaguide/java/jvm/parallel-scavenge-garbage-collector.png"alt="Parallel Old收集器运行示意图" /><figcaption aria-hidden="true">Parallel Old收集器运行示意图</figcaption></figure></li><li><p>CMS收集器</p><p><strong>MS（Concurrent MarkSweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root相连的对象，速度很快 ；</p><p><strong>并发标记：</strong> 同时开启 GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p><p><strong>重新标记：</strong>重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p><p><strong>并发清除：</strong> 开启用户线程，同时 GC线程开始对未标记的区域做清扫。</p><p>缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul></li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240416225857.png" /></p><ol start="5" type="1"><li><p>G1收集器</p><p>JDK9之后的默认收集器</p><p><strong>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region划分内存空间以及有优先级的区域回收方式，保证了 G1收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）</p><p><imgsrc="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240416230340.png" /></p></li></ol><h3 id="双亲委派">双亲委派</h3><h4 id="实现方式">实现方式</h4><p>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</p><p>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器<code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器<code>BootstrapClassLoader</code> 中。</p><p>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的<code>findClass()</code> 方法来加载类）。</p><p>如果子类加载器也无法加载这个类，那么它会抛出一个<code>ClassNotFoundException</code> 异常。</p><h4 id="好处">好处</h4><p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了Java 的核心 API 不被篡改。</p><p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为<code>java.lang.Object</code>类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code>类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code>类，而不是你写的 <code>Object</code> 类。这是因为<code>AppClassLoader</code> 在加载你的 <code>Object</code>类时，会委托给 <code>ExtClassLoader</code> 去加载，而<code>ExtClassLoader</code> 又会委托给<code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code>发现自己已经加载过了 <code>Object</code>类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>八股-Java并发编程</title>
    <link href="/2024/04/16/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/04/16/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>Java并发编程学习</p><span id="more"></span><h3 id="进程和线程">进程和线程</h3><p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区(JDK1.8之后的元空间)</strong>资源，但是每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和 <strong>本地方法栈</strong>。</p><h4id="虚拟机栈和本地方法栈为什么是私有的">虚拟机栈和本地方法栈为什么是私有的?</h4><ul><li><strong>虚拟机栈：</strong> 每个 Java方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><h4 id="线程安全">线程安全</h4><p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。</p><ul><li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li><li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li></ul><h4 id="线程生命周期和状态">线程生命周期和状态</h4><p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</p><p>RUNNABLE: 运行状态，线程被调用了<code>start()</code>等待运行的状态。</p><p>BLOCKED：阻塞状态，当线程进入 <code>synchronized</code>方法，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</p><p>WAITING：等待状态，当线程执行 <code>wait()</code>方法之后，线程进入<strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</p><p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像WAITING 那样一直等待。</p><p>TERMINATED：终止状态，表示该线程已经运行完毕。</p><h4 id="线程死锁">线程死锁</h4><p>互斥条件：该资源任意一个时刻只由一个线程占用。</p><p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p><p>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</p><h4 id="预防死锁">预防死锁</h4><p>互斥条件：原则性问题，不可通过这种方法解决</p><p>请求与保持条件：一次性申请所有需要的资源</p><p>不剥夺条件:占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源</p><p>循环等待条件:按序申请资源</p><h4 id="wait和sleep">wait()和sleep()</h4><ol type="1"><li><p><strong><code>sleep()</code> 方法没有释放锁，而<code>wait()</code> 方法释放了锁</strong> 。</p></li><li><p><code>wait()</code>通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</p></li><li><p><code>wait()</code>方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的<code>notify()</code>或者 <code>notifyAll()</code>方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用<code>wait(long timeout)</code> 超时后线程会自动苏醒。</p></li><li><p><code>sleep()</code> 是 <code>Thread</code>类的静态本地方法，<code>wait()</code> 则是 <code>Object</code>类的本地方法。<code>wait()</code>是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入WAITING状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p></li></ol><h4 id="可以直接调用-thread-类的-run-方法吗">可以直接调用 Thread 类的run 方法吗？</h4><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用<code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<code>start()</code> 会执行线程的相应准备工作，然后自动执行<code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行<code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结：调用 <code>start()</code>方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code>方法的话不会以多线程的方式执行。</strong></p><h4 id="volatile">volatile</h4><p><code>volatile</code>关键字可以保证变量的可见性，它最原始的意义就是禁用 CPU缓存。如果我们将变量声明为 <strong><code>volatile</code></strong>，这就指示JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p><strong>在 Java 中，<code>volatile</code>关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM的指令重排序。</strong> 如果我们将变量声明为<strong><code>volatile</code></strong>，在对这个变量进行读写操作的时候，会通过插入特定的<strong>内存屏障</strong> 的方式来禁止指令重排序。</p><h4 id="单例模式">单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>uniqueInstance</code> 采用 <code>volatile</code>关键字修饰也是很有必要的，<code>uniqueInstance = new Singleton();</code>这段代码其实是分为三步执行：</p><ol type="1"><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现<code>uniqueInstance</code> 不为空，因此返回<code>uniqueInstance</code>，但此时 <code>uniqueInstance</code>还未被初始化。</p><p><strong><code>volatile</code>关键字能保证变量的可见性，但不能保证对变量的操作是原子性的</strong></p><h3 id="锁">锁</h3><h4 id="cas乐观锁">CAS乐观锁</h4><p>CAS的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p><blockquote><p><strong>原子操作</strong>即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p></blockquote><p>CAS 涉及到三个操作数：</p><ul><li><strong>V</strong>：要更新的变量值(Var)</li><li><strong>E</strong>：预期值(Expected)</li><li><strong>N</strong>：拟写入的新值(New)</li></ul><p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V的值。如果不等，说明已经有其它线程更新了V，则当前线程放弃更新。当多个线程同时使用 CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p><h4 id="synchronized锁">synchronized锁</h4><ol type="1"><li>修饰实例方法：锁定对象实例，当前对象的其他被synchronized修饰的方法都不可进入，但是不被synchronized修饰的方法可以。</li><li>修饰静态方法：锁定类</li><li>修饰代码块：锁定括号里指定的对象/类</li></ol><h4 id="锁升级">锁升级</h4><p>在 Java 6 之后， <code>synchronized</code>引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让<code>synchronized</code> 锁的效率提升了很多（JDK18中，偏向锁已经被彻底废弃）。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h4 id="reentrantlock">ReentrantLock</h4><p><code>ReentrantLock</code>是一个可重入且独占式的锁。增加了轮询、超时、中断、公平锁和非公平锁等高级功能</p><h4 id="公平锁和非公平锁">公平锁和非公平锁</h4><p><strong>公平锁</strong> :锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p><p><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</p><h4id="synchronized和reentrantlock关系">Synchronized和ReentrantLock关系</h4><ol type="1"><li>二者都是可重入锁，线程可以再次获取自己的内部锁</li><li><code>synchronized</code> 是依赖于 JVM实现的，<code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）</li><li>ReentrantLock有一些新特性<ol type="1"><li>等待可中断：在等待锁的线程可以选择放弃等待，改为处理其他事情。<code>synchronized</code>就属于是不可中断锁</li><li>可实现公平锁：可以指定是公平锁还是非公平锁，而<code>synchronized</code>只能是非公平锁</li><li>可实现选择性通知（锁可以绑定多个条件）:<code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ol></li></ol><h4 id="condition">Condition</h4><p><code>Condition</code>是 JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。</strong></p><p><strong>在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由JVM选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong>，这个功能非常重要，而且是 <code>Condition</code>接口默认提供的。而<code>synchronized</code>关键字就相当于整个<code>Lock</code>对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而<code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p><h3 id="threadlocal">ThreadLocal</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的,<strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值</strong></p><p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为key ，Object 对象为 value 的键值对</strong></p><h4 id="内存泄漏">内存泄漏</h4><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code>的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code>没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value不会被清理掉。</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的Entry。假如我们不做任何措施的话，value 永远无法被 GC回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code>实现中已经考虑了这种情况，在调用<code>set()</code>、<code>get()</code>、<code>remove()</code>方法的时候，会清理掉 key 为 null 的记录。</p><h3 id="线程池">线程池</h3><h4 id="优点">优点</h4><p>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><h4 id="executors">Executors</h4><p>通过<code>Executors</code>工具类可以创建多种类型的线程池，包括：</p><ul><li><code>FixedThreadPool</code>：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><code>SingleThreadExecutor</code>：只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><code>CachedThreadPool</code>：可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li><code>ScheduledThreadPool</code>：给定的延迟后运行任务或者定期执行任务的线程池</li></ul><p><code>Executors</code> 返回线程池对象的弊端如下：</p><ul><li><code>FixedThreadPool</code> 和<code>SingleThreadExecutor</code>:使用的是无界的<code>LinkedBlockingQueue</code>，任务队列最大长度为<code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li><li><code>CachedThreadPool</code>:使用的是同步队列<code>SynchronousQueue</code>, 允许创建的线程数量为<code>Integer.MAX_VALUE</code>，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致OOM。</li><li><code>ScheduledThreadPool</code> 和<code>SingleThreadScheduledExecutor</code>:使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为<code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li></ul><h4 id="threadpoolexecutor">ThreadPoolExecutor</h4><ul><li><p><strong>intcorePoolSize</strong>：该线程池中<strong>核心线程数最大值</strong></p><blockquote><p>核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。</p></blockquote></li><li><p><strong>intmaximumPoolSize</strong>：该线程池中<strong>线程总数最大值</strong>。</p><blockquote><p>该值等于核心线程数量 + 非核心线程数量。</p></blockquote></li><li><p><strong>longkeepAliveTime</strong>：<strong>非核心线程闲置超时时长</strong>。</p><blockquote><p>非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。</p></blockquote></li><li><p><strong>TimeUnit unit</strong>：keepAliveTime的单位。</p><p>TimeUnit是一个枚举类型 ，包括以下属性：</p><blockquote><p>NANOSECONDS ： 1微毫秒 = 1微秒 / 1000 MICROSECONDS ： 1微秒 = 1毫秒 /1000 MILLISECONDS ： 1毫秒 = 1秒 /1000 SECONDS ： 秒 MINUTES ： 分 HOURS： 小时 DAYS ： 天</p></blockquote></li><li><p><strong>BlockingQueueworkQueue</strong>：阻塞队列，维护着<strong>等待执行的Runnable任务对象</strong>。</p><p>常用的几个阻塞队列：</p><ol type="1"><li><p><strong>LinkedBlockingQueue</strong></p><p>链式阻塞队列，底层数据结构是链表，默认大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。</p></li><li><p><strong>ArrayBlockingQueue</strong></p><p>数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</p></li><li><p><strong>SynchronousQueue</strong></p><p>同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</p></li><li><p><strong>DelayQueue</strong></p><p>延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。</p></li><li><p><strong>PriorityBlockingQueue</strong></p><p>优先级阻塞队列,创建 <code>PriorityBlockingQueue</code> 时传入一个<code>Comparator</code> 对象来指定任务之间的排序规则</p></li></ol></li><li><p><strong>RejectedExecutionHandler handler</strong></p><p><strong>拒绝处理策略</strong>，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为：</p><ol type="1"><li><strong>ThreadPoolExecutor.AbortPolicy</strong>：<strong>默认拒绝处理策略</strong>，丢弃任务并抛出RejectedExecutionException异常。</li><li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常。</li><li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</li><li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：由调用线程处理该任务。</li></ol></li></ul><h4 id="执行流程">执行流程</h4><ol type="1"><li>线程总数量 &lt;corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量&lt;corePoolSize时）。<strong>注意，这一步需要获得全局锁。</strong></li><li>线程总数量 &gt;=corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了<strong>线程复用</strong>）。</li><li>当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。<strong>注意，这一步需要获得全局锁。</strong></li><li>缓存队列满了，且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</li></ol><figure><imgsrc="https://oss.javaguide.cn/github/javaguide/java/concurrent/thread-pool-principle.png"alt="图解线程池实现原理" /><figcaption aria-hidden="true">图解线程池实现原理</figcaption></figure><h3 id="future">Future</h3><p><code>Future</code>类是<strong>异步思想</strong>的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成。</p><p>简单理解就是：我有一个任务，提交给了 <code>Future</code>来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以<code>Future</code> 那里直接取出任务执行结果。</p><h4 id="runable和callable">Runable和Callable</h4><p>runnable没有返回值，而实现callable接口的任务线程能返回执行结果</p><h4 id="completablefuture">CompletableFuture</h4><p><code>Future</code>在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的<code>get()</code> 方法为阻塞调用。</p><p>Java 8 才被引入<code>CompletableFuture</code>类可以解决<code>Future</code> 的这些缺陷。<code>CompletableFuture</code>除了提供了更为好用和强大的 <code>Future</code>特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p><h3 id="aqs">AQS</h3><p>抽象队列同步器,主要用来构建锁和同步器。</p><p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS 是用 <strong>CLH 队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个 CLH锁队列的一个结点（Node）来实现锁的分配。在 CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p><h3 id="semaphore">Semaphore</h3><p><code>synchronized</code> 和 <code>ReentrantLock</code>都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。<code>Semaphore</code>是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为<code>permits</code>，你可以将 <code>permits</code>的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p><h3 id="countdownlatch">CountDownLatch</h3><p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的<code>state</code> 值为 <code>count</code>。当线程使用<code>countDown()</code>方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少<code>state</code>,直至 <code>state</code> 为 0 。当调用<code>await()</code> 方法的时候，如果 <code>state</code> 不为0，那就证明任务还没有执行完毕，<code>await()</code>方法就会一直阻塞，也就是说 <code>await()</code>方法之后的语句不会被执行。直到<code>count</code>个线程调用了<code>countDown()</code>使 state 值被减为0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code>方法之后的语句得到执行。</p><p>我们要读取处理 6 个文件，这 6个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。为此我们定义了一个线程池和count 为 6 的<code>CountDownLatch</code>对象。使用线程池处理读取任务，每一个线程处理完之后就将count-1，调用<code>CountDownLatch</code>对象的<code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p><h3 id="jmm-java内存模型">JMM java内存模型</h3><p><strong>Java 内存模型（JMM）</strong>抽象了线程和主内存之间的关系</p><p><strong>主内存</strong>：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。</p><p><strong>本地内存</strong>：每个线程都有一个私有的本地内存，本地内存存储了该线程以读/写共享变量的副本。<strong>每个线程只能操作自己本地内存中的变量</strong>，无法直接访问其他线程的本地内存。如果线程间需要通信，必须通过主内存来进行。本地内存是JMM抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/jmm.png" alt="JMM(Java 内存模型)" style="zoom:50%;" /></p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>八股-Java集合</title>
    <link href="/2024/04/15/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Java%E9%9B%86%E5%90%88/"/>
    <url>/2024/04/15/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>Java集合学习</p><span id="more"></span><h3 id="list">List</h3><h4 id="arraylist和array的区别">ArrayList和Array的区别</h4><ol type="1"><li><p><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而<code>Array</code>需要在创建的时候指定大小，被创建之后就不能改变它的长度了。</p></li><li><p><code>ArrayList</code>允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</p></li><li><p><code>ArrayList</code>中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如Integer、Double 等）。<code>Array</code>可以直接存储基本类型数据，也可以存储对象。</p></li><li><p><code>ArrayList</code>支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如<code>add()</code>、<code>remove()</code>等。<code>Array</code>只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</p></li><li><p><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</p></li></ol><h4 id="arraylist和linkedlist">ArrayList和LinkedList</h4><ol type="1"><li>ArrayList的插入在不引发扩容的情况下，要看插入位置，头插<code>O(n)</code>，尾插<code>O(1)</code>,其他位置平均<code>O(n)</code>。由于ArrayList支持动态扩容，当前数组容量不足以插入的时候会创建新的列表，同时把数据拷贝过去，因此扩容需要<code>O(n)</code>的时间复杂度。删除同理但是不需要考虑扩容问题。</li><li>LinkedList是双向链表，头尾插删均为<code>O(1)</code>,指定位置插删需要先移动到指定位置，因此为<code>O(n)</code></li></ol><h4 id="arraylist扩容过程">ArrayList扩容过程</h4><p>以无参数构造方法创建 <code>ArrayList</code>时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10</p><p>在添加元素前，首先判断容量是否满足</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 加元素之前，先调用ensureCapacityInternal方法</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">// 这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>calculateCapacity计算当前所需容量，如果第一次添加元素同时采用默认构造方式，会构造一个长度为10的列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据给定的最小容量和当前数组元素来计算所需容量。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span><br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-comment">// 否则直接返回最小容量</span><br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br><br><span class="hljs-comment">// 确保内部容量达到指定的最小容量。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果当前容量小于最小需要的容量，就会进行扩容操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断是否需要扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">//判断当前数组容量是否足以存储minCapacity个元素</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//调用grow方法进行扩容</span><br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ArrayList 每次扩容之后容量都会变为原来的 1.5倍左右</strong>，如果仍然小于minCapacity，则newCapacity =minCapacity;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 要分配的最大数组大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ArrayList扩容的核心方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-comment">// 将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>    <span class="hljs-comment">// 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br><br>    <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span><br>    <span class="hljs-comment">// 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br><br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>Arrays.copyOf()内部调用System.arraycopy，内部自动申请一个新的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] copyOf(<span class="hljs-type">int</span>[] original, <span class="hljs-type">int</span> newLength) &#123;<br>  <span class="hljs-comment">// 申请一个新的数组</span><br>    <span class="hljs-type">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[newLength];<br><span class="hljs-comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span><br>    System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,<br>                     Math.min(original.length, newLength));<br>    <span class="hljs-keyword">return</span> copy;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="set">Set</h3><h4 id="comparable和comparator的区别">Comparable和Comparator的区别</h4><ul><li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包它有一个<code>compareTo(Object obj)</code>方法用来排序，用于一个实体类实现Comparable接口，然后重写compareTo方法，即可进行排序。</li><li><code>Comparator</code>接口实际上是出自 <code>java.util</code>包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序，用于Collction.sort的时候临时自定义排序方式。</li></ul><h3 id="hashmap">HashMap</h3><h4 id="扩容机制">扩容机制</h4><p>jdk1.8之前采用<strong>数组+链表</strong>实现，即拉链法避免冲突</p><p>jdk1.8之后，当链表长度大于阈值（默认为 8）时，会首先调用<code>treeifyBin()</code>方法。这个方法会根据 HashMap数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行<code>resize()</code> 方法对数组扩容。</p><h4 id="负载因子">负载因子</h4><p>oadFactor 负载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于1，那么数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。默认值为0.75。<code>HashMap</code>默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</p><h4 id="插入元素">插入元素</h4><p>如果定位到的数组位置没有元素 就直接插入。</p><p>如果定位到的数组位置有元素就和要插入的 key 比较，如果存在 key相同就直接覆盖，如果 key 不相同，就判断 p是否是一个树节点，如果是就将元素添加进入红黑树。如果不是就遍历链表插入(插入的是链表尾部)。</p><h4 id="头插还是尾插">头插还是尾插</h4><p>JDK1.7之前是头插，在多线程下可能会导致链表成环，JDK1.8之后更改为尾插。</p><h4 id="hashset如何实现">Hashset如何实现</h4><p>在 <code>HashSet</code> 的实现中，每个插入到 <code>HashSet</code>中的元素实际上作为 <code>HashMap</code>的键存储，而与每个键关联的值（value）则是一个固定的对象，通常是一个预定义的静态的私有对象（通常是<code>new Object()</code>的实例或者类似的占位符对象）。这个对象在所有的实例中是相同的</p><h4 id="hashmap和treemap">HashMap和TreeMap</h4><p><code>TreeMap</code> 和<code>HashMap</code>都继承自<code>AbstractMap</code>，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code>接口。</p><p><code>NavigableMap</code> 接口提供了丰富的方法来探索和操作键值对:</p><ol type="1"><li><p><strong>定向搜索</strong>: <code>ceilingEntry()</code>,<code>floorEntry()</code>, <code>higherEntry()</code>和<code>lowerEntry()</code>等方法可以用于定位大于、小于、大于等于、小于等于给定键的最接近的键值对。</p></li><li><p><strong>子集操作</strong>: <code>subMap()</code>,<code>headMap()</code>和 <code>tailMap()</code>方法可以高效地创建原集合的子集视图，而无需复制整个集合。</p></li><li><p><strong>逆序视图</strong>:<code>descendingMap()</code>方法返回一个逆序的 <code>NavigableMap</code> 视图，使得可以反向迭代整个<code>TreeMap</code>。</p></li><li><p><strong>边界操作</strong>: <code>firstEntry()</code>,<code>lastEntry()</code>, <code>pollFirstEntry()</code>和<code>pollLastEntry()</code> 等方法可以方便地访问和移除元素</p></li></ol><p>这些方法都是基于红黑树数据结构的属性实现的，红黑树保持平衡状态，从而保证了搜索操作的时间复杂度为O(log n)，这让 <code>TreeMap</code>成为了处理有序集合搜索问题的强大工具。</p><p><code>SortedMap</code>接口让 <code>TreeMap</code>有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，</p><h4 id="hashmap为什么线程不安全">Hashmap为什么线程不安全</h4><p>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突。当线程 1执行完哈希冲突判断后，认为没有冲突，但是由于时间片耗尽挂起。线程 2先完成了插入操作。随后，线程 1 获得时间片，由于之前已经进行过 hash碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1覆盖了。</p><h4 id="hashtable">Hashtable</h4><p><code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code>修饰，加的是全局锁。</p><h4 id="concurrenthashmap">ConcurrentHashMap</h4><p>Java7 中 <code>ConcurrentHashMap</code> 使用的分段锁，也就是每一个Segment 上同时只有一个线程可以操作，每一个 <code>Segment</code>都是一个类似 <code>HashMap</code>数组的结构，它可以扩容，它的冲突会转化为链表。但是 <code>Segment</code>的个数一但初始化就不能改变。</p><p>Java8 中的 <code>ConcurrentHashMap</code> 使用的<code>Synchronized</code> 锁加 CAS 的机制。结构也由 Java7 中的<strong><code>Segment</code> 数组 + <code>HashEntry</code> 数组 +链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node是类似于一个 HashEntry的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p><h4 id="linkedhashmap">LinkedHashMap</h4><p><code>LinkedHashMap</code> 是 Java 集合框架中 <code>HashMap</code>的一个子类，它继承了 <code>HashMap</code> 的所有属性和方法，并且在<code>HashMap</code> 的基础重写了<code>afterNodeRemoval</code>、<code>afterNodeInsertion</code>、<code>afterNodeAccess</code>方法。使之拥有顺序插入和访问有序的特性。</p><ol type="1"><li><p>如何按照插入顺序迭代元素？</p><p>LinkedHashMap内部维护了一个双向链表，用于记录元素的插入顺序。当使用迭代器迭代元素时即为在链表中进行移动</p></li><li><p>如何按照访问顺序迭代元素</p><p>通过构造函数中的accessOrder参数指定，当设置为true时，每访问一个元素，该元素会被移动到链表的末尾</p></li><li><p>如何实现LRU</p><p>将accessOrder设置为true，同时重写removeEldestEntry当链表大小超过容量时返回true，这样一旦插入操作使得返回为true时，会移除链表首元素。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">super</span>(capacity, <span class="hljs-number">0.75f</span>, <span class="hljs-literal">true</span>);<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;<br>        <span class="hljs-keyword">return</span> size() &gt; capacity;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h4 id="copyonwritearraylist">CopyOnWriteArrayList</h4><p>当需要修改（ <code>add</code>，<code>set</code>、<code>remove</code>等操作） <code>CopyOnWriteArrayList</code>的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 插入元素到 CopyOnWriteArrayList 的尾部</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 加锁</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取原来的数组</span><br>        Object[] elements = getArray();<br>        <span class="hljs-comment">// 原来数组的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        <span class="hljs-comment">// 创建一个长度+1的新数组，并将原来数组的元素复制给新数组</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 元素放在新数组末尾</span><br>        newElements[len] = e;<br>        <span class="hljs-comment">// array指向新数组</span><br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 解锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="arrayblockingqueue">ArrayBlockingQueue</h4><p><code>ArrayBlockingQueue</code> 是 <code>BlockingQueue</code>接口的有界队列实现类，常用于多线程之间的数据共享，底层采用数组实现.</p><ul><li><code>ArrayBlockingQueue</code>内部维护一个定长的数组用于存储元素。</li><li>通过使用 <code>ReentrantLock</code>锁对象对读写操作进行同步，即通过锁机制来实现线程安全。</li><li>通过 <code>Condition</code> 实现线程间的等待和唤醒操作。</li></ul><p>这里再详细介绍一下线程间的等待和唤醒具体的实现（不需要记具体的方法，面试中回答要点即可）：</p><ul><li>当队列已满时，生产者线程会调用 <code>notFull.await()</code>方法让生产者进行等待，等待队列非满时插入（非满条件）。</li><li>当队列为空时，消费者线程会调用<code>notEmpty.await()</code>方法让消费者进行等待，等待队列非空时消费（非空条件）。</li><li>当有新的元素被添加时，生产者线程会调用<code>notEmpty.signal()</code>方法唤醒正在等待消费的消费者线程。</li><li>当队列中有元素被取出时，消费者线程会调用<code>notFull.signal()</code>方法唤醒正在等待插入元素的生产者线程。</li></ul><h4 id="delayqueue">DelayQueue</h4><ol type="1"><li><p>实现原理</p><p><code>DelayQueue</code> 底层是使用优先队列 <code>PriorityQueue</code>来存储元素，而 <code>PriorityQueue</code>采用二叉小顶堆的思想确保值小的元素排在最前面，这就使得<code>DelayQueue</code> 对于延迟任务优先级的管理就变得十分方便了。同时<code>DelayQueue</code> 为了保证线程安全还用到了可重入锁<code>ReentrantLock</code>,确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率，<code>DelayQueue</code>还用到了 <code>Condition</code>，通过 <code>Condition</code> 的<code>await</code> 和 <code>signal</code>方法完成多线程之间的等待唤醒。</p></li><li><p>使用场景</p><p><code>DelayQueue</code>通常用于实现定时任务调度和缓存过期删除等场景。在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到<code>DelayQueue</code> 中，<code>DelayQueue</code>会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。对于缓存过期这个场景而言，在数据被缓存到内存之后，我们可以将缓存的key 封装成一个延迟的删除任务，并将其添加到 <code>DelayQueue</code>中，当数据过期时，拿到这个任务的 key，将这个 key 从内存中移除。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博弈论</title>
    <link href="/2024/04/12/Algorithm/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <url>/2024/04/12/Algorithm/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>博弈论相关问题 <span id="more"></span></p><h3 id="nim游戏">NIM游戏</h3><p>给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</p><p>我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。NIM博弈不存在平局，只有先手必胜和先手必败两种情况。</p><p>定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0</p><h3 id="sg函数">SG函数</h3><p>在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1,y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk的SG函数值构成的集合再执行mex(S)运算的结果，即： SG(x) = mex({SG(y1),SG(y2), …, SG(yk)})特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G)= SG(s)。</p><h4 id="mex运算">Mex运算</h4><p>设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：mex(S) = min{x}, x属于自然数，且x不属于S</p><h4 id="有向图游戏的和">有向图游戏的和</h4><p>设G1, G2, …, Gm是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1,G2, …, Gm的和。有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)</p><h4 id="例题">例题</h4><p>给定堆石子以及一个由k个不同正整数构成的数字集合S。现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合S,最后无法进行操作的人视为失败。问如果两人都采用最优策略，先手是否必胜。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> s[<span class="hljs-number">110</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">10010</span>];<br><br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[x] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> f[x];<br>    set&lt;<span class="hljs-type">int</span>&gt; se;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x &gt;= s[i]) se.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">sg</span>(x-s[i]));<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;;i++)&#123;<br>        <span class="hljs-keyword">if</span>(se.<span class="hljs-built_in">find</span>(i) == se.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> f[x] = i;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;s[i];<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> f);<br>    cin&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        res ^= <span class="hljs-built_in">sg</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(res) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>后端八股</title>
    <link href="/2024/04/02/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/04/02/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>Java基础学习</p><span id="more"></span><h3 id="所有对象实例都存在于堆中吗">所有对象实例都存在于堆中吗？</h3><p>在Java中，对象通常是在堆内存中分配的。堆内存用于存储Java程序运行期间创建的对象实例，而栈内存则用于存储方法调用时的局部变量和方法调用的上下文。但是，有一种优化技术，称为逃逸分析，可以改变这种分配方式。</p><p>逃逸分析是一种确定对象分配范围和寿命的技术。简单来说，它分析数据是否会“逃逸”出它被创建的上下文。如果一个对象只在一个方法中被使用，并且不会被返回或赋值给方法外的变量，那么这个对象就被认为是“不逃逸”的。</p><p>如果JIT（Just-In-Time编译器）在运行时通过逃逸分析确定一个对象不会逃逸到方法外部，它可以采取一种称为“标量替换”的优化手段。标量替换允许JIT编译器“拆解”这个对象，将其字段直接存储在栈上，而不是作为一个整体对象存储在堆上。这样做有几个好处：</p><ol type="1"><li><strong>性能提升</strong>：访问栈上的数据比堆上的数据要快，因为栈上的数据通常在内存中的位置更为靠近执行线程。</li><li><strong>减少垃圾收集压力</strong>：由于对象不在堆上分配，因此不需要由垃圾收集器回收，这可以减少垃圾收集的开销。</li></ol><h3 id="浮点数运算精度丢失">浮点数运算精度丢失</h3><p>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p><p><code>BigDecimal</code>可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过<code>BigDecimal</code> 来做的。</p><h3 id="重载和重写">重载和重写</h3><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p><h3 id="面向对象三大特性">面向对象三大特性</h3><h4 id="封装">封装</h4><p>封装是指把一个对象的状态信息（也就是属性）<strong>隐藏</strong>在对象内部，不允许外部对象直接访问对象的<strong>内部信息</strong>。但是可以提供一些可以被外界访问的方法来操作属性。</p><h4 id="继承">继承</h4><p>将一些具有相同特征的对象的这些相同特征提取出来构建一个父类。继承可以使用已存在的父类的定义作为基础建立新类，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间，提高我们的开发效率。</p><h4 id="多态">多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例</p><ol type="1"><li><p>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</p></li><li><p>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</p></li><li><p>多态不能调用“只在子类存在但在父类不存在”的方法；</p></li><li><p>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</p></li></ol><h3id="接口和抽象类有什么共同点和区别">接口和抽象类有什么共同点和区别？</h3><p><strong>共同点</strong>：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 <code>default</code>关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong>：</p><ul><li>接口主要用于对类的行为进行约束，是横向对功能的拓展。你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 <code>public static final</code>类型的，不能被修改且必须有初始值，而抽象类的成员变量默认default，可在子类中被重新定义，也可被重新赋值</li></ul><h3 id="深拷贝浅拷贝引用拷贝">深拷贝、浅拷贝、引用拷贝</h3><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p><ul><li><p><strong>浅拷贝</strong>：浅拷贝会在堆上<strong>创建一个新的对象</strong>（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p></li><li><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p></li><li><p><strong>引用拷贝</strong>:引用拷贝就是两个不同的引用指向同一个对象</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240403201541.png" /></p></li></ul><h3 id="和-equals-的区别">== 和 equals() 的区别</h3><p><strong><code>==</code></strong>比较的就是值，对于基本数据类型来说，<code>==</code>比较的就是本身的数值，对于引用数据类型来说，它存的值是对象的地址，所以此时<code>==</code>比较的是对象的内存地址。<code>equals()</code>是<code>Object</code>类的一个方法，所以基本数据类型是没有equals这个方法的，但是所有引用数据类型都有equals方法</p><p><strong><code>equals()</code></strong>不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p><ul><li><strong>类没有重写<code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是<code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写<code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回true(即，认为这两个对象相等)。</li></ul><h3 id="为什么要有-hashcode">为什么要有 hashCode？</h3><blockquote><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code>会先计算对象的 <code>hashCode</code>值来判断对象加入的位置，同时也会与其他已经加入的对象的<code>hashCode</code> 值作比较，如果没有相符的<code>hashCode</code>，<code>HashSet</code>会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code>值的对象，这时会调用 <code>equals()</code> 方法来检查<code>hashCode</code>相等的对象是否真的相同。如果两者相同，<code>HashSet</code>就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了<code>equals</code> 的次数，相应就大大提高了执行速度。</p></blockquote><p>其实， <code>hashCode()</code> 和<code>equals()</code>都是用于比较两个对象是否相等。</p><p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p><p>这是因为在一些容器（比如<code>HashMap</code>、<code>HashSet</code>）中，有了<code>hashCode()</code>之后，判断元素是否在对应容器中的<strong>效率会更高</strong>（参考添加元素进<code>HashSet</code>的过程）</p><p><strong>为什么重写 equals() 时必须重写 hashCode() 方法？</strong></p><p><code>equals()</code>是判断两个对象相等的金标准。那为什么要有hashcode呢？因为有了<code>hashCode()</code>之后，判断元素是否在对应容器中的<strong>效率会更高</strong>，在hashset中想插入一个对象，会先比较是否有hashcode相等的对象，如果相等，因为有散列冲突的问题存在，就需要进一步使用equals进行比较。也就是说如果<code>equals</code> 方法判断两个对象是相等的，那这两个对象的<code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code>方法的话就可能会导致 <code>equals</code>方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p><strong>总结</strong>：</p><ul><li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的<code>hashCode</code> 值也要相等。</li><li>两个对象有相同的 <code>hashCode</code>值，他们也不一定是相等的（哈希碰撞）。</li></ul><h3id="为什么jdk动态代理需要实现接口的类">为什么JDK动态代理需要实现接口的类？</h3><p><strong>JDK 动态代理类使用步骤</strong></p><ol type="1"><li>定义一个接口及其实现类；</li><li>自定义 <code>InvocationHandler</code>并重写<code>invoke</code>方法，在 <code>invoke</code>方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li><li>通过<code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code>方法创建代理对象；</li></ol><p>jdk动态代理生成的代理类实现了我们业务定义的接口，并重写了我们接口的方法，如此才实现代理的功能，所以我们的目标类需要实现接口。</p><p>在JDK动态代理中，当你创建一个代理实例时，你需要提供一个实现了一个或多个接口的类的实例，以及一个调用处理器（InvocationHandler）。Java运行时使用这些信息<strong>动态创建一个新的类</strong>，这个类在运行时被定义为提供的接口的一个<strong>实现</strong>。这意味着动态代理类在运行时创建，并且其类型信息是基于这些接口的。</p><p><strong>这个动态创建的类会将所有方法调用转发给调用处理器</strong>，这允许你在方法调用前后插入自定义逻辑，例如日志记录、事务处理等。这种转发是通过在代理类中重写接口的方法实现的，然后在这些方法中调用调用处理器。</p><h3 id="代理模式">代理模式</h3><p><strong>使用代理对象来代替对真实对象(realobject)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p><ol type="1"><li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB可以代理未实现任何接口的类。</strong>JDK动态代理基于<strong>接口</strong>实现,CGLIB基于<strong>继承</strong>实现.CGLIB动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK版本的升级，这个优势更加明显。</li></ol><h3 id="为什么bigdecimal没有精度问题">为什么BigDecimal没有精度问题</h3><p><code>BigDecimal</code>内部通过一个整数（<code>BigInteger</code>）来表示小数的精确值，和一个单独的整数来表示小数点的位置（也就是说，一个<code>BigDecimal</code>由一个不可变的<strong>任意精度整数</strong>非标度值和<strong>32位的整数标度组成</strong>，标度表示小数点右边的位数）。这意味着<code>BigDecimal</code>可以表示任意精度的小数，精度仅受可用内存的限制。</p><p>BigDecimal等值比较应使用compareTo()方法,而不是equals()方法,因为前者不会判断精度</p><h3 id="基本类型和包装类型">基本类型和包装类型</h3><ol type="1"><li>包装类型可用于泛型，而基本类型不可以</li><li>基本数据类型作为局部变量存放在栈中的局部变量表，成员变量存放在堆中；包装类型几乎都存在于堆中（逃逸分析）</li><li>基本数据类型有默认值，包装类型默认为null</li></ol><h3 id="为什么string是不可变的">为什么String是不可变的</h3><ol type="1"><li>保证 String对象的安全性，避免被篡改，毕竟像密码这种隐私信息一般就是用字符串存储的</li><li>保证哈希值不会频繁变更。毕竟要经常作为哈希表的键值，经常变更的话，哈希表的性能就会很差劲。</li><li>可以实现字符串常量池，Java会将相同内容的字符串存储在字符串常量池中。这样，具有相同内容的字符串变量可以指向同一个String 对象，节省内存空间。</li></ol><h3 id="字符串常量池">字符串常量池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;陈&quot;</span>);<br></code></pre></td></tr></table></figure><p>这行代码共创建了一个或两个对象：一个在字符串常量池中，一个在堆中</p><p>字符串常量池的位置：</p><ol type="1"><li>Java7之前在永久代中，永久代在堆中</li><li>java7时移动到堆中，永久代还在堆中</li><li>java8之后永久代被元空间替代，字符串常量池仍在堆中</li></ol><h3 id="永久代方法区元空间">永久代、方法区、元空间</h3><ul><li>方法区是 Java 虚拟机规范中的一个概念，就像是一个接口</li><li>永久代是 HotSpot虚拟机中对方法区的一个实现，就像是接口的实现类；</li><li>Java 8的时候，移除了永久代，取而代之的是元空间，是方法区的另外一种实现，更灵活了。<ul><li>它不会导致 OutOfMemoryError错误，因为元空间的大小可以动态调整。</li><li>元空间使用本机内存，而不是 JVM堆内存，这可以避免堆内存的碎片化问题。</li><li>元空间中的垃圾收集与堆中的垃圾收集是分离的，这可以避免应用程序在运行过程中因为进行类加载和卸载而频繁地触发Full GC。</li></ul></li></ul><h3 id="intern的作用">intern()的作用</h3><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br></code></pre></td></tr></table></figure><p>JVM首先会检查字符串常量池中是否已经存在字面值为"Java"的字符串对象。如果存在，就不会再创建一个新的字符串对象，而是直接将<code>s1</code>引用指向常量池中那已存在的字符串对象。如果不存在，JVM会在字符串常量池中创建一个新的字符串对象"Java"，然后<code>s1</code>引用指向这个新创建的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Java&quot;</span>)<br></code></pre></td></tr></table></figure><p>首先，如果字符串常量池中没有字面值为"java"的字符串，JVM会在常量池中创建一个"java"的字符串对象。如果常量池中已经存在"java"，则不会再创建。接着，<code>new String("java")</code>表达式会在堆内存中创建一个新的<code>String</code>对象。这个新的<code>String</code>对象会复制一份常量池中的"java"字符串作为自己的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;bro&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br>System.out.println(s1 == s2);<br></code></pre></td></tr></table></figure><p>返回false，因为s1指向的是堆中的对象，但是s2指向的是字符串常量池中的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br>System.out.println(s1 == s2);<br></code></pre></td></tr></table></figure><p>返回true，因为s1是对于常量池中的引用，s2也是</p><h3 id="stringbuffer和stringbuilder">StringBuffer和StringBuilder</h3><ol type="1"><li><code>String</code>中的对象是不可变的，也就可以理解为常量，线程安全。</li><li><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与<code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如<code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code>等公共方法。</li><li><code>StringBuffer</code>对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li><li><code>StringBuilder</code>并没有对方法进行加同步锁，所以是非线程安全的。如果要在多线程环境下修改字符串，可以使用<code>ThreadLocal</code>来避免多线程冲突。</li></ol><h3 id="异常">异常</h3><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240415163935.png" style="zoom: 67%;" /></p><ol type="1"><li><p><strong><code>Exception</code></strong>:程序本身可以处理的异常，可以通过 <code>catch</code>来进行捕获。</p></li><li><p><strong><code>Error</code></strong>：<code>Error</code>属于程序无法处理的错误</p></li><li><p>Java 代码在编译过程中，如果受检查异常（Checked Exception）没有被<code>catch</code>或者<code>throws</code>关键字处理的话，就没办法通过编译。</p></li></ol><h3 id="try-catch-final">try-catch-final</h3><h4id="try和final中都有return怎么执行">try和final中都有return，怎么执行？</h4><p>当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return语句会被忽略。这是因为 try 语句中的 return返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p><h4 id="final一定会执行吗">final一定会执行吗？</h4><p>finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Try to do something&quot;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;RuntimeException&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());<br>    <span class="hljs-comment">// 终止当前正在运行的Java虚拟机</span><br>    System.exit(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Finally&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="try-with-resource">try with resource</h4><p>Java中类似于<code>InputStream</code>、<code>OutputStream</code>、<code>Scanner</code>、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读取文本文件的内容</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D://read.txt&quot;</span>));<br>    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>        System.out.println(scanner.nextLine());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (scanner != <span class="hljs-literal">null</span>) &#123;<br>        scanner.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 Java 7 之后的 <code>try-with-resources</code>语句改造上面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>))) &#123;<br>    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>        System.out.println(scanner.nextLine());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException fnfe) &#123;<br>    fnfe.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射">反射</h3><p>赋予了我们在<strong>运行时</strong>分析类以及执行类中方法的能力。通过反射可以<strong>获取任意一个类的所有属性和方法</strong>，还可以<strong>调用这些方法和属性</strong>。可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis采用string存储实体对象</title>
    <link href="/2024/03/25/SoftwareDevelopment/Redis%E9%87%87%E7%94%A8string%E5%AD%98%E5%82%A8%E5%AE%9E%E4%BD%93%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/03/25/SoftwareDevelopment/Redis%E9%87%87%E7%94%A8string%E5%AD%98%E5%82%A8%E5%AE%9E%E4%BD%93%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>记录采用String而非Hash存储实体化对象的过程 <span id="more"></span></p><h3 id="问题描述">问题描述</h3><p>问题背景是在做登录验证的时候，需要将user暂时存储到redis上。</p><p>但是StringRedisTemplate无法直接将实体类对象转化为JSON格式存储，因此解决方案为</p><ol type="1"><li>使用Hash类型</li><li>进行序列化</li></ol><h3 id="json序列化">JSON序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">redisCode</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;login:code:&quot;</span> + phone);<br><br>    <span class="hljs-keyword">if</span>(!code.equals(redisCode))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>    &#125;<br><br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.eq(<span class="hljs-string">&quot;phone&quot;</span>,phone);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.selectOne(queryWrapper);<br><br>    <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">// 注册</span><br>        user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setCreateTime(DateTime.now().toLocalDateTime());<br>        user.setPhone(phone);<br>        user.setNickName(<span class="hljs-string">&quot;user_&quot;</span> + RandomUtil.randomString(<span class="hljs-number">10</span>));<br>        userMapper.insert(user);<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br><br>    <span class="hljs-comment">// 引入ObjectMapper</span><br>    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">userJson</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(user);<br><br>    redisTemplate.opsForValue().set(<span class="hljs-string">&quot;login:token:&quot;</span> + token, userJson, <span class="hljs-number">120</span>, TimeUnit.MINUTES);<br><br>    <span class="hljs-keyword">return</span> Result.ok(token);<br>&#125;<br></code></pre></td></tr></table></figure><p>在将user转化为json的时候，此处采用jackson的objectMapper，首先需要导入三个依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-datatype-jsr310<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中最后一个依赖用于在java8下将datetime类型转化为字符串。</p><p>同时，在pojo层还需要对datetime类型进行如下注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="hljs-meta">@JsonSerialize(using = LocalDateTimeSerializer.class)</span><br><span class="hljs-meta">@JsonDeserialize(using = LocalDateTimeDeserializer.class)</span><br><span class="hljs-keyword">private</span> LocalDateTime createTime;<br></code></pre></td></tr></table></figure><p>user的转化方式即为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 引入ObjectMapper</span><br><span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">userJson</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(user);<br></code></pre></td></tr></table></figure><p>读取时仍然采用objectMapper将字符串转化为User类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">userJson</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;login:token:&quot;</span> + token);<br><span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> objectMapper.readValue(userJson, User.class);<br></code></pre></td></tr></table></figure><p>可以看到Redis可以正确的进行存储</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240325201810.png" /></p><h3 id="更简单的序列化方式">更简单的序列化方式</h3><p>基于Hutools进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">redisTemplate.opsForValue().set(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id, JSONUtil.toJsonStr(shop));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id);<br><span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br></code></pre></td></tr></table></figure><h3 id="hash">Hash</h3><p>首先采用BeanUtil.copyProperties将User类映射到UserDTO(隐藏敏感信息)，然后使用BeanUtil.beanToMap将实体类对象转化为Map，然后就可以使用putAll插入到Redis中。注意使用opsForHash就只能单独设置有效期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br>Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),<br>        CopyOptions.create()<br>                .setIgnoreNullValue(<span class="hljs-literal">true</span>)<br>                .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));<br><span class="hljs-comment">// 7.3.存储</span><br><span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);<br><span class="hljs-comment">// 7.4.设置token有效期</span><br>stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);<br></code></pre></td></tr></table></figure><p>然后采用如下方式获取存储的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);<br><span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMao(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2024/03/24/SoftwareDevelopment/Redis/"/>
    <url>/2024/03/24/SoftwareDevelopment/Redis/</url>
    
    <content type="html"><![CDATA[<p>Redis学习</p><span id="more"></span><h3 id="sql-nosql">SQL &amp; noSQL</h3><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240324171909.png" /></p><h3 id="安装与启动">安装与启动</h3><h4 id="安装">安装</h4><p>Redis只能在Linux服务器使用，同时需要gcc环境</p><h4 id="后台启动">后台启动</h4><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，在解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span><br><span class="hljs-attr">bind</span> <span class="hljs-string">0.0.0.0</span><br><span class="hljs-comment"># 守护进程，修改为yes后即可后台运行</span><br><span class="hljs-attr">daemonize</span> <span class="hljs-string">yes </span><br><span class="hljs-comment"># 密码，设置后访问Redis必须输入密码</span><br><span class="hljs-attr">requirepass</span> <span class="hljs-string">123321</span><br></code></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 监听的端口</span><br><span class="hljs-attr">port</span> <span class="hljs-string">6379</span><br><span class="hljs-comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">.</span><br><span class="hljs-comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><br><span class="hljs-attr">databases</span> <span class="hljs-string">1</span><br><span class="hljs-comment"># 设置redis能够使用的最大内存</span><br><span class="hljs-attr">maxmemory</span> <span class="hljs-string">512mb</span><br><span class="hljs-comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span><br><span class="hljs-attr">logfile</span> <span class="hljs-string">&quot;redis.log&quot;</span><br></code></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入redis安装目录 </span><br><span class="hljs-built_in">cd</span> /usr/local/src/redis-6.2.6<br><span class="hljs-comment"># 启动</span><br>redis-server redis.conf<br></code></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span><br><span class="hljs-comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span><br>redis-cli -u 123321 shutdown<br></code></pre></td></tr></table></figure><h4 id="开机自启">开机自启</h4><p>通过配置来实现开机自启。首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vi /etc/systemd/system/redis.service<br></code></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf">[Unit]<br>Description=redis-server<br>After=network.target<br><br>[Service]<br>Type=forking<br>ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf<br>PrivateTmp=true<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl daemon-reload<br></code></pre></td></tr></table></figure><p>用下面这组命令来操作redis：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 启动</span><br>systemctl start redis<br><span class="hljs-comment"># 停止</span><br>systemctl stop redis<br><span class="hljs-comment"># 重启</span><br>systemctl restart redis<br><span class="hljs-comment"># 查看状态</span><br>systemctl status redis<br></code></pre></td></tr></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl <span class="hljs-built_in">enable</span> redis<br></code></pre></td></tr></table></figure><h4 id="命令行客户端">命令行客户端</h4><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli [options] [commonds]<br></code></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p><h4 id="远程连接">远程连接</h4><p>使用一些图形化客户端程序进行链接，服务器一定注意开启6397端口号</p><h3 id="常用数据结构与命令">常用数据结构与命令</h3><h4 id="通用">通用</h4><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除（验证码）</li><li>TTL：查看一个KEY的剩余有效期</li></ul><h4 id="string">String</h4><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><p>层级结构</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用':'隔开，格式如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">项目名:业务名:类型:<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p><p>例如我们的项目名称叫heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr class="header"><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr class="odd"><td>heima:user:1</td><td>{"id":1, "name": "Jack", "age": 21}</td></tr><tr class="even"><td>heima:product:1</td><td>{"id":1, "name": "小米11", "price": 4999}</td></tr></tbody></table><h4 id="hash">Hash</h4><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240325132100.png" /></p><h4 id="list">List</h4><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><ul><li>LPUSH key element ... ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element ... ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p>List使用示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryTypeList</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; shops = redisTemplate.opsForList().range(<span class="hljs-string">&quot;cache:shop-type&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(shops != <span class="hljs-literal">null</span> &amp;&amp; !shops.isEmpty())&#123;<br>        List&lt;ShopType&gt; shopTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String type:shops)&#123;<br>            shopTypes.add(JSONUtil.toBean(type, ShopType.class));<br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.ok(shopTypes);<br>    &#125;<br><br>    QueryWrapper&lt;ShopType&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.orderByAsc(<span class="hljs-string">&quot;sort&quot;</span>);<br><br>    List&lt;ShopType&gt; shopTypes = shopTypeMapper.selectList(queryWrapper);<br>    <span class="hljs-keyword">if</span>(shops != <span class="hljs-literal">null</span> &amp;&amp; !shopTypes.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;无店铺类型信息&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(ShopType shopType : shopTypes)&#123;<br>        redisTemplate.opsForList().rightPush(<span class="hljs-string">&quot;cache:shop-type&quot;</span>, JSONUtil.toJsonStr(shopType));<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok(shopTypes);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="set">Set</h4><ul><li>SADD key member ... ：向set中添加一个或多个元素</li><li>SREM key member ... : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 ... ：求key1与key2的交集</li><li>SDIFF key1 key2 ... ：求key1与key2的差集</li><li>SUNION key1 key2 ... ：求key1与key2的并集</li></ul><h4 id="sorted-set">Sorted Set</h4><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加hash表。</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sortedset中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key minmax：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK keymember</p></li><li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANKkey memeber</p></li></ul><p>将班级的下列学生得分存入Redis的SortedSet中：</p><p>Jack 85, Lucy 89, Rose 82, Tom 95, Jerry 78, Amy 92, Miles 76</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zadd stu <span class="hljs-number">85</span> jack <span class="hljs-number">89</span> lucy <span class="hljs-number">82</span> rose <span class="hljs-number">95</span> tom <span class="hljs-number">78</span> jerry <span class="hljs-number">92</span> amy <span class="hljs-number">76</span> miles<br></code></pre></td></tr></table></figure><p>并实现下列功能：</p><ul><li><p>删除Tom同学</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zrem stu tom<br></code></pre></td></tr></table></figure></p></li><li><p>获取Amy同学的分数</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zscore stu amy<br></code></pre></td></tr></table></figure></p></li><li><p>获取Rose同学的排名</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zrevrank stu rose<br></code></pre></td></tr></table></figure></p></li><li><p>查询80分以下有几个学生</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zcount stu <span class="hljs-number">0</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure></p></li><li><p>给Amy同学加2分</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zincrby stu <span class="hljs-number">2</span> amy<br></code></pre></td></tr></table></figure></p></li><li><p>查出成绩前3名的同学</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zrevrange stu <span class="hljs-number">0</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></p></li><li><p>查出成绩80分以下的所有同学 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ZRANGEBYSCORE stu <span class="hljs-number">0</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure></p></li></ul><h3 id="java客户端">Java客户端</h3><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h4 id="jedis">Jedis</h4><p>1）引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jedis--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--单元测试--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）建立连接</p><p>新建一个单元测试类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Jedis jedis;<br><br><span class="hljs-meta">@BeforeEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.建立连接</span><br>    jedis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.150.101&quot;</span>, <span class="hljs-number">6379</span>);<br>    <span class="hljs-comment">// 2.设置密码</span><br>    jedis.auth(<span class="hljs-string">&quot;123321&quot;</span>);<br>    <span class="hljs-comment">// 3.选择库</span><br>    jedis.select(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>3）测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 存入数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;虎哥&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>    <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 插入hash数据</span><br>    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);<br>    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>);<br><br>    <span class="hljs-comment">// 获取</span><br>    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="hljs-string">&quot;user:1&quot;</span>);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>4）释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;<br>        jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5）连接池</p><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，使用Jedis连接池代替Jedis的直连方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heima.jedis.util;<br><br><span class="hljs-keyword">import</span> redis.clients.jedis.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectionFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 配置连接池</span><br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        poolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>        poolConfig.setMaxIdle(<span class="hljs-number">8</span>);<br>        poolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>        poolConfig.setMaxWaitMillis(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span><br>        jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig, <span class="hljs-string">&quot;192.168.150.101&quot;</span>, <span class="hljs-number">6379</span>, <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;123321&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> jedisPool.getResource();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="springdataredis">SpringDataRedis</h4><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><h5 id="redistemplate">RedisTemplate</h5><p>1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redis-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>redis-demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--redis依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--common-pool--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--Jackson依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）配置Redis</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123321</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">100ms</span><br></code></pre></td></tr></table></figure><p>3）注入RedisTemplate</p><p>因为有了SpringBoot的自动装配，我们可以拿来就用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>&#125;<br></code></pre></td></tr></table></figure><p>4）编写测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate edisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 写入一条String数据</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;虎哥&quot;</span>);<br>        <span class="hljs-comment">// 获取string数据</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="springredistemplate">SpringRedisTemplate</h5><p>RedisTemplate不能自动序列化、反序列化，使用不便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br></code></pre></td></tr></table></figure><h3 id="redis进行登录校验">Redis进行登录校验</h3><p>核心流程如下图所示</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240325202024.png" /></p><h3 id="缓存">缓存</h3><h4 id="基本思路">基本思路</h4><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240326191446.png" /></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 查Redis</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id);<br>    <span class="hljs-keyword">if</span> (!StrUtil.isBlank(shopJson))&#123;<span class="hljs-comment">// 如果存在，直接返回</span><br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> shopMapper.selectById(id);<span class="hljs-comment">// 如果不存在，数据库查</span><br>    <span class="hljs-keyword">if</span>(shop == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>    &#125;<br><br>    redisTemplate.opsForValue().set(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id, JSONUtil.toJsonStr(shop));<span class="hljs-comment">// 写入Redis</span><br>    <span class="hljs-keyword">return</span> Result.ok(shop);<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数据不一致问题">数据不一致问题</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等</p><p>如果我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li>删除缓存还是更新缓存？<ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul></li><li>如何保证缓存与数据库的操作的同时成功或失败？<ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li></ul><p>应当是<strong>先操作数据库，再删除缓存</strong>，原因在于，如果选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240326205608.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">updateShop</span><span class="hljs-params">(Shop shop)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> shop.getId();<br>    <span class="hljs-keyword">if</span>(id == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;无商店信息&quot;</span>);<br>    &#125;<br>    shopMapper.updateById(shop);<br>    redisTemplate.delete(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="缓存穿透问题">缓存穿透问题</h4><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p><h4 id="缓存雪崩问题">缓存雪崩问题</h4><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><h4 id="缓存击穿问题">缓存击穿问题</h4><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法，那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240327174916.png" /></p><p>解决方案一、使用锁来解决：</p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法+ double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240327175011.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id);<br>    <span class="hljs-keyword">if</span> (!StrUtil.isBlank(shopJson))&#123;<br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;&quot;</span>.equals(shopJson))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 获取互斥锁</span><br>    <span class="hljs-keyword">if</span>(tryLock(<span class="hljs-string">&quot;shop:lock&quot;</span>))&#123;<br>        <span class="hljs-comment">// double check, 如果其他线程已经重建完成，那么递归到这里的时候就不应该再次重建</span><br>        shopJson = redisTemplate.opsForValue().get(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id);<br>        <span class="hljs-keyword">if</span> (!StrUtil.isBlank(shopJson))&#123;<br>            shop = JSONUtil.toBean(shopJson, Shop.class);<br>            <span class="hljs-keyword">return</span> Result.ok(shop);<br>        &#125;<br><br>        shop = shopMapper.selectById(id);<br>        <span class="hljs-keyword">if</span>(shop == <span class="hljs-literal">null</span>)&#123;<br>            redisTemplate.opsForValue().set(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">2</span>, TimeUnit.MINUTES);<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);<br>        &#125;<br><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;cache:shop:id:&quot;</span> + id, JSONUtil.toJsonStr(shop), <span class="hljs-number">30</span>, TimeUnit.MINUTES);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        Thread.sleep(<span class="hljs-number">50</span>);   <span class="hljs-comment">// 休眠50ms之后递归访问</span><br>        <span class="hljs-keyword">return</span> queryById(id);<br>    &#125;<br><br>    unlock(<span class="hljs-string">&quot;shop:lock&quot;</span>);<br>    <span class="hljs-keyword">return</span> Result.ok(shop);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span>&#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>    <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span>&#123;<br>    redisTemplate.delete(key);<br>&#125;<br></code></pre></td></tr></table></figure><p>解决方案二、逻辑过期方案</p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个线程去进行以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁，而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240327175025.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisData</span> &#123;<br>    <span class="hljs-keyword">private</span> LocalDateTime expireTime;<br>    <span class="hljs-keyword">private</span> Object data;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">( Long id )</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;<br>    <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isBlank(json)) &#123;<br>        <span class="hljs-comment">// 3.存在，直接返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4.命中，需要先把json反序列化为对象</span><br>    <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, RedisData.class);<br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);<br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>    <span class="hljs-comment">// 5.判断是否过期</span><br>    <span class="hljs-keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 5.1.未过期，直接返回店铺信息</span><br>        <span class="hljs-keyword">return</span> shop;<br>    &#125;<br>    <span class="hljs-comment">// 5.2.已过期，需要缓存重建</span><br>    <span class="hljs-comment">// 6.缓存重建</span><br>    <span class="hljs-comment">// 6.1.获取互斥锁</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>    <span class="hljs-comment">// 6.2.判断是否获取锁成功</span><br>    <span class="hljs-keyword">if</span> (isLock)&#123;<br>        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;<br><br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//重建缓存</span><br>                <span class="hljs-built_in">this</span>.saveShop2Redis(id,<span class="hljs-number">20L</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                unlock(lockKey);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 6.4.返回过期的商铺信息</span><br>    <span class="hljs-keyword">return</span> shop;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240327175039.png" /></p><h3 id="秒杀">秒杀</h3><h4 id="全局id">全局ID</h4><p>订单表如果使用数据库自增ID就存在一些问题：</p><ul><li>id的规律性太明显</li><li>受单表数据量的限制</li></ul><p>场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p><p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的，于是乎我们需要保证id的唯一性。</p><p><strong>基于Redis实现的全局ID组成部分</strong>：</p><p>符号位：1bit，永远为0</p><p>时间戳：31bit，以秒为单位，可以使用69年</p><p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdWorker</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始时间戳</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1640995200L</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列号的位数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisIdWorker</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span> &#123;<br>        <span class="hljs-comment">// 1.生成时间戳</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> nowSecond - BEGIN_TIMESTAMP;<br><br>        <span class="hljs-comment">// 2.生成序列号</span><br>        <span class="hljs-comment">// 2.1.获取当前日期，精确到天</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-comment">// 2.2.自增长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);<br><br>        <span class="hljs-comment">// 3.拼接并返回</span><br>        <span class="hljs-keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基本逻辑">基本逻辑</h4><p>首先判断秒杀券的时间，然后先扣减库存，再生成订单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">secikllVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> voucherMapper.selectById(voucherId);<br>    <span class="hljs-keyword">if</span>(seckillVoucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(seckillVoucher.getEndTime().isBefore(LocalDateTime.now()))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(seckillVoucher.getStock() &lt; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>    &#125;<br><br>    seckillVoucher.setStock(seckillVoucher.getStock() - <span class="hljs-number">1</span>);<br>    voucherMapper.updateById(seckillVoucher);<br><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> idWorker.nextId(<span class="hljs-string">&quot;voucher:order&quot;</span>);<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><br>    voucherOrder.setUserId(userId);<br>    voucherOrder.setVoucherId(voucherId);<br>    voucherOrder.setId(orderId);<br>    save(voucherOrder);<br><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="超卖问题">超卖问题</h4><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240330185537.png" /></p><p>乐观锁的典型代表：就是cas（compare andswap），利用cas进行无锁化机制加锁，var5是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 ==内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p><p>其中do while是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> var5;<br><span class="hljs-keyword">do</span> &#123;<br>    var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2);<br>&#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br><br><span class="hljs-keyword">return</span> var5;<br></code></pre></td></tr></table></figure><p>实际操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">seckillVoucher.setStock(seckillVoucher.getStock() - <span class="hljs-number">1</span>);<br>QueryWrapper&lt;SeckillVoucher&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>wrapper.gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> voucherMapper.update(seckillVoucher, wrapper);<br><span class="hljs-keyword">if</span>(row == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一人一单问题">一人一单问题</h4><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240330202206.png" /></p><p>需要注意的一些问题：</p><ol type="1"><li><p>在方法上添加了一把synchronized锁？锁的粒度太粗了，应该对单个用户加锁</p></li><li><p><code>intern()</code>方法是用于返回字符串对象的规范表示形式，这里的目的是确保即使有多个相同内容的字符串对象，锁定的也是同一个对象，从而确保线程安全。</p></li><li><p>锁为什么在主函数的return前后？如果加在子方法，子方法被spring的事务控制，如果在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题</p></li><li><p>在Spring框架中，当你在一个对象的内部方法中使用<code>this</code>关键字调用另一个方法时，你直接调用的是那个方法的本体。这种调用方式会<strong>绕过Spring的代理机制</strong>，导致与那个方法相关的AOP逻辑（例如事务管理）不会被触发。为了让事务能够正确管理，需要通过Spring的代理对象来调用那个方法，这样Spring框架就能够在调用前后执行相关的AOP逻辑，比如开启和提交（或回滚）事务。</p></li><li><p>为了实现该方法，需要添加依赖和注解</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.hmdp.mapper&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableAspectJAutoProxy(exposeProxy = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HmDianPingApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(HmDianPingApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">secikllVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> voucherMapper.selectById(voucherId);<br>    <span class="hljs-keyword">if</span>(seckillVoucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(seckillVoucher.getEndTime().isBefore(LocalDateTime.now()))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(seckillVoucher.getStock() &lt; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>    <span class="hljs-keyword">synchronized</span> (user.getId().toString().intern())&#123;<br>        <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>        <span class="hljs-keyword">return</span> proxy.createOrder(seckillVoucher);<br>    &#125;<br><br>&#125;<br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createOrder</span><span class="hljs-params">(SeckillVoucher seckillVoucher)</span>&#123;<br><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>    QueryWrapper&lt;VoucherOrder&gt; wrapper1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    wrapper1.eq(<span class="hljs-string">&quot;user_id&quot;</span>, user.getId()).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, seckillVoucher.getVoucherId());<br>    List&lt;VoucherOrder&gt; voucherOrders = getBaseMapper().selectList(wrapper1);<br>    <span class="hljs-keyword">if</span>(!voucherOrders.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不可重复下单&quot;</span>);<br>    &#125;<br><br>    seckillVoucher.setStock(seckillVoucher.getStock() - <span class="hljs-number">1</span>);<br>    QueryWrapper&lt;SeckillVoucher&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    wrapper.gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> voucherMapper.update(seckillVoucher, wrapper);<br><br>    <span class="hljs-keyword">if</span>(row == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> idWorker.nextId(<span class="hljs-string">&quot;voucher:order&quot;</span>);<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><br>    voucherOrder.setUserId(userId);<br>    voucherOrder.setVoucherId(seckillVoucher.getVoucherId());<br>    voucherOrder.setId(orderId);<br>    save(voucherOrder);<br><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="集群环境下的并发问题">集群环境下的并发问题</h4><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240330210546.png" /></p><h3 id="基于redis的分布式锁">基于Redis的分布式锁</h3><h4 id="基础版本">基础版本</h4><p>利用redis 的setNx方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis中就有这个key了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    StringRedisTemplate redisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisLock</span><span class="hljs-params">(String name, StringRedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, String.valueOf(id), timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        redisTemplate.delete(KEY_PREFIX + name);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br><span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> user.getId();<br><span class="hljs-type">RedisLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisLock</span>(<span class="hljs-string">&quot;order:&quot;</span> + voucherId + <span class="hljs-string">&quot;:&quot;</span> + id, redisTemplate);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">100</span>);<br><span class="hljs-keyword">if</span>(!isLock)&#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createOrder(seckillVoucher);<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="误删问题">误删问题</h4><p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><p>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p><ul><li>如果一致则释放锁</li><li>如果不一致则不释放锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    StringRedisTemplate redisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.fastUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&#x27;-&#x27;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisLock</span><span class="hljs-params">(String name, StringRedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, id, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(KEY_PREFIX + name);<br>        <span class="hljs-keyword">if</span> ((ID_PREFIX + Thread.currentThread().getId()).equals(id))&#123;<br>            redisTemplate.delete(KEY_PREFIX + name);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="原子性问题">原子性问题</h4><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的。</p><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：https://www.runoob.com/lua/lua-tutorial.html，</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>]) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    StringRedisTemplate redisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.fastUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&#x27;-&#x27;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<br>    <span class="hljs-keyword">static</span> &#123;<br>        UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>));<br>        UNLOCK_SCRIPT.setResultType(Long.class);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisLock</span><span class="hljs-params">(String name, StringRedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, id, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        redisTemplate.execute(<br>                UNLOCK_SCRIPT, <br>                Collections.singletonList(KEY_PREFIX + name), <br>                ID_PREFIX + Thread.currentThread().getId());<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="redisson">Redisson</h3><p>上述基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong>如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory DataGrid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><h4 id="基本实现">基本实现</h4><ol type="1"><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>配置Redisson</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://43.153.142.8:6379&quot;</span>).setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>使用Redisson</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + voucherId + <span class="hljs-string">&quot;:&quot;</span> + id);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br><br><span class="hljs-keyword">if</span>(!isLock)&#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createOrder(seckillVoucher);<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可重入性">可重入性</h4><p>redis中锁的存储使用hash结构，其中key为线程名称，value为重入次数，第一次获取即为1，第二次当前线程获取时即变为2</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240401220957.png" /></p><h4 id="主从一致性">主从一致性</h4><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上，主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的，这把锁加锁的逻辑需要写入到每一个主丛节点上，<strong>只有所有的服务器都写入成功，此时才是加锁成功</strong>，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数* 1500ms，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功，那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p><h3 id="秒杀优化">秒杀优化</h3><h4 id="异步秒杀">异步秒杀</h4><p>当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p><p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240402185808.png" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240402185840.png" /></p><ol type="1"><li><p>在添加秒杀券的时候同步存入redis</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSeckillVoucher</span><span class="hljs-params">(Voucher voucher)</span> &#123;<br>    <span class="hljs-comment">// 保存优惠券</span><br>    save(voucher);<br>    <span class="hljs-comment">// 保存秒杀信息</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeckillVoucher</span>();<br>    seckillVoucher.setVoucherId(voucher.getId());<br>    seckillVoucher.setStock(voucher.getStock());<br>    seckillVoucher.setBeginTime(voucher.getBeginTime());<br>    seckillVoucher.setEndTime(voucher.getEndTime());<br>    seckillVoucherService.save(seckillVoucher);<br>    <span class="hljs-comment">// 保存秒杀库存到Redis中</span><br>    <span class="hljs-comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span><br>    <span class="hljs-comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span><br>    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>编写lua脚本保证原子性</p><p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 1.参数列表</span><br><span class="hljs-comment">-- 1.1.优惠券id</span><br><span class="hljs-keyword">local</span> voucherId = ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-comment">-- 1.2.用户id</span><br><span class="hljs-keyword">local</span> userId = ARGV[<span class="hljs-number">2</span>]<br><span class="hljs-comment">-- 1.3.订单id</span><br><span class="hljs-keyword">local</span> orderId = ARGV[<span class="hljs-number">3</span>]<br><br><span class="hljs-comment">-- 2.数据key</span><br><span class="hljs-comment">-- 2.1.库存key</span><br><span class="hljs-keyword">local</span> stockKey = <span class="hljs-string">&#x27;seckill:stock:&#x27;</span> .. voucherId<br><span class="hljs-comment">-- 2.2.订单key</span><br><span class="hljs-keyword">local</span> orderKey = <span class="hljs-string">&#x27;seckill:order:&#x27;</span> .. voucherId<br><br><span class="hljs-comment">-- 3.脚本业务</span><br><span class="hljs-comment">-- 3.1.判断库存是否充足 get stockKey</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.2.库存不足，返回1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.3.存在，说明是重复下单，返回2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.4.扣库存 incrby stockKey -1</span><br>redis.call(<span class="hljs-string">&#x27;incrby&#x27;</span>, stockKey, <span class="hljs-number">-1</span>)<br><span class="hljs-comment">-- 3.5.下单（保存用户）sadd orderKey userId</span><br>redis.call(<span class="hljs-string">&#x27;sadd&#x27;</span>, orderKey, userId)<br><span class="hljs-comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span><br>redis.call(<span class="hljs-string">&#x27;xadd&#x27;</span>, <span class="hljs-string">&#x27;stream.orders&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;userId&#x27;</span>, userId, <span class="hljs-string">&#x27;voucherId&#x27;</span>, voucherId, <span class="hljs-string">&#x27;id&#x27;</span>, orderId)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></p></li><li><p>添加堵塞队列，返回结果</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">secikllVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> redisTemplate.execute(<br>            SECKILL_SCRIPT,<br>            Collections.emptyList(),<br>            voucherId,<br>            UserHolder.getUser().getId()<br>    );<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> result.intValue();<br>    <span class="hljs-keyword">if</span>(r!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(r==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不能重复下单&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> idWorker.nextId(<span class="hljs-string">&quot;voucher:order&quot;</span>);<br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="/2024/03/22/SoftwareDevelopment/SpringMVC/"/>
    <url>/2024/03/22/SoftwareDevelopment/SpringMVC/</url>
    
    <content type="html"><![CDATA[<p>springMVC学习</p><span id="more"></span><h3 id="核心组件与调用流程">核心组件与调用流程</h3><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240322155606.png" /></p><p><strong>SpringMVC涉及组件理解：</strong> 1. DispatcherServlet :SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发！[CEO ] 2. HandlerMapping :SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！[秘书]3. HandlerAdapter :SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器！[经理]4. Handler :handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果！[打工人]5. ViewResovler :SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的！[财务]</p><h3 id="参数接收">参数接收</h3><p>参见SpringBoot模块</p><h3 id="全局异常处理">全局异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * projectName: com.atguigu.execptionhandler</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * description: 全局异常处理器,内部可以定义异常处理Handler!</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RestControllerAdvice</span> = <span class="hljs-doctag">@ControllerAdvice</span> + <span class="hljs-doctag">@ResponseBody</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ControllerAdvice</span> 代表当前类的异常处理controller! </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常处理handler </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@ExceptionHandler</span>(HttpMessageNotReadableException.class) </span><br><span class="hljs-comment">     * 该注解标记异常处理Handler,并且指定发生异常调用该方法!</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 获取异常对象!</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回handler处理结果!</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(HttpMessageNotReadableException.class)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">handlerJsonDateException</span><span class="hljs-params">(HttpMessageNotReadableException e)</span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当发生空指针异常会触发此方法!</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(NullPointerException.class)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">handlerNullException</span><span class="hljs-params">(NullPointerException e)</span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 所有异常都会触发此方法!但是如果有具体的异常处理Handler! </span><br><span class="hljs-comment">     * 具体异常处理Handler优先级更高!</span><br><span class="hljs-comment">     * 例如: 发生NullPointerException异常!</span><br><span class="hljs-comment">     *       会触发handlerNullException方法,不会触发handlerException方法!</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">handlerException</span><span class="hljs-params">(Exception e)</span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拦截器">拦截器</h3><h4 id="拦截器和过滤器">拦截器和过滤器</h4><p>Filter处于整个SpringMVC外部进行过滤，拦截器在Handler方法调用前后进行拦截</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240322164304.png" /></p><p>拦截器 Springmvc VS 过滤器 javaWeb：</p><ul><li>相似点<ul><li>拦截：必须先把请求拦住，才能执行后续操作</li><li>过滤：拦截器或过滤器存在的意义就是对请求进行统一处理</li><li>放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源</li></ul></li><li>不同点<ul><li>工作平台不同<ul><li>过滤器工作在 Servlet 容器中</li><li>拦截器工作在 SpringMVC 的基础上</li></ul></li><li>拦截的范围<ul><li>过滤器：能够拦截到的最大范围是整个 Web 应用</li><li>拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求</li></ul></li><li>IOC 容器支持<ul><li>过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的</li><li>拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC容器中装配组件，也就是可以直接得到 IOC 容器的支持</li></ul></li></ul></li></ul><figure><imgsrc="https://secure-bigfile.wostatic.cn/static/prqG4dtu3rDWj7VwX4WgsW/image.png?auth_key=1711097129-t5FPdcvuXo9HR3hbxiT6bu-0-8562a1a0170f20142e3bd7656e687ca7&amp;file_size=9432213"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="使用方法">使用方法</h4><p>创建拦截器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Process01Interceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-comment">// if( ! preHandler())&#123;return;&#125;</span><br>    <span class="hljs-comment">// 在处理请求的目标 handler 方法前执行</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;request = &quot;</span> + request + <span class="hljs-string">&quot;, response = &quot;</span> + response + <span class="hljs-string">&quot;, handler = &quot;</span> + handler);<br>        System.out.println(<span class="hljs-string">&quot;Process01Interceptor.preHandle&quot;</span>);<br>         <br>        <span class="hljs-comment">// 返回true：放行</span><br>        <span class="hljs-comment">// 返回false：不放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">// 在目标 handler 方法之后，handler报错不执行!</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;request = &quot;</span> + request + <span class="hljs-string">&quot;, response = &quot;</span> + response + <span class="hljs-string">&quot;, handler = &quot;</span> + handler + <span class="hljs-string">&quot;, modelAndView = &quot;</span> + modelAndView);<br>        System.out.println(<span class="hljs-string">&quot;Process01Interceptor.postHandle&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">// 渲染视图之后执行(最后),一定执行!</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;request = &quot;</span> + request + <span class="hljs-string">&quot;, response = &quot;</span> + response + <span class="hljs-string">&quot;, handler = &quot;</span> + handler + <span class="hljs-string">&quot;, ex = &quot;</span> + ex);<br>        System.out.println(<span class="hljs-string">&quot;Process01Interceptor.afterCompletion&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebMvc</span>  <span class="hljs-comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;)</span> <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 进行controller扫描</span><br><span class="hljs-comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-comment">//添加拦截器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123; <br>        <span class="hljs-comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Process01Interceptor</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>    <br>    <span class="hljs-comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span><br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Process01Interceptor</span>());<br>    <br>    <span class="hljs-comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span><br>    <span class="hljs-comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span><br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Process01Interceptor</span>()).addPathPatterns(<span class="hljs-string">&quot;/common/request/one&quot;</span>,<span class="hljs-string">&quot;/common/request/tow&quot;</span>);<br>    <br>    <br>    <span class="hljs-comment">//排除匹配,排除应该在匹配的范围内排除</span><br>    <span class="hljs-comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span><br>    <span class="hljs-comment">//excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内</span><br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Process01Interceptor</span>())<br>            .addPathPatterns(<span class="hljs-string">&quot;/common/request/one&quot;</span>,<span class="hljs-string">&quot;/common/request/tow&quot;</span>)<br>            .excludePathPatterns(<span class="hljs-string">&quot;/common/request/tow&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>毕设</title>
    <link href="/2024/03/21/BJUT/%E6%AF%95%E8%AE%BE/"/>
    <url>/2024/03/21/BJUT/%E6%AF%95%E8%AE%BE/</url>
    
    <content type="html"><![CDATA[<p>本科毕设 <span id="more"></span></p><h2 id="现有情况">现有情况</h2><ol type="1"><li><p>Exp17为做基于特征分布的零样本学习的文件夹</p><ol type="1"><li>输入数据格式为（batch_size, 4, 96, 96, 64）</li></ol></li><li><p>Exp10/utils是生成训练数据的代码</p><ol type="1"><li>上面的4代表四个模态['FLAIR', 'T1', 'T1C', 'T2']</li><li>（96，96，64）为经过mask之后将图片缩放到的大小</li><li>labels = np.array([tri_category, six_category, IDH,onep19q])，因此在进行三分类、六分类的时候要改WholeDataset里面的信息。</li></ol></li><li><p>七个模态</p><p>这些模态通常指的是磁共振成像（MRI）中的不同成像技术或序列，每种模态可以揭示脑组织的不同属性或病理状态。MRI是一种强大的医学成像工具，能够提供高分辨率的三维图像，用于诊断、研究和治疗规划。以下是提到的模态的简要说明：</p><ol type="1"><li><strong>ADC (Apparent Diffusion Coefficient)</strong>:体现水分子在组织中扩散能力的图像。ADC图像常用于脑卒中的诊断，特别是早期识别缺血性脑卒中，因为水分子在受损脑细胞中的扩散受到限制。</li><li><strong>DWI (Diffusion Weighted Imaging)</strong>:一种特殊的MRI技术，用来测量水分子在脑组织中的扩散过程。DWI对于检测急性或早期脑缺血非常有用，因为缺血区域的水分子扩散会受到限制。</li><li><strong>FLAIR (Fluid Attenuated Inversion Recovery)</strong>:一种特殊的成像序列，用于抑制脑脊液（CSF）的信号，使脑组织中的病变（如多发性硬化斑块或其他炎症）更容易被检测到。</li><li><strong>T1</strong>:一种MRI序列，能够提供组织结构的详细图像。在T1加权成像中，脂肪组织显示为高信号（亮白色），而水和脑脊液显示为低信号（暗色）。</li><li><strong>T1C (T1 with Contrast)</strong>:使用对比剂（如含钆的药物）进行的T1成像。对比剂可以提高某些病变（如肿瘤）的可见性，因为这些病变可能会吸收对比剂而显示为更高的信号强度。</li><li><strong>T2</strong>:另一种MRI序列，与T1成像相反，水和脑脊液在T2加权成像中显示为高信号（亮白色）。T2成像对于检测脑内的水分变化和病变非常有用。</li></ol><p>这些模态各有其独特的优点，在临床诊断和研究中常常结合使用，以提供有关疾病状态的更全面视图。例如，结合使用这些模态可以更精确地检测和定位脑肿瘤、脑缺血、炎症性疾病和其他脑部病变。</p></li><li><p>样本分布</p><figure><imgsrc="C:/Users/chenl/AppData/Roaming/Typora/typora-user-images/image-20240401154222425.png"alt="image-20240401154222425" /><figcaption aria-hidden="true">image-20240401154222425</figcaption></figure><p>匹配到1243个数据 WHO三分类数据分布: [302, 241, 700]WHO六分类数据分布: [209, 700, 91, 2, 164, 77]</p></li></ol><p>三分类 训练集分布： {0: 302, 1: 241, 2: 697} 测试集分布： {0: 41, 1:28, 2: 83} 验证集分布： {0: 55, 1: 42, 2: 126} 六分类 训练集分布： {0:209, 1: 697, 2: 91, 3: 2, 4: 164, 5: 77} 测试集分布： {0: 28, 1: 83, 2:12, 3: 1, 4: 19, 5: 9} 验证集分布： {0: 36, 1: 126, 2: 18, 3: 1, 4: 27,5: 15}</p><h2 id="实验结果">实验结果</h2><h3 id="全数据废弃">全数据（废弃）</h3><h4 id="三分类baseline-300轮">三分类baseline 300轮</h4><p>数据来源于Exp19</p><p>测试集总体精度为: 0.9850746393203735 测试集各类精度为:tensor([1.0000, 0.9688, 0.9848]) 测试集混淆矩阵为: tensor([[ 37., 0.,0.], [ 1., 31., 0.], [ 2., 0., 130.]])</p><h4 id="三分类次序约束全样本-300轮">三分类+次序约束+全样本 300轮</h4><p>数据来源于Exp18</p><p>测试集总体精度为: 0.7960199117660522 测试集各类精度为:tensor([0.4865, 0.6250, 0.9242]) 测试集混淆矩阵为: tensor([[ 18., 5.,14.], [ 7., 20., 5.], [ 5., 5., 122.]])</p><h4 id="三分类0样本学习-300轮">三分类+0样本学习 300轮</h4><p>数据来源于Exp20</p><p>测试集总体精度为: 0.7661691308021545 测试集各类精度为:tensor([0.0000, 0.9697, 0.9919]) 测试集混淆矩阵为: tensor([[ 0., 26.,19.], [ 0., 32., 1.], [ 0., 1., 122.]])</p><h4 id="三分类特征约束0样本学习-300轮">三分类+特征约束+0样本学习300轮</h4><p>数据来源于Exp17_fix_fix</p><p>测试集总体精度为: 0.6915422677993774 测试集各类精度为:tensor([0.0000, 0.6667, 0.9512]) 测试集混淆矩阵为: tensor([[ 0., 24.,21.], [ 0., 22., 11.], [ 0., 6., 117.]])</p><h3 id="匹配数据废弃">匹配数据（废弃）</h3><h4 id="三分类baseline-200轮">三分类baseline 200轮</h4><p>数据来源于Exp19</p><p>测试集总体精度为: 0.875 测试集各类精度为: tensor([0.8780, 0.7143,0.9277]) 测试集混淆矩阵为: tensor([[36., 1., 4.], [ 5., 20., 3.], [ 5.,1., 77.]])</p><h3 id="均衡后匹配数据废弃">均衡后匹配数据（废弃）</h3><p>训练集分布： {0: 206, 1: 171, 2: 254} 测试集分布： {0: 41, 1: 28, 2:42} 验证集分布： {0: 55, 1: 42, 2: 61}</p><h4 id="baseline300">baseline300</h4><p>Exp19_balanced</p><p>测试集总体精度为: 0.6126126050949097 测试集各类精度为:tensor([0.8537, 0.3571, 0.5476]) 测试集混淆矩阵为: tensor([[35., 2.,4.], [16., 10., 2.], [14., 5., 23.]])</p><h4 id="次序约束200">次序约束200</h4><p>Exp18_balanced</p><p>测试集总体精度为: 0.6666666865348816 测试集各类精度为:tensor([0.5366, 0.6429, 0.8095]) 测试集混淆矩阵为: tensor([[22., 11.,8.], [ 8., 18., 2.], [ 7., 1., 34.]])</p><h4 id="次序约束0样本300">次序约束0样本300</h4><p>exp22</p><p>测试集总体精度为: 0.5405405163764954 测试集各类精度为:tensor([0.0000, 0.7857, 0.9048]) 测试集混淆矩阵为: tensor([[ 0., 27.,14.], [ 0., 22., 6.], [ 0., 4., 38.]])</p><h3 id="均衡后匹配数据第二类极少样本">均衡后匹配数据+第二类极少样本</h3><p>郑大generated后数据_balanced_less</p><p>训练集分布： {0: 6, 1: 171, 2: 244} 测试集分布： {0: 41, 1: 28, 2:35} 验证集分布： {0: 55, 1: 42, 2: 64}</p><h4 id="baseline">baseline</h4><p>测试集总体精度为: 0.5096153616905212<br />测试集各类精度为: tensor([0.0000, 0.8571, 0.8286])<br />测试集混淆矩阵为: tensor([[ 0., 31., 10.],<br />[ 0., 24., 4.],<br />[ 0., 6., 29.]])</p><h4 id="次序约束">次序约束</h4><p>测试集总体精度为: 0.5192307829856873 测试集各类精度为:tensor([0.0000, 0.8929, 0.8286]) 测试集混淆矩阵为: tensor([[ 0., 31.,10.], [ 0., 25., 3.], [ 0., 6., 29.]])</p><h4 id="mix-up">mix-up</h4><p>测试集总体精度为: 0.4038461446762085 测试集各类精度为:tensor([0.2439, 0.6786, 0.3714]) 测试集混淆矩阵为: tensor([[10., 25.,6.], [ 9., 19., 0.], [18., 4., 13.]])</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>八股-Mybatis</title>
    <link href="/2024/03/13/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Mybatis/"/>
    <url>/2024/03/13/SoftwareDevelopment/%E5%85%AB%E8%82%A1-Mybatis/</url>
    
    <content type="html"><![CDATA[<p>记录Mybatis主要用法 <span id="more"></span></p><h2 id="基本概念">基本概念</h2><h3 id="mybatis">Mybatis</h3><p>Mybatis 是一个半 ORM(对象关系映射)框架,它内部封装了JDBC,开发时只需要关注 SQL语句本身,不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态 sql,可以严格控制 sql执行性能,灵活度高。</p><p>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC代码和手动设置参数以及获取结果集。</p><h3 id="orm">ORM</h3><p>ORM( Object RelationalMapping),对象关系映射,是一种为了解决关系型数据库数据与简单Java对象(POJO)的映射关系的技术。简单来说,ORM是通过使用描述对象和数据库之间映射的元数据,将程序中的对象自动持久化到关系型数据库中。</p><p>Mybatis在查询关联对象或关联集合对象时,需要手动编写SQL来完成,所以,被称之为半自动ORM映射工具。</p><h3 id="mybatis和ibatis">Mybatis和ibatis</h3><p>ibatis通过直接调用sqlsession的select等方法进行操作，而Mybatis首先创建一个mapper接口，通过sqlsession的getMapper方法传入这个接口，sqlSession会基于jdk动态代理生成一个代理对象，根据类的全限定符、方法名在mapper.xml文件中自动实现接口的功能，事实上就是底层调用ibatis进行实现。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240313202035.png" /></p><h2 id="基础示例">基础示例</h2><ol type="1"><li><p>数据库配置</p><p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE `mybatis<span class="hljs-operator">-</span>example`;<br><br>USE `mybatis<span class="hljs-operator">-</span>example`;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_emp`(<br>  emp_id <span class="hljs-type">INT</span> AUTO_INCREMENT,<br>  emp_name <span class="hljs-type">CHAR</span>(<span class="hljs-number">100</span>),<br>  emp_salary <span class="hljs-keyword">DOUBLE</span>(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>),<br>  <span class="hljs-keyword">PRIMARY</span> KEY(emp_id)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_emp`(emp_name,emp_salary) <span class="hljs-keyword">VALUES</span>(&quot;tom&quot;,<span class="hljs-number">200.33</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_emp`(emp_name,emp_salary) <span class="hljs-keyword">VALUES</span>(&quot;jerry&quot;,<span class="hljs-number">666.66</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_emp`(emp_name,emp_salary) <span class="hljs-keyword">VALUES</span>(&quot;andy&quot;,<span class="hljs-number">777.77</span>);<br></code></pre></td></tr></table></figure></p></li><li><p>依赖导入</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- mybatis依赖 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- MySQL驱动 mybatis底层依赖jdbc驱动实现,本次不需要导入连接池,mybatis自带! --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--junit5测试--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></p></li><li><p>实体类（pojo）</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer empId;<br><br>    <span class="hljs-keyword">private</span> String empName;<br><br>    <span class="hljs-keyword">private</span> Double empSalary;<br>    <br>    <span class="hljs-comment">//getter | setter</span><br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>mapper接口</p><p>注意这里mapper定义的是接口并非类，接口的实现依赖xml文件而不是类</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmployeeMapper</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据员工id查询员工数据方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> empId  员工id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 员工实体对象</span><br><span class="hljs-comment">     */</span><br>    Employee <span class="hljs-title function_">selectEmployee</span><span class="hljs-params">(Integer empId)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>mapper xml文件</p><p><mapper>标签中的namespace为对应的接口文件名，注意在接口中不支持重载方法，因为xml文件无法进行映射。</p><p>注意如果不经过特殊设置，要把数据库字段映射到pojo的属性名上</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.spring.mapper.EmployeeMapper&quot;</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 查询使用 select标签</span><br><span class="hljs-comment">            id = 方法名</span><br><span class="hljs-comment">            resultType = 返回值类型</span><br><span class="hljs-comment">            标签内编写SQL语句</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmployee&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.spring.pojo.Employee&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- #&#123;empId&#125;代表动态传入的参数,并且进行赋值!后面详细讲解 --&gt;</span><br>        select emp_id empId,emp_name empName, emp_salary empSalary from <br>           t_emp where emp_id = #&#123;empId&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></p></li><li><p>mybatis配置文件</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- Mybatis的内置的事务管理器 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>      <span class="hljs-comment">&lt;!-- 配置数据源 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 建立数据库连接的具体信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt;</span><br>    <span class="hljs-comment">&lt;!--    对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/EmployeeMapper.xml&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></p></li><li><p>测试</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectEmployee</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">// 1.创建SqlSessionFactory对象</span><br>        <span class="hljs-comment">// ①声明Mybatis全局配置文件的路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">mybatisConfigFilePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br><br>        <span class="hljs-comment">// ②以输入流的形式加载Mybatis配置文件</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(mybatisConfigFilePath);<br><br>        <span class="hljs-comment">// ③基于读取Mybatis配置文件的输入流创建SqlSessionFactory对象</span><br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br><br>        <span class="hljs-comment">// 2.使用SqlSessionFactory对象开启一个会话</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-comment">// 3.根据EmployeeMapper接口的Class对象获取Mapper接口类型的对象(动态代理技术)</span><br>        <span class="hljs-type">EmployeeMapper</span> <span class="hljs-variable">employeeMapper</span> <span class="hljs-operator">=</span> session.getMapper(EmployeeMapper.class);<br><br>        <span class="hljs-comment">// 4. 调用代理类方法既可以触发对应的SQL语句</span><br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> employeeMapper.selectEmployee(<span class="hljs-number">1</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;employee = &quot;</span> + employee);<br><br>        <span class="hljs-comment">// 4.关闭SqlSession</span><br>        session.commit(); <span class="hljs-comment">//提交事务 [DQL不需要,其他需要]</span><br>        session.close(); <span class="hljs-comment">//关闭会话</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h2 id="详解">详解</h2><h3 id="配置日志输出">配置日志输出</h3><p>在mybatis-config.xml文件中设置settings标签,应注意需要处于environments标签上方</p><p>value取值：SLF4J | LOG4J（3.5.9 起废弃） | LOG4J2 | JDK_LOGGING |COMMONS_LOGGING | STDOUT_LOGGING |NO_LOGGING</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="配置驼峰自动映射">配置驼峰自动映射</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在全局范围内对Mybatis进行配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 具体配置 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 从org.apache.ibatis.session.Configuration类中可以查看能使用的配置项 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 将mapUnderscoreToCamelCase属性配置为true，表示开启自动映射驼峰式命名规则 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 规则要求数据库表字段命名方式：单词_单词 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 规则要求Java实体类属性名命名方式：首字母小写的驼峰式命名 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="和的区别">#{}和${}的区别</h3><p>Mybatis会将SQL语句中的#{}转换为问号占位符；</p><p>${}形式传参，底层Mybatis做的是字符串拼接操作，会有SQL注入攻击问题</p><p>通常不会采用${}的方式传值。一个特定的适用场景是：通过Java程序动态生成数据库表，表名部分需要Java程序通过参数传入；而JDBC对于表名部分是不能使用问号占位符的，此时只能使用</p><h3 id="数据传入">数据传入</h3><h4 id="简单类型参数">简单类型参数</h4><p>对于参数是简单的单值类型，方法的参数名即为xml中的参数名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span>&gt;</span><br>    delete from t_emp where emp_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="实体类型参数">实体类型参数</h4><p>方法中为实体类对象，xml文件中以实体类的变量名作为参数名</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240315205558.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">insertEmployee</span><span class="hljs-params">(Employee employee)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertEmployee&quot;</span>&gt;</span><br>    insert into t_emp(emp_name, emp_salary) values (#&#123;empName&#125;, #&#123;empSalary&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="多个简单类型">多个简单类型</h4><p>必须在方法参数列表添加@Param,括号内部是参数名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; <span class="hljs-title function_">queryByNameAndSalary</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String name, <span class="hljs-meta">@Param(&quot;salary&quot;)</span> Double salary)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryByNameAndSalary&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.spring.pojo.Employee&quot;</span>&gt;</span><br>    select emp_id empId,emp_name empName, emp_salary empSalary from<br>    t_emp where emp_name = #&#123;name&#125; and emp_salary &gt; #&#123;salary&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="map类型参数">Map类型参数</h4><p>xml文件中的参数名为map的key值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">insertEmployeeMap</span><span class="hljs-params">(Map&lt;String, Object&gt; data)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertEmployeeMap&quot;</span>&gt;</span><br>    insert into t_emp(emp_name, emp_salary) values (#&#123;name&#125;, #&#123;salary&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; stringObjectMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>stringObjectMap.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;chen2&quot;</span>);<br>stringObjectMap.put(<span class="hljs-string">&quot;salary&quot;</span>, <span class="hljs-number">1000.0</span>);<br>employeeMapper.insertEmployeeMap(stringObjectMap);<br></code></pre></td></tr></table></figure><h3 id="数据输出">数据输出</h3><h4 id="简单类型输出">简单类型输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">queryNameById</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryNameById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;string&quot;</span>&gt;</span><br>    select emp_name from t_emp where tmp_id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="实体类型输出">实体类型输出</h4><p>select标签中要指定resultType，值为指定类类型的全限定符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Employee <span class="hljs-title function_">queryById</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.spring.pojo.Employee&quot;</span>&gt;</span><br>    select emp_id empId,emp_name empName, emp_salary empSalary from<br>    t_emp where emp_id = #&#123;empId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="map输出">Map输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,Object&gt; <span class="hljs-title function_">selectEmpNameAndMaxSalary</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmpNameAndMaxSalary&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>  SELECT<br>    emp_name 员工姓名,<br>    emp_salary 员工工资,<br>    (SELECT AVG(emp_salary) FROM t_emp) 部门平均工资<br>  FROM t_emp WHERE emp_salary=(<br>    SELECT MAX(emp_salary) FROM t_emp<br>  )<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="list类型">List类型</h4><p>方法的返回值为List，但xml文件不做改变，返回List内部的类型即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; <span class="hljs-title function_">queryBySalary</span><span class="hljs-params">(Double salary)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBySalary&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.spring.pojo.Employee&quot;</span>&gt;</span><br>    select emp_id empId,emp_name empName, emp_salary empSalary from<br>    t_emp where emp_salary &gt; #&#123;salary&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="resultmap简单自定义映射">resultMap简单自定义映射</h4><p>resultType安装规则自动映射，只能映射一层结构，多表查询的时候结果无法映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;employeeMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.spring.pojo.Employee&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empId&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empName&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;emp_salary&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;empSalary&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;employeeMap&quot;</span>&gt;</span><br>    select * from t_emp where emp_id = #&#123;empId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="主键回显">主键回显</h4><h5 id="自增长">自增长</h5><p>在xml文件中设置useGeneratedKeys为true，随后指定数据库中列明和映射的属性名即可，这样主键就赋值到了insert的实体类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">insertEmployee</span><span class="hljs-params">(Employee employee)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertEmployee&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyColumn</span>=<span class="hljs-string">&quot;emp_id&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;empId&quot;</span>&gt;</span><br>    insert into t_emp(emp_name, emp_salary) values (#&#123;empName&#125;, #&#123;empSalary&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();<br>employee.setEmpSalary(<span class="hljs-number">10000.0</span>);<br>employee.setEmpName(<span class="hljs-string">&quot;chen&quot;</span>);<br>employeeMapper.insertEmployee(employee);<br>System.out.println(employee.getEmpId());<br></code></pre></td></tr></table></figure><h5 id="非自增长">非自增长</h5><p>selectKey的order代表在sql语句之前还是之后运行，keyProperty代表结果映射到的变量名，可以在sql语句中使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span>&gt;</span><br>        SELECT UUID() as id<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br>    INSERT INTO user (id, username, password) <br>    VALUES (<br>        #&#123;id&#125;,<br>        #&#123;username&#125;,<br>        #&#123;password&#125;<br>    )<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="多表映射">多表映射</h3><h4 id="对一映射">对一映射</h4><p>在编写resultMap的时候注意一层一层编写，首先写Order类的id、属性，然后对于实体类对象，采用association来指定映射对象类，然后再继续编写Customer类的id、属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Order <span class="hljs-title function_">queryOrderById</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.spring.mapper.OrderMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.spring.pojo.Order&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderName&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerId&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customer&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.spring.pojo.Customer&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerId&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerName&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryOrderById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;orderMap&quot;</span>&gt;</span><br>        select * from t_order, t_customer<br>        where t_order.customer_id = t_customer.customer_id and order_id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="对多映射">对多映射</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Customer <span class="hljs-title function_">selectCustomerWithOrderList</span><span class="hljs-params">(Integer customerId)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置resultMap实现从Customer到OrderList的“对多”关联关系 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectCustomerWithOrderListResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 映射Customer本身的属性 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerId&quot;</span>/&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;customer_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;customerName&quot;</span>/&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- collection标签：映射“对多”的关联关系 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- property属性：在Customer类中，关联“多”的一端的属性名 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- ofType属性：集合属性中元素的类型 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 映射Order的属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderName&quot;</span>/&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Customer selectCustomerWithOrderList(Integer customerId); --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectCustomerWithOrderList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;selectCustomerWithOrderListResultMap&quot;</span>&gt;</span><br>  SELECT c.customer_id,c.customer_name,o.order_id,o.order_name<br>  FROM t_customer c<br>  LEFT JOIN t_order o<br>  ON c.customer_id=o.customer_id<br>  WHERE c.customer_id=#&#123;customerId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="动态sql">动态SQL</h3><h4 id="where-if">where &amp; if</h4><p>where标签在检测到内部有任何if满足的时候，会添加where关键字，同时会自动去掉“标签体内前面多余的and/or</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByCondition(Employee employee); --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmployeeByCondition&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;employee&quot;</span>&gt;</span><br>    select emp_id,emp_name,emp_salary from t_emp<br>    <span class="hljs-comment">&lt;!-- ” --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 使用if标签，让我们可以有选择的加入SQL语句的片段。这个SQL语句片段是否要加入整个SQL语句，就看if标签判断的结果是否为true --&gt;</span><br>        <span class="hljs-comment">&lt;!-- 在if标签的test属性中，可以访问实体类的属性，不可以访问数据库表的字段 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null&quot;</span>&gt;</span><br>            emp_name=#&#123;empName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empSalary <span class="hljs-symbol">&amp;gt;</span> 2000&quot;</span>&gt;</span><br>            or emp_salary&gt;#&#123;empSalary&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="set-if">set if</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- void updateEmployeeDynamic(Employee employee) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateEmployeeDynamic&quot;</span>&gt;</span><br>    update t_emp<br>    <span class="hljs-comment">&lt;!-- set emp_name=#&#123;empName&#125;,emp_salary=#&#123;empSalary&#125; --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用set标签动态管理set子句，并且动态去掉两端多余的逗号 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null&quot;</span>&gt;</span><br>            emp_name=#&#123;empName&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empSalary <span class="hljs-symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span><br>            emp_salary=#&#123;empSalary&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where emp_id=#&#123;empId&#125;<br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">         第一种情况：所有条件都满足 SET emp_name=?, emp_salary=?</span><br><span class="hljs-comment">         第二种情况：部分条件满足 SET emp_salary=?</span><br><span class="hljs-comment">         第三种情况：所有条件都不满足 update t_emp where emp_id=?</span><br><span class="hljs-comment">            没有set子句的update语句会导致SQL语法错误</span><br><span class="hljs-comment">     --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="choose-when-otherwise">choose &amp; when &amp; otherwise</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByChoose(Employee employee) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmployeeByConditionByChoose&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span><br>    select emp_id,emp_name,emp_salary from t_emp<br>    where<br>    <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empName != null&quot;</span>&gt;</span>emp_name=#&#123;empName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;empSalary <span class="hljs-symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span>emp_salary <span class="hljs-symbol">&amp;lt;</span> 3000<span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span>1=1<span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">     第一种情况：第一个when满足条件 where emp_name=?</span><br><span class="hljs-comment">     第二种情况：第二个when满足条件 where emp_salary &lt; 3000</span><br><span class="hljs-comment">     第三种情况：两个when都不满足 where 1=1 执行了otherwise</span><br><span class="hljs-comment">     --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="批量操作">批量操作</h4><h5 id="批量查询">批量查询</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.spring.mapper.OrderMapper&quot;</span>&gt;</span><br>    select * from t_order where<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="批量删除">批量删除</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;delete&quot;</span>&gt;</span><br>    delete from t_order where order_id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="批量插入">批量插入</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span>&gt;</span><br>    insert into t_order(order_name, customer_id) values <br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>            (#&#123;order.orderName&#125;, #&#123;order.customerId&#125;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="批量更新">批量更新</h5><p>批量插入的例子本质上是一条SQL语句，而实现批量更新则需要多条SQL语句拼起来，用分号分开。也就是一次性发送多条SQL语句让数据库执行。此时需要在数据库连接信息的URL地址中设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">atguigu.dev.url=jdbc:mysql:///mybatis-example?allowMultiQueries=true<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span><br>        update t_order set order_name = #&#123;order.orderName&#125; where order_id = #&#123;order.orderId&#125;;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="mybatisplus">MybatisPlus</h2><h3 id="排序">排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">QueryWrapper&lt;ShopType&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>queryWrapper.orderByAsc(<span class="hljs-string">&quot;sort&quot;</span>);<br>List&lt;ShopType&gt; shopTypes = shopTypeMapper.selectList(queryWrapper);<br></code></pre></td></tr></table></figure><h3 id="逻辑删除">逻辑删除</h3><ol type="1"><li>数据库和实体类添加逻辑删除字段,可以是一个布尔类型、整数类型或枚举类型。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">ADD</span> deleted <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> ;  # <span class="hljs-type">int</span> 类型 <span class="hljs-number">1</span> 逻辑删除 <span class="hljs-number">0</span> 未逻辑删除<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><p>指定逻辑删除字段和属性值</p><p>单一指定</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-variable">@Data</span><br>public class <span class="hljs-keyword">User</span> &#123;<br><br>   <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-variable">@TableId</span><br>    private <span class="hljs-type">Integer</span> id;<br>    private String name;<br>    private <span class="hljs-type">Integer</span> age;<br>    private String email;<br>     <span class="hljs-variable">@TableLogic</span><br>    <span class="hljs-operator">/</span><span class="hljs-operator">/</span>逻辑删除字段 <span class="hljs-type">int</span> mybatis<span class="hljs-operator">-</span>plus下,默认 逻辑删除值为<span class="hljs-number">1</span> 未逻辑删除 <span class="hljs-number">1</span> <br>    private <span class="hljs-type">Integer</span> deleted;<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 全局指定</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">logic-delete-field:</span> <span class="hljs-string">deleted</span> <span class="hljs-comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span><br>      <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 逻辑已删除值(默认为 1)</span><br>      <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 逻辑未删除值(默认为 0)</span><br></code></pre></td></tr></table></figure><h3 id="乐观锁和悲观锁">乐观锁和悲观锁</h3><h4 id="悲观锁">悲观锁</h4><p>悲观锁的基本思想是，在整个数据访问过程中，将共享资源锁定，以确保其他线程或进程不能同时访问和修改该资源。悲观锁的核心思想是"先保护，再修改"。在悲观锁的应用中，线程在访问共享资源之前会获取到锁，并在整个操作过程中保持锁的状态，阻塞其他线程的访问。只有当前线程完成操作后，才会释放锁，让其他线程继续操作资源。这种锁机制可以确保资源独占性和数据的一致性，但是在高并发环境下，悲观锁的效率相对较低。</p><h4 id="乐观锁">乐观锁</h4><p>乐观锁的基本思想是，认为并发冲突的概率较低，因此不需要提前加锁，而是<strong>在数据更新阶段</strong>进行冲突检测和处理。乐观锁的核心思想是"先修改，后校验"。在乐观锁的应用中，线程在读取共享资源时不会加锁，而是记录特定的<strong>版本信息</strong>。当线程准备更新资源时，会先检查该资源的版本信息是否与之前读取的版本信息一致，如果一致则执行更新操作，否则说明有其他线程修改了该资源，需要进行相应的冲突处理。乐观锁通过避免加锁操作，提高了系统的并发性能和吞吐量，但是在并发冲突较为频繁的情况下，乐观锁会导致较多的冲突处理和重试操作。</p><h4 id="乐观锁实现">乐观锁实现</h4><p>添加版本号更新插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>    interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimisticLockerInnerInterceptor</span>());<br>    <span class="hljs-keyword">return</span> interceptor;<br>&#125;<br></code></pre></td></tr></table></figure><p>乐观锁字段添加@Version注解</p><p>注意: 数据库也需要添加version字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">ALTER TABLE USER ADD VERSION INT DEFAULT <span class="hljs-number">1</span> ;  # <span class="hljs-type">int</span> 类型 乐观锁字段<br></code></pre></td></tr></table></figure><pre><code class="hljs">- 支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime- 仅支持 `updateById(id)` 与 `update(entity, wrapper)` 方法</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Version</span><br><span class="hljs-keyword">private</span> Integer version;<br></code></pre></td></tr></table></figure><p>正常更新使用即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//演示乐观锁生效场景</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQuick7</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//步骤1: 先查询,在更新 获取version数据</span><br>    <span class="hljs-comment">//同时查询两条,但是version唯一,最后更新的失败</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span>  <span class="hljs-operator">=</span> userMapper.selectById(<span class="hljs-number">5</span>);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user1</span>  <span class="hljs-operator">=</span> userMapper.selectById(<span class="hljs-number">5</span>);<br><br>    user.setAge(<span class="hljs-number">20</span>);<br>    user1.setAge(<span class="hljs-number">30</span>);<br><br>    userMapper.updateById(user);<br>    <span class="hljs-comment">//乐观锁生效,失败!</span><br>    userMapper.updateById(user1);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面试">面试</h2><h3 id="模糊查询like语句该怎么写">模糊查询like语句该怎么写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt; select id= <span class="hljs-string">&quot;listUserLikeUsername&quot;</span> resultType= <span class="hljs-string">&quot;com.jourwon.pojo.User&quot;</span>&gt;<br>    select id, sex, age, username, password from person where username LIKE <span class="hljs-title function_">CONCAT</span><span class="hljs-params">(<span class="hljs-string">&#x27;%&#x27;</span>, pattern, <span class="hljs-string">&#x27;%&#x27;</span>)</span><br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><h3 id="mybatis延迟加载">Mybatis延迟加载</h3><p>Mybatis支持 association关联对象和collection关联集合对象的延迟加载。在Mybatis配置文件中,可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p><p>它的原理是,使用CGLIB创建目标对象的代理对象,当调用目标方法时,进入拦截器方法,比如调用 a.getB().getName(), 拦截器invoke()方法发现 a.getB()是 null值 ,那么就会单独发送事先保存好的查询关联B 对象的sql, 把 B 查询上来,然后调用a.setB(b),于是a 的对象b 属性就有值了, 接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><h3 id="mybatis的缓存">Mybatis的缓存</h3><ol type="1"><li>一级缓存: 基于 PerpetualCache 的 HashMap本地缓存,其<strong>存储作用域为 SqlSession</strong>, 各个SqlSession之间的缓存相互隔离 ,当 Session flush 或 close 之后 , 该SqlSession 中的所有 Cache 就将清空, MyBatis默认打开一级缓存。</li><li>二级缓存与一级缓存其机制相同 ,默认也是采用 PerpetualCache, HashMap存储,不同之处在于其存储作用域为Mapper(Namespace),可以在多个SqlSession之间共享, 并且可自定义存储源 , 如Ehcache。默认不打开二级缓存,要开启二级缓存,使用二级缓存属性类需要实现Serializable序列化接又 ( 可用来保存对象的状态),可在它的映射文件中配置。</li></ol><h3 id="mybatis工作流程">Mybatis工作流程</h3><ol type="1"><li>读取 MyBatis 配置文件——mybatis-config.xml、加载映射文件——映射文件即SQL 映射文件 ,文件中配置了操作数据库的 SQL语句。最后生成一个配置对象。</li><li>构造会话工厂 :通过 MyBatis 的环境等配置信息构建会话工厂SqlSessionFactory。</li><li>创建会话对象:由会话工厂创建 SqlSession对象,<strong>该对象中包含了执行 SQL 语句的所有方法</strong>。</li><li>Executor 执行器 : MyBatis 底层定义了一个 Executor接口来操作数据库,它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL语句,同时负责查询缓存的维护。</li><li>StatementHandler:数据库会话器,串联起参数映射的处理和运行结果映射的处理。</li><li>参数处理:对输入参数的类型进行处理,并预编译。</li><li>结果处理:对返回结果的类型进行处理,根据对象映射规则,返回相应的对象。</li></ol><h3 id="mybatis功能架构">Mybatis功能架构</h3><p><img src="http://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240513135837.png" style="zoom: 67%;" /></p><ol type="1"><li><p>API接口层: 提供给外部使用的接又 API,开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</p></li><li><p>数据处理层 : 负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</p></li><li><p>基础支撑层 : 负责最基础的功能支撑 ,包括连接管理、事务管理、配置加载和缓存处理,这些都是共用的东西,将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring-AOP</title>
    <link href="/2024/03/10/SoftwareDevelopment/Spring-AOP/"/>
    <url>/2024/03/10/SoftwareDevelopment/Spring-AOP/</url>
    
    <content type="html"><![CDATA[<p>记录Spring-AOP学习过程 <span id="more"></span></p><h3 id="什么是aop">什么是AOP</h3><p>AOP：面向切面编程。简单说，就是把一些业务逻辑中的相同的代码抽取到一个独立的模块中，让业务逻辑更加清爽。</p><p>具体来说 , 假如我现在要 crud写一堆业务,我们可以把日志记录和数据校验<strong>可重用的功能模块</strong>分离出来,然后在程序的执行的合适的地方动态地植入这些代码并执行。这样就简化了代码的书写。业务逻辑代码中没有参和通用逻辑的代码,业务模块更简洁, 只包含核心业务代码。实现了业务逻辑和通用逻辑的代码分离,便于维护和升级,<strong>降低了业务逻辑和通用逻辑的耦合性</strong>。</p><h3 id="spring-aop">Spring-AOP</h3><ul><li>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口。</li><li>cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口。</li><li>AspectJ：早期的AOP实现的框架，SpringAOP借用了AspectJ中的AOP注解。</li></ul><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240310162431.png" /></p><h3 id="实现流程">实现流程</h3><h4 id="导入相关依赖">导入相关依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-comment">&lt;!--注解形式--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="准备接口">准备接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="核心代码实现类">核心代码实现类</h4><p>使用Spring自然要把实现类加入到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorPureImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i + j;<br>    <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i - j;<br>    <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i * j;<br>    <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i / j;<br>    <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="切面类">切面类</h4><p>对于切片类要声明两个参数：</p><ol type="1"><li><span class="citation"data-cites="Aspect表明这个类是切面类">@Aspect表明这个类是切面类</span></li><li><span class="citation"data-cites="Component将这个类加入IOC容器">@Component将这个类加入IOC容器</span></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.advice;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">// @Aspect表示这个类是一个切面类</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-comment">// @Component注解保证这个切面类能够放入IOC容器</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br>        <br>    <span class="hljs-comment">// @Before注解：声明当前方法是前置通知方法</span><br>    <span class="hljs-comment">// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上</span><br>    <span class="hljs-meta">@Before(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLogBeforeCore</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[AOP前置通知] 方法开始了&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@AfterReturning(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLogAfterSuccess</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[AOP返回通知] 方法成功返回了&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@AfterThrowing(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLogAfterException</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[AOP异常通知] 方法抛异常了&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@After(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLogFinallyEnd</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;[AOP后置通知] 方法最终结束了&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="开启aspectj支持">开启AspectJ支持</h4><p>要在配置类中添加@EnableAspectJAutoProxy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.PropertySource;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.spring&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试">测试</h4><p>需要注意的是注入的事实上是代理对象，需要用接口接值，不能用纯净实现类接值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringJUnitConfig(value=Config.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AOPtest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Calculator calculator;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAOP</span><span class="hljs-params">()</span> &#123;<br>        calculator.add(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取切点详细信息">获取切点详细信息</h3><h4 id="获取目标方法信息">获取目标方法信息</h4><p>所有切面方法里面都可以这么获取：在参数中定义joinPoint</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com.spring.CalculatorPureImpl.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br><br>    <span class="hljs-comment">// 获取方法属于的类的信息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">simpleName</span> <span class="hljs-operator">=</span> joinPoint.getTarget().getClass().getSimpleName();<br>    System.out.println(<span class="hljs-string">&quot;simpleName: &quot;</span> + simpleName);<br><br>    <span class="hljs-comment">// 获取方法的修饰符</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getModifiers();<br>    System.out.println(<span class="hljs-string">&quot;modifiers: &quot;</span> + Modifier.toString(modifiers));<br><br>    <span class="hljs-comment">// 获取方法名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();<br>    System.out.println(<span class="hljs-string">&quot;name: &quot;</span> + name);<br><br>    <span class="hljs-comment">// 获取参数列表</span><br>    Object[] args = joinPoint.getArgs();<br>    System.out.println(<span class="hljs-string">&quot;args: &quot;</span> + args[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot; &quot;</span> + args[<span class="hljs-number">1</span>]);<br><br>    System.out.println(<span class="hljs-string">&quot;start log&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4id="在afterreturning中获取返回值信息">在AfterReturning中获取返回值信息</h4><p>注意要在@AfterReturning括号内加入returning的参数名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterReturning(value = &quot;execution(* com.spring.CalculatorPureImpl.*(..))&quot;, returning = &quot;result&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">(JoinPoint joinPoint, Object result)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;afterReturning, result=&quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure><h4id="在afterthrowing中获取异常信息">在AfterThrowing中获取异常信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterThrowing(value = &quot;execution(* com.spring.CalculatorPureImpl.*(..))&quot;, throwing = &quot;e&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">(JoinPoint joinPoint, Throwable e)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;afterThrowing, e=&quot;</span> + e);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切点表达式">切点表达式</h3><h4 id="格式">格式</h4><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240310164540.png" /></p><h4 id="统一管理切点">统一管理切点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(* com.spring.CalculatorPureImpl.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-meta">@AfterThrowing(value = &quot;pointcut()&quot;, throwing = &quot;e&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">(JoinPoint joinPoint, Throwable e)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;afterThrowing, e=&quot;</span> + e);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="环绕通知">环绕通知</h4><ol type="1"><li>参数需要添加ProceedingJointPoint，使用jointPoint.proceed()来执行方法</li><li>catch代码块一定要把异常再次throw出去，不然外部接收不到异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAroundAdvice</span> &#123;<br><br>    <span class="hljs-meta">@Around(&quot;execution(* com.spring.CalculatorPureImpl.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;around before&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            result = joinPoint.proceed();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;around afterThrowing&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;around after&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切面优先级设置">切面优先级设置</h3><p>使用 <span class="citation" data-cites="Order">@Order</span>注解可以控制切面的优先级：</p><ul><li><span class="citation"data-cites="Order">@Order</span>(较小的数)：优先级高</li><li><span class="citation"data-cites="Order">@Order</span>(较大的数)：优先级低</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2024/03/07/SoftwareDevelopment/MySQL/"/>
    <url>/2024/03/07/SoftwareDevelopment/MySQL/</url>
    
    <content type="html"><![CDATA[<p>MySQL学习 <span id="more"></span></p><h2 id="基本语法">基本语法</h2><h3 id="数据库相关操作">数据库相关操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">查询所有数据库<br>show databases;<br><br>指定某个数据库<br>use xxx<br><br>创建数据库<br>create database [if not exists] xxx<br><br>删除数据库<br>drop database [if exists] xxx<br></code></pre></td></tr></table></figure><h3 id="表相关操作">表相关操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql">创建表<br>create table user(<br>    id bigint auto_increment primary key ,<br>    name varchar(30),<br>    age int,<br>    email varchar(50)<br>);<br><br>约束类型：<br>not null<br>unique<br>primary key<br>default<br>foreign key<br><br>删除表<br>drop table [if exists] user<br><br>查询当前数据库所有表<br>show tables;<br><br>查询表结构<br>desc user;<br><br>修改表名<br>rename table xxx to yyy<br><br>添加字段<br>alter table user add gender int;<br><br>删除字段<br>alter table user drop gender<br></code></pre></td></tr></table></figure><h3 id="数据相关操作">数据相关操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs mysql">插入数据<br>INSERT INTO user(name, age, email, gender) VALUES(&#x27;陈&#x27;, 18, &#x27;test@emails.com&#x27;, 1);<br><br>更新数据<br>update user set name=&quot;liu&quot; where id = 1;<br><br>删除数据<br>delete from user where id=1<br>删除全部数据<br>delete from user<br><br>基础查询<br>select * from mybatis_example.tb_emp<br>         WHERE entrydate &gt;= &#x27;2000-01-01&#x27; and entrydate &lt;= &#x27;2012-11-01&#x27;;<br>         <br>模糊查询(_代表一个字符，%代表任意个字符)<br>select * from mybatis_example.tb_emp<br>         WHERE name like &#x27;__&#x27;;<br><br>聚合查询<br>select count(name) from tb_emp<br><br>分组查询<br>select gender, count(*) from tb_emp group by gender having count(*) &gt; 6;<br><br>排序<br>select * from tb_emp order by entrydate DESC ;<br><br>分页查询(从0开始查询五个)<br>select * from tb_emp limit 0,5<br><br>多表查询<br>select * from tb_emp where dept_id = (select id from tb_dept where name = &#x27;教研部&#x27;);<br>select * from tb_emp where dept_id in (select id from tb_dept where name = &#x27;教研部&#x27; or name = &#x27;咨询部&#x27;);<br><br></code></pre></td></tr></table></figure><h2 id="事务">事务</h2><h3 id="四大特性">四大特性</h3><ul><li>原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><blockquote><p>事务的四大特性简称为：ACID</p></blockquote><h2 id="索引">索引</h2><h3 id="语法">语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create index idx_sku_sn on tb_sku (sn);<br><br>show  index  from  tb_emp;<br><br>drop index idx_emp_name on tb_emp;<br></code></pre></td></tr></table></figure><p>优点：</p><ol type="1"><li>提高数据查询的效率，降低数据库的IO成本。</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗。</li></ol><p>缺点：</p><ol type="1"><li>索引会占用存储空间。</li><li>索引大大提高了查询效率，同时却也降低了insert、update、delete的效率。</li></ol><h3 id="结构">结构</h3><p>我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree结构组织的索引。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2024/03/07/SoftwareDevelopment/SpringBoot/"/>
    <url>/2024/03/07/SoftwareDevelopment/SpringBoot/</url>
    
    <content type="html"><![CDATA[<p>springBoot学习</p><span id="more"></span><h2 id="理论">理论</h2><h3 id="spring-security">Spring Security</h3><h4 id="简述">简述</h4><p>SpringSecurity针对Web应用做了安全加固，本质上在应用的Servlet执行前后做了一系列拦截。可以把其理解为AOP的方式，在执行的前后做了额外的操作：依托于Servlet的Filter过滤器接口来实现的。</p><h4 id="认证流程">认证流程</h4><ol type="1"><li><p>先是一个请求带着身份信息进来，用户名和密码被过滤器获取到，封装成<code>Authentication</code>，通常情况下是<code>UsernamePasswordAuthenticationToken</code> 这个实现类。</p></li><li><p>这个 <code>Authentication</code> 经过<code>AuthenticationManager</code>的认证（身份管理器负责验证）认证成功后，<code>AuthenticationManager</code>身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）<code>Authentication</code>实例。</p><p>具体认证过程：</p><ol type="1"><li><code>DaoAuthenticationProvider</code> 是<code>AuthenticationProvider</code>的最常实现类，<code>DaoAuthenticationProvider</code>通过用户名到数据库去查找对应用户，把相关信息（用户名、密码、权限信息）存储到UserDetails类里面</li><li>完成<code>UsernamePasswordAuthenticationToken</code>和<code>UserDetails</code> 密码的比对，这是交给<code>additionalAuthenticationChecks</code>方法完成的</li></ol></li><li><p>认证完成没有出现异常，使用 <code>SecurityContextHolder</code>获取 <code>SecurityContext</code> 之后，将认证完成之后的<code>Authentication</code> 对象，放入上下文对象。</p></li><li><p>从 <code>Authentication</code> 对象中拿到我们的<code>UserDetails</code> 对象，认证后的 <code>Authentication</code>对象调用它的 <code>getPrincipal()</code>方法就可以拿到我们先前数据库查询后组装出来的 <code>UserDetails</code>对象。</p></li><li><p>使用JWT对UserId进行加密，生成token</p><figure><imgsrc="https://img-blog.csdnimg.cn/159e24ea11db4a89ac34b42bbcf328bb.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure></li></ol><h2 id="实践">实践</h2><h3 id="简单示例">简单示例</h3><p>首先在新创建的Springboot的项目中新建controller文件夹，创建一个controller文件</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20240307182743.png" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.springboot.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><span class="hljs-comment">// Controller + ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><span class="hljs-comment">// 设置路径,RequestMapping可以接收各种方式的请求</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;<span class="hljs-comment">// 返回值</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="各种参数传递方式">各种参数传递方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.springboot.pojo;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> Integer age;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.springboot.pojo;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-keyword">private</span> String city;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.springboot.pojo;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComplexUser</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Address address;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 简单参数传递</span><br><span class="hljs-comment">// 要求传参的名字和参数名字相同</span><br><span class="hljs-meta">@GetMapping(&quot;/request_1&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">request1</span><span class="hljs-params">(String name, Integer age)</span>&#123;<br>    <span class="hljs-keyword">return</span> name + String.valueOf(age);<br>&#125;<br><br><span class="hljs-comment">// 可以使用RequestParam来指定传过来的参数名字</span><br><span class="hljs-meta">@GetMapping(&quot;/request_2&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">request2</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(name=&quot;username&quot;)</span>String name, Integer age)</span>&#123;<br>    <span class="hljs-keyword">return</span> name + String.valueOf(age);<br>&#125;<br><br><span class="hljs-comment">// 通过Get获得实体参数，传参方式同上</span><br><span class="hljs-comment">// 可以只传一部分属性</span><br><span class="hljs-meta">@GetMapping(&quot;/request_3&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">request3</span><span class="hljs-params">(User user)</span>&#123;<br>    <span class="hljs-keyword">return</span> user.getUsername() + String.valueOf(user.getAge());<br>&#125;<br><br><span class="hljs-comment">// 通过Post传递复杂实体，注意一定要实现getter和setter方法（用@Data注解简化）</span><br><span class="hljs-meta">@PostMapping(&quot;/request_4&quot;)</span><br><span class="hljs-keyword">public</span> ComplexUser <span class="hljs-title function_">request4</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> ComplexUser user)</span>&#123;<span class="hljs-comment">// 注意一定要@RequestBody</span><br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br><br><span class="hljs-comment">// 路径参数</span><br><span class="hljs-meta">@PostMapping(&quot;request_5/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">request5</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>    <span class="hljs-keyword">return</span> id;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统一返回类">统一返回类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer code;<br>    <span class="hljs-keyword">private</span> String msg;<br>    <span class="hljs-keyword">private</span> Object data;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cookie和请求头">Cookie和请求头</h3><h4 id="接收cookie">接收Cookie</h4><p>可以使用 <span class="citation"data-cites="CookieValue">@CookieValue</span> 注释将 HTTP Cookie的值绑定到控制器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span> &#123; <br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="设置cookie方式">设置cookie方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/save&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(HttpServletResponse response)</span> &#123;<br>    <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;JSESSIONID&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br>    response.addCookie(cookie);<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="接收请求头">接收请求头</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding, </span><br><span class="hljs-params">    <span class="hljs-meta">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class="hljs-type">long</span> keepAlive)</span> &#123; <br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统一配置文件">统一配置文件</h3><p>SpringBoot工程下，进行统一的配置管理，任何参数（端口号、项目根路径、数据库连接信息等等)都集中到一个固定位置和命名的配置文件（<code>application.properties</code>或<code>application.yml</code>）中</p><p>配置文件应该放置在SpringBoot工程的<code>src/main/resources</code>目录下。这是因为<code>src/main/resources</code>目录是SpringBoot默认的类路径（classpath），配置文件会被自动加载并可供应用程序访问。</p><h4 id="常见配置">常见配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># application.properties 为统一配置文件</span><br><span class="hljs-comment"># 内部包含: 固定功能的key,自定义的key</span><br><span class="hljs-comment"># 此处的配置信息,我们都可以在程序中@Value等注解读取</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 固定的key</span><br><span class="hljs-comment"># 启动端口号</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">80 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 自定义</span><br><span class="hljs-attr">spring.jdbc.datasource.driverClassName</span>=<span class="hljs-string">com.mysql.cj.jdbc.driver</span><br><span class="hljs-attr">spring.jdbc.datasource.url</span>=<span class="hljs-string">jdbc:mysql:///springboot_01</span><br><span class="hljs-attr">spring.jdbc.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.jdbc.datasource.password</span>=<span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><h4 id="yaml格式">yaml格式</h4><p>yaml语法说明 1. 数据结构用树形结构呈现，通过缩进来表示层级， 2.连续的项目（集合）通过减号 ” - ” 来表示 3.键值结构里面的key/value对用冒号 ” : ” 来分隔。 4.YAML配置文件的扩展名是yaml 或 yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-comment"># YAML配置文件示例</span><br><span class="hljs-attr">app_name:</span> <span class="hljs-string">我的应用程序</span><br><span class="hljs-attr">version:</span> <span class="hljs-number">1.0</span><span class="hljs-number">.0</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">张三</span><br><br><span class="hljs-attr">database:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">5432</span><br>  <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span><br>  <span class="hljs-attr">password:</span> <span class="hljs-string">password123</span><br><br><span class="hljs-attr">features:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">登录</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">注册</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">仪表盘</span><br><br><span class="hljs-attr">settings:</span><br>  <span class="hljs-attr">analytics:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">theme:</span> <span class="hljs-string">dark</span><br></code></pre></td></tr></table></figure><h4 id="批量配置文件属性读取">批量配置文件属性读取</h4><p><span class="citation"data-cites="ConfigurationProperties是SpringBoot提供的重要注解">@ConfigurationProperties是SpringBoot提供的重要注解</span>,他可以将一些配置属性批量注入到bean对象。</p><p>在类上通过@ConfigurationProperties注解声明该类要读取属性配置</p><p>prefix="spring.jdbc.datasource"读取属性文件中前缀为spring.jdbc.datasource的值。前缀和属性名称和配置文件中的key必须要保持一致才可以注入成功</p><p>另外还有一个很大的优点：<span class="citation"data-cites="Value并不能读取list">@Value并不能读取list</span>，只能读取单值；用@ConfigurationProperties则可以解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.atguigu.properties;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.jdbc.datasource&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceConfigurationProperties</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String driverClassName;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多环境配置与激活">多环境配置与激活</h4><p>application-dev.yml（开发）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jdbc:</span><br>    <span class="hljs-attr">datasource:</span><br>      <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql:///dev</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p>application-test.yml（测试）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jdbc:</span><br>    <span class="hljs-attr">datasource:</span><br>      <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql:///test</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p>application-prod.yml（生产）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jdbc:</span><br>    <span class="hljs-attr">datasource:</span><br>      <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql:///prod</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p>环境激活</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><h3 id="拦截器">拦截器</h3><ol type="1"><li>定义Interceptor拦截方式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.springboot.interceptor;<br><br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> jakarta.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.ModelAndView;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyInterceptor拦截器的preHandle方法执行....&quot;</span>);<br>        <span class="hljs-keyword">return</span> HandlerInterceptor.<span class="hljs-built_in">super</span>.preHandle(request, response, handler);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyInterceptor拦截器的postHandle方法执行....&quot;</span>);<br>        HandlerInterceptor.<span class="hljs-built_in">super</span>.postHandle(request, response, handler, modelAndView);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyInterceptor拦截器的afterCompletion方法执行....&quot;</span>);<br>        HandlerInterceptor.<span class="hljs-built_in">super</span>.afterCompletion(request, response, handler, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>创建SpringMVC配置文件，添加Interceptor，只要在main的目录下即可自动扫描到。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.springboot.config;<br><br><span class="hljs-keyword">import</span> org.example.springboot.interceptor.MyInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MyInterceptor myInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(myInterceptor).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="声明式事务">声明式事务</h3><p>SpringBoot项目会自动配置一个DataSourceTransactionManager，所以只需在方法（或者类）加上 <spanclass="citation" data-cites="Transactional">@Transactional</span>注解，就自动纳入 Spring 的事务管理了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setId(<span class="hljs-number">1</span>);<br>    user.setPassword(<span class="hljs-string">&quot;test2&quot;</span>);<br>    user.setAccount(<span class="hljs-string">&quot;test2&quot;</span>);<br>    userMapper.update(user);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="aop">AOP</h3><p>直接使用aop注解即可:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAdvice</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(* com..service.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;LogAdvice.before&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;joinPoint = &quot;</span> + joinPoint);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="连接服务器">连接服务器</h3><p>在properties文件中指定这三个变量即可</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">cdt</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://43.143.187.188:3308/chongdetang?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useAffectedRows=true</span><br><br></code></pre></td></tr></table></figure><h3 id="项目打包">项目打包</h3><h4 id="添加打包插件">添加打包插件</h4><p>在SpringBoot项目中添加<code>spring-boot-maven-plugin</code>插件是为了支持将项目打包成可执行的可运行jar包。如果不添加<code>spring-boot-maven-plugin</code>插件配置，使用常规的<code>java -jar</code>命令来运行打包后的SpringBoot项目是无法找到应用程序的入口点，因此导致无法运行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!--    SpringBoot应用打包插件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="打包">打包</h4><p>在idea点击package进行打包，可以在编译的target文件中查看jar包</p><h4 id="部署">部署</h4><p><code>java -jar</code>命令用于在Java环境中执行可执行的JAR文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs XML">命令格式：java -jar  [选项] [参数] <span class="hljs-tag">&lt;<span class="hljs-name">jar文件名</span>&gt;</span><br></code></pre></td></tr></table></figure><ol type="1"><li><code>-D&lt;name&gt;=&lt;value&gt;</code>：设置系统属性，可以通过<code>System.getProperty()</code>方法在应用程序中获取该属性值。例如：<code>java -jar -Dserver.port=8080 myapp.jar</code>。</li><li><code>-X</code>：设置JVM参数，例如内存大小、垃圾回收策略等。常用的选项包括：<ul><li><code>-Xmx&lt;size&gt;</code>：设置JVM的最大堆内存大小，例如<code>-Xmx512m</code> 表示设置最大堆内存为512MB。</li><li><code>-Xms&lt;size&gt;</code>：设置JVM的初始堆内存大小，例如<code>-Xms256m</code> 表示设置初始堆内存为256MB。</li></ul></li><li><code>-Dspring.profiles.active=&lt;profile&gt;</code>：指定SpringBoot的激活配置文件，可以通过<code>application-&lt;profile&gt;.properties</code>或<code>application-&lt;profile&gt;.yml</code>文件来加载相应的配置。例如：<code>java -jar -Dspring.profiles.active=dev myapp.jar</code>。</li></ol><figure><imgsrc="https://secure2.wostatic.cn/static/66fP6WRTExeyyKpybyBx7B/image.png?auth_key=1711188390-YuNZShUpKsUvM8pHJdvf7-0-869fc54faa72600c5332dfff1e7a1570&amp;file_size=426147"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaBasis</title>
    <link href="/2024/03/06/SoftwareDevelopment/JavaBasis/"/>
    <url>/2024/03/06/SoftwareDevelopment/JavaBasis/</url>
    
    <content type="html"><![CDATA[<p>Java基础的学习</p><span id="more"></span><h3 id="scanner键盘录入">Scanner键盘录入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">lesson1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 声明Scanner</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">// 获取下一个输入</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> scanner.next();<br>        System.out.println(next);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="random">Random</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">10</span>);<br>System.out.println(i);<br></code></pre></td></tr></table></figure><h3 id="数组">数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> []a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> [][]b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> a.length;  <span class="hljs-comment">// 获取数组长度</span><br><br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>b[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>System.out.println(Arrays.toString(a)); <span class="hljs-comment">// 打印数组</span><br>System.out.println(Arrays.deepToString(b)); <span class="hljs-comment">// 打印二维数组</span><br></code></pre></td></tr></table></figure><h3 id="字符串">字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcde&quot;</span>;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">substring</span> <span class="hljs-operator">=</span> s.substring(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);   <span class="hljs-comment">// [1,3)</span><br>System.out.println(substring);  <span class="hljs-comment">// &quot;bc&quot;</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">substring1</span> <span class="hljs-operator">=</span> s.substring(<span class="hljs-number">3</span>); <span class="hljs-comment">// [3,)</span><br>System.out.println(substring1); <span class="hljs-comment">// &quot;de&quot;</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.indexOf(<span class="hljs-string">&quot;de&quot;</span>);<br>System.out.println(i);  <span class="hljs-comment">// 3</span><br><br>s = <span class="hljs-string">&quot;abcabcabc&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> s.indexOf(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 从下标为3的位置开始找</span><br>System.out.println(i1); <span class="hljs-comment">// 5</span><br><br><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcabcabc&quot;</span>;<br><span class="hljs-keyword">if</span>(s.equals(s2))&#123;   <span class="hljs-comment">// == 是比较内存地址， equals是比较内容</span><br>    System.out.println(<span class="hljs-string">&quot;equals&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="arraylist">ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>arrayList.add(<span class="hljs-number">5</span>);<br>arrayList.add(<span class="hljs-number">10</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> arrayList.size();<br>System.out.println(size);<br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arrayList.get(<span class="hljs-number">1</span>);<br>System.out.println(i);<br><br>arrayList.remove(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 移除下标为1的元素</span><br>System.out.println(arrayList);  <span class="hljs-comment">// [5]</span><br><br>arrayList.set(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>);<br>System.out.println(arrayList);  <span class="hljs-comment">// [10]</span><br></code></pre></td></tr></table></figure><h3 id="hashset">HashSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>set.add(<span class="hljs-number">1</span>);<br>set.add(<span class="hljs-number">1</span>);<br>set.add(<span class="hljs-number">3</span>);<br><br>System.out.println(set);<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">contains</span> <span class="hljs-operator">=</span> set.contains(<span class="hljs-number">3</span>);<br>System.out.println(contains);<br><br>set.remove(<span class="hljs-number">1</span>);<br>System.out.println(set);<br></code></pre></td></tr></table></figure><h3 id="priorityqueue">PriorityQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br><br><span class="hljs-comment">// 添加元素</span><br>queue.offer(<span class="hljs-number">3</span>);<br>queue.offer(<span class="hljs-number">1</span>);<br>queue.offer(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 删除元素</span><br>queue.poll();<br>System.out.println(queue);  <span class="hljs-comment">// [3,5]</span><br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">peek</span> <span class="hljs-operator">=</span> queue.peek();<br>System.out.println(peek); <span class="hljs-comment">// 返回顶端元素</span><br></code></pre></td></tr></table></figure><h3 id="hashmap">HashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>map.put(<span class="hljs-string">&quot;陈&quot;</span>, <span class="hljs-number">21</span>);<br>map.put(<span class="hljs-string">&quot;刘&quot;</span>, <span class="hljs-number">18</span>);<br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">&quot;陈&quot;</span>);<br>System.out.println(i);  <span class="hljs-comment">// 21</span><br><br><span class="hljs-comment">// 修改元素</span><br>map.put(<span class="hljs-string">&quot;陈&quot;</span>, <span class="hljs-number">22</span>);<br>System.out.println(map.get(<span class="hljs-string">&quot;陈&quot;</span>));<br><br>map.remove(<span class="hljs-string">&quot;刘&quot;</span>);<br>System.out.println(map);<br></code></pre></td></tr></table></figure><h3 id="collections">Collections</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>arrayList.add(<span class="hljs-number">3</span>);<br>arrayList.add(<span class="hljs-number">1</span>);<br>arrayList.add(<span class="hljs-number">5</span>);<br><br>Collections.sort(arrayList);<span class="hljs-comment">// 排序</span><br>System.out.println(arrayList);<br><br>Collections.shuffle(arrayList);<span class="hljs-comment">// 打乱</span><br>System.out.println(arrayList);<br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Collections.max(arrayList);<span class="hljs-comment">// 获取最大值</span><br>System.out.println(max);<br></code></pre></td></tr></table></figure><h3 id="静态工厂">静态工厂</h3><p>https://chat.openai.com/share/f828a7ac-be8f-48e5-abee-63c659b6a088</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">// 私有化构造函数，防止外部通过new创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 公共的静态工厂方法，返回唯一实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>小知识</title>
    <link href="/2024/03/06/Algorithm/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/03/06/Algorithm/%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>记录常见的小知识点</p><span id="more"></span><h3 id="位运算相关操作">位运算相关操作</h3><ol type="1"><li><p>获取一个数的二进制表示中第k位</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">n&gt;&gt;k&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></p></li><li><p>获取一个数最后一位1</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">n&amp;-n<br></code></pre></td></tr></table></figure></p><p>给定一个长度为 n的数列，请你求出数列中每个数的二进制表示中 1的个数。</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> m;<br>        cin&gt;&gt;m;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(m&amp;-m)&#123;<br>            cnt ++;<br>            m -= (m &amp; -m);<br>        &#125;<br>        cout&lt;&lt;cnt&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java</title>
    <link href="/2023/07/25/SoftwareDevelopment/Java/"/>
    <url>/2023/07/25/SoftwareDevelopment/Java/</url>
    
    <content type="html"><![CDATA[<p>Java基础学习</p><span id="more"></span><h3 id="代码块">代码块</h3><ol type="1"><li>静态代码块:<ol type="1"><li><strong>格式</strong>：static { }</li><li><strong>特点</strong>：类加载时自动执行，由于类只会加载一次，所以静态代码块也只会执行一次。</li><li><strong>作用</strong>：完成类的初始化，例如：对类变量的初始化赋值。</li></ol></li><li>实例代码块<ol type="1"><li><strong>格式</strong>：{ }<br /></li><li><strong>特点</strong>：每次创建对象时，执行实例代码块，并在构造器前执行。</li><li><strong>作用：</strong>和构造器一样，都是用来完成对象的初始化的，例如：对实例变量进行初始化赋值。</li></ol></li></ol><h3 id="单例设计模式">单例设计模式</h3><ol type="1"><li>保证一个类只有一个对象，防止内存占用</li><li>定义方法：把类的构造器私有；定义一个类变量存储类的一个对象；提供一个类方法返回对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">//2. 类变量存储唯一类对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    <br>    <span class="hljs-comment">//1. 私有构造器使得在外部无法构造类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">//3. 定义一个类方法返回对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> A <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多态">多态</h3><ol type="1"><li><p>在函数传参时可以直接定义为父类并传入各个子类，但此时无法调用各个类特有的方法。</p><p>为了解决该问题，可以在传入后强转类型到子类类型再处理。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果p接收的是子类对象</span><br><span class="hljs-keyword">if</span>(父类变量 instance 子类)&#123;<br>    <span class="hljs-comment">//则可以将p转换为子类类型</span><br>    子类 变量名 = (子类)父类变量;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="final">final</h3><ol type="1"><li>用法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">- <span class="hljs-keyword">final</span>修饰类：该类称为最终类，特点是不能被继承<br>- <span class="hljs-keyword">final</span>修饰方法：该方法称之为最终方法，特点是不能被重写。<br>- <span class="hljs-keyword">final</span>修饰变量：该变量只能被赋值一次。<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>被 static final 修饰的成员变量，称之为常量。</li></ol><h3 id="object">Object</h3><ol type="1"><li><p>可以通过重写toString()和equals()来自定义打印的信息和比较的规则</p></li><li><p>如果想实现拷贝，需要实现Cloneble接口</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 在使用时以如下方式调用 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;wo666&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[]&#123;<span class="hljs-number">99.0</span>,<span class="hljs-number">99.5</span>&#125;);<br><span class="hljs-comment">//调用方法克隆得到一个新对象</span><br>   <span class="hljs-type">User</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> (User) u1.clone();<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="日期旧">日期（旧）</h3><ol type="1"><li><p>使用Date类获取当前时间 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>System.out.println(d);<br></code></pre></td></tr></table></figure></p></li><li><p>将日期格式化</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;</span>);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> sdf.format(d);<br><br><span class="hljs-type">Date</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> sdf.parse(rs)<br></code></pre></td></tr></table></figure></p></li><li><p>Calendar</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>now.get(Calendar.YEAR)<span class="hljs-comment">// 获取年份信息</span><br>now.getTime()<span class="hljs-comment">// 获取Date对象</span><br>now.set(Calendar.MONTH, <span class="hljs-number">9</span>);<span class="hljs-comment">// 修改日期</span><br><br><span class="hljs-comment">//为某个信息增加或者减少多少</span><br>now.add(Calendar.DAY_OF_YEAR, <span class="hljs-number">100</span>);<br>now.add(Calendar.DAY_OF_YEAR, -<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="日期jdk8">日期（JDK8）</h3><ol type="1"><li><p>LocalDate 年月日</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld</span> <span class="hljs-operator">=</span> LocalDate.now();<span class="hljs-comment">// 2023-07-25</span><br>ld.getMonth();<span class="hljs-comment">// JULY</span><br>ld.withMonth(<span class="hljs-number">12</span>);<span class="hljs-comment">// 修改月份</span><br>ld.plusYears(<span class="hljs-number">2</span>);<span class="hljs-comment">// 添加年份</span><br>ld.minusYears(<span class="hljs-number">2</span>);<span class="hljs-comment">// 减小年份</span><br><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld8</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2099</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>);<span class="hljs-comment">// 创建LocalDate</span><br><span class="hljs-comment">//判断2个日期对象，是否相等，在前还是在后： equals isBefore isAfter</span><br>System.out.println(ld8.equals(ld9));<span class="hljs-comment">// true</span><br>System.out.println(ld8.isAfter(ld)); <span class="hljs-comment">// true</span><br>System.out.println(ld8.isBefore(ld)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></p></li><li><p>LocalTime 时 分 秒 纳秒</p><p>内置函数同LocalDate</p></li><li><p>LocalDateTime 年 月 日 时 分 秒 纳秒</p></li><li><p>DateTimeFormatter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);<br><br>formatter.format(LocalDateTime.now());<span class="hljs-comment">// 转化</span><br>LocalDateTime.parse(dateStr, formatter);<span class="hljs-comment">// 解析</span><br></code></pre></td></tr></table></figure></li><li><p>Period &amp; Duration</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2029</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2029</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>);<br><br><span class="hljs-comment">// 1、创建Period对象，封装两个日期对象。</span><br><span class="hljs-type">Period</span> <span class="hljs-variable">period</span> <span class="hljs-operator">=</span> Period.between(start, end);<br><br><span class="hljs-comment">// 2、通过period对象获取两个日期对象相差的信息。</span><br>System.out.println(period.getYears());<br>System.out.println(period.getMonths());<br>System.out.println(period.getDays());<br><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2025</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2025</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>);<br><span class="hljs-comment">// 1、得到Duration对象</span><br><span class="hljs-type">Duration</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> Duration.between(start, end);<br><br><span class="hljs-comment">// 2、获取两个时间对象间隔的信息</span><br>System.out.println(duration.toDays());<span class="hljs-comment">// 间隔多少天</span><br>System.out.println(duration.toHours());<span class="hljs-comment">// 间隔多少小时</span><br>System.out.println(duration.toMinutes());<span class="hljs-comment">// 间隔多少分</span><br>System.out.println(duration.toSeconds());<span class="hljs-comment">// 间隔多少秒</span><br>System.out.println(duration.toMillis());<span class="hljs-comment">// 间隔多少毫秒</span><br>System.out.println(duration.toNanos());<span class="hljs-comment">// 间隔多少纳秒</span><br></code></pre></td></tr></table></figure></p></li></ol><h3 id="任意类数组排序">任意类数组排序</h3><ol type="1"><li><p>方法一</p><p>首先对于类，需要实现Compareable接口</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt;<br></code></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student s)</span> &#123;<br>    <span class="hljs-keyword">return</span> s.getChinese() - <span class="hljs-built_in">this</span>.getChinese();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>随后在使用时如下所示</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(students)<br></code></pre></td></tr></table></figure></p></li><li><p>方法二</p><p>在调用时实现比较函数</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(students, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> Double.compare(o1.getHeight(), o2.getHeight()); <span class="hljs-comment">// 升序</span><br>        <span class="hljs-comment">// return Double.compare(o2.getHeight(), o1.getHeight()); // 降序</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></p><p>Lambda写法</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(students, (Student o1, Student o2) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> Double.compare(o1.getHeight(), o2.getHeight()); <span class="hljs-comment">// 升序</span><br>&#125;);<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="异常">异常</h3><ol type="1"><li><p>自定义异常</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeIllegalException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<span class="hljs-comment">// 继承Exception类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AgeIllegalException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AgeIllegalException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>抛出异常</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>    <span class="hljs-keyword">if</span>(age &gt; <span class="hljs-number">0</span> &amp;&amp; age &lt; <span class="hljs-number">150</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;年龄被成功保存： &quot;</span> + age);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 用一个异常对象封装这个问题</span><br>        <span class="hljs-comment">// throw 抛出去这个异常对象</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AgeIllegalRuntimeException</span>(<span class="hljs-string">&quot;/age is illegal, your age is &quot;</span> + age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>捕获异常</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    saveAge2(<span class="hljs-number">225</span>);<br>    System.out.println(<span class="hljs-string">&quot;saveAge2底层执行是成功的！&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (AgeIllegalException e) &#123;<br>    e.printStackTrace();<br>    System.out.println(<span class="hljs-string">&quot;saveAge2底层执行是出现bug的！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="properties属性文件">Properties属性文件</h3><ol type="1"><li><p>格式</p><ol type="1"><li>属性文件后缀以<code>.properties</code>结尾</li><li>属性文件里面的每一行都是一个键值对，键和值中间用=隔开。比如:<code>admin=123456</code></li><li><code>#</code>表示这样是注释信息，是用来解释这一行配置是什么意思。</li><li>每一行末尾不要习惯性加分号，以及空格等字符；不然会把分号，空格会当做值的一部分。</li><li>键不能重复，值可以重复</li></ol></li><li><p>读取/写入</p><ol type="1"><li><p>读取</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;path&quot;</span>));<br>properties.getProperty(<span class="hljs-string">&quot;a&quot;</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>写入</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.setProperty(<span class="hljs-string">&quot;张无忌&quot;</span>, <span class="hljs-string">&quot;minmin&quot;</span>);<br>properties.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;path&quot;</span>), <span class="hljs-string">&quot;i saved many users!&quot;</span>);<br></code></pre></td></tr></table></figure></p></li></ol></li></ol><h3 id="logback日志">Logback日志</h3><ol type="1"><li><p>导入库</p><ol type="1"><li><p>在资料中找到<code>slftj-api.jar、logback-core.jar、logback-classes.jar</code>这三个jar包，复制一下</p></li><li><p>在当前模块下面新建一个lib文件夹，把刚刚复制的三个jar包都粘贴到此处</p></li><li><p>右键lib文件夹，点击<code>Add as Library</code></p></li><li><p>从资料中找到<code>logback.xml</code>配置文件，将此文件复制粘贴到src目录下（必须是src目录）</p></li></ol></li><li><p>在代码中使用</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;LogTest&quot;</span>);<span class="hljs-comment">// 创建Logger对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            LOGGER.info(<span class="hljs-string">&quot;除法准备执行&quot;</span>);<br>            div(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>);<br>            LOGGER.info(<span class="hljs-string">&quot;除法正常执行&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            LOGGER.error(<span class="hljs-string">&quot;除法异常&quot;</span>);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        LOGGER.debug(<span class="hljs-string">&quot;参数a=&quot;</span>+a+<span class="hljs-string">&quot;;参数b=&quot;</span>+b+<span class="hljs-string">&quot;;&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a/b;<br>        System.out.println(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="多线程">多线程</h3><ol type="1"><li><p><strong>继承Thread类</strong></p><ol type="1"><li><p>创建线程类</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<span class="hljs-comment">// 继承Thread类</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 描述线程执行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>在程序中使用</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<span class="hljs-comment">// 实例化</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        t.start();<span class="hljs-comment">// 运行，调用run方法</span><br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol></li><li><p><strong>实现Runable接口</strong></p><ol type="1"><li><p>实现接口</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 描述线程执行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>使用</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>       <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol></li><li><p><strong>Runable接口其他实现</strong></p><ol type="1"><li><p>匿名内部类</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>               <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>                   System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>+i);<br>               &#125;<br>           &#125;<br>       &#125;;<br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>简化</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure></p></li><li><p>进一步简化</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt;&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>+i);<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure></p></li></ol></li><li><p><strong>实现Callable接口</strong></p><p><strong>好处</strong>：可以返回线程执行结果</p><ol type="1"><li><p>实现接口</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">this</span>.n;i++)&#123;<br>            sum += i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> String.valueOf(sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>使用</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;String&gt; call = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-number">100</span>);<span class="hljs-comment">// 创建Callable类</span><br>FutureTask&lt;String&gt; f1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);<span class="hljs-comment">// 创建FutureTask类</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(f1).start();<span class="hljs-comment">// 运行</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> f1.get();<span class="hljs-comment">// 获取执行结果</span><br><br>System.out.println(res);<br></code></pre></td></tr></table></figure></p></li></ol></li><li><p>常用API</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/1668051403591.png" style="zoom:50%;" /></p></li></ol><h3 id="同步问题">同步问题</h3><ol type="1"><li><p>同步代码块</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱&quot;</span> + money + <span class="hljs-string">&quot;成功！&quot;</span>);<br>        <span class="hljs-built_in">this</span>.money -= money;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱：余额不足~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><ol type="1"><li>建议把共享资源作为锁对象, 不要将随便无关的对象当做锁对象</li><li>对于实例方法，建议使用this作为锁对象</li><li>对于静态方法，建议把类的字节码(类名.class)当做锁对象</li></ol></li><li><p>同步方法</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<span class="hljs-comment">// 在声明时声明synchronized</span><br>    <span class="hljs-comment">// 先搞清楚是谁来取钱？</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>    <span class="hljs-comment">// 1、判断余额是否足够</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱&quot;</span> + money + <span class="hljs-string">&quot;成功！&quot;</span>);<br>        <span class="hljs-built_in">this</span>.money -= money;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;来取钱：余额不足~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>Lock自定义锁</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">// 创建锁</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-comment">// 先搞清楚是谁来取钱？</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        <span class="hljs-keyword">try</span> &#123;<br>            lk.lock(); <span class="hljs-comment">// 加锁</span><br>            <span class="hljs-comment">// 1、判断余额是否足够</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.money &gt;= money)&#123;<br>                System.out.println(name + <span class="hljs-string">&quot;来取钱&quot;</span> + money + <span class="hljs-string">&quot;成功！&quot;</span>);<br>                <span class="hljs-built_in">this</span>.money -= money;<br>                System.out.println(name + <span class="hljs-string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="hljs-built_in">this</span>.money);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                System.out.println(name + <span class="hljs-string">&quot;来取钱：余额不足~&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">// 在finally里解锁，防止出现异常无法解锁</span><br>            lk.unlock(); <span class="hljs-comment">// 解锁</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="线程池">线程池</h3><ul><li><p>临时线程什么时候创建？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">新任务提交时，发现核心线程都在忙、任务队列满了、并且还可以创建临时线程，此时会创建临时线程。<br></code></pre></td></tr></table></figure></li><li><p>什么时候开始拒绝新的任务？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">核心线程和临时线程都在忙、任务队列也满了、新任务过来时才会开始拒绝任务。<br></code></pre></td></tr></table></figure></li></ul><ol type="1"><li>创建线程池</li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230726180918.png" /></p><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">3</span>,<span class="hljs-comment">//核心线程数有3个</span><br>    <span class="hljs-number">5</span>,  <span class="hljs-comment">//最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2</span><br>    <span class="hljs-number">8</span>,<span class="hljs-comment">//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。</span><br>    TimeUnit.SECONDS,<span class="hljs-comment">//时间单位（秒）</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">4</span>), <span class="hljs-comment">//任务阻塞队列，没有来得及执行的任务在，任务队列中等待</span><br>    Executors.defaultThreadFactory(), <span class="hljs-comment">//用于创建线程的工厂对象</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="hljs-comment">//拒绝策略</span><br>);<br></code></pre></td></tr></table></figure></code></pre><ol start="2" type="1"><li>执行Runnable对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 任务是干啥的？</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ==&gt; 输出666~~&quot;</span>);<br>        <span class="hljs-comment">//为了模拟线程一直在执行，这里睡久一点</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(Integer.MAX_VALUE);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>pool.execute(target); <span class="hljs-comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span><br>pool.execute(target); <br>pool.execute(target); <br><br>pool.shutdown();<span class="hljs-comment">// 等待线程全部执行结束后关闭</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>执行Callable对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCallable</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br><br>    <span class="hljs-comment">// 2、重写call方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 描述线程的任务，返回线程执行返回后的结果。</span><br>        <span class="hljs-comment">// 需求：求1-n的和返回。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Thread.currentThread().getName() + <span class="hljs-string">&quot;求出了1-&quot;</span> + n + <span class="hljs-string">&quot;的和是：&quot;</span> + sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">3</span>,<br>            <span class="hljs-number">5</span>,<br>            <span class="hljs-number">8</span>,<br>            TimeUnit.SECONDS, <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">4</span>),<br>            Executors.defaultThreadFactory(),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br><br>        <span class="hljs-comment">// 2、使用线程处理Callable任务。</span><br>        Future&lt;String&gt; f1 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">100</span>));<br>        Future&lt;String&gt; f2 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">200</span>));<br>        Future&lt;String&gt; f3 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">300</span>));<br>        Future&lt;String&gt; f4 = pool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">400</span>));<br><br>        <span class="hljs-comment">// 3、执行完Callable任务后，需要获取返回结果。</span><br>        System.out.println(f1.get());<br>        System.out.println(f2.get());<br>        System.out.println(f3.get());<br>        System.out.println(f4.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230726201654.png" /></p><h3 id="网络通信">网络通信</h3><ol type="1"><li><p>InetAddress</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InetAddress</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> InetAddress.getLocalHost();<br>System.out.println(ip.getHostAddress());<span class="hljs-comment">// 获取IP地址</span><br>System.out.println(ip.getHostName());<span class="hljs-comment">// 获取机器名4</span><br><br><span class="hljs-type">InetAddress</span> <span class="hljs-variable">ip2</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;www.baidu.com&quot;</span>);<span class="hljs-comment">// 根据url获取ip</span><br>System.out.println(ip2.isReachable(<span class="hljs-number">5000</span>));<span class="hljs-comment">// 判断是否可达</span><br></code></pre></td></tr></table></figure></p></li><li><p>UDP通信</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-string">&quot;test&quot;</span>.getBytes();<br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf,buf.length, InetAddress.getLocalHost(),<span class="hljs-number">6666</span>);<br><br>        socket.send(packet);<br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">6666</span>);<br><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">24</span>];<br><br>        <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf,buf.length);<br><br>        socket.receive(packet);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> packet.getLength();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span> , len);<br>        System.out.println(rs);<br>        socket.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>TCP多线程通信</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReaderThread</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(is);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> dis.readUTF();<br>                    System.out.println(msg);<br><br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;有人下线了：&quot;</span> + socket.getRemoteSocketAddress());<br>                    dis.close();<br>                    socket.close();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;-----服务端启动成功-------&quot;</span>);<br>        <span class="hljs-comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8888</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br><br>            System.out.println(<span class="hljs-string">&quot;有人上线了：&quot;</span> + socket.getRemoteSocketAddress());<br><br>            <span class="hljs-comment">// 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReaderThread</span>(socket).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="junit测试">junit测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringUtil</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNumber</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;名字长度：&quot;</span>+name.length());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringUtilTest</span>&#123;<br>    <span class="hljs-meta">@Test</span><span class="hljs-comment">// 必须加注解</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetMaxIndex</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> StringUtil.getMaxIndex(<span class="hljs-literal">null</span>);<br>       System.out.println(index1);<br>        <br>       <span class="hljs-type">int</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> StringUtil.getMaxIndex(<span class="hljs-string">&quot;admin&quot;</span>);<br>       System.out.println(index2);<br>        <br>        <span class="hljs-comment">//断言机制：预测index2的结果,用来判断逻辑是否有问题</span><br>        Assert.assertEquals(<span class="hljs-string">&quot;方法内部有Bug&quot;</span>,<span class="hljs-number">4</span>,index2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230727215753.png" /></p><p>假设我想在每个测试方法中使用Socket对象，并且用完之后，需要把Socket关闭，上述注解就会起作用</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux服务器工具</title>
    <link href="/2023/07/13/SoftwareDevelopment/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E5%85%B7/"/>
    <url>/2023/07/13/SoftwareDevelopment/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>tmux、vim用法 <span id="more"></span></p><h2 id="tmux">tmux</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs stata">功能：<br>    (1) 分屏。<br>    (2) 允许断开Terminal连接后，继续运行进程。<br>结构：<br>    一个tmux可以包含多个session，一个session可以包含多个<span class="hljs-keyword">window</span>，一个<span class="hljs-keyword">window</span>可以包含多个pane。<br>    实例：<br>        tmux:<br>            session 0:<br>                <span class="hljs-keyword">window</span> 0:<br>                    pane 0<br>                    pane 1<br>                    pane 2<br>                    ...<br>                <span class="hljs-keyword">window</span> 1<br>                <span class="hljs-keyword">window</span> 2<br>                ...<br>            session 1<br>            session 2<br>            ...<br>操作：<br>    (1) tmux：新建一个session，其中包含一个<span class="hljs-keyword">window</span>，<span class="hljs-keyword">window</span>中包含一个pane，pane里打开了一个<span class="hljs-keyword">shell</span>对话框。<br>    (2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。<br>    (3) 按下Ctrl + a后手指松开，然后按<span class="hljs-string">&quot;（注意是双引号&quot;</span>）：将当前pane上下平分成两个pane。<br>    (4) Ctrl + <span class="hljs-keyword">d</span>：关闭当前pane；如果当前<span class="hljs-keyword">window</span>的所有pane均已关闭，则自动关闭<span class="hljs-keyword">window</span>；如果当前session的所有<span class="hljs-keyword">window</span>均已关闭，则自动关闭session。<br>    (5) 鼠标点击可以选pane。<br>    (6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。<br>    (7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。<br>    (8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。<br>    (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。<br>    (10) 按下ctrl + a后手指松开，然后按<span class="hljs-keyword">d</span>：挂起当前session。<br>    (11) tmux a：打开之前挂起的session。<br>    (12) 按下ctrl + a后手指松开，然后按s：选择其它session。<br>        方向键 —— 上：选择上一项 session/<span class="hljs-keyword">window</span>/pane<br>        方向键 —— 下：选择下一项 session/<span class="hljs-keyword">window</span>/pane<br>        方向键 —— 右：展开当前项 session/<span class="hljs-keyword">window</span><br>        方向键 —— 左：闭合当前项 session/<span class="hljs-keyword">window</span><br>    (13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的<span class="hljs-keyword">window</span>。<br>    (14) 按下Ctrl + a后手指松开，然后按w：选择其他<span class="hljs-keyword">window</span>，操作方法与(12)完全相同。<br>    (15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。<br>    (16) 鼠标滚轮：翻阅当前pane内的内容。<br>    (17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持<span class="hljs-keyword">Mac</span>，不过该操作并不是必须的，因此影响不大）<br>    (18) tmux中复制/粘贴文本的通用方式：<br>        (1) 按下Ctrl + a后松开手指，然后按[<br>        (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板<br>        (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处<br></code></pre></td></tr></table></figure><h2 id="vim">vim</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs bash">功能：<br> (1) 命令行模式下的文本编辑器。<br> (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。<br> (3) 使用方式：vim filename<br>     如果已有该文件，则打开它。<br>     如果没有该文件，则打开个一个新的文件，并命名为filename<br>模式：<br> (1) 一般命令模式<br>     默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。<br> (2) 编辑模式<br>     在一般命令模式里按下i，会进入编辑模式。<br>     按下ESC会退出编辑模式，返回到一般命令模式。<br> (3) 命令行模式<br>     在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。<br>     可以查找、替换、保存、退出、配置编辑器等。<br>操作：<br> (1) i：进入编辑模式<br> (2) ESC：进入一般命令模式<br> (3) h 或 左箭头键：光标向左移动一个字符<br> (4) j 或 向下箭头：光标向下移动一个字符<br> (5) k 或 向上箭头：光标向上移动一个字符<br> (6) l 或 向右箭头：光标向右移动一个字符<br> (7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符<br> (8) 0 或 功能键[Home]：光标移动到本行开头<br> (9) $ 或 功能键[End]：光标移动到本行末尾<br> (10) G：光标移动到最后一行<br> (11) :n 或 nG：n为数字，光标移动到第n行<br> (12) gg：光标移动到第一行，相当于1G<br> (13) n&lt;Enter&gt;：n为数字，光标向下移动n行<br> (14) /word：向光标之下寻找第一个值为word的字符串。<br> (15) ?word：向光标之上寻找第一个值为word的字符串。<br> (16) n：重复前一个查找操作<br> (17) N：反向重复前一个查找操作<br> (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2<br> (19) :1,<span class="hljs-variable">$s</span>/word1/word2/g：将全文的word1替换为word2<br> (20) :1,<span class="hljs-variable">$s</span>/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。<br> (21) v：选中文本<br> (22) d：删除选中的文本<br> (23) <span class="hljs-built_in">dd</span>: 删除当前行<br> (24) y：复制选中的文本<br> (25) yy: 复制当前行<br> (26) p: 将复制的数据在光标的下一行/下一个位置粘贴<br> (27) u：撤销<br> (28) Ctrl + r：取消撤销<br> (29) 大于号 &gt;：将选中的文本整体向右缩进一次<br> (30) 小于号 &lt;：将选中的文本整体向左缩进一次<br> (31) :w 保存<br> (32) :w! 强制保存<br> (33) :q 退出<br> (34) :q! 强制退出<br> (35) :wq 保存并退出<br> (36) :<span class="hljs-built_in">set</span> <span class="hljs-built_in">paste</span> 设置成粘贴模式，取消代码自动缩进<br> (37) :<span class="hljs-built_in">set</span> nopaste 取消粘贴模式，开启代码自动缩进<br> (38) :<span class="hljs-built_in">set</span> nu 显示行号<br> (39) :<span class="hljs-built_in">set</span> nonu 隐藏行号<br> (40) gg=G：将全文代码格式化<br> (41) :noh 关闭查找关键词高亮<br> (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令<br>异常处理：<br> 每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。<br> 如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：<br>     (1) 找到正在打开该文件的程序，并退出<br>     (2) 直接删掉该swp文件即可<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>夏令营面试</title>
    <link href="/2023/06/24/BJUT/%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%9D%A2%E8%AF%95/"/>
    <url>/2023/06/24/BJUT/%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>夏令营面试 <span id="more"></span></p><h2 id="高数">高数</h2><ol type="1"><li><p><strong>函数</strong></p><p>对于一个给定的数集D，对于每个值x属于D，按照一定的法则f，有一个确定的值y与之对应，则称y为x的函数</p></li><li><p><strong>极限</strong></p><p>若函数f(x)在点<spanclass="math inline">\(x_0\)</span>的去心邻域中有定义，若存在常数A，对于任意给定的<spanclass="math inline">\(\varepsilon &gt;0\)</span>,总存在正数<spanclass="math inline">\(\sigma\)</span>,使得当<spanclass="math inline">\(0&lt;|x-x_0|&lt;\sigma\)</span>时，对应的函数值</p><p>f(x)都满足不等式<spanclass="math inline">\(|f(x)-A|&lt;\varepsilon\)</span>，则A称为f(x)当x-&gt;x0的极限</p></li><li><p><strong>拐点</strong></p><p>连续曲线的凹弧与凸弧的分界点称为该曲线的拐点</p><p>二阶导为0三阶导不为0</p></li><li><p><strong>罗尔定理</strong></p><p>f(x)满足在[a,b]上连续，在(a,b)可导，f(a)=f(b),则存在一点c，使得f'(c)=0</p></li><li><p><strong>拉格朗日中值定理</strong></p><p>f(x)满足在[a,b]上连续，在(a,b)可导，则有<spanclass="math inline">\(f(b)-f(a)=f&#39;(c)(b-a)\)</span></p></li><li><p><strong>柯西中值定理</strong></p><p>f(x),g(x)满足在[a,b]连续，(a,b)可导，则存在一点c属于(a,b),有<spanclass="math inline">\(\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f&#39;(c)}{g&#39;(c)}\)</span></p></li><li><p><strong>二元函数极限</strong></p><p>f(x,y)在(x0,y0)的去心领域内有定义，且(x,y)以任意方式趋向于(x0,y0)时，f(x,y)均趋向于A</p></li><li><p><strong>一元函数可微条件</strong></p><p>可导必可微，可微必可导</p><p>可导条件：函数在该点的 去心邻域 内有定义；左右导数存在且相同</p></li><li><p><strong>二元函数可微条件</strong></p><p>全增量减去线性增量比上根号下derta x的平方加dertay的平方的极限值若趋于0则可微</p></li><li><p><strong>方向导数</strong></p><p>在函数定义域内的点，对某一方向求导得到的导数</p><p><span class="math inline">\(\frac{\partial f}{\partiall}=\mathrm{grad}f\cdot\frac{\overline{l}}{\left|\overline{l}\right|}\)</span></p></li><li><p><strong>梯度</strong></p><p><span class="math inline">\(\text{grad}f=(\frac{\partial f}{\partialx},\frac{\partial f}{\partial y})\)</span></p></li><li><p><strong>散度</strong></p><p><span class="math inline">\(\operatorname{div}F:=\nabla\cdotF={\frac{\partial F_{x}}{\partial x}}+{\frac{\partial F_{y}}{\partialy}}+{\frac{\partial F_{z}}{\partial z}}\)</span></p></li></ol><h2 id="线代">线代</h2><ol type="1"><li><p><strong>线性相关</strong></p><p>对m个n维向量<spanclass="math inline">\(\alpha_1、\alpha_2,...,\alpha_m\)</span>，若存在一组不全为0的数<spanclass="math inline">\(k_1,k_2,...,k_m\)</span>，使得<spanclass="math inline">\(k_1\alpha_1+k_2\alpha_2+...+k_m\alpha_m=0\)</span>则称该向量组线性相关</p></li><li><p><strong>矩阵的秩</strong></p><p>矩阵的最高阶非零子式的阶数</p><p>矩阵A中有一个r阶子式Dr!=0且所有r+1阶子式值全等于0</p></li><li><p><strong>向量组的秩</strong></p><p>向量组的极大线性无关组中所含向量的个数r称为向量组的秩</p></li><li><p><strong>特征向量</strong></p><p>设A是n阶矩阵，<spanclass="math inline">\(\lambda\)</span>是一个数，若存在n维非零列向量x使得<spanclass="math inline">\(Ax=\lambda x\)</span>,则称<spanclass="math inline">\(\lambda\)</span>是A的特征值，x是A的对应于特征值<spanclass="math inline">\(\lambda\)</span>的特征向量</p></li><li><p><strong>矩阵的相似</strong></p><p>AB是两个n阶方阵，若存在P，使得<spanclass="math inline">\(P^{-1}AP=B\)</span>,则称A相似于B</p><p>相似的矩阵是同一个线性变换在不同基/坐标系下的的不同描述</p><p><span class="math inline">\(Bx =P^{-1}APx\)</span>,即先对x使用P变换到新的坐标系，然后使用A进行线性变换，然后再使用<spanclass="math inline">\(P^{-1}\)</span>回到当前坐标系</p></li><li><p><strong>矩阵的相似对角化</strong></p><p>对于A若有<spanclass="math inline">\(P^{-1}AP=B\)</span>,其中B是对角矩阵，则称A可相似对角化</p><p>A可以相似对角化的充要条件为A有n个线性无关的特征向量</p><p><strong>只有实对称矩阵能正交相似对角化</strong></p></li><li><p>实对称矩阵<strong>A</strong>的不同<ahref="https://baike.baidu.com/item/特征值/11034909?fromModule=lemma_inlink">特征值</a>对应的<ahref="https://baike.baidu.com/item/特征向量/8663983?fromModule=lemma_inlink">特征向量</a>是正交的。</p></li><li><p><strong>特征值对应的特征向量就是理想中想取得正确的坐标轴，而特征值就等于数据在旋转之后的坐标上对应维度上的方差。</strong></p></li><li><p><strong>正定矩阵</strong></p><p>若对于任意的x，均有<spanclass="math inline">\(x^TAx&gt;0\)</span>,则称A为正定矩阵</p><p>特征值都大于0</p></li><li><p><strong>向量范数</strong></p><ol type="1"><li>1-范数 ：<spanclass="math inline">\(||x||_1=\sum_{i=1}^m|x_i|\)</span>，向量元素绝对值之和</li><li>2-范数：<span class="math inline">\(||x||_1=\sqrt{\sum_{i=1}^mx_i^2}\)</span>，向量元素平方和开方</li><li>p-范数：<spanclass="math inline">\(||x||_p=(\sum_{i=1}^m|x_i|^p)^{\frac{1}{p}}\)</span>，到0点的闵可夫斯基距离</li><li><span class="math inline">\(\infty\)</span>-范数： <spanclass="math inline">\(||x||_{\infty}=\max\limits_{i}|x_i|\)</span></li></ol></li><li><p><strong>矩阵范数</strong></p><ol type="1"><li>1-范数：<spanclass="math inline">\(||A||_1=\max\limits_{j}\sum_{i=1}^m|a_{i,j}|\)</span>，列和范数，所有矩阵列向量绝对值之和的最大值</li><li>2-范数：<spanclass="math inline">\(||A||_2=\sqrt{\lambda_1}\)</span>, <spanclass="math inline">\(\lambda_1\)</span>表示<spanclass="math inline">\(A^TA\)</span>的最大特征数，称为谱范数</li><li><span class="math inline">\(\infty\)</span>-范数：<spanclass="math inline">\(||A||_{\infty}=\max\limits_{j}\sum\limits_{j=1}^{m}|a_{i,j}|\)</span>,行和范数，即所有矩阵行向量绝对值之和的最大值</li><li>F-范数：<spanclass="math inline">\(||A||_F=(\sum_{i=1}^m\sum_{j=1}^na_{i,j}^2)^{\frac{1}{2}}\)</span>,矩阵元素绝对值平方和再开方</li></ol></li><li><p><strong>线性方程组解的情况</strong></p><ol type="1"><li>无解：系数矩阵秩&lt;增广矩阵的秩</li><li>唯一解：系数矩阵的秩=增广矩阵的秩=列数n</li><li>无穷解：系数矩阵的秩=增广矩阵的秩&lt;列数n</li></ol></li><li><p><strong>合同矩阵</strong></p><p>若存在可逆矩阵C，使得<spanclass="math inline">\(C^TAC=B\)</span>则称矩阵A与B合同</p></li><li><p><strong>正交矩阵</strong></p><p>满足<span class="math inline">\(A^T=A^{-1}\)</span>的矩阵</p><p>行向量均正交的矩阵</p></li></ol><h2 id="概率论">概率论</h2><ol type="1"><li><p><strong>古典概型</strong></p><p>样本空间只有有限个样本点且每个样本点发生的可能性都一样</p></li><li><p><strong>几何概型</strong></p><p>样本空间是可度量的有界区域，每个样本点发生的可能性都相同</p></li><li><p><strong>条件概率</strong></p><p>在已知A发生的条件下，事件B发生的概率为条件概率，有<spanclass="math inline">\(P(B|A)=\frac{P(AB)}{P(A)}\)</span></p></li><li><p><strong>全概率公式</strong></p><p>把<span class="math inline">\(B_i\)</span>看作是事件<spanclass="math inline">\(A\)</span>发生的一种“可能途径”，<spanclass="math inline">\(P ( A ∣ B 1 )\)</span> 则是通过这种途径得到<spanclass="math inline">\(A\)</span>的可能性，而途径的选择是随机的，因此可以把<spanclass="math inline">\(P(A)\)</span>看作不同途径概率的和。</p><p><span class="math inline">\(P(A) =\sum_{i=1}^nP(B_i)P(A/B_i)\)</span></p></li><li><p><strong>贝叶斯公式</strong></p><p><spanclass="math inline">\(P(A_j|B)=\frac{P(A_j)P(B|A_j)}{\sum_{i-1}^{n}P(A_i)P(B|A_i)}\)</span></p><p>以手写数字识别为例：识别目标<spanclass="math inline">\(P(A_j|B)\)</span>代表在给定的图片(B)的基础上，是0/1/.../9的的概率，取其中的最大值作为预测结果即可</p><p>先验概率<spanclass="math inline">\(P(A_j)\)</span>即为每个数字的样本数量占比；类条件概率<spanclass="math inline">\(P(B|A_j)\)</span>为对于数字为j的所有样本，第1,2,...,28*28个特征中颜色为白色的概率相乘的值。</p><p>分母是事件B发生的全概率</p></li><li><p>常见的随机变量分布类型</p><ol type="1"><li><p><strong>0-1分布</strong>：<spanclass="math inline">\(P\{x=1\}=p,P\{x=0\}=1-p\)</span></p></li><li><p><strong>伯努利分布</strong>：n次0-1分布</p></li><li><p><strong>二项分布</strong>：<spanclass="math inline">\(P\{X=k\}=C_n^kp^k(1-p)^{n-k}\)</span>，在只有两个结果的n次独立伯努利实验中，所期望的结果出现次数的概率</p></li><li><p><strong>泊松分布</strong>：<spanclass="math inline">\(P\{X=k\}=\frac{\lambda^k}{k!}e^{-\lambda}\)</span>,称X服从参数为<spanclass="math inline">\(\lambda\)</span>的泊松分布</p><p>为了预测在固定时间间隔内发生<strong>指定数量</strong>事件的概率,常用于对小概率事件进行建模</p><p>例子：1.已知某家小杂货店，平均每周售出2个水果罐头。请问该店水果罐头的最佳库存量是多少2. 一个月内某条路上出现车祸的概率</p><p><ahref="https://zhuanlan.zhihu.com/p/146951852">如何深刻理解二项式分布到泊松分布？- 知乎 (zhihu.com)</a></p><p>参数 λ是单位时间(或单位面积)内随机事件的<strong>平均发生次数</strong>，满足线性相加（2倍单位时间内…服从 2λ分布）。</p></li><li><p><strong>几何分布</strong>：<spanclass="math inline">\(P\{X=k\}=(1-p)^{k-1}p\)</span>,即前k-1次都失败，第k次成功了</p></li><li><p><strong>超几何分布</strong>：<spanclass="math inline">\(P(X=k)=\frac{C_m^k\timesC_{N-m}^{n-k}}{C_N^n}\)</span></p><p>假设有限总体包含N个样本，其中质量合格的为m个，则剩余的N-m个为不合格样本，如果从该有限总体中抽取出n个样本，其中有k个是质量合格的概率</p></li><li><p><strong>均匀分布</strong>：U(a,b)：在一个区间内为定值，除了这个区间都是0</p></li><li><p><strong>指数分布</strong>：<spanclass="math inline">\(E(\lambda)=\lambda e^{-\lambdax},x&gt;0\)</span></p></li><li><p><strong>正态分布</strong>：<spanclass="math inline">\(f(x)=\frac{1}{\sqrt{2\pi}\sigma}\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)\)</span></p></li></ol></li><li><p><strong>边缘分布</strong>：多维随机变量中只包含其中部分变量的概率分布。如对(X,Y)分布只研究X的分布。</p></li><li><p><strong>期望</strong></p><p>对于离散型随机变量，若级数<spanclass="math inline">\(\sum^{\infty}_{i=1}x_ip_i\)</span>绝对收敛，则期望即为该值</p><p>对于连续型随机变量，若对xf(x)dx在负无穷到正无穷的积分绝对收敛，则数学期望为该值</p><p>数学期望称为概率平均值，是描述随机变量平均取值状况特征的指标</p></li><li><p><strong>方差</strong></p><p><spanclass="math inline">\(DX=E[(X-EX)^2]=E(X^2)-(EX)^2\)</span></p></li><li><p><strong>切比雪夫不等式</strong></p><p><span class="math inline">\(P(|X-\mu|\geqk)\leq\frac{\sigma^2}{k^2}或P(|X-\mu|&lt;k)\geq1-\frac{\sigma^2}{k^2}\)</span></p><p>方差越小，X的值越接近均值，说明方差是<strong>刻画随机变量与其期望值偏离程度的指标</strong></p></li><li><p><strong>协方差</strong></p><p>随机变量XY的协方差<spanclass="math inline">\(Cov(X,Y)=E[(X-EX)(Y-EY)]=E(XY)-EXEY\)</span></p><p>用于衡量两个变量的相关性</p></li><li><p><strong>皮尔逊相关系数</strong></p><p><spanclass="math inline">\(\frac{Cov(X,Y)}{\sqrt{DX}\sqrt{DY}}\)</span>,若值为0则不相关</p></li><li><p><strong>大数定理</strong></p><ol type="1"><li><p>当样本量足够大时，能用频率近似代替概率；能用样本均值近似代替总体均值。</p></li><li><p><strong>伯努利大数定理</strong>：</p><p>从定义概率的角度，<strong>揭示了概率与频率的关系</strong>，当N很大的时候，事件A发生的概率等于A发生的频率。</p><p><spanclass="math inline">\(\lim\limits_{n\to\infty}P\left\{\left|\frac{f_A}{n}-p\right|&lt;\epsilon\right\}=1\)</span></p></li><li><p><strong>切比雪夫大数定理</strong></p><p><strong>揭示了样本均值和真实期望的关系</strong></p><p><spanclass="math inline">\(\lim\limits_{n\to+\infty}P\left\{\left|\frac{1}{n}\sum_{i=1}^{n}X_i-\frac{1}{n}\sum_{i=1}^{n}\mu_i\right|&lt;\xi\right\}=1\)</span></p></li><li><p>辛钦大数定律</p><p><strong>揭示了算术平均值和数学期望的关系</strong></p><p><spanclass="math inline">\(\lim\limits_{n\to\infty}P\left\{\left|\frac{1}{n}\sum_{i=1}^{n}X_i-\frac{1}{n}\sum_{i=1}^{n}E\left(X_{\mathbb{i}}\right)\right|\leq\varepsilon\right\}=1\)</span></p></li></ol></li><li><p><strong>中心极限定理</strong></p><p>对于一系列独立同分布的离散随机变量来说，当样本量足够大时，样本均值的分布呈现正态分布</p><p>要求一系列离散随机变量独立同分布且存在均值方差</p><p>样本数量无穷大的时候，<strong>样本均值的分布</strong>呈现<strong>正态分布</strong>，其对原总体的分布不做任何要求，意味着无论总体是什么分布，其抽样样本的均值的频数的分布都随着抽样数的增多而趋于正态分布。</p></li><li><p><strong>事件的独立性</strong></p><p>某一事件发生的概率完全不受到其他事件的影响。 用公式表示就是<spanclass="math inline">\(P(A,B)=P(A)*P(B)\)</span></p></li><li><p><strong>马尔科夫链</strong></p><p>马尔可夫链描述的是随机变量的一个状态序列，在这个状态序列里未来信息只与当前信息有关，而与过去的信息无关。它有两个很重要的假设：</p><ol type="1"><li>t+1时刻的状态的概率分布只与t时刻有关</li><li>t到t+1时刻状态转移与t值无关</li></ol></li></ol><p><a href="https://www.zhihu.com/question/36214010">(90 封私信 / 68条消息) 二项分布、泊松分布和正态分布的区别及联系? - 知乎(zhihu.com)</a></p><h2 id="离散数学">离散数学</h2><ol type="1"><li><p>幂集</p><p>集合的全体子集</p></li><li><p>笛卡尔乘积</p><p>用两个集合AB中的元素组成有序对，以A的元素作为第一个分量，B的元素作为第二个分量。这些有序对的集合称为A和B的笛卡尔乘积</p></li><li><p>单射：任给x1,x2属于X,若x1!=x2,则f(x1)!=f(x2)</p></li><li><p>满射：任给y属于Y，存在x属于X使得f(x)=y</p></li><li><p>双射：同时满足单射和满射</p></li><li><p>自反：对任意x，有R(x,x)</p></li><li><p>反自反：对任意x，没有R(x,x)</p></li><li><p>对称：有R(x,y)则有R(y,x)</p></li><li><p>反对称：有R(x,y)则没有R(y,x)</p></li><li><p>传递：有R(x,y)和R(y,z)则有R(x,z)</p></li><li><p>相容关系: R是自反、对称的</p></li><li><p>等价关系：R是自反、对称、传递的</p><ol type="1"><li><p>等价类：对于所有属于集合A的元素x,<spanclass="math inline">\([x]_R\)</span>为所有满足xRy的y元素集合</p></li><li><p><strong>商集</strong>：设 R 是集合 A 上的等价关系，由 R确定的<strong>所有等价类</strong>组成的集合，称为集合 A 上关于 R的商集，记为 <strong>A/R，是集合 A 的一个划分。</strong></p></li></ol></li><li><p>偏序关系：R是自反、反对称、传递的</p></li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230626185200.png" /></p><ol type="1"><li><p>最大元：在都可比的情况下最大的，有可能有好几个极大元没有最大元</p></li><li><p>最小元：在都可比的情况下最小的</p></li><li><p>极大元：在可比的那条链中最大的</p></li><li><p>极小元：在可比的那条链中最小的</p></li><li><p>上界：两个集合AB,B包含于A，对于任意的B中的x，有A中的y，x&lt;=y,则y为B的上界</p></li><li><p>下界：两个集合AB,B包含于A，对于任意的B中的x，有A中的y，y&lt;=x,则y为B的下界</p></li><li><p>上确界：上界中最小的</p></li><li><p>下确界：下届中最小的</p></li><li><p>逆序关系：R是反自反、反对称、传递的</p></li><li><p>哈密顿图：能走出一条通过<strong>每个节点</strong>仅一次的回路</p></li><li><p>欧拉图：能走出一条通过<strong>每条边</strong>仅一次的回路</p></li><li><p>任意命题公式都可由仅含有 <span class="math inline">\(\{\lnot,\lor\}\)</span>或<span class="math inline">\(\{\lnot, \land\}\)</span>的命题公式来等价表示,这两个集合就是完备集</p></li><li><p>自反闭包：R 的<strong>自反闭包</strong> r（R）是包含 R的最小的、自反的关系集合</p></li><li><p>代数系统</p><ol type="1"><li>&lt;S,*&gt;,代表非空集合和运算</li><li>幺元e:对任意x属于S，e*x=x则为左幺元，x*e=x则为右幺元</li><li>零元0：对任意x属于S，0*x = 0则为左零元</li><li>逆元<span class="math inline">\(x^{-1}\)</span>：对x属于S，<spanclass="math inline">\(x^{-1}*x=e\)</span>则为左逆元</li><li>广群：S非空，*运算封闭</li><li>半群：S非空，*运算封闭可结合</li><li>群：S非空，*封闭可结合存在幺元，每个元素均存在s逆元</li><li>有限群：S为有限集的群</li><li>阿贝尔群：S非空，*运算可以交换的群</li><li>循环群：阿贝尔群，其内任意元素均可由a的幂组成，a称为生成元</li></ol></li></ol><h2 id="数据结构">数据结构</h2><h3 id="参数传递的方式">参数传递的方式</h3><ol type="1"><li>值传递：生成一个临时变量作为形参传递给函数</li><li>指针传递：直接把地址传过去</li><li>引用传递：在栈中开辟一个空间，空间里面存的是地址，对引用的操作都是间接寻址的过程</li></ol><h3 id="p问题np问题np完全问题">P问题、NP问题、NP完全问题</h3><ol type="1"><li>P问题：存在多项式时间算法的问题</li><li>NP问题：能在多项式时间内验证得出一个正确解的问题，也就是不好求解，但是能验证一个答案是否正确</li><li>NP完全问题：所有的NP问题都可以规约到他，只要解决了这个问题，所有的NP问题都能得到解决，他本身也是个NP问题</li><li>NP难问题：所有的NP问题都能约化到它，但是它不一定是一个NP问题。</li></ol><h3 id="稳定性">稳定性</h3><p>如果两个具有相同键的对象以相同的顺序出现在排序输出中，则排序算法是<strong>稳定的</strong>。</p><p>稳定性的好处：<strong>排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。</strong>基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。</p><p>稳定的排序算法：<strong>冒泡排序、插入排序、归并排序和基数排序</strong></p><p>不是稳定的排序算法：<strong>选择排序、快速排序、希尔排序、堆排序</strong></p><h3 id="改进冒泡排序">改进冒泡排序</h3><p>设置一标志性变量pos，用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位，故在进行下一趟排序时只要扫描到pos位置即可。</p><h3 id="改进快排">改进快排</h3><p>只对长度大于 k kk的子序列递归调用快速排序，让原序列基本有序，然后再对整个基本有序序列用插入排序算法排序</p><h3 id="判断图中是否有环">判断图中是否有环</h3><ol type="1"><li>拓扑排序</li><li>深搜出现重复结点</li></ol><h3 id="g数据1g内存如何排序">10G数据，1G内存如何排序</h3><p><strong>分别排序</strong>：根据内存1G，数据10G，我们将10G数据切分成10份，通过内存调用磁盘的方式，每1G进行排序，排序结束后，我们会得到10个有序的数据数组。<strong>归并</strong>：多路归并过程可以使用最小堆。内存中开辟一个大小为10的最小堆，和一个缓冲区（小于1G，不要太小）。取10份排序好的数据的首位进入最小堆。则最小的数位于堆顶，移除堆顶元素并写入缓冲区，然后从移除元素的元素所属数组中的下一位进入最小堆，在次移除堆顶进入缓冲区...直到缓冲区满，缓冲区回写磁盘，清空缓冲区，再次将数据置入最小堆...直到10份数据全部写完，然后将最小堆的元素按顺序回写磁盘即可。</p><h3 id="堆栈区别">堆栈区别</h3><ol type="1"><li>栈：存放函数的参数值、局部变量，由编译器自动分配释放。</li><li>堆 ：是由 new 分配的内存块，由应用程序控制，需要程序员手动利用delete 释放，如果没有，程序结束后，操作系统自动回收。</li></ol><h3 id="数组名数组首地址">数组名、数组首地址</h3><ol type="1"><li>&amp;array是整个数组的首地址，array是数组首元素的首地址</li><li>&amp;array加一之后移动一整个数组，array加一后移动一个数组元素</li></ol><h3 id="内存的分配方式">内存的分配方式</h3><ol type="1"><li>从静态存储区域分配，如全局变量</li><li>在栈上创建，函数内局部变量的存储单元都在栈上创建</li><li>从堆上分配，动态内存分配</li></ol><h3id="函数名函数指针函数的入口地址">函数名，函数指针，函数的入口地址</h3><ol type="1"><li>函数名：一个指向其函数入口指针常量</li><li>函数指针：向函数的指针变量</li><li>函数入口地址：</li></ol><h2 id="计组">计组</h2><h3 id="为什么要设计多级缓存">为什么要设计多级缓存</h3><ol type="1"><li>L1 Cache用的晶体管比较多，同样的制程都给L1会导</li><li>Cache容量上升后期对命中率的提升并不明显，边际效用递减</li><li>L1如果太大，始终频率就做不了太大，影响处理器处理速度</li></ol><h3 id="单周期和多周期cpu的区别">单周期和多周期CPU的区别</h3><p>一个程序的不同指令所需要的执行时间是不同的，所以如果按照单周期处理的话，无论什么指令我都按照最长的那条指令去处理，对CPU资源是有浪费的</p><h3 id="自旋锁和互斥锁">自旋锁和互斥锁</h3><ol type="1"><li>互斥锁加锁失败后，线程释放CPU,给其他线程</li><li>自旋锁加锁失败后，线程会忙等待，知道拿到锁</li><li>看起来自旋锁效率低，但是互斥锁会在加锁失败后让线程进入睡眠状态，资源释放后会唤醒该进程，这就导致了两次的上下文切换，如果程序较短效率就会比较低</li></ol><h2 id="计网">计网</h2><p><ahref="https://blog.csdn.net/weixin_42369760/article/details/100008786">(135条消息)网络中主机通信过程_网络中的主机通信流程_Cold_Johnsnow的博客-CSDN博客</a></p><h3 id="数据链路层流量控制的方式">数据链路层流量控制的方式</h3><ol type="1"><li><p><strong>停止-等待</strong></p><p>发送方每发一帧，都要等待接收方回应，如果没收到就一直等待</p></li><li><p><strong>滑动窗口</strong></p><p>发送方维持一组连续的允许发送的帧的序号，称为发送窗口：同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。发送窗口用来对发送方进行流量控制，发送窗口的大小W代表在还未收到对方确认信息的情况下发送方最多还可以发送多少个数据帧。同理，在接收端设置接收窗口是为了控制可以接收哪些数据帧和不可以接收哪些帧。在接收方，只有收到的数据帧的序号落入接收窗口内时，才允许将该数据帧收下。若接收到的数据帧落在接收窗口之外，则一律将其丢弃。</p></li><li><p><strong>后退N帧</strong></p><p>发送方可以连续发送帧，当接收方检测出失序的信息帧或者发送方之前发送的某个帧超时后，发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧，接收方只允许按顺序接收帧</p></li><li><p><strong>选择重传.</strong></p><p>先收下发送序号不连续但是在接收窗口的那些数据帧，等待所缺序号的数据帧收到后再一并交给主机</p></li></ol><h3 id="交换机能替代路由器吗">交换机能替代路由器吗</h3><ol type="1"><li>同构网络可以</li></ol><h2 id="操作系统">操作系统</h2><h3 id="进程和线程">进程和线程</h3><ol type="1"><li>进程是资源分配的基本单位，线程是调度的基本单位</li><li>在操作系统的发展过程中，为了提高CPU利用率提出了多道程序的并发执行，并发执行就涉及到了程序之间的切换，当一个程序去做IO了，我得能找到一个对象让他来执行，为了表示这个对象就提出了进程。但是进程的在上下文切换时的代价较大，为了进一步提高并行性，提出线程的概念。一个进程可以创建多个线程，线程只保留一些必要的堆栈，共享进程的内存空间。</li></ol><h2 id="编译原理">编译原理</h2><h3 id="程序的编译执行过程">程序的编译执行过程</h3><ol type="1"><li>预处理：处理头文件、宏定义、条件编译指令</li><li>编译：词法分析、语法分析、语义分析、中间代码生成、目标代码生成、目标代码优化</li><li>汇编：将编译产生的源码转化为object file</li><li>链接：将一些object file链接成一个可执行文件</li></ol><h3 id="文法句型句子语言">文法、句型、句子、语言</h3><ol type="1"><li>文法：文法是一个四元组(<spanclass="math inline">\(V_N,V_T,P,S\)</span>)，分别代表非终结符集、终结符集、产生式集合、开始符号</li><li>句型：由开始符号推导出的符号串</li><li>句子：只由终结符组成的句型</li><li>语言：所有句子的集合</li><li>等价文法：文法的语言相同</li></ol><h3 id="文法的四种类型">文法的四种类型</h3><ol type="1"><li>0型文法：所有文法</li><li>1型文法(上下文有关文法)：对于所有a-&gt;b,均有|b|&gt;=|a|</li><li>2型文法(上下文无关文法)：|b|&gt;=|a|且a为非终结符</li><li>3型文法(正规文法)：对任意a-&gt;b,都有A-&gt;w或A-&gt;wB</li></ol><h3 id="ll1文法">LL(1)文法</h3><ol type="1"><li>对于A的所有产生式，FIRST子集不能有交集</li><li>如果A能推出空，则所有非空产生式的FIRST子集和FOLLOW(A)不能有交集</li><li>消除左递归、提取左因子</li></ol><h2 id="数据库">数据库</h2><h3 id="范式">范式</h3><ol type="1"><li><strong>第一范式</strong>：所有属性不可再分，强调表的原子性</li><li><strong>第二范式</strong>：若某关系R属于第一范式，且每一个非主属性完全函数依赖于任何一个候选码，则关系R属于第二范式。<ol type="1"><li><strong>候选码</strong>：能唯一标识元组的属性或属性组</li><li><strong>主属性</strong>：所有候选码的属性称为主属性</li><li><strong>函数依赖</strong>：设R(U)是属性集U上的关系模式，X、Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称Y函数依赖于X或X函数确定Y。</li><li><strong>完全函数依赖</strong>：如果Y函数依赖于X，且对于X的任何一个真子集X’，都有Y不函数依赖于X’，则称Y对X完全函数依赖。</li><li><strong>部分函数依赖</strong>：如果Y函数依赖于X，但Y不完全函数依赖于X，则称Y对X部分函数依赖。</li><li>第二范式理解：每个表必须有一个（有且仅有一个）数据项作为关键字或主键（primarykey），其他数据项与关键字或者主键一一对应，即其他数据项完全依赖于关键字或主键</li></ol></li><li><strong>第三范式</strong>：非主属性既不传递依赖于码，也不部分依赖于码。<ol type="1"><li><strong>传递函数依赖</strong>：在R(U)中，若X函数依赖于Y，Y不函数依赖于X，Y函数依赖于Z。则称Z对X传递函数依赖</li></ol></li><li><strong>BCNF范式</strong>：关系模式R&lt;U,F&gt;中，若每一个决定因素都包含码，则R&lt;U,F&gt;属于BCFN。<ol type="1"><li>理解：<ol type="1"><li>所有非主属性对每一个码都是完全函数依赖；</li><li>所有主属性对每一个不包含它的码也是完全函数依赖；</li><li>没有任何属性完全函数依赖于非码的任何一组属性。</li></ol></li></ol></li></ol><h3 id="事务的四大特性acid">事务的四大特性ACID</h3><ol type="1"><li>原子性：要么都做要么都不做</li><li>一致性：事务必须使数据库从一个一致性状态变换到另一个一致性状态</li><li>隔离性：事务之间不互相干扰，多个并发事务之间互相隔离</li><li>持久性：一个事务一旦被提交，对数据的改变就是永久的</li></ol><h3 id="机器学习">机器学习</h3><h3 id="pca">PCA</h3><p>PCA (Principal ComponentAnalysis)是最常用的<strong>线性降维</strong>方法，它的目标是通过某种线性投影，将高维的数据映射到低维的空间中表示，并期望在所投影的维度上数据的<strong>方差最大</strong>，以此使用较少的数据维度，同时保留住较多的原数据点的特性。</p><h3 id="k-means">K-means</h3><p>聚类算法，事先确定常数 k代表着聚类类别数。首先随机选取k个初始点为质心，并通过计算每一个样本与质心之间的相似度（可以采用欧式距离），将样本点归到最相似的类中，接着重新计算每个类的质心（该类中所有点的平均值），重复这样的过程直到质心不再改变，最终就确定了每个样本所属的类别以及每个类的质心。</p><h3 id="牛顿法和梯度下降法">牛顿法和梯度下降法</h3><p>从本质上去看，牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。更通俗地说，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大（二阶导数信息）。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。（牛顿法目光更加长远，所以少走弯路；相对而言，梯度下降法只考虑了局部的最优，没有全局思想。）</p><p>从几何上说，牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230628102018.png" style="zoom:50%;" /></p><h2 id="项目">项目</h2><h3 id="yolov4">Yolov4</h3><ol type="1"><li><p>输入端</p><ol type="1"><li><strong>Mosaic数据增强</strong>：随机使用<strong>4张图片</strong>，随机缩放，再随机分布进行拼接，大大丰富了检测数据集，特别是随机缩放增加了很多小目标，让网络的鲁棒性更好。</li></ol></li><li><p>BackBone</p><ol type="1"><li><strong>CSPDarknet53</strong>：CSPNet的作者认为推理计算过高的问题是由于网络优化中的<strong>梯度信息重复</strong>导致的。因此采用CSP模块先将基础层的特征映射划分为两部分，然后通过跨阶段层次结构将它们合并，在减少了计算量的同时可以保证准确率。</li><li><strong>Dropblock</strong>：Dropout的方式会随机的删减丢弃一些信息，但<strong>Dropblock的研究者</strong>认为，卷积层对于这种随机丢弃并不敏感，因为卷积层通常是三层连用：<strong>卷积+激活+池化层</strong>，池化层本身就是对相邻单元起作用。而且即使随机丢弃，卷积层仍然可以从相邻的激活单元学习到<strong>相同的信息</strong>。因此，在全连接层上效果很好的Dropout在卷积层上<strong>效果并不好</strong>。</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625131008.png" style="zoom: 67%;" /></p><ol start="3" type="1"><li>Neck<ol type="1"><li><strong>SPP</strong>：使用k={1<em>1,5</em>5,9<em>9,13</em>13}的最大池化的方式，再将不同尺度的特征图进行Concat操作。比单纯的使用<strong>k*k最大池化</strong>的方式，更有效的增加主干特征的接收范围，显著的分离了最重要的上下文特征。</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625131645.png" style="zoom: 50%;" /></p><p>​ 2.<strong>FPN+PAN</strong>:FPN层自顶向下传达<strong>强语义特征</strong>，而特征金字塔则自底向上传达<strong>强定位特征</strong>，两两联手，从不同的主干层对不同的检测层进行参数聚合</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625132401.png" /></p><ol start="4" type="1"><li><p>输出端</p><ol type="1"><li><p>IOU_loss：1-交集/并集。当预测框和目标框不相交时无法衡量；当相交但相交的位置不同时无法衡量</p></li><li><p>GIOU_Loss</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625134108.png" style="zoom:50%;" /></p></li><li><p>DIOU_Loss</p><p><img src="https://pic1.zhimg.com/80/v2-029f094658e87f441bf30c80cb8d07d0_1440w.webp" alt="img" style="zoom:50%;" /></p></li><li><p>CIOU_Loss</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625134312.png" style="zoom:50%;" /></p></li><li><p><strong>DIOU_nms</strong>：Nms主要用于预测框的筛选</p></li></ol></li></ol><h3 id="yolov5">Yolov5</h3><ol type="1"><li><p>输入端</p><ol type="1"><li>Mosaic数据增强</li><li>自适应锚框计算</li><li>letterbox统一尺寸</li></ol></li><li><p>Backbone</p><ol type="1"><li><p>Focus结构：将<spanclass="math inline">\(608*608*3\)</span>切片为<spanclass="math inline">\(304*304*12\)</span>,再经过32个卷积核的卷积操作得到<spanclass="math inline">\(304*304*32\)</span>的特征图</p></li><li><p>CSP结构</p><p><img src="https://pic4.zhimg.com/80/v2-1da2f1a93c888dfe7c9002de56cff02b_1440w.webp" alt="img" style="zoom:50%;" /></p></li></ol></li><li><p>Neck</p><ol type="1"><li>FPN_PAN</li></ol></li><li><p>输出端</p><ol type="1"><li>CIOU_Loss</li><li>加权nms</li></ol></li></ol><h2 id="英文面">英文面</h2><h3 id="分钟自我介绍">2分钟自我介绍</h3><p>Good afternoon professors. I am honored to be here for thisinterview. Now i will give a brief introduction about myself. My name isChenLibiao and I am studying Computer Science at Beijing University ofTechnology.</p><p>First of all, for my in-class studies, you can see that I achievedhigh grade points and high ranking. And outside of class, I am alsoresponsible for tutoring advanced mathematics at our school, so I have astrong ability to communicate with others.</p><p>In terms of competitions, I have received some awards in many fieldssuch as mathematics, algorithms and data analysis So I think I havecomprehensive knowledge.</p><p>In terms of scientific research, under the guidance of my tutor, Ihave completed a paper on deep neural network as the first author andyou can see that paper in the middle of my materials. In addition tothat, I also have several other research projects so I believe that Ican complete high-level research work under the guidance of teachers andresearch team.</p><p>Beihang university has been my dream school for a long time. If Ihave the honor of being selected as an excellent camper, I will surelychoose Beihang University in September. Ok that's all, thanks forlistening</p><h3 id="项目介绍">项目介绍</h3><p>This project is about using deep neural networks for the diagnosis ofASD. ASD is a complex neurodevelopmental disorder that severely impactssocial abilities. In this project, we employed sliding windows andpearson rank correlation coefficient to collect dynamic functionalconnectivity (dFC) data and applied Kendall's rank correlationcoefficient to extract features. We then introduced self-attentionmechanism in our DNN architecture to efficiently extract high-orderspatial features across consecutive windows. By stacking multi-headself-attention layers with feed-forward neural networks, our modeleffectively extracts rich information in multiple dimensions andintegrates them together. We conducted systematic experiments on thelarge-sacle ABIDE dataset to validate the performance of our model.Moreover, our study revealed that the middle frontal gyrus and middletemporal gyrus exhibit significant alterations in ASD patients,highlighting their diagnostic value and potential relevance as targetsfor intervention. Our model provides an effective approach to assist inthe diagnosis of ASD.</p>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/06/23/BJUT/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/06/23/BJUT/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>计算机网络复习</p><span id="more"></span><h2 id="计算机网络体系结构">计算机网络体系结构</h2><ol type="1"><li><p>局域网基本都使用广播式通信技术，广域网中的无线、卫星通信也采用广播式通信</p></li><li><p>是否采用分组存储转发与路由选择机制是点对点网络与广播式网络的重要区别</p></li><li><p>计算机网络的组成</p><ol type="1"><li>按组成部分：硬件+软件+协议</li><li>按功能：通信子网（交换机、路由器等）+资源子网（计算机设备、软件）</li><li>按工作方式：边缘部分（主机）+核心部分（路由器等）</li></ol></li><li><p>计算机网络的交换技术</p><ol type="1"><li><p>电路交换网络</p><p>建立专用的通路用于传送数据，包括建立连接、传输数据、断开链接三个阶段。连接建立后则该线路被独占</p><p>数据直接传送、时延小；线路利用率低、不能充分利用线路容量、不便于进行差错控制</p></li><li><p>报文交换网络</p><p>用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文。<strong>整个报文</strong>传送到相邻结点，全部存储后再转发给下一个节点，又称为存储-转发网络。报文交换对报文的大小没有限制。</p><p>可以较为充分地利用线路容量；增大了资源开销、时延</p></li><li><p>分组交换网络</p><p>也称为包交换网络。将数据分成较短的<strong>固定长度</strong>的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包)，以存储-转发方式传输。</p><p>除具备报文交换网络的优点外，分组交换网络还具有自身的优点：缓冲易于管理；包的平均时延更小，网络占用的平均缓冲区更少；更易于标准化；更适合应用。现在的主流网络基本上都可视为分组交换网络。</p></li></ol></li><li><p>协议是控制两个或多个对等实体进行通信的规则的集合，是水平的；服务是指下层为紧邻的上层提供的功能调用，是垂直的</p></li><li><p>服务的分类</p><ol type="1"><li><p>面向连接服务与无连接服务</p><p>面向连接服务：连接建立、数据传输、连接释放</p></li><li><p>可靠服务和不可靠服务</p><p>可靠服务指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地</p></li><li><p>有应答服务和无应答服务</p><p>有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统内部自动实现，而不由用户实现。所发送的应答既可以是肯定应答，也可以是否定应答，通常在接收到的数据有错误时发送否定应答。</p></li></ol></li><li><p>OSI（开放系统互连参考模型）</p><p>低三层为通信子网，高三层为资源子网</p><ol type="1"><li>物理层：传输单位为比特，在物理媒体上为数据端设备透明地传输原始比特流</li><li>数据链路层：传输单位是帧，任务是将网络层传来的IP数据报组装成帧。有成帧、差错控制、流量控制和传输管理的功能</li><li>网络层：传输单位是数据报，关心的是通信子网的运行控制。主要任务是把网络层的协议数据单元从源端传送到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互连等</li><li>传输层：传输单位是报文段（TCP）或用户数据报（UDP），负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为<strong>端到端连接</strong>提供流量控制、差错控制、服务质量、数据传输管理等服务。高层使用传输层的服务而忽略通信子网的存在</li><li>会话层：允许不同主机上的各个进程之间进行会话。利用传输层端到端的服务为表示层实体或用户进程建立连接并传输数据</li><li>表示层：处理在两个通信系统中交换信息的表示方式，可以进行数据压缩、加密解密等</li><li>应用层：用户与网络的界面</li></ol></li><li><p>OSI和TCP/IP</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010617.png" style="zoom:50%;" /></p></li></ol><h2 id="物理层">物理层</h2><ol type="1"><li><p>数据报与虚电路</p><p><strong>分组交换</strong>根据其通信子网向端点系统提供的服务，可以分为面向连接的虚电路方式和无连接的数据报方式，这两种方式都由<strong>网络层</strong>提供</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010638.png" /></p></li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010654.png" /></p><p>​虚电路试图结合数据报方式和电路交换方式，每次建立虚电路时就确定一条固定线路，以后数据传输都从这条线路走，但是并不独占线路。</p><ol start="2" type="1"><li>中继器：将信号整形并放大再转发出去，消除信号的失真和衰减，扩大网络传输的距离</li><li>集线器：多端口的中继器</li></ol><h2 id="数据链路层">数据链路层</h2><h3 id="功能">功能</h3><ol type="1"><li>为网络提供服务：无确认的无连接服务、有确认的无连接服务、有确认的面向连接服务</li><li>链路管理：连接的建立、维持和释放</li><li>帧定界：确定开始结束位格式；帧同步：接收方能够从比特流中识别出开始结束标志</li><li>流量控制：防止发送方发送能力大于接收方接受能力而导致淹没现象</li><li>差错控制：检错码（奇偶校验码、循环冗余码），纠错编码（海明码）</li></ol><h3 id="流量控制的方式">流量控制的方式</h3><ol type="1"><li><p><strong>停止-等待</strong></p><p>发送方每发一帧，都要等待接收方回应，如果没收到就一直等待</p></li><li><p><strong>滑动窗口</strong></p><p>发送方维持一组连续的允许发送的帧的序号，称为发送窗口：同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。发送窗口用来对发送方进行流量控制，发送窗口的大小W代表在还未收到对方确认信息的情况下发送方最多还可以发送多少个数据帧。同理，在接收端设置接收窗口是为了控制可以接收哪些数据帧和不可以接收哪些帧。在接收方，只有收到的数据帧的序号落入接收窗口内时，才允许将该数据帧收下。若接收到的数据帧落在接收窗口之外，则一律将其丢弃。</p></li><li><p><strong>后退N帧</strong></p><p>发送方可以连续发送帧，当接收方检测出失序的信息帧或者发送方之前发送的某个帧超时后，发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧，接收方只允许按顺序接收帧</p></li><li><p><strong>选择重传.</strong></p><p>先收下发送序号不连续但是在接收窗口的那些数据帧，等待所缺序号的数据帧收到后再一并交给主机</p></li></ol><h3 id="介质访问控制">介质访问控制</h3><ol type="1"><li><p>信道划分介质访问控制</p><ol type="1"><li>频分多路复用：共享时间</li><li>时分多路复用：共享空间</li><li>波分多路复用：光的频分多路复用</li><li>码分多路复用：采用不同编码区分各路原始信号</li></ol></li><li><p>随机访问介质访问控制</p><p>不采用<strong>集中控制</strong>的方式解决发送信息的次序问题</p><ol type="1"><li><p>纯ALOHA协议：不检测直接发，如果没收到确认帧随机等一段时间后再发</p></li><li><p>时隙ALOHA协议：将时间划分为一段段等长的时隙，只能在每个时隙开始时才能发送一个帧</p></li><li><p>CSMA（载波监听多路访问）</p><ol type="1"><li>1-坚持CSMA：发送数据前监听信道，若空闲则发送，若不空闲则一直等待</li><li>非坚持CSMA：若不空闲则等待一个随机时间后再发送</li><li>p-坚持CSMA：如果空闲，则以p概率发送，以1-p概率下一个时隙再发送，如果忙则一直监听</li></ol></li><li><p>CSMA/CD：载波监听+碰撞检测。先听后发，边听边发，冲突停发，随机重发。适用于有线连接的半双工通信</p><p>CSMA/CD算法的归纳如下：①准备发送：适配器从网络层获得一个分组，封装成帧，放入适配器的缓存。②检测信道：若检测到信道空闲，它就开始发送这个帧。若检测到信道忙，它就持续检测直至信道上没有信号能量，然后开始发送这个帧。③在发送过程中，适配器仍持续检测信道。这里只有两种可能：发送成功：在争用期内一直未检测到碰撞，这个帧肯定能发送成功。发送失败：在争用期内检测到碰撞，此时立即停止发送，适配器执行指数退避算法，等待一段随机时间后返回到步骤②。若重传16次仍不能成功，则停止重传并向上报错。</p></li><li><p>CSMA/CA：载波监听+碰撞避免，适用于无线局域网（接收信号强度弱、存在隐蔽站，不能进行碰撞检测）</p><p>CSMA/CA算法的归纳如下：</p><ol type="1"><li>若站点最初有数据要发送（而不是发送不成功再进行重传)，且检测到信道空闲，在等待时间DIFS后，就发送整个数据帧。</li><li>否则，站点执行CSMA/CA退避算法，选取一个随机回退值。一旦检测到信道忙，退避计时器就保持不变。只要信道空闲，退避计时器就进行倒计时。</li><li>当退避计时器减到0时（这时信道只可能是空闲的），站点就发送整个帧并等待确认。</li><li>发送站若收到确认，就知道已发送的帧被目的站正确接收。这时如果要发送第二帧，就要从步骤2开始，执行CSMA/CA退避算法，随机选定一段退避时间。若发送站在规定时间（由重传计时器控制）内没有收到确认帧ACK,就必须重传该帧，再次使用CSMA/CA协议争用该信道，直到收到确认，或经过若干次重传失败后放弃发送。</li></ol></li></ol></li><li><p>轮询访问</p><p>主机在逻辑上形成环，令牌在环上移动，拿到令牌才能发送</p></li></ol><h3 id="局域网">局域网</h3><ol type="1"><li><p>局域网现在由以太网垄断，以太网采用无连接的工作方式，不对发送的数据帧编号，也不要求接收方发送确认，提供的是不可靠服务，对于差错的纠正由高层完成。</p></li><li><p>以太网发送的数据都是用曼彻斯特编码的信号，每个码元的中间出现一次电压转换，接收端利用这种电压转换方便地把位同步信号提取出来</p></li><li><p>计算机与外界局域网的连接是通过主机箱内插入的一块网络接口板[又称网络适配器(Adapter)或网络接口卡(NetworkInterfaceCard,NIC)]实现的。<strong>网卡</strong>上装有处理器和存储器，是工作在<strong>数据链路层</strong>的网络组件。<strong>网卡和局域网</strong>的通信是通过电缆或双绞线以串行方式进行的，而<strong>网卡和计算机</strong>的通信则是通过计算机主板上的/O总线以并行方式进行的。因此，网卡的重要功能就是进行数据的串并转换。网卡不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码及数据缓存功能等。</p></li><li><p>每一个网卡都有一个唯一的介质访问控制（MAC）地址</p></li><li><p>MAC帧，802.3帧格式用长度域替代了类型域</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010713.png" /></p></li><li><p>无线局域网分为有固定基础设施无线局域网和无固定基础设施移动自组织网络</p></li><li><p>通用虚拟局域网，可以把一个较大的局域网分割为一些较小的与地理位置无关的逻辑上的VLAN</p></li><li><p>VLAN在以太网帧中插入一个四字节的标识符，用来指明发送该帧的计算机属于哪个虚拟局域网</p></li></ol><h3 id="广域网">广域网</h3><ol type="1"><li>广域网中的一个重要问题是<strong>路由选择</strong>和<strong>分组转发</strong>。路由选择协议负责搜索分组从某个结点到目的结点的最佳传输路由，以便构造路由表，然后从路由表再构造出转发分组的转发表。分组是通过转发表进行转发的。</li></ol><p>2.PPP协议：点对点协议是使用串行线路通信的面向字节的协议，应用在直接连接的两个节点的链路上(找不到就广播)</p><h3 id="数据链路层设备">数据链路层设备</h3><ol type="1"><li><strong>网桥</strong>：两个以上以太网通过网桥连接后可以成为一个覆盖范围更广的以太网，原来每个以太网称为一个网段</li><li><strong>局域网交换机</strong>：多端口的网桥，每个端口都直接与单台主机或另一个交换机连接，通常都工作在全双工模式。具有自学习能力，能够方便的扩展以太网。</li></ol><h2 id="网络层">网络层</h2><h3 id="功能-1">功能</h3><h3id="异构网络互连用路由器进行网络互联和路由选择来将多个网络连接在一起"><strong>异构网络互连</strong>：用路由器进行网络互联和路由选择来将多个网络连接在一起</h3><ol start="2" type="1"><li><p><strong>路由与转发</strong>：路由器的两个功能：路由选择（确定哪一条道路）、分组转发（当一个分组到达时所采取的动作）</p><p>路由选择按照复杂的分布式算法动态改变所选择的路由，生成路由表；转发表通过路由表生成。</p></li><li><p><strong>软件定义网络（SDN）</strong>：分为数据平面和控制平面。采用集中式的控制平面和分布式的数据平面。路由器不需要路由选择软件，路由器之间不再需要交换路由信息。</p></li><li><p><strong>拥塞控制</strong>：因出现过量的分组而引起网络性能下降的现象称为拥塞</p></li></ol><h3 id="路由算法">路由算法</h3><ol type="1"><li><p>静态路由算法：人工指定</p></li><li><p>距离-向量路由算法(RIP)：</p><p>所有结点都定期地将他们的整个路由选择表传送给所有与之直接相邻的结点。当出现新的路由或者距离某个已有路由距离有更近路径时更新自身路由表。</p><p>RIP使用跳数来衡量到达目的网络的距离</p></li><li><p>链路状态路由算法（OSPF）：</p><p>要求每个参与该算法的结点都具有完全的网络拓扑信息，他们执行以下两项任务:(1)主动测试所有邻接结点的状态.(2)定期将链路状态传播给所有其他结点</p><p>当别的结点的状态报文发送来时，如果对自身状态有更新，则使用Dijkstra算法更新到各个目标节点的最短路径</p></li><li><p>层次路由</p><p>将互联网划分为许多较小的自治系统。每个自治系统内部决定采用何种路由选择协议（内部网关协议），自治系统之间采用相同协议（外部网关协议）。</p></li></ol><h3 id="ipv4">IPv4</h3><ol type="1"><li><p>早期IP地址</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/image-20230624125348468.png" style="zoom:67%;" /></p></li><li><p>网络地址转换（NAT）</p><ol type="1"><li><p>将专用网络地址转化为公用地址，从而对外隐藏内部管理的IP地址。</p></li><li><p>每个NAT路由器至少有一个有效的外部全球IP地址，本地地址的主机和外界通信时，NAT路由器使用NAT转换表进行本地IP地址和全球IP地址的转换。</p></li></ol></li><li><p>子网划分</p><p>从主机号借用若干比特作为子网号，不改变网络号，属于单位内部的事情，对外仍表现为没有划分的网络</p></li><li><p>子网掩码</p><ol type="1"><li><p>使用子网掩码表达对原网络中主机号的借位</p></li><li><p>子网掩码是一个与IP地址相对应的、长32bt的二进制串，它由一串1和跟随的一串0组成。其中，1对应于P地址中的网络号及子网号，而0对应于主机号。计算机只需将IP地址和其对应的子网掩码逐位“与”，就可得出相应子网的网络地址。</p></li><li><p>一台主机在设置IP地址信息的同时，必须设置子网掩码</p></li><li><p>同属于一个子网的所有主机及路由器的相应端口必须设置相同的子网掩码</p></li><li><p>路由器的路由表中所包含的主要内容有目的网络地址、子网掩码、下一跳地址</p></li></ol></li><li><p>无分类编址CIDR</p><ol type="1"><li>在变长子网掩码的基础上提出一种消除传统ABC类网络划分，并可以在软件支持下实现超网构造的一种IP地址划分方法</li><li>IP::={<网络前缀>,<主机号>}，其中网络前缀的长度不定，使用IP/前缀比特数的方式得到网络前缀</li><li>使用网络前缀都相同的连续IP地址组成“CIDR地址块”，一个CIDR地址块可以表示很多地址，这种地址的聚合称为路由聚合，或称构成超网。路由聚合使得路由表中的一个项目可以表示多个原来传统分类地址的路由，有利于减少路由器之间的信息的交换，从而提高网络性能</li><li>路由表中的每个项目由网络前缀和下一跳地址组成，在查找路由表时应该从匹配结果中选择具有最长网络前缀的路由</li></ol></li><li><p>网络层转发分组的过程</p><ol type="1"><li>从收到的IP分组的首部提取目的主机的P地址D(即目的地址)。</li><li>若查找到特定主机路由（目的地址为D),就按照这条路由的下一跳转发分组；否则从转发表中的下一条（即按前缀长度的顺序）开始检查，执行步骤3)。</li><li>将这一行的子网掩码与目的地址D进行按位与运算。若运算结果与本行的前缀匹配，则查找结束，按照“下一跳”指出的进行处理（或者直接交付本网络上的目的主机，或通过指定接口发送到下一跳路由器)。否则，若转发表还有下一行，则对下一行进行检查，重新执行步骤3)。否则，执行步骤4)。</li><li>若转发表中有一个默认路由，则把分组传送给默认路由；否则，报告转发分组出错。</li></ol></li><li><p>地址解析协议（ARP）</p><ol type="1"><li><p>实现IP地址到MAC地址的映射</p></li><li><p>每台主机都设有一个ARP高速缓存用来存放本局域网上各主机和路由器的IP地址到MAC地址的映射表，称为ARP表</p></li><li><p>工作原理</p><p>主机A向B发送IP数据报时，先在ARP高速缓存中查找有无B的IP地址，如果有就可以查出其对应的硬件地址，再将此硬件地址写入MAC帧通过局域网发过去。如果没有就使用MAC地址为FFFF-FF-FF-FF-FF的帧来封装并广播ARP请求分组，B收到后通过单播向A发送响应分组，包含B的IP与MAC地址的对应关系。</p></li><li><p>当主机想要发数据给另一个网络的主机时，本地主机查找路由器硬件地址并发送数据，由路由器完成后续操作</p></li></ol></li><li><p>动态主机配置协议（DHCP）</p><ol type="1"><li><p>是应用层协议，基于UDP，用于给主机动态的分配IP地址</p></li><li><p>DHCP的工作原理</p><p>使用客户/服务器模式。需要IP地址的主机在启动时就向DHCP服务器广播发送发现报文，这时该主机就成为DHCP客户。本地网络上所有主机都能收到此广播报文，但只有DHCP服务器才回答此广播报文。DHCP服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的P地址池中取一个地址分配给该计算机。DHCP服务器的回答报文称为提供报文。</p></li></ol></li><li><p>网际控制报文协议</p><p>为了提高IP数据报交付成功的机会，在网络层使用了网际控制报文协议(InternetControl MessageProtocol,ICMP)来让主机或路由器报告差错和异常情况。</p></li></ol><h3 id="ipv6">IPv6</h3><ol type="1"><li>解决IP地址耗尽的措施<ol type="1"><li>采用无类别编址CIDR，使IP地址分配更加合理</li><li>采用网络地址转换NAT节省全球IPI地址</li><li>采用更大地址空间的IPv6</li></ol></li></ol><h3 id="路由协议">路由协议</h3><ol type="1"><li><p>内部网关协议</p><ol type="1"><li><p>路由信息协议（RIP）</p><ol type="1"><li>基于距离向量的路由选择协议</li><li>直连路由器跳数为1，随后每多一个加1跳，大于15跳认为不可达</li><li>每个路由器和直接相连的路由器交换自身路由表，一段时间后每个路由器都将知道全部的路由器信息，称为RIP收敛</li><li>是应用层协议，使用UDP传送数据</li></ol></li><li><p>开放最短路径优先协议（OSPF）</p><ol type="1"><li><p>分布式链路状态路由算法的代表</p></li><li><p>采用洪泛法向本自治系统中所有路由器发送信息，信息为自己和相邻路由器的度量</p></li><li><p>只有当链路状态改变时才发送信息</p></li><li><p>是网络层协议，直接用IP数据报传送</p></li><li><p>所有路由器最终都能建立一个链路状态数据库，采用Dijkstra算法计算从自己到各目的网络的最优路径以构造自己的路由表</p></li></ol></li></ol></li><li><p>外部网关协议</p><ol type="1"><li>边界网关协议（BGP）<ol type="1"><li>采用路径向量路由选择协议，是应用层协议，基于TCP</li><li>每个自治系统选择一个或多个BGP发言人，发言人要与其他BGP发言人建立TCP连接并交换路由信息</li><li>找的是较好的路径，并非最佳路径</li></ol></li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010842.png" style="zoom: 50%;" /></p><h3 id="ip组播">IP组播</h3><ol type="1"><li>缘由：有的应用程序要把一个分组发送给多个目的地主机，只发送一次但是可以发送到多个主机</li><li>每个组都有一个地址，要给该组发送的计算机将使用这个地址作为分组的目标地址</li><li>仅应用于UDP，地址采用D类地址</li><li>使用因特网组管理协议（IGMP）使路由器知道组播组成员的信息</li></ol><h3 id="移动ip">移动IP</h3><ol type="1"><li>移动站在归属网络时，按传统的TCP/IP方式进行通信。</li><li>移动站漫游到外地网络时，向外地代理进行登记，以获得一个临时的转交地址。外地代理要向移动站的归属代理登记移动站的转交地址。</li><li>归属代理知道移动站的转交地址后，会构建一条通向转交地址的隧道，将截获的发送给移动站的P分组进行再封装，并通过隧道发送给被访网络的外地代理。</li><li>外地代理把收到的封装的数据报进行拆封，恢复成原始的P分组，然后发送给移动站，这样移动站在被访网络就能收到这些发送给它的P分组。</li><li>移动站在被访网络对外发送数据报时，仍然使用自己的永久地址作为数据报的源地址，此时显然无须通过A的归属代理来转发，而是直接通过被访网络的外部代理。</li><li>移动站移动到另一外地网络时，在新外地代理登记后，然后新外地代理将移动站的新转交地址告诉其归属代理。无论如何移动，移动站收到的数据报都是由归属代理转发的。</li><li>移动站回到归属网络时，移动站向归属代理注销转交地址。</li></ol><h2 id="传输层">传输层</h2><h3 id="服务">服务</h3><ol type="1"><li><p>功能</p><ol type="1"><li><p>为运行在不同主机上的<strong>进程</strong>之间提供逻辑通信</p></li><li><p>复用和分用：复用指发送方不同的应用进程都可使用同一个传输层协议传送数据；分用指接收方的传输层在剥去报文首部后能够把这些数据正确交付到目的应用进程</p></li><li><p>对收到的报文进行差错检测（首部和数据部分），网络层只检查IP数据报的首部</p></li><li><p>提供两种不同的传输协议（TCP和UDP）</p></li></ol></li><li><p>套接字Socket：IP地址：端口号,唯一标识一台主机上的一个进程</p></li></ol><h3 id="udp">UDP</h3><ol type="1"><li><p>UDP在IP数据报服务的基础上提供复用和分用以及差错检测服务</p></li><li><p>优点</p><ol type="1"><li>无需建立连接，因此不会引入建立连接的时延</li><li>无连接状态。不需要维护连接状态，也不跟走这些参数，因此一般可以支持更多的活动客户机</li><li>分组首部开销小，只有8B</li><li>没有拥塞控制，应用层能更好的控制要发送的数据和发送时间</li><li>支持一对一、一对多、多对一的通信</li></ol></li><li><p>面向报文，对应用层交下来的报文在添加首部后就向下交付给IP层，保留报文边界。报文是UDP数据报处理的最小单位。</p></li></ol><h3 id="tcp">TCP</h3><ol type="1"><li><p>每条TCP连接只能有两个端点，每一条TCP连接只能是点到点的</p></li><li><p>TCP面向字节流，应用程序和TCP的交互是大小不一的数据块，但TCP把应用程序交下来的数据仅视为一连串的无结构字节流</p></li><li><p>TCP连接的两端为套接字或插口</p></li><li><p>三次握手</p><p>连接建立前，服务器进程处于LISTEN(收听)状态，等待客户的连接请求。</p><ol type="1"><li>客户机的TCP首先向服务器的TCP发送连接请求报文段。这个特殊报文段的首部中的<strong>同步位SYN置1</strong>，同时选择一个初始序号<strong>seq=x</strong>。TCP规定，SYN报文段不能携带数据，但要消耗掉一个序号。这时，TCP客户进程进入SYN-SENT(同步已发送)状态。</li><li>服务器的TCP收到连接请求报文段后，如同意建立连接，则向客户机发回确认，<strong>并为该TCP连接分配缓存和变量</strong>，在确认报文段中，把<strong>SYN位和ACK位都置1</strong>，确认号是ack=x+1,同时也为自己选择一个初始序号seq=y。注意，确认报文段不能携带数据，但也要消耗掉一个序号。这时，TCP服务器进程进入SYN-RCVD(同步收到).状态。</li><li>当客户机收到确认报文段后，还要向服务器给出确认，<strong>并为该TCP连接分配缓存和变量</strong>。确认报文段的ACK位置1，确认号ack=y+l,序号seq=x+1。该报文段<strong>可以携带数据</strong>，若不携带数据则不消耗序号。这时，TCP客户进程进入ESTABLISHED'(已建立连接)状态。</li></ol><p>成功进行以上三步后，就建立了TCP连接，接下来就可以传送应用层数据。TCP提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据。另外，值得注意的是，服务器端的资源是在完成第二次握手时分配的，.而客户端的资源是在完成第三次握手时分配的，这就使得服务器易于受到SYN洪泛攻击。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010903.png" style="zoom: 50%;" /></p><ol start="5" type="1"><li>四次挥手<ol type="1"><li>客户机打算关闭连接时，向其TCP发送连接释放报文段，并停止发送数据，主动关闭TCP连接，该报文段的终止位FN置1，序号sq=u,它等于前面已传送过的数据的最后一个字节的序号加1，FN报文段即使不携带数据，也消耗掉一个序号。这时，TCP客户进程进入FNWAIT-1(终止等待1)状态。TCP是全双工的，即可以想象为一条TCP连接上有两条数据通路，发送FN的-一端不能再发送数据，即关闭了其中一条数据通路，但对方还可以发送数据。</li><li>服务器收到连接释放报文段后即发出确认，确认号ack=u+1,序号seq=v,等于它前面已传送过的数据的最后一个字节的序号加1。然后服务器进入CLOSE-WAIT(关闭等待)状态。此时，<strong>从客户机到服务器这个方向的连接就释放了</strong>，·T℃P连接处于半关闭状态。但服务器若发送数据，客户机仍要接收，即从服务器到客户机这个方向的连接并未关闭。</li><li>若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时，其发出FN=1的连接释放报文段。设该报文段的序号为w(在半关闭状态服务器可能又发送了一些数据)，还须重复上次已发送的确认号ck=u+1。这时服务器进入LAST-ACK(最后确认)状态。</li><li>客户机收到连接释放报文段后，必须发出确认。把确认报文段中的确认位ACK置1,确认号ack=w+1,序号seq=u+1。此时TCP连接还未释放，必须经过时间等待计时器设置的时间2MSL（最长报文段寿命)后，客户机才进入CLOSED(连接关闭)状态。</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010954.png" style="zoom:50%;" /></p><ol start="6" type="1"><li><p>TCP的可靠传输</p><ol type="1"><li>校验</li><li>序号：用来保证数据能够有序提交给应用层</li><li>确认：TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号</li><li>重传<ol type="1"><li>超时重传：计时器设置的重传时间到期但还未收到确认就重传</li><li>冗余ACK：基于上述“确认”，多次收到ACK中同样的序号则认为丢失，进行重传</li></ol></li></ol></li><li><p>TCP流量控制</p><ol type="1"><li>接收方根据自己接收缓存的大小动态调整发送发发送窗口大小，称为接收窗口rwnd</li><li>发送方根据其对当前网络拥塞程度的估计而确定的窗口值称为拥塞窗口cwnd</li><li>A的发送窗口取rwnd和cwnd的最小值</li></ol></li><li><p>TCP拥塞控制</p><ol type="1"><li>流量控制是防止发送的过快导致接收方无法接收；拥塞控制是防止网络链路压力过大。二者都对发送方的发送速率进行控制</li><li>慢开始和拥塞避免<ol type="1"><li>慢开始：连接建立时cwnd为1，此后每收到一个确认cwnd加一直到到达阈值，随后采用拥塞避免算法</li><li>拥塞避免：每经过一个往返时延RTT就把cwnd加一</li><li>网络拥塞的处理：当判断网络出现拥塞（未按时收到确认），把慢开始阈值设置为此时cwnd的一半并置cwnd为1</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625011022.png" style="zoom:50%;" /></p></li><li><p>快重传和快恢复</p><pre><code class="hljs">1. 快重传：当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。    2. 快恢复：当发送方连续收到三个冗余ACK时，把阈值设置为此时cwnd的一半并置cwnd为当前的阈值</code></pre><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625011039.png" style="zoom: 50%;" /></p></li></ol><h2 id="应用层">应用层</h2><h3 id="网络应用模型">网络应用模型</h3><ol type="1"><li>C/S模型</li><li>P2P模型：每个结点都同时具有下载、上传的功能</li></ol><h3 id="域名系统dns">域名系统（DNS）</h3><ol type="1"><li>域名服务器：因特网的域名系统被设计成一个联机分布式的数据库系统，采用C/S模型。每个域名服务器保存一个区内所有主机的域名到IP地址的映射，同时具有连向其他域名服务器的信息。</li><li>域名服务器是分层结构，分为根域名服务器、顶级域名服务器、授权域名服务器、本地域名服务器</li><li>域名解析过程：<ol type="1"><li>递归查询：本地域名服务器向根域名服务器查询一次，后面几次查询都递归的在其他几个域名服务器之间进行。</li><li>迭代查询：<ol type="1"><li>主机向本地域名服务器采用递归查询</li><li>如果查不到，向根域名服务器发起请求，根域名服务器告诉本地域名服务器去哪个顶级域名服务器查询，迭代上述过程直到找到目标服务器</li></ol></li></ol></li></ol><h3 id="文件传输协议ftp">文件传输协议（FTP）</h3><ol type="1"><li>FTP使用两个并行的TCP连接，一个是控制连接（带外传送）一个是数据连接。</li><li>数据连接分为两种：主动模式PORT和被动模式PASV。PORT是服务器连接到客户端的某个端口，PASV是客户端连接到服务器的某个端口。</li></ol><h3 id="电子邮件">电子邮件</h3><ol type="1"><li>发信人调用用户代理来撰写和编辑要发送的邮件。用户代理用SMTP把邮件传送给发送端邮件服务器。</li><li>发送端邮件服务器将邮件放入邮件缓存队列中，等待发送。</li><li>运行在发送端邮件服务器的SMTP客户进程，发现邮件缓存中有待发送的邮件，就向运行在接收端邮件服务器的SMTP服务器进程发起建立TCP连接。</li><li>TCP连接建立后，SMTP客户进程开始向远程SMTP服务器进程发送邮件。当所有待发送邮件发完后，SMTP就关闭所建立的TCP连接。</li><li>运行在接收端邮件服务器中的SMTP服务器进程收到邮件后，将邮件放入收信人的用户邮箱，等待收信人在方便时进行读取。</li><li>收信人打算收信时，调用用户代理，使用POP3(或IMAP)协议将自己的邮件从接收端邮件服务器的用户邮箱中取回（如果邮箱中有来信的话）。</li></ol><h3 id="万维网">万维网</h3><p>用户单击鼠标后所发生的事件按顺序如下（以访问清华大学的网站为例）：</p><ol type="1"><li>浏览器分析链接指向页面的URL(http://www.tsinghua.edu.cn/chn/index.htm)。</li><li>浏览器向DNS请求解析www.tsinghua.edu.cn的IP地址。</li><li>域名系统DNS解析出清华大学服务器的P地址。</li><li>浏览器与该服务器建立TCP连接（默认端口号为80）。</li><li>浏览器发出HTTP请求：GET/chn/index.htm。</li><li>服务器通过HTTP响应把文件index.htm发送给浏览器。</li><li>释放TCP连接。</li><li>浏览器解释文件index.htm,并将Web页显示给用户。</li></ol>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2023/06/22/BJUT/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/06/22/BJUT/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>数据结构复习</p><span id="more"></span><ol type="1"><li><p>数据的逻辑结构：线性结构（栈、队列）、非线性结构（树、图）</p></li><li><p>数据的存储结构：顺序存储、链式存储、索引存储、散列存储</p></li><li><p>满二叉树：就是都满了</p><p>完全二叉树：除了最后一层都满，最后一层从左到右排列</p><p>二叉排序树：左子树的值小于根节点的值，右子树的值大于根节点的值</p><p>平衡二叉树：任意节点左右子树的深度差不大于1</p></li><li><p>二叉树遍历</p><ol type="1"><li>先序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ol></li><li><p>树的遍历</p><ol type="1"><li>先根遍历：先访问根节点，再依次遍历每棵子树</li><li>后根遍历：先依次遍历每棵子树，再访问根节点</li></ol></li><li><p>在无向图中若任意两个顶点是联通的则称为连通图；在有向图中若任意两个顶点双向可达则称为强连接图</p></li><li><p>最小生成树</p><ol type="1"><li><p>Prim算法<span class="math inline">\(O(n^2)\)</span></p><p>初始时从图中任取一个点加入T集合，之后每次选择一个与集合T距离最近的顶点加入</p><p><img src="C:\Users\chenl\AppData\Roaming\Typora\typora-user-images\image-20230622205421669.png" alt="image-20230622205421669" style="zoom:67%;" /></p></li><li><p>Kruskal算法<span class="math inline">\(O(n^2)\)</span></p><p>将边按权值排序，不断选择权值最小的边，使用并查集判断如果边的两个端点ab已经在一类中了则跳过，否则加入</p><p><img src="C:\Users\chenl\AppData\Roaming\Typora\typora-user-images\image-20230622205745004.png" alt="image-20230622205745004" style="zoom: 67%;" /></p></li></ol></li><li><p>最短路径</p><ol type="1"><li><p>Dijkstra单源最短路<span class="math inline">\(O(n^2)\)</span></p><p>初始时把源点放入S，寻找距离原点最近的顶点并入，然后更新原点到所有点的距离，重复上述过程直到到达目标点</p></li><li><p>Floyd多源最短路<span class="math inline">\(O(n^3)\)</span></p><p>基于动态规划，初始时对于任意两个点，如果他们之间存在边则边权值作为最短路径，若不存在则置无穷。之后每次尝试加入一个顶点k，看看每两个点之间增加k后得到的距离是否更短，若更短则进行更新。</p></li></ol></li><li><p>二叉排序树的删除：</p><ol type="1"><li>叶子节点直接删</li><li>只有一个子树直接替代</li><li>左右子树都有，找右子树中序遍历第一个结点替代（即右子树中的最小值）</li></ol></li><li><p>平衡二叉树（AVL）：在二叉排序树基础上规定任意顶点左右子树高度差不超过1.插删如果破坏了平衡则对最近不平衡结点进行旋转</p></li><li><p>排序算法</p><ol type="1"><li>直接插入排序<spanclass="math inline">\(O(n^2)\)</span>：遍历数组，对于某个值，遍历他前面的有序序列找到插入的地方并插入</li><li>折半插入排序<spanclass="math inline">\(O(n^2)\)</span>：在上述基础上用二分法找插入位置<spanclass="math inline">\(O(n(logn+n))\)</span></li><li>冒泡排序<spanclass="math inline">\(O(n^2)\)</span>：遍历两边，若逆序则调整顺序</li><li>快排<span class="math inline">\(O(nlogn)\)</span>：最坏<spanclass="math inline">\(O(n^2)\)</span>，最好<spanclass="math inline">\(O(nlogn)\)</span>，是平均性能最优的算法</li><li>选择排序<spanclass="math inline">\(O(n^2)\)</span>：每次在后面序列中选一个最大的和前面的交换</li><li>堆排序<span class="math inline">\(O(nlogn)\)</span></li><li>归并排序<spanclass="math inline">\(O(nlogn)\)</span>：将序列不断二分直到只有一个或两个元素，然后进行排序，然后再原路合并回去，合并时采用双指针遍历一遍存入新数组即可，需要O(n)的空间</li><li>桶排序：划分多个范围相同的区间，每个子区间内部进行排序，然后再合并</li><li>基数排序$O(d(n+r))：d代表分配回收的趟数，n代表长度，r代表基数</li></ol></li></ol><p><img src="C:\Users\chenl\AppData\Roaming\Typora\typora-user-images\image-20230622221713048.png" alt="image-20230622221713048" style="zoom:67%;" /></p><ol start="12" type="1"><li><p>外部排序</p><p>主要思路为减少访存次数.常用归并排序.将外存上的文件划分为若干长度为l的子文件,依次读入内存使用内部排序算法进行排序并写回外存.随后逐渐进行归并操作.</p></li><li><p>查找算法</p><ol type="1"><li><p>顺序查找</p></li><li><p>二分查找</p></li><li><p>插值查找：<span class="math inline">\(mid = low + \frac{(key -a[low])*(high-low)}{a[high]-a[low]}\)</span>,时间复杂度O(lglgn)</p></li><li><p>二叉排序树</p></li><li><p>平衡二叉树</p></li><li><p>红黑树：平衡二叉树调整太多了，红黑树稍微放宽了限制</p></li><li><p>B树:除根节点的非叶节至少有m/2上取整棵子树，最多有m棵子树</p></li><li><p>B+树：叶节点包含了全部关键字，非叶节点的关键字也会出现在叶结点中，叶子节点按大小顺序链接起来</p><p>B+树有两种查找运算：一种从最小关键词开始查找，一种从根节点开始查找，查找到最底层cai'jie'shu</p></li><li><p>散列表</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件工程导论</title>
    <link href="/2023/06/07/BJUT/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/07/BJUT/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>软件工程导论期末复习 <span id="more"></span></p><h2 id="第一章-概述">第一章 概述</h2><ol type="1"><li><p>软件定义</p><ol type="1"><li>软件是计算机系统中与硬件相互依存的另一部分，它是包括<strong>程序</strong>，<strong>数据</strong>及其<strong>相关文档</strong>的完整集</li><li>一种具有<核心功能>，能够实现<目标>的<事物></li></ol></li><li><p>软件分类</p><p>系统软件、应用软件、支撑软件、可复用软件(标准函数库)</p></li><li><p>软件工程定义</p><ol type="1"><li>建立并使用完善的工程化原则 ,以较经济的手段获得能在实际机器上有效运行的可靠软件的一系列方法</li><li>软件工程是开发，运行 , 维护和修复软件的系统方法</li><li>"软件工程是：①把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程，也就是把工程应用于软件；②研究①中提到的途径。</li></ol></li><li><p>软件工程三个要素</p><p>过程、方法、工具</p></li></ol><h2 id="第二章-软件生存期模型">第二章 软件生存期模型</h2><h3 id="软件生存期">软件生存期</h3><ol type="1"><li><p>软件生存期由<strong>软件定义</strong>、<strong>软件开发</strong>和<strong>运行维护</strong>三个时期组成，每个时期会包含一系列活动（Activity）和任务（Task）</p><ol type="1"><li><p><strong>活动</strong>：实现某个目的而采取的步骤或执行的责任。可行性分析，软件需求分析，软件体系结构设计等</p></li><li><p><strong>任务</strong>：构成活动的基本元素，一项活动往往有若干任务构成。软件需求分析包含需求抽取，需求分析，需求撰写，需求</p><p>验证等</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607173237.png" style="zoom: 67%;" /></p></li></ol><h3 id="软件过程模型">软件过程模型</h3><h4 id="瀑布模型">瀑布模型</h4><ol type="1"><li><p>介绍</p><ol type="1"><li><p>各项活动按自上而下，相互衔接的固定次序，如同瀑布逐级下落</p></li><li><p>每个阶段必须完成规定的文档；每个阶段结束前完成文档审查</p></li><li><p>阶段间具有顺序性和依赖性</p></li><li><p>质量保证与推迟实现的观点</p></li></ol></li><li><p>优缺点</p><ol type="1"><li>强迫进行规范化、每个阶段都有文档、每个阶段都验证过</li><li>很有可能没法一遍过，不能真正满足用户需求（到后面阶段了发现前面设计的有问题)，不适用于大型软件开发</li></ol></li></ol><h4 id="快速原型模型">快速原型模型</h4><ol type="1"><li><p>介绍</p><p>先开发一个‘原型’软件，完成部分主要功能，展示给用户并征求意见，然后逐步完善，最终获得满意的软件产品</p></li><li><p>分类</p><p>抛弃式原型：为了引出需求方便客户看，之后抛弃</p><p>进化式原型：在这个基础上继续做出成品</p></li><li><p>优缺点</p><ol type="1"><li><p>有助于满足用户的真实需求；</p><p>开发过程的后续阶段不会因为发现规格说明文档的错误而进行较大的返工</p></li><li><p>（进化式原型）系统结构较差</p><p>给用户造成项目已经（接近）完成的错觉</p></li></ol></li></ol><h4 id="增量模型">增量模型</h4><ol type="1"><li><p>介绍</p><p>增量模型把软件产品分解成一系列的增量构件，在增量开发迭代中逐步加入</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607182914.png" style="zoom:67%;" /></p></li><li><p>优缺点</p><ol type="1"><li><p>能在较短时间内向用户提交可完成一些有用的工作产品</p><p>项目失败的风险较低</p><p>最重要的系统服务将接受最多的测试</p></li><li><p>增量构件的划分比较困难</p><p>难以将客户的需求映射到适当规模的增量上</p></li></ol></li></ol><h4 id="螺旋模型">螺旋模型</h4><ol type="1"><li><p>介绍</p><p>将瀑布模型与快速原型模型结合起来，并且加入两种模型均忽略了的<strong>风险分析</strong></p><p>包含四个阶段：制定计划；<strong>风险分析</strong>；开发与验证（实施工程）；评审（评价开发工作）</p></li><li><p>优缺点</p><ol type="1"><li><p>对可选方案和约束条件的强调，有利构件的重用和软件质量的提升</p><p>通过风险分析，最大程度地降低软件彻底失败的可能性</p></li><li><p>螺旋模型是风险驱动的，对软件开发人员要求高，必须具有丰富的风险评估经验和专门知识</p><p>通常只适用大型软件，过大的风险管理支出会影响客户的最终收益</p></li></ol></li></ol><h4 id="统一过程模型">统一过程模型</h4><ol type="1"><li><p>介绍</p><p>包含四个过程阶段和六个核心过程流</p><p>四个阶段：初始阶段、细化阶段、构造阶段、移交阶段</p><p>六个工作流：业务建模工作流、需求工作流、分析和设计工作流、实现工作流、测试工作流、部署工作流</p></li></ol><h2 id="第三章-软件需求工程">第三章 软件需求工程</h2><h3 id="需求分类">需求分类</h3><p>用户需求和软件需求</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607190026.png" style="zoom:67%;" /></p><h3 id="软件需求工程">软件需求工程</h3><p>需求工程通过工程化的过程，方法和工具实现软件需求的获取、分析、文档化、确认和管理。</p><p>前四个是需求开发，最后一个是需求管理</p><h4 id="需求开发">需求开发</h4><ol type="1"><li><p>需求获取</p><p>分析任务：获取系统干系人的原始需求，建立对待开发软件所要解决问题的初步理解，收集软件开发所需的领域知识</p><p>确定需求来源：系统干系人、现有文档、现有系统</p><p><strong>需求获取方法</strong></p><p>​ • 访谈：访谈后使用扎根理论（GroundedTheory）等方法对访谈结果进行<strong>定性</strong>分析</p><p>​ • 专题小组</p><p>​ •问卷调查：所收集数据用于<strong>定量</strong>分析，具有统计学意义</p><p>​ •民族志研究：彻底置身于研究对象的文化和日常生活中，以观察者的身份获取领域知识和用户需求</p><p>​ • 系统原型</p><p>​ • 文档学习</p><p>​ • 同类系统调研</p><p>​ • 用户评论挖掘</p></li><li><p>需求分析</p><ol type="1"><li>问题框架分析</li><li>目标建模分析</li><li>结构化分析：<strong>数据流图</strong>、实体关系图、状态转换图、数据字典等</li><li>面向对象分析：<strong>用例图</strong>、<strong>类图</strong>、时序图、协作图、状态图等</li></ol></li><li><p>文档化</p><p>需求规格说明：精确地阐述一个软件系统必须提供的功能和性能以及它所要考虑的限制条件</p><ol type="1"><li>只描述“做什么”而无须描述“怎么做”</li><li>确保需求是可验证的</li></ol></li><li><p>需求确认</p><ol type="1"><li>需求评审：针对<strong>需求文档</strong>的评审活动</li><li>需求原型：通过动画、界面原型等方式向利益相关者展示开发团队当前对于系统软件需求的理解，从而获取反馈</li></ol></li></ol><h4 id="需求管理">需求管理</h4><p>需求管理贯穿上述四个过程</p><ol type="1"><li><p><strong>需求跟踪管理</strong>：维护需求文档与前继和后续工作成果之间的对应关系，确保产品满足用户需求</p><p>向前追踪、向后追踪</p><p>辅助理解，变更管理，软件复用，项目管理</p></li><li><p><strong>需求优先级管理</strong>：保证重要的需求优先被实现</p><p>优先级分类（KANO）：基本需求、期望需求、兴奋性需求</p></li><li><p><strong>需求变更控制</strong>：对依据规范处理需求变更，防止需求变更失去控制而导致项目混乱</p><p>基本流程：分析评估、变更决策、变更实施、变更发布</p></li></ol><h2 id="第四章-结构化分析方法">第四章 结构化分析方法</h2><h3 id="介绍">介绍</h3><ol type="1"><li><p>定义</p><p>针对用户需求建立抽象的分析模型</p></li><li><p>核心思想</p><p>自顶向下，逐步求精</p></li></ol><h3 id="功能建模">功能建模</h3><h4 id="数据流图">数据流图</h4><ol type="1"><li><p>定义</p><p>从数据传递和加工的角度，以图形的方式刻画数据流从输入到输出的移动变换过程</p></li><li><p>组成</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607192455.png" style="zoom: 67%;" /></p><ol start="3" type="1"><li><p>分层</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607192705.png" style="zoom: 67%;" /></p></li><li><p>例题</p></li></ol><p>​ PPT4 13~14面</p><h3 id="数据建模">数据建模</h3><h4 id="实体关系图">实体关系图</h4><ol type="1"><li>组成</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607193003.png" style="zoom:67%;" /></p><ol start="2" type="1"><li><p>关系类型</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607193927.png" style="zoom:67%;" /></p></li><li><p>例题</p><p>PPT4 p18</p></li></ol><h3 id="行为建模">行为建模</h3><h4 id="状态转换图">状态转换图</h4><ol type="1"><li><p>组成</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607194146.png" /></p></li></ol><h3 id="数据字典">数据字典</h3><ol type="1"><li><p>定义</p><p>对于分析模型中出现的所有数据对象给出准确的定义,三种分析模型的“粘合剂”</p></li><li><p>数据结构定义式</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607194547.png" style="zoom:67%;" /></p></li><li><p>例题</p><p>PPT4 p25~p27</p></li></ol><h2 id="第五章-软件设计">第五章 软件设计</h2><h3 id="软件设计任务和过程">软件设计任务和过程</h3><ol type="1"><li><p>软件设计的目标</p><ol type="1"><li><p>满足所有分析模型中涵盖的需求</p></li><li><p>从实现的角度展示软件在数据、功能、行为等方面的全景图</p></li><li><p>具有可读性，能够被软件开发人员准确地理解性</p></li></ol></li><li><p>软件设计的阶段</p><ol type="1"><li>从工程管理角度: 概要设计阶段和详细设计阶段</li><li>从设计目标维度: 体系结构设计、数据设计、接口设计和过程设计</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607195829.png" style="zoom:67%;" /></p></li><li><p>软件设计的任务</p><ol type="1"><li>体系结构设计: 定义软件系统的各主要成份以及它们之间的关系</li><li>数据设计: 确定数据的组织、彼此的关联、存取方式以及处理方法</li><li>接口设计：在用户和目标系统之间（界面设计）、目标系统内部各模块间（内部接口）、目标系统和其他系统之间（外部接口）构建有效地交流媒介</li><li>过程设计：描述各模块的实现算法</li></ol></li></ol><h3 id="软件设计原则">软件设计原则</h3><ol type="1"><li><p>分而治之</p><ol type="1"><li><p>解决大型复杂问题时通常采用的策略</p></li><li><p>不是越小越好</p></li></ol></li><li><p>模块独立性</p><ol type="1"><li><p>软件系统中每个模块只涉及软件要求的具体的子功能，而和软件系统中其他的模块的接口是简单的</p></li><li><p>独立性比较强的模块应是<strong>高内聚</strong>，<strong>低耦合</strong>的模块</p></li><li><p>两个准则:</p><ol type="1"><li><p>耦合性</p><p>模块之间耦合性越强，功能独立性越差，这样形成的模块结构界面不好</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607200555.png" style="zoom: 80%;" /></p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607200405.png" style="zoom: 67%;" /></p><ol start="2" type="1"><li><p>内聚性</p><p>模块内聚性越强，功能独立性越好，对于形成的模块结构有比较好的作用</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607202734.png" style="zoom:67%;" /></p></li><li><p>信息隐藏: 与正确使用无关的细节信息都应当被隐藏</p></li><li><p>复用性设计: 将复用的思想用于软件开发，称为软件复用</p></li><li><p>灵活性设计:保证软件灵活性设计的关键是<strong>抽象</strong></p></li></ol></li></ol></li></ol><h3 id="软件体系结构">软件体系结构</h3><ol type="1"><li><p>定义</p><p>系统在某种环境下的一组最基本的概念和属性，包括了元素、关系以及设计和演化的原则</p></li><li><p>分类</p><ol type="1"><li>管道和过滤器</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607201341.png" style="zoom: 67%;" /></p><ol start="2" type="1"><li>主程序-子进程体系结构</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607201413.png" style="zoom: 67%;" /></p><ol start="3" type="1"><li>分层体系结构</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607201821.png" style="zoom:67%;" /></p><ol start="4" type="1"><li>客户机/服务器体系结构<ol type="1"><li>瘦客户机模型:所有的应用处理和数据管理都在服务器上执行，客户机只负责表示部分</li><li>胖客户机模型:服务只负责对数据的管理，客户机实现应用逻辑和与用户的交互</li></ol></li></ol><p>### 用户界面设计</p></li><li><p>基于分层框架的设计方法</p><p>逐层进行设计，每一个层关注界面设计的一个特定方面</p></li></ol><p>​ 功能层、架构层、导航层、形式层、细节层</p><ol start="2" type="1"><li><p>界面布局模式</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607202301.png" /></p></li></ol><h2 id="第六章-面向对象方法概述">第六章 面向对象方法概述</h2><h3 id="面向对象">面向对象</h3><ol type="1"><li><p>对象</p><p>系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位，由一组<strong>属性</strong>和对这组属性进行操作的一组<strong>服务</strong>组成</p></li><li><p>类图</p><ol type="1"><li><p>概念类图</p><p>描述<strong>现实世界</strong>的实体与概念，重点反映现实世界问题域，与具体实现技术无关</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607203650.png" style="zoom: 50%;" /></p></li><li><p>分析类图</p><p>与系统实现相关的对象的抽象，由系统设计师绘制，其作用是描述系统的架构结构、指导程序员编码(实体类，边界类，控制类)</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607203712.png" style="zoom: 50%;" /></p></li><li><p>实现类图</p><p>真正考虑程序实现，揭示<strong>软件开发细节</strong></p></li></ol></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607203759.png" style="zoom:50%;" /></p><h3 id="uml">UML</h3><ol type="1"><li>特点<ol type="1"><li>统一标准</li><li>面向对象</li><li>可视化,表达能力强</li><li>独立于过程: UML是系统建模的语言，不依赖特定的开发过程</li><li>容易掌握使用</li><li>与编程语言紧密关联: 可以根据 UML所建立的系统模型自动产生Java、C++等代码框架</li></ol></li></ol><h2 id="第八章-软件构建">第八章 软件构建</h2><ol type="1"><li><p>交互方式</p><p>命令式编程: 做什么,怎么做</p><p>声明式编程:做什么,机器决定怎么做(如数据库查询语言,正则表达式等)</p></li><li><p>逻辑组织</p><p>• 结构化编程</p><p>• 面向对象编程</p><p>• 函数式编程: 结果唯一取决于输入参数</p><p>• 逻辑编程: 事实+规则=结果</p></li></ol><h2 id="第九章-软件测试">第九章 软件测试</h2><p>软件测试是使用人工和自动手段来运行或检测某个系统的过程，其目的在于检验系统是否满足规定的需求并找出与预期结果之间的差别.</p><h3 id="软件测试阶段">软件测试阶段</h3><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607205503.png" style="zoom:67%;" /></p><h4 id="单元测试">单元测试</h4><ol type="1"><li>测试模块接口保证被测程序单元的信息能够正常地流入和流出</li><li>走遍控制结构中的所有独立路径（基本路径）以确保模块中的所有语句至少执行一次</li><li>对所有的错误处理进行测试</li></ol><h4 id="集成测试">集成测试</h4><ol type="1"><li><p><strong>大爆炸集成测试</strong>指在软件开发过程中，先编写各个模块的代码，然后将这些代码一次性地集成到整个系统中进行测试的方法。这种方法的优点是适用于紧急项目和初步设计差异不大的项目，但缺点是容易发现问题，难以定位问题。</p></li><li><p><strong>自顶向下集成测试</strong>指从软件系统的最高层开始，逐步添加和测试下层的模块或组件，直到整个系统被完整集成并测试的方法。这种方法的优点是能够更早地发现整体性问题，但缺点是对底层模块进行测试时需要模拟上层模块的行为。</p></li><li><p><strong>自底向上集成测试</strong>指从底层的模块或组件开始，逐步添加和测试上层的模块或组件，直到整个系统被完整集成并测试的方法。这种方法的优点是对底层模块进行测试比较彻底，但缺点是对于整体性问题可能会晚于自顶向下集成测试发现。</p></li></ol><h4 id="系统测试">系统测试</h4><p>基于软件需求说明书的黑盒测试</p><p>分类: 功能测试, 性能测试(负载测试,压力测试)</p><h4 id="验收测试">验收测试</h4><p>确保软件准备就绪，让最终用户将其用于执行软件的既定功能和任务，测试其需求是否被满足</p><ol type="1"><li>α测试：由一个用户在受控环境下进行的测试</li><li>β测试：由软件的多个用户在实际使用环境下进行的测试</li></ol><h4 id="回归测试">回归测试</h4><p>错误被修正后或软件功能、环境发生变化后进行的重新测试</p><h3 id="主要软件测试技术">主要软件测试技术</h3><h4 id="白盒测试">白盒测试</h4><h5 id="基本路径测试法">基本路径测试法</h5><ol type="1"><li><p>语句覆盖</p><p>使得每个可执行<strong>语句</strong>至少要执行一次</p></li><li><p>判定覆盖(分支覆盖)</p><p>使得程序中每个判断的<strong>取真分支</strong>和<strong>取假分支</strong>至少经历一次</p></li><li><p>条件覆盖</p></li></ol><p>​使得程序中每个判断的每个<strong>条件</strong>的可能取值至少执行一次</p><ol start="4" type="1"><li><p>判定/条件覆盖</p><p>同时满足判定覆盖和条件覆盖的要求</p></li><li><p>条件组合覆盖</p><p>求出判定中所有条件的各种可能组合值</p></li></ol><h5 id="程序控制流图">程序控制流图</h5><p>​ 例题: PPT9 P60</p><h4 id="黑盒测试">黑盒测试</h4><h5 id="等价类划分法">等价类划分法</h5><ol type="1"><li><p>定义</p><p>等价类是某个输入域的子集，在该子集中每个输入数据的作用是等效的</p></li><li><p>分类</p><ol type="1"><li>有效等价类: 可以检查程序是否实现了规格说明中所规定的功能和性能</li><li>无效等价类: 用于检查程序能否妥善处理异常输入数据</li></ol></li><li><p>例题</p><p>PPT9 P78</p></li></ol><h5 id="边界值分析法">边界值分析法</h5><p>确定边界情况(输入或输出等价类的边界).选取正好等于、刚刚大于或刚刚小于边界值作为测试数</p><h4 id="静态测试">静态测试</h4><p>不通过执行被测软件而进行测试的技术</p><h4 id="组合测试">组合测试</h4><p>对部分参数的所有取值组合进行验证，即可有效地发现软件的缺陷——降低测试复杂度</p><p>被测试软件能够抽象为一个受到多个因素（参数）影响的系统，且该因素应当是离散且有限的</p>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式操作系统</title>
    <link href="/2023/05/27/BJUT/%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/05/27/BJUT/%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>分布式操作系统期末复习 <span id="more"></span></p><h3 id="名词">名词</h3><ol type="1"><li>autonomous 自治的，自己管理自己</li><li>Concurrency 并发</li><li>Coordination 协调</li><li>Transparency 透明</li><li>Trade-off 权衡</li><li>latency 延迟</li><li>Homogeneous 同构</li><li>Heterogeneous 异构</li><li>Tightly-coupled 紧耦合</li><li>Paradigm 范式</li><li>Tiered Architecture 分层架构</li><li>synchronous 同步</li><li>asynchronous 异步</li><li>Transient Communication 暂时通信</li><li>Persistent Communication 持久通信</li><li>router 路由</li><li>relay 中继</li><li>Primitives 原语</li><li>Message Brokers 消息代理</li><li>Decoupling 解耦</li><li>Processor allocation 处理器分配</li><li>Deterministic Algorithm 确定性算法</li><li>Heuristic Algorithm 启发式算法</li><li>replica 副本</li><li>Mounting 挂载</li><li>recursive name resolution 递归名称解析</li><li>clock skew 时钟偏移</li><li>concurrent 并发</li><li>Mutual Exclusion 互斥</li><li>critical region 临界区</li><li>Transaction 事务</li><li>cascaded aborts 级联终止</li></ol><h3 id="第一章">第一章</h3><ol type="1"><li><p>分布式操作系统定义</p><p>分布式系统是独立计算机的集合，在其用户看来是一个单一的连贯系统。</p><p>由位于<strong>联网</strong>计算机上的<strong>硬件或软件</strong>组件组成的任何系统，这些组件通过<strong>消息传递</strong>来通信和协调它们的操作。</p></li><li><p>特性</p><ol type="1"><li>Hidden ：Hide the difference and the communication among all kindsof computers</li><li>Consistent and Uniform<br /></li><li>Scalability：伸缩性，即使坏了一部分整个系统也不会瘫痪（允许某些功能不可用了）</li><li>Concurrency ：Coordination among different concurrently executingprograms that share resource</li><li>No Global Clock ：</li></ol></li><li><p>目标</p><ol type="1"><li><p>Making Resources Accessible</p></li><li><p>Distribution Transparency 看起来只有一个电脑</p></li><li><p>Openness</p><p>Mechanism : (How to do it)It need cache</p><p>Policy : (What will be done)Size? • Consistency? • Always or only onesession? • Can user control?</p></li><li><p>Scalability</p></li></ol></li></ol><h3 id="第二章-communication">第二章 Communication</h3><ol type="1"><li><p>UDP offers no guarantee of delivery 不可靠的传输 No setup costs不需要建立连接，额外花销小</p></li><li><p>RPC(Remote Procedure Call)</p><p>Problems:</p><ol type="1"><li>Call by Value：异构的计算机对于相同的字符串的解读不同</li><li>Call by Reference：<ol type="1"><li>For array: copy/restore把整个数组发过去，搞完之后再发回本机修改</li><li>For ordinary pointer 接收机器拿着指针回来找</li></ol></li><li>How to Create Stub：Interface Definition Language(IDL)使用统一接口</li></ol></li><li><p>RMI（Remote Method Invocation）</p><p>Client:Proxy</p><p>Server:Skleton</p><p>RMI and RPC are same theoretically.</p></li><li><p>同步通信收发都是堵塞的，异步通信发是非堵塞的收都可以</p></li><li><p>Transient communication:A message is not stored in communicationsystem 瞬时通信不存储信息</p><ol type="1"><li>Sockets Interface<ol type="1"><li>TCP/UDP</li><li>IP Multicast: IP multicast is available only via UDP</li></ol></li><li>MPI(Message Passing Interface standard)</li></ol></li><li><p>Persistent Communication:A message is stored in communicationsystem until it is sent to receiver 持久通信</p><ol type="1"><li>Message Queue Model 保证一定送达但是不保证时间长短<ol type="1"><li>router：进行接收转发</li><li>relay：接收之后进行处理 Relay can build a scalable message-queuingsystem</li><li>Application of Message Queue System<ol type="1"><li>Asynchronization 异步</li><li>Decoupling of application 解耦</li><li>Flow Cutting 流切割</li></ol></li></ol></li></ol></li><li><p>Stream Oriented Communication</p><ol type="1"><li><p>Continuous representation media: Temporal relationship betweendata items is IMPORTANT to explain the meaning of data.</p></li><li><p>Discrete representation media: Temporal relationship between dataitems is NOT IMPORTANT to explain the meaning of data</p></li><li><p>Transmission types</p><ol type="1"><li><p>Asynchronous transmission mode</p><p>Data items are transmitted one by one. No time restriction ontransmission.</p></li><li><p>Synchronous transmission mode</p><p>Every data item has a maximum end-to-end delay defined for each unitin a data stream.</p></li><li><p>Isochronous transmission mode</p><p>Data item must be transmitted on time.</p></li></ol></li><li><p>Interleaving frames 交错帧，减小数据包丢失的影响</p></li><li><p>QoSNegotiation是一种网络协议，用于协商和确定网络中各种流量的优先级、带宽、延迟等服务质量参数。</p></li></ol></li></ol><h3 id="第三章">第三章</h3><ol type="1"><li><p>Server Classification</p><ol type="1"><li>Iterative Server：Server is responsible for dealing with request andreturn the result to client</li><li>Concurrent Server：Server doesn’t deal with request from client. Itsends the request to a thread or a process,then wait for nextrequest</li></ol></li><li><p><strong>Out-of-band</strong> data ： data that is to be processedby the server before any other data from thatclient.优先级很高，需要及时处理</p></li><li><p>Stateless Server：Don’t save any information about client</p><p>Server with state：Maintain information about client</p></li><li><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230606232439.png" style="zoom:50%;" /></p></li><li><p>Code Migration</p><ol type="1"><li><p>Process migration ：An entire process was moved from one machineto another.</p><ol type="1"><li><p>Weak Mobility: Only migrate code segment and some initializationdata</p></li><li><p>Strong Mobility: Migrate the code segment and the executingsegment</p></li></ol></li><li><p>Resource Migration:</p><ol type="1"><li>Process-Resource Binding: ID,Value,Type</li><li>Resource-Machine Binding: Unattached Resource,FastenedResource,Fixed Resource</li></ol></li></ol></li><li><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607005703.png" style="zoom:50%;" /></p></li><li><p>Processor Allocation Algorithm</p><ol type="1"><li>Deterministic Algorithm：Know all information about allprocesses</li><li>Heuristic Algorithm：The load of a system is unpredictable.</li></ol></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607010738.png" style="zoom:50%;" /></p><h3 id="第四章">第四章</h3><ol type="1"><li>Flat Naming</li><li>Struct Naming<ol type="1"><li>Iterative NameResolution:迭代名称解析：每一层都给服务器发，然后服务器返回下一层地址</li><li>Recursive NameResolution：递归名称解析：主机只发一次，服务器之间进行通讯完成工作</li></ol></li><li>Attribute-Based Naming：To describe an entity in terms of(attribute,value) pairs</li></ol><h3 id="第五章">第五章</h3><ol type="1"><li><p>物理时钟</p><ol type="1"><li>Cristian Algorithm<ol type="1"><li>如果有一个有WWV接收器的机器，其他机器都可以向这个机器请求时间</li><li>Time is not allowed to runbackward.如果一个机器的时间在同步时钟之后，时间回溯是不被允许的</li></ol></li><li>Berkeley Algorithm<ol type="1"><li>Time server polls the time of every machine</li><li>Average the results and tell the time to other machine</li></ol></li><li>Averaging Algorithm<ol type="1"><li>Every machine broadcast its time to others in every timeinterval</li><li>After broadcasting,machine collect time response from other machinesin an interval S</li><li>Average all the time values，Discard m highest and m lowest</li><li>Try to add an estimated time delay to correct the time</li></ol></li><li>应用: Network Time Protoc ol (NTP)</li></ol></li><li><p>逻辑时钟</p><ol type="1"><li><p>为什么不用物理时钟</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607101629.png" style="zoom: 50%;" /></p></li><li><p>Lamport’s Logical Clocks</p><pre><code class="hljs">1. If a and b are two events in a **same process**,and a happens before b,then a→b is true    2. If a is a **sending** event of a message in a process,b is receiving event of this message in another process,then a→b is true    3. If a→b is not true,b→ a is not true,a and b is concurrent 并发</code></pre><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607104453.png" style="zoom:50%;" /></p></li></ol></li><li><p>Vector Clocks</p></li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607104716.png" style="zoom:50%;" /></p><ol start="4" type="1"><li><p>Election Algorithm</p><ol type="1"><li>Bully Algorithm</li></ol><p>进程P发现协调员(coordinator)无法工作，发起一个选举，给所有比自己PID大的进程Q发消息，要是应答了则P放弃，Q继续上述过程，直到只剩一个，成为新的协调员</p><ol start="2" type="1"><li><p>Ring Algorithm</p><p>逻辑上的环，每个进程知道自己的后继进程。转一圈之后选PID最大的当新协调员。</p></li></ol></li><li><p>Mutual Exclusion</p><ol type="1"><li><p>Centralized Algorithm</p><p>P是协调者，Q想进去要问P，能进就可以，不能进Q就进等待队列。里面的进程出来之后授权队列头进程</p></li><li><p>Distributed Algorithm</p><p>P想进去，发请求给所有进程Q，要是Q不想进去就发ok回来，要是Q就在里面就不回应，要是Q也想进去就比较时间戳，要是比自己早就回ok</p></li><li><p>Token Ring Algorithm</p><p>一个令牌在环里绕，拿到令牌的可以进去。</p><p>这个算法不是一个fair algorithm，前面俩都是fair algorithm</p></li></ol></li><li><p>Distributed Transaction</p><p>A transaction can • Protect shared resource from concurrent accesses• Permit a process read and write several data items as if it is readand written by a single atomic operation</p><ol type="1"><li><p>Characteristics</p><ol type="1"><li><p>Atomic • A transaction cannot be separated.</p></li><li><p>Consistent • A transaction cannot spoil the consistent item ofsystem.</p></li><li><p>Isolated • Concurrent transaction cannot affect eachother.</p></li><li><p>Durable • Once a transaction is committed,the change will bepermanent.</p></li><li><p>RollBack</p></li><li><p>Private Workspace: Give a private workspace to a transaction whenit begins</p><p>All data are read and written in the private workspace until thetransaction is committed or failed</p></li></ol></li><li><p>Writeahead Log</p><ol type="1"><li><p>Before a file is updated,a record is written in a log</p></li><li><p>Only after write the log successfully,the change can be committedto the file</p><ol start="2" type="1"><li>Serial Equivalence</li></ol></li></ol></li><li><p>Several transactions can be executed at the same time but thefinal result is the same as the situation that all transactions areexecuted one by one</p></li><li><p>Two Concurrent Control Methods</p><ol type="1"><li><p>Pessimistic approaches 不允许可能出现的问题</p><p>Timestamp Ordering</p><ol type="1"><li>A transaction’s request to <strong>write</strong> an object is validonly if that object was last read and written by earliertransactions</li><li>A transaction’s request to <strong>read</strong> an object is validonly if that object was last written by earlier transactions</li></ol><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230607153228.png" style="zoom:50%;" /></p></li><li><p>Optimistic approaches 可以有问题，回滚就行了</p></li></ol></li></ol></li></ol><h3 id="第六章">第六章</h3><ol type="1"><li><p>Replication 副本</p><ol type="1"><li><p>为什么需要副本</p><p>• Reliability</p><p>• Performance</p><p>• Fault tolerance</p></li><li><p>CAP</p><ol type="1"><li>Partition Tolerance 分区容错性<ol type="1"><li>Every subnetwork is called a partition</li><li>The system still work when communication fail</li></ol></li><li>Consistency 一致性<ol type="1"><li>All replica in the system should be consist</li></ol></li><li>Availability 可用性<ol type="1"><li>All nodes in the system can be used when user need it</li></ol></li><li>上述三个不能bingcun<ol type="1"><li>如果想有P，那肯定得有预留的副本，那么一致性和全可用性就不可能实现</li><li>如果想有CA,那P肯定不能实现</li></ol></li></ol></li><li><p>一致性</p><ol type="1"><li>Strict Consistency<ol type="1"><li>Any read operation on data item x can return back the result of lastwrite on x.</li><li>Depend on absolute global time</li></ol></li><li>Sequential Consistency<ol type="1"><li>The result of all process’s read and write operation are the same asif they are executed according to a specific order.</li><li>一个进程内部执行顺序一致就行，俩进程谁先谁后无所谓？</li></ol></li><li>Linearizability<ol type="1"><li>every operation has a timestamp,and satisfies followingcondition</li><li>时间在前的先发生</li></ol></li><li>Causal Consistency<ol type="1"><li>Writes that are potentially causally related must be seen by allprocesses in the same order.</li><li>得分析前面的潜在因果关系，要是俩写操作判断不出来谁前谁后，那读的时候谁前谁后都可以</li></ol></li></ol></li><li><p>修改的传播方法</p><ol type="1"><li><p>Only propagate a notification of an update</p><p>告诉别人我已经改了，别再用那个旧的了</p></li><li><p>Transfer data from one copy to another</p><p>把改了的数据发给别人</p></li><li><p>Propagate the update to other copies</p><p>告诉别人我怎么改的</p></li></ol></li><li><p>传染病模型</p><ol type="1"><li><p>传统的方法是P一个人告诉其他所有人更新消息，传染病模型是P告诉Q之后，PQ一起告诉别人</p></li><li><p>Anti-Entropy Model 反熵模型</p><p>A server P select another server Q randomly and exchangeupdates</p></li><li><p>Gossiping Model 八卦模型</p><p>P拿到更新之后随机再告诉别人要更新</p></li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高数下串讲</title>
    <link href="/2023/05/17/BJUT/%E9%AB%98%E6%95%B0%E4%B8%8B%E4%B8%B2%E8%AE%B2/"/>
    <url>/2023/05/17/BJUT/%E9%AB%98%E6%95%B0%E4%B8%8B%E4%B8%B2%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>朋辈讲师高数下串讲 <span id="more"></span></p><h3 id="多元函数微分">多元函数微分</h3><ol type="1"><li>偏导定义</li><li>判断是否可微 P161</li><li>判断偏导是否连续 P161，P165例1.11.2</li><li>复合函数求偏导 P166 例1.11.3</li><li>隐函数公式证明 P162</li><li>无条件极值、条件极值、拉格朗日乘数法 P165 P168 P169</li><li>例1.11.8</li></ol><h3 id="二重积分">二重积分</h3><ol type="1"><li><p>对称性P176，注例，P178例1.12.2</p></li><li><p>交换积分次序 P180 例1.12.8</p></li><li><p>直角坐标和极坐标的转换 P179 例1.12.5</p></li></ol><h3 id="section"></h3>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基础-小作业</title>
    <link href="/2023/05/07/BJUT/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E5%B0%8F%E4%BD%9C%E4%B8%9A/"/>
    <url>/2023/05/07/BJUT/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E5%B0%8F%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<p>基于华为云平台使用机器学习算法进行鸢尾花数据集分类 <span id="more"></span></p><h3 id="实验环境搭建">实验环境搭建</h3><ol type="1"><li><p>首先访问华为云的modelarts平台：https://console.huaweicloud.com/modelarts/，在左侧找到<strong>开发环境</strong>，选择Notebook并点击创建，如下图所示。</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230508124116.png" /></p></li><li><p>随后在创建界面指定名称，设置自动停止可以保证不会忘记关闭服务器而造成损失，镜像根据需求选择即可。其他默认，点击<strong>立即创建</strong>并提交，等待创建完成即可。</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230508124205.png" /></p></li><li><p>点击<strong>打开</strong>，即可进入服务器操作页面</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230508124525.png" /></p></li><li><p>左上角蓝色箭头可以上传文件到服务器，右侧可以选择交互的平台，本次选择Notebook。打开后即可进入代码编写阶段。</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230508124636.png" /></p></li></ol><h3 id="核心代码">核心代码</h3><p>本文使用<strong>sklearn</strong>实现若干模型对鸢尾花数据集的分类。由于本次实验选择的数据集为鸢尾花的前两类，他们之间是线性可分的，因此理想情况下分类准确率应为100%.</p><ol type="1"><li><p>头文件导入</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.rcParams[<span class="hljs-string">&quot;font.sans-serif&quot;</span>]=[<span class="hljs-string">&quot;SimHei&quot;</span>] <span class="hljs-comment">#设置字体</span><br>plt.rcParams[<span class="hljs-string">&quot;axes.unicode_minus&quot;</span>]=<span class="hljs-literal">False</span> <span class="hljs-comment">#该语句解决图像中的“-”负号的乱码问题</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br></code></pre></td></tr></table></figure></p></li><li><p>数据预处理</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">data = pd.read_csv(<span class="hljs-string">&quot;iris.data&quot;</span>,header=<span class="hljs-literal">None</span>)[:<span class="hljs-number">100</span>]<br>x = data.iloc[:,:<span class="hljs-number">4</span>]<br>y = []<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data.iloc[:<span class="hljs-number">100</span>,<span class="hljs-number">4</span>]:<br>    <span class="hljs-keyword">if</span> item == <span class="hljs-string">&#x27;Iris-setosa&#x27;</span>:<br>        y.append(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">else</span>:<br>        y.append(<span class="hljs-number">1</span>)<br>X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>线性模型</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><br>model = LogisticRegression()<br><br>model.fit(X_train, y_train)<br><br>y_pred = model.predict(X_test)<br><br>accuracy = accuracy_score(y_test, y_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy: &#123;:.2f&#125;%&quot;</span>.<span class="hljs-built_in">format</span>(accuracy * <span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure></p></li><li><p>决策树</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier<br>model = DecisionTreeClassifier()<br><br>model.fit(X_train, y_train)<br><br>y_pred = model.predict(X_test)<br><br>accuracy = accuracy_score(y_test, y_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy: &#123;:.2f&#125;%&quot;</span>.<span class="hljs-built_in">format</span>(accuracy * <span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure></p></li><li><p>其他</p><p>由于sklearn的模型接口一致，除model的定义不同外其他均一致，因此后续只给出头文件以及model定义</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 支持向量机</span><br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC<br>model = SVC()<br><br><span class="hljs-comment"># 贝叶斯</span><br><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB<br>model = GaussianNB()<br><br><span class="hljs-comment"># 神经网络</span><br><span class="hljs-keyword">from</span> sklearn.neural_network <span class="hljs-keyword">import</span> MLPClassifier<br>model = MLPClassifier(hidden_layer_sizes=(<span class="hljs-number">10</span>,), max_iter=<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment"># 集成学习（以随机森林为例）</span><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br>model = RandomForestClassifier()<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="结果和总结">结果和总结</h3><ol type="1"><li>实验结果</li></ol><p>​通过在华为云平台的Notebook运行，所有分类的准确率均为100%，符合预期。</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/result.png" /></p><ol start="2" type="1"><li><p>总结</p><p>通过本次实验，我深入了解了华为云平台具有创建方便、使用方式简洁、资源充足、不占有本机资源等优点，并通过实际操作熟悉了其使用方法，使我能够更加便捷地进行机器学习和数据处理等任务。</p><p>在本次实验中，我们采用了鸢尾花数据集进行二分类任务，通过理论学习和实践操作的结合，我掌握了机器学习中数据预处理、模型训练和评估等基本流程，提升了我的数据分析和模型建立能力。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛打印</title>
    <link href="/2023/05/04/Algorithm/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%B0/"/>
    <url>/2023/05/04/Algorithm/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%B0/</url>
    
    <content type="html"><![CDATA[<p>经典的算法题 <span id="more"></span></p><h3 id="背包问题">背包问题</h3><p>给定 N 个正整数 A1,A2,…，从中选出若干个数，使它们的和为M，求有多少种选择方案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[<span class="hljs-number">110</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">110</span>][<span class="hljs-number">10010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(a[i]&lt;=j) dp[i][j] = dp[i][j] + dp[i<span class="hljs-number">-1</span>][j-a[i]];<span class="hljs-comment">// 两个方案加起来</span><br>        &#125;<br>    &#125;<br>    <br>    cout&lt;&lt;dp[n][m];<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="判断闰年">判断闰年</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(x%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;x%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span> || x%<span class="hljs-number">400</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="蛇形数组">蛇形数组</h3><p>注意算a[20,20]要满足j&gt;=20 &amp;&amp; i-j+1 &gt;=20,i要算到40多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">300</span>][<span class="hljs-number">300</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> reverse = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">50</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(reverse)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++) &#123;<br>                a[j][i - j + <span class="hljs-number">1</span>] = cnt++;<br>                cout&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;i-j+<span class="hljs-number">1</span>&lt;&lt;endl;<br>            &#125;<br>            reverse = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++) &#123;<br>                a[i - j + <span class="hljs-number">1</span>][j] = cnt++;<br>                cout&lt;&lt;i-j+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;endl;<br>            &#125;<br>            reverse = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;a[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="正方形内的z字数组">正方形内的Z字数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> a[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            cin &gt;&gt; a[i][j];<br><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(x != n || y != n)&#123;<br>        <span class="hljs-keyword">if</span>(x &lt; n &amp;&amp; y &lt; n)<br>            cout &lt;&lt; a[x][y] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">if</span>(flag) x--, y++;<br>        <span class="hljs-keyword">else</span> x++, y--;<br><br>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>) &#123;<br>            x = <span class="hljs-number">0</span>;<br>            flag = !flag;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(y &lt; <span class="hljs-number">0</span>)&#123;<br>            y = <span class="hljs-number">0</span>;<br>            flag = !flag;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维涂色差分">二维涂色差分</h3><p>给定两个点(x1,y1),(x2,y2)，对其中间的格子进行涂色，问最后有多少个格子被涂色</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> map[N][N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;<br>        x1++;<span class="hljs-comment">// 注意区分点和格子</span><br>        y1++;<br>        map[x1][y1] ++;<br>        map[x1][y2+<span class="hljs-number">1</span>] --;<br>        map[x2+<span class="hljs-number">1</span>][y1] --;<br>        map[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]++;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;N;j++)&#123;<br>            map[i][j] = map[i<span class="hljs-number">-1</span>][j] + map[i][j<span class="hljs-number">-1</span>] - map[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + map[i][j];<br>            <span class="hljs-keyword">if</span>(map[i][j] &gt; <span class="hljs-number">0</span>) res++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串子串查找">字符串子串查找</h3><p>给出一个字符串和多行文字，在这些文字中找到字符串出现的那些行。你的程序还需支持大小写敏感选项：当选项打开时，表示同一个字母的大写和小写看作不同的字符；当选项关闭时，表示同一个字母的大写和小写看作相同的字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function">string <span class="hljs-title">to_lower</span><span class="hljs-params">(string s)</span></span>&#123;<br>    string temp = s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temp.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(temp[i]&gt;=<span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; temp[i]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>) temp[i] = temp[i] -<span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-string">&#x27;a&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string refer;<br>    cin&gt;&gt;refer;<br>    <span class="hljs-type">int</span> sign;<br>    cin&gt;&gt;sign;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">if</span>(!sign) refer = <span class="hljs-built_in">to_lower</span>(refer);<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        string s;<br>        cin&gt;&gt;s;<br>        string temp = s;<br>        <span class="hljs-keyword">if</span>(!sign) temp = <span class="hljs-built_in">to_lower</span>(s);<br><br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">find</span>(refer)!=string::npos)&#123;<br>            cout&lt;&lt;s&lt;&lt;endl;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统复习</title>
    <link href="/2023/05/03/BJUT/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/05/03/BJUT/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>操作系统基础知识复习 <span id="more"></span></p><h2 id="计算机系统概述">计算机系统概述</h2><ol type="1"><li><p>计算机自下而上的四个部分：硬件、操作系统、应用程序、用户。</p></li><li><p>操作系统定义：指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。</p></li><li><p>操作系统的四个特征:<strong>并发</strong>、<strong>共享</strong>、虚拟、异步(P2)。前两者必须实现。</p></li><li><p>操作系统为用户提供了两种接口：命令接口和程序接口。前者分为联机命令接口（交互式命令接口，在终端一问一答）和脱机命令接口（批处理系统，用户无法干预过程）。后者由一组系统调用组成。</p></li><li><p>操作系统发展历程</p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230503155929.png" style="zoom:67%;" /></p></li><li><p>计算机通过硬件完成操作系统由用户态到核心态的转换。</p></li><li><p>操作系统主要的四种结构</p><ol type="1"><li><p>分层法：自底向上逐层验证</p><ol type="1"><li>优点：便于系统的调试和验证，简化了系统的设计和实现；易扩充和易维护</li><li>缺点：合理定义各层比较困难；效率差（需要穿越多层）</li></ol></li><li><p>模块化：按功能分为若干个模块，向外提供接口</p><ol type="1"><li>优点：提高操作系统的正确性、可解释性和可维护性；增强了操作系统的可适应性；加速了操作系统的开发过程</li><li>缺点：接口规定难以满足对接口的实际需求；无法可靠的决定开发顺序</li></ol></li><li><p>宏内核：将系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为用户程序提供高性能的系统服务。</p></li><li><p>微内核：将内核中最基本的功能保留在内核，将不需要在和心态执行的功能移到用户态执行</p><p>操作系统中绝大部分功能都放在微内核外的一组服务器（进程）中实现，只有微内核运行在内核态，是C/S模式。</p><p>优点：扩展性和灵活性；可靠性和安全性；可移植性；分布式计算</p></li></ol></li><li><p>操作系统的<strong>引导过程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625005915.png" style="zoom: 50%;" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625005955.png" /></p></li></ol><h2 id="进程与线程">进程与线程</h2><h3 id="进程与线程-1">进程与线程</h3><ol type="1"><li><p>进程的组成：PCB、程序段、数据段</p></li><li><p>进程的<strong>创建过程</strong>（原语）</p><ol type="1"><li>为新进程分配一个唯一的进程标识号，并申请一个空白PCB(PCB是有限的)。若PCB申请失败，则创建失败。</li><li>为进程分配其运行所需的资源，如内存、文件、I/O设备和CPU时间等（在PCB中体现)。这些资源或从操作系统获得，或仅从其父进程获得。如果资源不足（如内存），则并不是创建失败，而是处于创建态，等待内存资源。</li><li>初始化PCB,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</li><li>若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。</li></ol></li><li><p>进程的<strong>终止过程</strong>（原语）</p><ol type="1"><li>根据被终止进程的标识符，检索出该进程的PCB,从中读出该进程的状态。</li><li>若被终止进程处于运行状态，立即终止该进程的执行，将处理机资源分配给其他进程。</li><li>若该进程还有子孙进程，则应将其所有子孙进程终止。</li><li>将该进程所拥有的全部资源，.或归还给其父进程，或归还给操作系统。</li><li>将该PCB从所在队列（链表）中删除。</li></ol></li><li><p><strong>进程的通信</strong>包含三种：共享存储、消息传递（直接通信、间接通信）、管道通信</p></li><li><p>为什么<strong>引入进程</strong></p><p>在多道程序同时运行的背景下，进程之间需要共享系统资源，因此会导致各程序在执行过程中出现相互制约的关系，程序的执行会表现出间断性的特征。这些特征都是在程序的执行过程中发生的，是动态的过程，而传统的程序本身是一组指令的集合，是一个静态的概念，无法描述程序在内存中的执行情况，即我们无法从程序的字面上看出它何时执行、何时停顿，也无法看出它与其他执行程序的关系，因此，程序这个静态概念己不能如实反映程序并发执行过程的特征。为了深刻描述程序动态执行过程的性质乃至更好地支持和管理多道程序的并发执行，人们引入了进程的概念。</p></li></ol><h3 id="处理机调度">处理机调度</h3><ol type="1"><li><p>调度的层次</p><ol type="1"><li><p>高级调度（作业调度）</p><p>按照一定原则从外存上处于后备队列的作业中挑选一个分配资源建立相应进程使他们获得竞争处理机的权利。是内存与辅存之间的调度</p></li><li><p>中级调度（内存调度）</p><p>为了提高内存利用率和系统吞吐量，将暂时不能运行的进程调至外存等待，将状态改为挂起态。当运行条件具备且内存有空闲时再调入内存</p></li><li><p>低级调度（进程调度）</p><p>从就绪队列中选择一个进程执行</p></li></ol></li><li><p>评价指标</p><ol type="1"><li>CPU利用率：有效工作时间/总时间</li><li>系统吞吐量：单位时间CPU完成作业的数量</li><li>周转时间：作业完成时间-作业提交时间</li><li>等待时间：进程处于等处理机的时间之和</li><li>响应时间：从用户提交请求到系统首次响应所用的时间</li></ol></li><li><p>上下文切换过程</p><ol type="1"><li>挂起一个进程，保存CPU上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>跳转到新进程PCB中的程序计数器所指向的位置执行。</li><li>恢复处理机上下文。</li></ol></li></ol><h3 id="同步与互斥">同步与互斥</h3><ol type="1"><li><p>等待时间：等待CPU的时间；周转时间：作业完成时间-作业提交时间；响应比：<spanclass="math inline">\(\frac{等待时间+要求服务时间}{要求服务时间}\)</span></p></li><li><p>同步与互斥</p><ol type="1"><li><p>同步：同步是指多个进程或线程之间的协作，按照一定的顺序执行，保证数据的正确性和一致性。通常使用信号量、事件等机制实现。</p></li><li><p>互斥：互斥是指多个进程或线程之间的竞争，保证同一时间只有一个进程或线程能够访问共享资源，避免数据的竞争和冲突。通常使用互斥锁、读写锁等机制实现。</p></li><li><p>区别：同步和互斥都是为了保证多个进程或线程之间的正确性和一致性，但它们侧重点不同。同步主要关注不同进程或线程之间的协作和顺序执行，而互斥则主要关注共享资源的竞争和访问控制。同时，同步可以用于实现互斥，但互斥不能实现同步。</p></li></ol></li></ol><h3 id="死锁">死锁</h3><ol type="1"><li><p>死锁产生的必要条件</p><ol type="1"><li>互斥:对资源进行排他性使用</li><li>不剥夺:进程的资源在未使用完之前,不能被其他进程夺走</li><li>请求并保持:进程已经保持了至少一个资源,但又提出了新的资源请求,而该资源已被其他进程占有</li><li>循环等待:存在一个资源的循环等待链</li></ol></li><li><p>死锁预防</p><ol type="1"><li>破坏互斥条件:比如打印机,肯定不可行</li><li>破坏不剥夺条件:确实可以,但是会增加系统开销,可以用于易于保存和恢复的资源比如CPU的寄存器和内存资源</li><li>破坏请求并保持条件:进程在运行前申请所有需要的资源,如果资源不足就等待,资源足够后一次性分配.</li><li>破坏循环等待条件:采用顺序资源分配法,给每个资源一个编号,每个进程必须按照编号递增的顺序请求资源,同类资源一次申请完.</li></ol></li><li><p>死锁避免</p><ol type="1"><li><p>银行家算法</p><p>要求每个进程给出最大的资源请求量MAX,已知每个进程的现在资源占有量ALLO.对于一个新的资源请求NEW,首先检查NEW+ALLO是否大于MAX,若大于则不予分配.然后检查如果分配了,系统是否还是安全状态(找到一个安全序列),如果是就可以进行分配.</p></li></ol></li><li><p>死锁检测和<strong>解除</strong></p><ol type="1"><li>资源剥夺法:挂起某些死锁进程并抢占他的资源,将这些资源分配给其他死锁进程.</li><li>撤销进程法:撤销部分或者全部死锁进程并剥夺资源</li><li>进程回退法:让一个/多个进程回退到足以回避死锁的地步</li></ol></li></ol><h2 id="内存管理">内存管理</h2><h3 id="内存管理概念">内存管理概念</h3><ol type="1"><li><p>交换与覆盖：覆盖是在同一个程序或者进程中进行的，交换是在不同进程之间进行的。</p></li><li><p>连续分配管理方式</p><ol type="1"><li>单一连续分配：内存分为系统区和用户区，用户区中只有一道用户程序</li><li>固定分区分配：分区大小可以相同也可以不同，会产生内部碎片</li><li>动态分区分配：分配策略：首次适应、邻近适应、最佳适应、最坏适应，会产生外部碎片</li></ol></li><li><p>基本分页存储管理</p><ol type="1"><li><p>系统为每个进程建立一个页表，他记录页面在内存中对应的物理块号</p></li><li><p>基本地址变换</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010241.png" style="zoom:67%;" /></p></li><li><p>快表（TLB）：由页号+块号组成，是高速缓冲存储器</p><p>基本的分页存储需要先到页表查找对应的物理块号然后再去访存，需要经过两次访存。快表根据局部性原理将最近访问过的页面存储起来，直接建立页号+块号的结构，可以快速定位到物理块号</p></li></ol></li><li><p>基本分段存储管理</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230504213228.png" /></p><p>段的共享是通过两个作业的段表中相应表项指向被共享的段的统一物理副本实现的</p></li><li><p>段页式管理</p><ol type="1"><li><p>分页存储能够有效提高内存利用率，分段存储能够反映程序的逻辑结构并有利于段的共享和保护</p></li><li><p>系统为贝格进程建立一张段表，每个分段有一张页表。段表表项至少包含段号、页表长度和页表始址，页表表项至少包括页号和块号</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010326.png" style="zoom: 50%;" /></p></li></ol></li></ol><h3 id="虚拟内存管理">虚拟内存管理</h3><ol type="1"><li><p>基于局部性原理，在程序装入时，仅须将程序当前要运行的少数页面或段先装入内存，而将其余部分暂留在外存，便可启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存容量大得多的存储器，称为虚拟存储器。</p></li><li><p>程序局部性原理</p><ol type="1"><li>时间局部性：由于程序中存在大量的循环操作，程序中的某条指令一旦执行，不久后该指令可能再次执行；某数据被访问过，不久后该数据可能再次被访问。</li><li>空间局部性：一旦程序访问了某个存储单元，不久后其附近的存储单元也会被访问，即程序在一段时间内所访问的地址可能集中在一定的范围之内，因为指令通常是顺序存放、执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li><li>时间局部性通过将近来使用的指令和数据保存到高速缓存中，并使用高速缓存的层次结构实现。空间局部性通常使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上建立了“内存-外存”的两级存储器结构，利用局部性原理实现高速缓存。</li></ol></li><li><p>置换算法</p><ol type="1"><li>最佳置换算法（OPT）：淘汰最长时间内不再被访问的页面</li><li>先进先出算法(FIFO)：淘汰最早进入内存的页面</li><li>最近最久未使用算法（LRU）：淘汰最近最长时间未访问过的页面</li><li><strong>Belady异常</strong>：分配的物理块数增大但缺页率不减反增。只有FIFO有这种现象</li></ol></li></ol><h2 id="文件管理">文件管理</h2><ol type="1"><li><p>文件系统的<strong>逻辑结构</strong>分为无结构文件（流式文件）和有结构文件</p></li><li><p>文件分配磁盘块方式（物理结构）</p><ol type="1"><li><p>连续分配</p></li><li><p>链接分配</p><ol type="1"><li>隐式链接：目录项中含有文件的第一块的指针和最后一块的指针。每个盘块都含有指向下一个盘块的指针</li><li>显式链接：把指针显式的放在一张表中</li></ol></li><li><p>索引分配：设置索引块记录所有分配的块</p></li><li><p>混合索引分配</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010348.png" style="zoom:50%;" /></p></li></ol></li><li><p>虚拟文件系统（VFS）</p><p>为用户提供了文件系统操作的统一接口，屏蔽了不同文件系统带来的差异和操作细节。</p></li></ol><h2 id="输入输出管理">输入/输出管理</h2><ol type="1"><li>设备可以分为块设备和字符设备</li><li>I/O接口指设备控制器，组成如下</li></ol><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010408.png" style="zoom:67%;" /></p><ol start="3" type="1"><li>I/O端口指设备控制器中可被CPU直接访问的寄存器，主要包括数据寄存器、状态寄存器、控制寄存器</li><li>端口可以独立编址采用特殊内核指令，也可以统一编址使用内存空间</li><li>I/O控制分为程序直接控制、中断驱动、DMA，参考计组</li><li>I/O软件层次结构<ol type="1"><li>用户层I/O软件：实现与用户交互的接口，用户可直接调用在用户层提供的库函数</li><li>设备独立性软件：使得应用程序独立于具体使用的物理设备</li><li>设备驱动程序：与硬件直接相关，负责具体实现系统对设备发出的操作指令</li><li>中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完毕后再恢复中断现场返回中断程序</li></ol></li><li>设备独立性：用户在编程序时使用的设备与实际设备无关，一个程序应独立于分配给他的某类设备的具体设备，即在用户程序中只指明I/O使用的设备类型即可</li><li>在磁盘上进行一次读写的时间由寻道时间、延迟时间和传输时间决定。<ol type="1"><li>寻道时间：将磁头移动到指定磁道所需要的时间（时间最长）</li><li>延迟时间：磁头定位到某一磁道的扇区所需要的时间</li><li>传输时间：从磁盘读出或向磁盘写入数据所需要的时间</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法提高课</title>
    <link href="/2023/04/27/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%8F%90%E9%AB%98%E8%AF%BE/"/>
    <url>/2023/04/27/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%8F%90%E9%AB%98%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<p>算法提高课的DP题 <span id="more"></span></p><h3 id="最长上升子序列">最长上升子序列</h3><ol type="1"><li><p><a href="https://www.acwing.com/problem/content/484/">482.合唱队形 - AcWing题库</a></p></li><li><p><a href="https://www.acwing.com/problem/content/1014/">1012.友好城市 - AcWing题库</a></p></li></ol><h3 id="背包">背包</h3><ol type="1"><li><ahref="https://www.acwing.com/problem/content/description/280/">278.数字组合 - AcWing题库</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/2023/04/24/BJUT/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/2023/04/24/BJUT/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>编译原理易错知识点 <span id="more"></span></p><h3 id="文法">文法</h3><ol type="1"><li><p>符号串真前缀、真后缀、真子串要求<strong>非空</strong>且不等于原串</p></li><li><p>终结符与非终结符的交集为空集</p></li><li><p>开始符号S至少必须在某个产生式的左部出现一次</p></li><li><p>高级程序设计语言的语法可以用2型文法描述</p></li><li><p>高级程序设计语言的词法可以用3型文法描述</p></li><li><p>使用<strong>正规式</strong>、<strong>正规文法</strong>描述高级程序设计语言的单词结构</p></li></ol><h4 id="正规式">正规式</h4><ol type="1"><li><p>正规文法是3型文法，左线性表示为A-&gt;w或A-&gt;Bw;右线性表示为A-&gt;w或A-&gt;wB</p></li><li><p><span class="math display">\[A=r_1^*=\varepsilon | r_1^+=\varepsilon|r_1r_1^*=\varepsilon|r_1A\]</span></p><p><span class="math display">\[A=r_1^+=r_1r_1^*=r_1(\varepsilon|r_1^+)=r_1|r_1r_1^+=r_1|r_1A\]</span></p><p><span class="math display">\[A=r_1^*r_2=(\varepsilon|r_1^+)r_2=r_2|r_1^+r_2=r_2|r_1r_1^*r_2=r_2|r_1A\]</span></p></li></ol><h3 id="语法">语法</h3><ol type="1"><li>对于LL(1)文法，A的候选式中最多允许1个可以推导出<spanclass="math inline">\(\varepsilon\)</span></li><li>规范规约要求推导过程是对句柄进行规约，也叫最左规约</li><li>算符优先文法：对于一个算符文法，a==b，a&lt;b,a&gt;b至多只有一个成立</li><li>算符优先分析不是一种严格的规范规约，规约对象不是句柄</li><li><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230511115528.png" style="zoom:50%;" /></li><li>素短语：句型中至少含有一个终结符且不含其他素短语的短语</li><li>消除左递归只在自顶向下分析使用，自底向上不需要</li><li>上下文无关文法并不是都能用LR(0)方法进行分析</li><li>对于SLR(1)分析，A-&gt;a.只将Follow（A）集合中的字符进行规约，别的要么移进要么<strong>空着</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2023/04/24/BJUT/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2023/04/24/BJUT/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>计组复习 <span id="more"></span></p><h3 id="计算机系统概述">计算机系统概述</h3><ol type="1"><li>冯诺依曼提出计算机硬件系统由<strong>运算器、存储器、寄存器、输入设备、输出设备</strong>组成，指令和数据以同等地位存储，都以二进制表示，以<strong>运算器</strong>为核心</li><li>冯诺依曼机基本工作方式是控制流驱动，提出的“存储程序”的基本思想是：将事先编制好的程序和原始数据送入主存后才能执行，一旦程序被启动执行，就无须操作人员的干预，计算机会自动逐条执行指令，直至程序执行结束。</li></ol><h3 id="数据的表示和计算">数据的表示和计算</h3><ol type="1"><li><p><strong>大端方式</strong>按从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节存放在前面；<strong>小端方式</strong>按从最低有效字节到最高有效字节的顺序存储数据，即最低有效字节存放在前面。</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010547.png" style="zoom:50%;" /></p></li><li><p>IEEE754的短浮点数由1位符号位、8位阶码、23位尾数组成，其中阶码采用移码，偏移量为127，尾数采用原码表示</p><p>真值表示为<spanclass="math inline">\((-1)^S*1.M*2^{(E-127)}\)</span></p></li></ol><p>### 存储系统</p><ol type="1"><li><p>CPU可以与Cache和主存交换信息。<strong>主存和Cache</strong>之间的数据调动是由硬件自动完成的，<strong>主存和辅存</strong>之间的数据调动是由硬件和操作系统共同完成的(虚拟存储技术)。</p></li><li><p>静态随机存储器（SRAM）：速度快、不需要刷新、用于高速缓存</p><p>动态随机存储器（DRAM）：速度慢，需要刷新，用于内存</p></li><li><p><strong>高位交叉编址</strong>中高位地址表示体号，低位地址表示体内地址。每次存完一个存储体后才存下一个，并行性差</p><p>低位交叉编址中低位地址表示体号，每次存某一个存储体，下次就存下一个存储体，并行性好</p></li><li><p>主存容量的扩展：</p><ol type="1"><li><strong>位扩展</strong>改变字长，将多个存储芯片的地址端、片选端、读写控制端相应并联，数据端分别引出。</li><li>字扩展增加存储体字的数量，不改变字长，通过片选信号进行选择。</li></ol></li><li><p>Cache和主存的映射</p><ol type="1"><li><p>直接映射</p><p>Cache行号=主存块号 mod Cache总行数</p><p>即主存的第<spanclass="math inline">\(1、2^{c}+1、2^{c+1}+1\)</span>块均映射到第0行。当产生冲突时无条件进行置换</p><p>主存块号的低c位正好是要装入的Cache行号，因此给每个Cache行设置一个长为m-c的标记，就可以知道是哪块主存在cache中了</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230625010509.png" style="zoom: 50%;" /></p></li><li><p>全相联映射</p><p>主存中的每一块可以装入Cache的任意位置。但是需要一行一行的查找</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230629133704.png" style="zoom:50%;" /></p></li><li><p>组相联映射</p><p>组间直接映射，组内全相联映射</p><p><img src="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBedNew/20230629133750.png" style="zoom:50%;" /></p></li></ol></li><li><p>Cache写策略</p><ol type="1"><li>写命中<ol type="1"><li>全写法：把数据同时写入Cache和主存</li><li>回写法：只把数据写入Cache同时标记脏页，当块被换出时若为脏页才写回主存</li></ol></li><li>写不命中<ol type="1"><li>写分配法：加载主存的块到Cache中，然后更新Cache块，常与回写法搭配</li><li>非写分配法：只写入主存，不进行调块，常与全写法搭配</li></ol></li></ol></li></ol><h3 id="指令系统">指令系统</h3><ol type="1"><li><p>数据寻址方式</p><ol type="1"><li><p>隐含寻址：在指令中隐含特定操作数的地址</p></li><li><p>立即数寻址：本身就是操作数</p></li><li><p>直接寻址：指令中的地址是主存中真实的地址</p></li><li><p>间接寻址：指令中的地址是数据所在地址的地址，在此基础上可以进行多级寻址</p></li><li><p>寄存器寻址：给出操作数所在的寄存器编号</p></li><li><p>寄存器间接寻址：指向的寄存器给出操作数所在的地址</p></li><li><p>相对寻址：在PC基础上添加一个偏移量</p></li><li><p>基址寻址：基址寄存器BX加上一个偏移量</p><p>基址寄存器面向操作系统，其内容由操作系统或管理程序确定</p></li><li><p>变址寻址：变址寄存器IX加上一个偏移量</p><p>变址寄存器面向用户，可由用户改变</p></li><li><p>堆栈寻址：通过堆栈指针SP寻址</p></li></ol></li><li><p>复杂指令系统：CISC</p><p>精简指令系统：RISC</p></li></ol><h3 id="中央处理器">中央处理器</h3><ol type="1"><li><p>CPU全周期：取指、译码、执行、访存、写回</p></li><li><p>异常和中断</p><ol type="1"><li>异常：故障（除0、缺页等）、自陷（单步调试）、终止（硬件故障）</li><li>中断：可屏蔽中断、不可屏蔽中断</li><li>响应过程<ol type="1"><li>关中断：防止在保存断点和程序状态时被打断</li><li>保存断点和程序状态</li><li>识别异常和中断并转到相应的处理程序</li></ol></li></ol></li><li><p>数据旁路：在流水线设计中不等待ALU写入寄存器同时下一个读寄存器，而是直接把结果输出到ALU的输入</p></li></ol><h3 id="总线">总线</h3><ol type="1"><li>特点<ol type="1"><li>分时：同一时刻只允许有一个部件向总线发送消息</li><li>共享：总线上可以挂接多个部件，各个部件之间互相交换的信息可以通过这个线路进行分时共享，多个部件可以同时从总线上接收相同的消息</li></ol></li></ol><h3 id="问答题">问答题</h3><ol type="1"><li><p>指令和数据均存放在内存中，计算机如何区分他们是指令还是数据</p><p>从时间上讲，取指令发生在取指阶段，取数据发生在执行阶段。从空间上讲，从内存读出的指令流流向控制器（指令寄存器），从内存读出的数据流流向运算器（通用寄存器）。</p></li><li><p>组合逻辑电路和时序逻辑电路有什么区别？组合逻辑电路是具有一组输出和一组输入的非记忆性逻辑电路，它的基本特点是任何时刻的输出信号状态仅取决于该时刻各个输入信号状态的组合，而与电路在输入信号作用前的状态无关。组合电路不含存储信号的记忆单元，输出与输入之间无反馈通路，信号是单向传输的。时序逻辑电路中任意时刻的输出信号不仅和当时的输入信号有关，而且与电路原来的状态有关，这是时序逻辑电路在逻辑功能上的特点。因而时序逻辑电路必然包含存储记忆单元。</p><p>此外，组合逻辑电路没有统一的时钟控制，而时序逻辑电路则必须在时钟节拍下工作。</p></li><li><p>引入总线结构有什么好处？ ①简化了系统结构，便于系统设计制造。②大大减少了连线数目，便于布线，减小体积，提高系统的可靠性。③便于接口设计，所有与总线连接的设备均采用类似的接口。④便于系统的扩充、更新与灵活配置，易于实现系统的模块化。⑤便于设备的软件设计，所有接口的软件对不同的接口地址进行操作。⑥便于故障诊断和维修，同时也能降低成本。</p></li><li><p>计算机系统的五层层次结构</p><p>微程序机器层、传统机器语言层、操作系统层、汇编语言层、高级语言层</p><p>其中后三层称为虚拟机</p></li><li><p>机器字长、指令字长、存储字长</p><p>机器字长：计算机能直接处理的二进制数据位数，为内部寄存器字长等长</p><p>指令字长：一条指令的二进制位数</p><p>存储字长：一个存储单元所能存储的二进制的位数</p><p>三者都必须是字节的整数倍，彼此之间没有直接的制约关系</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线性代数</title>
    <link href="/2023/04/12/BJUT/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <url>/2023/04/12/BJUT/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>线性代数基础知识复习 <span id="more"></span></p><h3 id="矩阵与方程组">矩阵与方程组</h3><ol type="1"><li><p><strong>超定方程组</strong>：方程个数大于未知数个数</p></li><li><p><strong>亚定方程组</strong>：方程个数小于未知数个数</p></li><li><p><strong>首变量</strong>：增广矩阵每一行第一个非零元对应的变量</p></li><li><p><strong>自由变量</strong>：化简过程中跳过的列对应的变量</p></li><li><p><strong>行最简式</strong>：矩阵是行阶梯形的且每一行的第一个非零元是该列唯一的非零元</p><figure><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230412123644.png"alt="行最简式子" /><figcaption aria-hidden="true">行最简式子</figcaption></figure></li><li><p><strong>齐次方程组</strong>：线性方程组右侧全为0</p></li><li><p><strong>奇异</strong>：一个<span class="math inline">\(n\timesn\)</span>的矩阵若不存在乘法逆元。矩阵A是奇异的当且仅当其行列式为0</p></li><li><p>若A是非奇异的，则<spanclass="math inline">\(Ax=0\)</span>仅有平凡解0，A与I行等价</p><p>证明：假设存在<span class="math inline">\(\barx\)</span>是一个非零解，则有<span class="math inline">\(\bar x=I\barx=(A^{-1}A)\bar x=A^{-1}A\bar x=A^{-1}0=0\)</span>.矛盾，得证。</p></li><li><p><strong>LU分解</strong>：将矩阵A分解为一个单位下三角矩阵L和一个严格上三角矩阵U的乘积的过程。</p><p>如果一个<span class="math inline">\(n\timesn\)</span>的矩阵能够仅利用行运算3化简为严格上三角形的，则A有一个LU分解</p></li><li><p>给定<spanclass="math inline">\(R^n\)</span>中的两个向量x,y.则<spanclass="math inline">\(x^Ty\)</span>为标量积或者<strong>内积</strong>，<spanclass="math inline">\(xy^T\)</span>为<strong>外积</strong></p></li><li><p>矩阵求导<ahref="https://zhuanlan.zhihu.com/p/273729929">矩阵求导公式的数学推导（矩阵求导——基础篇）- 知乎 (zhihu.com)</a></p></li></ol><h3 id="行列式">行列式</h3><ol type="1"><li><p><spanclass="math inline">\(a_{ij}\)</span>的<strong>余子式</strong><spanclass="math inline">\(A{ij}=(-1)^{i+j}|M_{ij}|\)</span>,<spanclass="math inline">\(|A|\)</span>可以表示为任意行或列的余子式展开</p><ol type="1"><li>若A为三角形方阵，则A的行列式等于A的对角线元素的乘积。可以用递归证明。</li><li>若A有一行或一列包含的元素值全为0，则|A|为0.</li></ol></li><li><p>交换矩阵的两行或两列会改变行列式的符号</p></li><li><p>某行的倍数加到另一行上不会改变矩阵的行列式</p></li><li><p>可以通过将行列式转化为三角形求值，若最后一行全为0则行列式值为0，否则为对角线元素的乘积</p></li><li><p><strong>伴随矩阵</strong>：将原矩阵的元素用它们的余子式替换，然后将结果矩阵转置。<spanclass="math inline">\(A^{-1}=\frac{adj(A)}{|A|}\)</span></p></li></ol><p>​ <span class="math inline">\(A(adj(A))=det(A)I\)</span>,则有<spanclass="math inline">\(A\frac{adj(A)}{det(A)} =I\)</span>,即可推出上述表达式</p><ol start="6" type="1"><li><p><strong>克拉默法则</strong>:若A为非奇异矩阵，<spanclass="math inline">\(Ax=b\)</span>，则有<spanclass="math inline">\(x_i=\frac{det(A_i)}{det(A)}\)</span>,其中<spanclass="math inline">\(A_i\)</span>为将矩阵A中第i列用b替换得到的矩阵。<span class="math display">\[x=A^{-1}b=\frac{1}{det(A)}adj(A)b\]</span></p><p><span class="math display">\[x_i=\frac{b_1A_{1i}+b_2A_{2i}+...+b_nA_{ni}}{det(A)}=\frac{det(A_i)}{det(A)}\]</span></p></li></ol><h3 id="正交性">正交性</h3><ol type="1"><li><p><strong>最小二乘法</strong>原理：<ahref="https://zhuanlan.zhihu.com/p/38128785">最小二乘法（least sqauremethod） - 知乎 (zhihu.com)</a></p></li><li><p>$x^Ty = | x | | y | cos$ 用余弦定理证明</p></li><li><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230423122641.png" /></p><p>已知<span class="math inline">\(x\)</span>,<spanclass="math inline">\(y\)</span>,则有</p></li></ol><p><span class="math display">\[\alpha=\left \| x \right \|cos\theta=\frac{\left \| x \right \| \left \|y \right \|  cos\theta}{\left \| y \right \|}=x^Ty\]</span></p><p><span class="math display">\[p=\alpha u=\alpha\frac{1}{\left \| y \right \|}y=\frac{x^Ty}{y^Ty}y\]</span></p><ol start="4" type="1"><li>求过一个定点<span class="math inline">\(p\)</span>且与已知向量<spanclass="math inline">\(l\)</span>垂直的平面：对于任意点x,应有<spanclass="math inline">\(\overrightarrow{xp}·l=0\)</span>，即可求得x表达式</li><li>求给定三个点确定的平面：先求得两个向量，然后根据叉乘求出法向量，然后任取一个给定点按4中方式计算即可</li><li>施密特正交化过程：<ahref="https://zhuanlan.zhihu.com/p/136627868">如何理解施密特（Schmidt）正交化- 知乎 (zhihu.com)</a></li></ol><h3 id="特征值">特征值</h3><ol type="1"><li>一个矩阵A是可对角化的，当且仅当A有n个线性无关的特征向量</li></ol>]]></content>
    
    
    <categories>
      
      <category>保研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux总结</title>
    <link href="/2023/04/09/BJUT/Linux_School/Linux%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/09/BJUT/Linux_School/Linux%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 <span id="more"></span></p><h3 id="第一章-基础知识">第一章 基础知识</h3><ol type="1"><li><p>Linux五个子系统的关系（关系图见1-3）</p><p>·进程调度与内存管理之间的关系：这两个子系统互相依赖。在多道程序环境下，程序要运行必须为之创建进程，而创建进程的第一件事，就是要将程序和数据装入内存。</p><p>·进程间通信与内存管理的关系：进程间通信子系统要依赖内存管理支持共享内存通信机制，这种机制允许两个进程除了拥有自己的私有内存，还可存取共同的内存区域。</p><p>·虚拟文件系统与网络接口之间的关系：虚拟文件系统利用网络接口支持网络文件系统(NFS)，也利用内存管理支持RAMDISK设备。</p><p>· 内存管理与虚拟文件系统之间的关系：内存管理利用虚拟文件系统支持交换，交换进程(swapd)定期地由调度程序调度，这也是内存管理依赖于进程调度的唯一原因。当一个进程存取的内存映射被换出时，内存管理向文件系统发出请求，同时，挂起当前正在运行的进程。</p></li><li><p>华为的OpenEuler操作系统是基于Linux内核的开源操作系统</p></li><li><p>GNU与Linux</p><p>Linux与GNU有很大关系。实际上，通常所说的Linux操作系统其实是由Linux内核和GNU操作系统（包括shell、工具集、库等）共同组成的。Linux操作系统的内核由LinusTorvalds在1991年发起开发，而GNU则在此之前就开始了基础软件和工具的开发。LinusTorvalds将GNU的类Unix系统和他的内核结合起来，形成了我们今天所说的Linux操作系统。</p></li></ol><h3 id="第二章-进程">第二章 进程</h3><ol type="1"><li><p>Linux2.4与2.6在进程堆栈上的区别</p><p>使用thread_info代替了task_struct</p><p>在2.6版本中，内存管理存在SLUB、SLAB等多种机制，可以更加灵活地管理内存。而在2.4版本中，则只支持较为简单的伙伴系统（BuddySystem）来管理内存</p></li></ol><p>​</p><h3 id="第五章">第五章</h3><ol type="1"><li><p>hw_interrupt_type结构中的域都是函数指针，它们指向了一些用来操作中断服务例程的函数，采用的是<strong>面向对象</strong>的方法</p></li><li><p>为什么引入下半部，下半部的组织</p><p>下半部通常使用软中断（Softirq）实现，在内核中被组织为一组可重入的函数队列，并伴随着一个标志位，表示是否有下半部需要处理。当某个中断处理程序需要执行下半部任务时，它只需要将任务添加到下半部队列中，然后向内核中断处理程序返回。当CPU空闲时，内核会检查下半部队列是否有任务需要执行，并按照优先级顺序逐个执行。这种机制使得中断处理程序可以更快地退出，从而提高系统的吞吐量和响应速度。</p></li></ol><h3 id="第六章">第六章</h3><ol type="1"><li><p>为什么要划分VMA</p><p>Linux2.4 将用户地址空间划分成多个 VMA区域的主要原因是为了实现虚拟内存管理机制，即将虚拟地址映射到物理地址，从而提升系统的内存利用率和安全性。由于每个VMA区域都有不同的访问权限和属性，可以灵活地为不同的代码和数据分配合适的内存空间，从而避免了其中一个区域出现问题影响整个系统的情况。</p></li><li><p>以write()为例,VFS是如何与EXT2结合的</p><p>以 ext2 文件系统为例，当应用程序执行 write() 系统调用时，内核会首先在VFS 层进行处理。VFS 会查找并获得要写入文件的 inode结构，并将其缓存到本地内存中，以便之后高效地访问。VFS 层还会根据 inode的地址，找到对应的靠近磁盘缓存中的 buffer_head数据结构，建立起文件系统中每个块和缓存的映射关系，进而实现读写请求与具体物理设备之间的转换。</p><p>接下来，VFS 会将写入数据的请求传递给 ext2文件系统，以处理这个文件系统的特定细节，如块的分配、解析目录等。ext2文件系统首先检查写入数据的可用空间是否足够，如果空间不足，需要进行扩展块的分配和逻辑分区的重分配等操作。如果数据空间足够，则会将数据写入相应的块中，并更新inode结构和超级块等元数据信息。更新元数据时，需要确保在出现断电等异常情况时，文件系统仍然可以保持一致性，并使用日志文件（journal）来记录必要的元数据信息，以备后续恢复。</p><p>最后，当 ext2 文件系统完成数据写入操作后，VFS层会返回相应的结果给应用程序，并清除 inode缓存等临时数据，以便之后更高效地进行访问。整个过程中，VFS层扮演了一个统一接口的角色，将 Linux系统与具体文件系统解耦，并实现了文件读写等基本操作的抽象，从而方便了内核的开发工作</p></li><li><p>什么是设备文件？什么是设备驱动程序？</p><p>在 Linux2.4中，设备文件是一种特殊的文件类型，它用于与系统中的各种物理或虚拟设备进行交互。设备文件一般存储在/dev目录下，其中包括了很多常用设备（如硬盘、显示器、键盘等）的设备文件。</p><p>设备文件可以分为两种类型：块设备文件和字符设备文件。块设备文件通常用于访问磁盘等存储设备，而字符设备文件则用于访问串口、键盘鼠标等非存储类设备。</p><p>而设备驱动程序是指控制设备功能的软件程序，通过设备驱动程序可以控制设备的输入、输出、中断处理等操作。设备驱动程序一般是由操作系统内核或者用户态应用程序所提供的。</p><p>在 Linux2.4中，设备驱动程序通常被编译为模块的形式，称为内核模块。这些模块可以动态地加载到内核中，从而实现对特定设备的控制和管理。当设备文件被打开时，内核将自动使用与该设备相关的设备驱动程序，以实现对设备的操作。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件系统</title>
    <link href="/2023/04/06/BJUT/Linux_School/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/04/06/BJUT/Linux_School/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 第七章.文件系统 <span id="more"></span></p><h3 id="文件系统的特征">文件系统的特征</h3><ol type="1"><li>Linux文件是无结构的字符流式文件</li><li>外部设备也被看作文件</li></ol><h3 id="虚拟文件系统vfs">虚拟文件系统VFS</h3><ol type="1"><li>虚拟文件系统VFS是面向对象的设计</li><li>向上提供给用户接口，向下要求各文件系统分别实现各接口</li><li>四种通用文件模型：超级块对象、索引节点对象、文件对象、目录项对象</li></ol><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230406212830.png" /></p><p>进程和文件系统之间数据结构的关系</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux中断处理</title>
    <link href="/2023/04/05/BJUT/Linux_School/Linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
    <url>/2023/04/05/BJUT/Linux_School/Linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 第五章.中断处理 <span id="more"></span></p><h3 id="快中断与慢中断">快中断与慢中断</h3><ol type="1"><li><p>在中断响应时，OS规定要关闭中断允许位，直到中断处理程序中调用了开中断指令STI为止</p></li><li><p>快中断对应上半部处理程序，慢中断对应下半部处理程序</p></li><li><p>处理慢中断前：需保存所有寄存器的内容,而快中断处理仅要保存部分被修改的寄存器</p></li><li><p>慢中断处理时不屏蔽其它中断信号（开中断）,而快中断处理时会屏蔽所有其它中断（关中断）</p></li><li><p>慢中断处理完毕后，通常不立即返回被中断的进程，而是进入调度程序重新调度，调度结果未必是被中断的原进程运行(是抢先式调度)。快中断处理完毕后，通常恢复现场返回被中断的进程继续执行(是非抢先式调度)。</p></li><li><p>可以将上半部看做是一个用来实现“登记中断”功能的函数，即当一个中断发生时，它就把中断例程的下半部分挂接到该设备的下半部分执行队列中，然后不再做其他事情</p></li></ol><h3 id="中断请求队列">中断请求队列</h3><ol type="1"><li>hw_interrupt_type结构中的域都是函数指针，它们指向了一些用来操作中断服务例程的函数，采用的是<strong>面向对象</strong>的方法。</li><li>几个重要数据结构之间的关系</li><li><img src=https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230405163958.png width="80%"></li></ol><h3 id="中断的注册与安装">中断的注册与安装</h3><ol type="1"><li>中断服务例程在安装之前，需先用函数<strong>request_irq()</strong>进程注册，以向系统申请一个中断描述符结构空间和一个中断号。</li><li>调用函数<strong>setup_irq()</strong>把中断服务例程安装到中断请求队列中。该函数的主要作用是为中断服务例程分配一个irqaction结构，并把指针handler指向中断服务例程的函数。</li><li>在中断结束之后，关闭申请中断的设备时，调用<strong>free_irq()</strong>释放所申请的中断号。</li><li><strong>do_IRQ()</strong>负责处理所有的外部设备中断.在do_IRQ的末尾，调用<strong>iqr_exit()</strong>,它的一项重要工作中就使启动中断的下半部分</li></ol><h3 id="linux的时间系统">Linux的时间系统</h3><ol type="1"><li>Jiffies是一个全局变量，用于存放自系统启动以来产生的总的节拍数。给全局变量jiffies加1这项工作是紧急的，因此它由上半部来完成；而其余各项，则因它们不那么紧急，由下半部分完成</li><li>上半部函数：timer_interrupt() 下半部函数：timer_bh()</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统调用</title>
    <link href="/2023/04/05/BJUT/Linux_School/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2023/04/05/BJUT/Linux_School/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 第四章.系统调用 <span id="more"></span></p><h3 id="系统调用功能">系统调用功能</h3><ol type="1"><li>Linux利用i386体系结构的软件中断实现系统调用，即调用了int$0x80汇编指令。</li><li>系统调用处理程序的入口是system_call()</li></ol><h3 id="系统调用和中断处理的区别">系统调用和中断处理的区别</h3><p>中断必须完成当前指令后才进入中断，而系统调用可以在一条指令中进行</p><h3 id="系统调用的参数传递">系统调用的参数传递</h3><ol type="1"><li>系统调用使用寄存器来传递参数.要传递的参数有：系统调用号、系统调用所需的参数</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树状数组&amp;线段树</title>
    <link href="/2023/04/03/Algorithm/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2023/04/03/Algorithm/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>Acwing蓝桥杯树状数组和线段树内容 <span id="more"></span></p><h3 id="树状数组">树状数组</h3><p>可以实现在增加某个位置一个值的情况下快速求前缀和,时间复杂度O(logn)</p><p>例题：<ahref="https://www.acwing.com/problem/content/description/1267/">1265.数星星 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> a[N],tr[N];<br><span class="hljs-type">int</span> n,m;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;-x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i)) tr[i] += y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i&gt;=<span class="hljs-number">1</span>;i-=<span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-comment">// 初始化操作</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">add</span>(i,a[i]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> k,x,y;<br>        cin&gt;&gt;k&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-built_in">query</span>(y) - <span class="hljs-built_in">query</span>(x<span class="hljs-number">-1</span>)&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(x,y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线段树">线段树</h3><h4 id="求动态区间和">求动态区间和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> l,r;<br>    <span class="hljs-type">int</span> val;<br>&#125;node[<span class="hljs-number">4</span>*N];<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    node[u].val = node[<span class="hljs-number">2</span>*u].val + node[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) node[u] = &#123;l,r,a[l]&#125;;<br>    <span class="hljs-keyword">else</span>&#123;<br>        node[u] = &#123;l,r&#125;;<br>        <span class="hljs-type">int</span> mid = l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u,l,mid);<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>        <span class="hljs-built_in">pushup</span>(u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(node[u].l &gt;= l &amp;&amp; node[u].r &lt;= r) <span class="hljs-keyword">return</span> node[u].val;<br>    <span class="hljs-type">int</span> mid = node[u].l + node[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l&lt;=mid) sum += <span class="hljs-built_in">query</span>(<span class="hljs-number">2</span>*u,l,r);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) sum += <span class="hljs-built_in">query</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>,l,r);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(node[u].l == node[u].r) node[u].val += y;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> mid = node[u].l + node[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(x&lt;=mid) <span class="hljs-built_in">modify</span>(<span class="hljs-number">2</span>*u,x,y);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>,x,y);<br>        <span class="hljs-built_in">pushup</span>(u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> k,x,y;<br>        cin&gt;&gt;k&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,x,y)&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,x,y);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求区间最大值">求区间最大值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> l,r;<br>    <span class="hljs-type">int</span> val;<br>&#125;node[<span class="hljs-number">4</span>*N];<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    node[u].val = <span class="hljs-built_in">max</span>(node[<span class="hljs-number">2</span>*u].val, node[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r) node[u] = &#123;l,r,a[l]&#125;;<br>    <span class="hljs-keyword">else</span>&#123;<br>        node[u] = &#123;l,r&#125;;<br>        <span class="hljs-type">int</span> mid = l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u,l,mid);<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>        <span class="hljs-built_in">pushup</span>(u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(node[u].l &gt;= l &amp;&amp; node[u].r &lt;= r) <span class="hljs-keyword">return</span> node[u].val;<br>    <span class="hljs-type">int</span> mid = node[u].l + node[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(l&lt;=mid) sum = <span class="hljs-built_in">query</span>(<span class="hljs-number">2</span>*u,l,r);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) sum = <span class="hljs-built_in">max</span>(sum,<span class="hljs-built_in">query</span>(<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>,l,r));<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    <br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>        <span class="hljs-comment">// printf(&quot;%d\n&quot;,query(1,x,y));</span><br>        cout&lt;&lt;<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,x,y)&lt;&lt;endl;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>硬件课设</title>
    <link href="/2023/04/02/BJUT/%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/"/>
    <url>/2023/04/02/BJUT/%E7%A1%AC%E4%BB%B6%E8%AF%BE%E8%AE%BE/</url>
    
    <content type="html"><![CDATA[<p>记录硬件课设学习过程 <span id="more"></span></p><h3 id="实验一-pl端设计">实验一 PL端设计</h3><ol type="1"><li>新建工程，编写好.v文件</li><li>Synthesis -&gt; Run Synthesis 检查是否具有语法错误</li><li>新建simulation sources，编写仿真文件</li><li>将仿真文件右键设置为top文件，Simulation -&gt; Run Simulation进行仿真</li><li>I/O Ports 设置引脚</li><li>Program and Debug -&gt; Generate Bitstream 产生字节流</li><li>Open Hardware Manager 将程序烧到电路板</li></ol><h3 id="实验二-ps端设计">实验二 PS端设计</h3><ol type="1"><li><p>新建工程，IP Integrator -&gt; Create Block Design</p></li><li><p>查找zynq，选择第一个</p></li><li><p>双击芯片，添加预配置文件</p></li><li><p>MIO Configuration -&gt; I/O Peripherals -&gt; GPIO -&gt; EMIOGPIO (Width) 打勾，选择引脚数量</p></li><li><p>将GPIO_0 DDR FIXED_IO三个引脚右键Make External引出</p></li><li><p>点击Validate Design 审查是否具有错误</p><figure><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/image-20230402143111433.png"alt="审查错误" /><figcaption aria-hidden="true">审查错误</figcaption></figure></li><li><p>右键IP文件选择Generate Output Product, 点击Generate</p><figure><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230402143328.png"alt="生成输出" /><figcaption aria-hidden="true">生成输出</figcaption></figure></li><li><p>右键IP文件点击Create HDL Wrapper进行封装</p></li><li><p>Run Synthesis</p></li><li><p>Add Source -&gt; Add or create constraints新建约束文件并填写</p></li><li><p>Generate Bitstream</p></li><li><p>File-&gt;Export-&gt;Export Hardware-&gt;Includebitstream</p></li><li><p>Launch SDK</p></li><li><p>在SDK中File-&gt;New-&gt;Application Project-&gt;Next-&gt;emptyProject</p></li><li><p>bsp文件夹/system.mss中有一些测试示例，选择gpiops的ImportExamples</p></li><li><p>修改文件逻辑</p></li><li><p>在Vivado中Open Target 连接电路板</p></li><li><p>在SDK中Run as -&gt; Launch on Hardware(System Debugger)烧到电路板上</p></li></ol><h3 id="实验三-ps-pl已有ip">实验三 PS + PL已有IP</h3><ol type="1"><li><p>同实验二的1~3，然后打开AXI总线并在Interrupts勾选FabricInterrupts,展开后在PL-PS InterruptPorts勾选IRQ_F2P[15:0]开启中断</p></li><li><p>添加另一个IP查找GPIO，添加后双击勾选Enable DualChannel开启双使能通道</p></li><li><p>对于两个GPIO宽度都设置为4(LED和按键都是占4个引脚)</p></li><li><p>勾选Enable Interrupt，点击确定</p></li><li><p>引出DDR FIXED_IO GPIO DPIO2</p></li><li><p>点击页面上方的自动连接将IP和ZYNQ连接起来，然后手动将ZYNQ和IP的中断接口连起来</p></li><li><p>同实验二6~12</p></li><li><p>File-&gt;new-&gt;Board Support Package 全默认即可</p></li><li><p>system.mss中勾选gpio的前两个示例代码</p></li><li><p>同实验二后续</p></li></ol><h3 id="实验四-ps-pl自定义ip">实验四 PS + PL自定义IP</h3><ol type="1"><li><p>新建工程编准备好.v文件</p></li><li><p>Tools-&gt;Create and Package New IP-&gt;Create a new AXI4peripheral-&gt;Edit IP</p></li><li><p>添加资源，将需要封装为IP的文件（记作A）引入进来</p></li><li><p>将文件中的module声明复制到自动产生文件（记作B）的末尾 userlogic处，同时指定端口的连接</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230402200933.png" /></p></li><li><p>在Users to add portshere处添加IP的输入输出，注意reg要改为wire</p></li></ol><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230402200643.png" /></p><ol start="6" type="1"><li><p>在top层两处添加端口</p><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230402201224.png" /></p></li></ol><p><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230402201255.png" /></p><ol start="7" type="1"><li>Run Synthesis</li><li>在Package IP - AXI_SMG-&gt;File Groups页面点击Merge changes fromFile Grops Wizard,在下面一个页面进行同样的操作</li><li>点击最下面Review and Package完成IP打包</li><li>新建项目，IP Integrator-&gt;Create Block Design打开IP设计界面</li><li>在Project-&gt;Project Setting中的IP页面中添加IP的路径</li><li>预配值Zynq，勾选AXI总线（默认已勾选）</li><li>引出DDR FIXED_IO led_out a_g key_in四个引脚，然后点击自动连接</li><li>同实验三后续</li></ol><h3 id="正点原子">正点原子</h3><ol type="1"><li>嵌入式开发流程</li></ol><p><img src= https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230417123616.png width="50%"></p><ol start="2" type="1"><li>GPIO是一个外设，用来对器件的引脚作观测(input)以及控制(output)。</li><li>MIO(MultiuseI/O),将来自PS外设X和静态存储器接口的访问多路复用到PS的引脚上。</li></ol><h3 id="oled">OLED</h3><ol type="1"><li>引脚：<ol type="1"><li><p>SDA:C17</p></li><li><p>SCLK:D15</p></li><li><p>CS:C15</p></li><li><p>GPIO[0]:D16(DC)</p></li><li><p>GPIO[1]:F17(RES)</p></li></ol></li></ol><h3 id="pm2.5">PM2.5</h3><p>TX u4</p><p>RX v4</p><p>GPIO y4</p><h3 id="asr">ASR</h3><p>UART0_TX Y13</p><p>UART0_RX Y14</p><h3 id="顶层">顶层</h3><h4 id="oled-1">OLED</h4><ol type="1"><li><p>SDA:C17</p></li><li><p>SCLK:D15</p></li><li><p>CS:C15</p></li><li><p>GPIO[0]:D16(DC)</p></li><li><p>GPIO[1]:F17(RES)</p></li></ol><h4 id="asr-1">ASR</h4><ol type="1"><li><p>RX:R15</p><p>"小植"：0x01</p><p>“温湿度”：0x32(50)</p><p>"空气"：0x33(51)</p><p>"甲醛"：0x34(52)</p></li></ol><h4 id="pm">PM</h4><ol type="1"><li>RX:W13</li></ol><h4 id="jq">JQ</h4><ol type="1"><li>RX:V14</li></ol><h4 id="tts">TTS</h4><ol type="1"><li>TX:T16</li></ol><h3 id="dht11">DHT11</h3><ol type="1"><li>dht11_data:AB21</li></ol>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程调度</title>
    <link href="/2023/04/01/BJUT/Linux_School/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <url>/2023/04/01/BJUT/Linux_School/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 第二章.进程调度 <span id="more"></span></p><h4 id="进程调度策略">进程调度策略</h4><ol type="1"><li><p>分为普通进程和实时进程，普通进程的优先级动态变化，实时进程的优先级刚开始就设置好并固定。</p></li><li><p>普通进程采用动态优先级策略，SCHED_OTHER;实时进程采用SCHED_FIFO或者SCHED_RR</p></li><li><p>如果一个进程是实时进程，则其子孙进程也是实时进程</p></li></ol><h4 id="进程调度依据">进程调度依据</h4><ol type="1"><li>依据weight值选择最大的运行<ol type="1"><li>对于普通进程，weight值首先赋值为剩余的时钟数，若上次也是在当前CPU上运行的则weight增加一个常量，若不需要切换内存则weight再加1，然后还受人为控制的nice的影响(weight+=20-nice)</li><li>对于实时进程，weight=1000+rt_priority</li></ol></li><li>在一个单独时期里，每个进程有一个指定时间片，用完就会被抢占，没用完可以多次调度运行</li><li>所有进程用完其时间片，一个时期才结束</li><li>创建新进程时，子进程继承父进程的一半剩余时间片。子进程结束运行时，剩余时间片也将归还给父进程</li></ol><h3 id="进程调度时机">进程调度时机</h3><p>分为被动调度和主动调度</p><ol type="1"><li><p>被动调度：</p><ol type="1"><li>适用情况<ol type="1"><li>当前进程用完CPU时间片</li><li>一个进程被唤醒且优先级高于当前进程</li></ol></li><li>调度时机<ol type="1"><li>调用sched_setscheduler()或sched_yield()系统调用时</li><li>进程用户态进程前</li><li>系统调用执行结束，控制由核心态返回用户态前</li></ol></li></ol></li><li><p>主动调度</p><p>当进程所需资源无法满足而必须立即阻塞时，直接调度schedule()</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搜索与图论</title>
    <link href="/2023/03/30/Algorithm/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
    <url>/2023/03/30/Algorithm/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>树、图 <span id="more"></span></p><h3 id="dfs回溯">DFS(回溯)</h3><p>深度优先搜索，和回溯同模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> select[])</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(满足某条件)&#123;<br>        result.<span class="hljs-built_in">push_back</span>(a);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:select[])&#123;<br>        做出选择;<br>        <span class="hljs-built_in">DFS</span>(a,select);<br>        撤销选择;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓扑排序">拓扑排序</h3><p>本质为宽搜，通过结点的入度判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,M=N*<span class="hljs-number">2</span>;<br><br><span class="hljs-type">int</span> h[N],e[M],ne[M],idx;<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">int</span> n,m;<br>vector&lt;<span class="hljs-type">int</span>&gt;res;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">add</span>(a,b);<br>        d[b] ++;<br>    &#125;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(d[i] == <span class="hljs-number">0</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(i);<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br>            <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=h[t];j!=<span class="hljs-number">-1</span>;j=ne[j])&#123;<br>                <span class="hljs-type">int</span> k = e[j];<br>                d[k]--;<br>                <span class="hljs-keyword">if</span>(d[k] == <span class="hljs-number">0</span>)&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(k);<br>                    q.<span class="hljs-built_in">push</span>(k);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()!=n) cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : res)&#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/image-20230331164952535.png"alt="最短路算法" /><figcaption aria-hidden="true">最短路算法</figcaption></figure><h3 id="dijkstra">Dijkstra</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> st[N];<br><br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;cnt&lt;n<span class="hljs-number">-1</span>;cnt++)&#123;<br><span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!st[i] &amp;&amp; (t == <span class="hljs-number">-1</span> || d[t]&gt;d[i])) t = i;<br>&#125;<br>st[t] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>    d[j] = <span class="hljs-built_in">min</span>(d[j],d[t] + g[t][j]);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">if</span>(d[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> d[n]; <br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>g[a][b] = <span class="hljs-built_in">min</span>(g[a][b],c);<br>&#125;<br><br>cout&lt;&lt;<span class="hljs-built_in">dijkstra</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化的dijkstra">堆优化的Dijkstra</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N],e[N],ne[N],w[N],idx;<br><span class="hljs-type">int</span> st[N];<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; q;<span class="hljs-comment">// 距离并不用于更新，而用于排序</span><br>    <br>q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-keyword">auto</span> mint = q.<span class="hljs-built_in">top</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-type">int</span> t = mint.second;<br>        <span class="hljs-keyword">if</span>(t == n) <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 能快一些</span><br><span class="hljs-keyword">if</span>(st[t]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 可能存在重边</span><br>st[t] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br><span class="hljs-type">int</span> j = e[i];<br><span class="hljs-keyword">if</span>(d[j] &gt; d[t] + w[i]) &#123;<br>d[j] = d[t] + w[i];<br>q.<span class="hljs-built_in">push</span>(&#123;d[j],j&#125;);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(d[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> d[n]; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>e[idx] = b;<br>w[idx] = c;<br>ne[idx] = h[a];<br>h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-built_in">add</span>(a,b,c);<br>&#125;<br><br>cout&lt;&lt;<span class="hljs-built_in">dijkstra</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="belman_fold">belman_fold</h3><p>用于求路径包含不大于k条边且可能包含负权边的单源最短路径</p><p>例题：<ahref="https://ac.nowcoder.com/acm/contest/52244/F?&amp;headNav=acm">F-坐火车_2023年中国高校计算机大赛-团队程序设计天梯赛（GPLT）上海理工大学校内选拔赛（同步赛)(nowcoder.com)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br><span class="hljs-type">int</span> a,b,w;<br><br>&#125;edge[N];<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> d[N],backup[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br><br><span class="hljs-built_in">memcpy</span>(backup,d,<span class="hljs-keyword">sizeof</span> d);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>    <span class="hljs-type">int</span> a = edge[j].a;<br>    <span class="hljs-type">int</span> b = edge[j].b;<br>    <span class="hljs-type">int</span> w = edge[j].w;<br>    <br>d[b] = <span class="hljs-built_in">min</span>(d[b],backup[a] + w);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> d[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>edge[i] = &#123;a,b,c&#125;;<br>&#125;<br><br><span class="hljs-type">int</span> res = <span class="hljs-built_in">bellman_ford</span>();<br><span class="hljs-keyword">if</span>(res &gt; <span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;res;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="spfa">SPFA</h3><p>存在负权边的单源最短路算法，大多数情况下优于dijkstra</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> h[N],w[N],e[N],ne[N],idx;<br><span class="hljs-type">int</span> d[N],used[N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>e[idx] = b;<br>w[idx] = c;<br>ne[idx] = h[a];<br>h[a] = idx++; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>used[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>used[t] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br><span class="hljs-type">int</span> j = e[i];<br><span class="hljs-keyword">if</span>(d[j] &gt; d[t] + w[i])&#123;<br>d[j] = d[t] + w[i];<br><span class="hljs-keyword">if</span>(!used[j])&#123;<br>q.<span class="hljs-built_in">push</span>(j); <br>used[j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> d[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-built_in">add</span>(a,b,c);<br>&#125;<br><br><span class="hljs-built_in">spfa</span>();<br><span class="hljs-keyword">if</span>(d[n] &gt; <span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;d[n];<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="spfa判断负环">SPFA判断负环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> h[N],w[N],e[N],ne[N],idx;<br><span class="hljs-type">int</span> d[N],used[N],cnt[N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<br>e[idx] = b;<br>w[idx] = c;<br>ne[idx] = h[a];<br>h[a] = idx++; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">// 不一定从1开始，要全加进去</span><br>    used[i] = <span class="hljs-number">1</span>;<br>    q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>used[t] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br><span class="hljs-type">int</span> j = e[i];<br><span class="hljs-keyword">if</span>(d[j] &gt; d[t] + w[i])&#123;<br>d[j] = d[t] + w[i];<br>cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 如果边数为n，则有n+1个点，则必有一个点经过了两次，则必存在负环（若正环则不会走）</span><br><span class="hljs-keyword">if</span>(cnt[j]&gt;=n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(!used[j])&#123;<br>q.<span class="hljs-built_in">push</span>(j); <br>used[j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-built_in">add</span>(a,b,c);<br>&#125;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>()) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="floyd">Floyd</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> g[N][N];<br><br><span class="hljs-type">int</span> n,m,k;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                g[i][j] = <span class="hljs-built_in">min</span>(g[i][j],g[i][k] + g[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(i==j) g[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> g[i][j] = INF;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b],c);<br>    &#125;<br>    <br>    <span class="hljs-built_in">floyd</span>();<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(g[a][b] &gt; <span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;g[a][b]&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="prim">Prim</h3><p>求最小生成树</p><p>注意不事先将1号点放进去所以要特判多处i=0的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> d[N],used[N];<br><br><br><span class="hljs-type">int</span> n,m;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!used[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || d[t] &gt; d[j])) t = j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &amp;&amp; d[t] == INF) <span class="hljs-keyword">return</span> INF;<br>        <br>        <span class="hljs-keyword">if</span>(i) res += d[t];<br>        used[t] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>            <span class="hljs-keyword">if</span>(!used[k])&#123;<br>                d[k] = <span class="hljs-built_in">min</span>(d[k],g[t][k]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b] = g[b][a] = <span class="hljs-built_in">min</span>(g[a][b],c);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">prim</span>();<br>    <span class="hljs-keyword">if</span>(res == INF) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="kruskal">Kruskal</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> p[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>    <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Edge &amp;e)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> w &lt; e.w;<br>    &#125;<br>&#125;edge[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,res=<span class="hljs-number">0</span>;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        edge[i] = &#123;a,b,c&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(edge,edge+m);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        p[i] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a = edge[i].a;<br>        <span class="hljs-type">int</span> b = edge[i].b;<br>        <span class="hljs-type">int</span> w = edge[i].w;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a) != <span class="hljs-built_in">find</span>(b))&#123;<br>            res += w;<br>            p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>            cnt++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(cnt != n<span class="hljs-number">-1</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程管理</title>
    <link href="/2023/03/30/BJUT/Linux_School/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2023/03/30/BJUT/Linux_School/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Linux课程笔记 第三章.进程管理 <span id="more"></span></p><h4 id="进程的类别">进程的类别</h4><ol type="1"><li><p>TASK_RUNNING: 正在运行/就绪</p></li><li><p>TASK_TRACED: 供调试使用</p></li><li><p>TASK_INTERRUPTIBLE: 可被信号或中断唤醒进入就绪队列（）</p></li><li><p>TASK_UNINTERRUPTIBLE：等待资源不可被其他进程中断，例如在等待打印机资源，则在获得之前不可进入就绪状态</p></li><li><p>TASK_STOPPED: 被调试暂停，或收到SIGSTOP信号</p></li><li><p>TASK_ZOMBIE:正在终止（已经释放内存、文件等资源，但是父进程还未收到通知，描述符未释放）</p></li><li><p>TASK_DEAD:已退出且不需要父进程回收的进程的状态</p></li></ol><p><img src=https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/image-20230330143205241.png width="80%"></p><h4 id="进程的系统堆栈">进程的系统堆栈</h4><ol type="1"><li><p>Linux2.4的PCB于所属进程的内核堆栈放在一起，为每个进程分配8KB大小的内存区域。</p></li><li><p>进程描述符task_struct位于8k低端，内核堆栈位于8k高端</p></li></ol><p><img src=https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/image-20230331205455782.png width="80%"></p><ol start="3" type="1"><li>操作系统可以使用current宏通过esp指针获得PCB的指针，具体方式为将低13位清零得到起始空间地址</li></ol><p>current = (struct task_struct*) STACK_POINTE &amp; 0xFFFE000</p><h4 id="进程的链表结构">进程的链表结构</h4><ol type="1"><li><p>Linux进程通过双向链表连接。</p></li><li><p>对于TASK_RUNNING状态的进程，引入运行队列(runningqueue)，使用list_head实现，本质为双链表</p></li><li><p>对于非TASK_RUNNING状态的进程，引入等待队列，其可以细分很多种分别维护，本质为双循环链表</p></li><li><p>为了快速定位进程，以PID为关键字建立了哈希表，可以通过PID快速找到进程</p></li></ol><h4 id="进程控制">进程控制</h4><ol type="1"><li><p>sys_fork() sys_vfork() sys_clone()均可创建新进程</p></li><li><p>对于sys_fork()，除了代码段外父子进程不共享任何东西</p></li><li><p>对于sys_clone(),有选择地对父进程进行赋值，如果不提供标志则和fork()一样。</p></li><li><p>对于sys_vfork(),子进程能够共享父进程的内存地址空间，使用复制指针的方法使子进程与父进程资源实现共享。父进程在子进程运行时会被堵塞，保证子进程先运行。出现COW后就基本不再用了。</p></li><li><p>wait()wait_pid()用于检测子进程是否终止。如果子进程仍在运行则父进程堵塞，如果子进程终止则返回子进程的终止状态，如果没有子进程则出错返回</p></li><li><p>exit()释放大部分进程占用的资源，终止进程。进程进入ZOMBIE状态后内核调用exit_notify()通知父进程调用wait()判断子进程状态并通过release()回收子进程的task_struct，#### 进程与线程</p></li><li><p>进程是资源分配的基本单位，线程是处理器调度的独立单位，但是在Linux中弱化了这样的关系，不明确区分进程线程。</p></li><li><p>Linux认为线程是一组共享资源的进程</p></li><li><p>clone()可以创建内核支持的用户线程，对内核可见且由内核调度</p></li><li><p>pthread_create()由基于POSIX标准的线程库创建的用户线程</p></li><li><p>对于多线程进程，组内所有线程的tgid都相等且等于父进程的pid</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法中的数学</title>
    <link href="/2023/03/22/Algorithm/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    <url>/2023/03/22/Algorithm/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>算法竞赛中常用的数学知识 <span id="more"></span></p><h3 id="判断质数">判断质数</h3><p>若d能够整除n，则<spanclass="math inline">\(\frac{n}{d}\)</span>也能整除n，因此只需要枚举到<spanclass="math inline">\(d\leq\frac{n}{d}\)</span>即可，时间复杂度<spanclass="math inline">\(O(\sqrt{n})\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_Prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=x/i;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分解质因数">分解质因数</h3><p>定义：不考虑排列顺序的情况下，每个正整数都能够以唯一的方式表示成它的质因数的乘积。<span class="math inline">\(n=p_1^{a_1} * p_2^{a_2}*p_3^{a_3}.....p_n^{a_n}\)</span></p><p>其中<span class="math inline">\(p_i\)</span>为质数</p><p>大于根号n的质因数最多只有一个，因为如果有两个，他们的乘积就大于n了。因此只需要判断到x/i即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<span class="hljs-comment">// 满足此条件的一定是质数</span><br>        &#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, s ++ ;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="埃筛质数">埃筛质数</h3><p>思路为从前往后枚举，将所有当前值的倍数筛掉即可，时间复杂度约为<spanclass="math inline">\(O(n)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> used[N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!used[i])&#123;<br>            cnt++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+i;j&lt;=n;j+=i)&#123;<br>                used[j] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125; <br>    &#125;    <br>    <br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin&gt;&gt;n;<br>    cout&lt;&lt;<span class="hljs-built_in">work</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线性筛质数">线性筛质数</h3><p>没懂，比埃筛效率高</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求所有约数">求所有约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=x/i;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span>(i!=x/i) res.<span class="hljs-built_in">push_back</span>(x/i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求约数个数约数之和">求约数个数&amp;约数之和</h3><p>假设$x=p_1<sup>{<em>{1}}p_2^{</em>{2}}...p_n</sup>{_{n}} $,则</p><p>约数个数为<spanclass="math inline">\((\alpha_1+1)(\alpha_2+1)...(\alpha_n+1)\)</span>，因为每个约数都可以表示为<spanclass="math inline">\(p_1^{\beta_{1}}p_2^{\beta_{2}}...p_n^{\beta_{n}}\)</span>,则所有个数即为所有<spanclass="math inline">\(\beta\)</span>的组合数</p><p>约数之和为<spanclass="math inline">\((P_1^0+P_1^1+...P_1^{\alpha_1})(P_2^0+P_2^1+...P_2^{\alpha_2})...(P_n^0+P_n^1+...P_n^{\alpha_n})\)</span>，因为这些展开即是上述的各个组合</p><p><a href="https://www.acwing.com/problem/content/872/">870. 约数个数 -AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; primes;<br><br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                x /= i;<br>                primes[i] ++ ;<br>            &#125;<br><br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) primes[x] ++ ;<br>    &#125;<br><br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : primes) res = res * (p.second + <span class="hljs-number">1</span>) % mod;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/873/">871. 约数之和 -AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;primes;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=x/i;i++)&#123;<br>            <span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>)&#123;<br>                x/=i;<br>                primes[i]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) primes[x]++;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:primes)&#123;<br>        <span class="hljs-type">int</span> a = t.first;<br>        <span class="hljs-type">int</span> b = t.second;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> temp = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(b--) temp = (a*temp+<span class="hljs-number">1</span>)%mod;<br>        res = res*temp%mod;<br>    &#125;<br>    <br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大公约数">最大公约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最小公倍数">最小公倍数</h3><p>在#include&lt;algorithm&gt;后可以使用__gcd(a,b)求最小公倍数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a*b/<span class="hljs-built_in">gcd</span>(a,b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="欧拉函数">欧拉函数</h3><p><span class="math inline">\(1-N\)</span>中与<spanclass="math inline">\(N\)</span>互质的数的个数称为欧拉函数</p><p>若<spanclass="math inline">\(N=P_1^{a_1}P_2^{a_2}...P_m^{a_m}\)</span>,则<spanclass="math inline">\(f(N)=N*\frac{p_1-1}{p1}*\frac{p_2-1}{p2}*...*\frac{p_m-1}{pm}\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res = res / i * (i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) res = res / x * (x - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>筛法求欧拉函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">int</span> euler[N];           <span class="hljs-comment">// 存储每个数的欧拉函数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_eulers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    euler[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            primes[cnt ++ ] = i;<br>            euler[i] = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> t = primes[j] * i;<br>            st[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>)<br>            &#123;<br>                euler[t] = euler[i] * primes[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            euler[t] = euler[i] * (primes[j] - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速幂">快速幂</h3><p>求 m^k mod p，时间复杂度 O(logk)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(k)&#123;<br>        <span class="hljs-keyword">if</span>(k&amp;<span class="hljs-number">1</span>)&#123;<br>            res = (LL) res*a%p;<br>        &#125;<br>        k&gt;&gt;=<span class="hljs-number">1</span>;<br>        a=(LL)a*a%p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求组合数">求组合数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j ++ )<br>            <span class="hljs-keyword">if</span> (!j) c[i][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % mod;<br></code></pre></td></tr></table></figure><h3 id="龟速乘">龟速乘</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LL <span class="hljs-title">qadd</span><span class="hljs-params">(LL a, LL b, LL p)</span></span>&#123;<br>    LL res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res = (res+a)%p;<br>        a = (a+a) % p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯题集</title>
    <link href="/2023/03/22/Algorithm/LanQiao/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E9%9B%86/"/>
    <url>/2023/03/22/Algorithm/LanQiao/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>蓝桥杯好题 <span id="more"></span></p><h3 id="回溯">回溯</h3><p><ahref="https://www.acwing.com/activity/content/problem/content/1551/">1209带分数</a></p><h3 id="卡尔可夫链式问题">卡尔可夫链式问题</h3><h5 id="砖块---acwing题库"><ahref="https://www.acwing.com/problem/content/3780/">3777. 砖块 -AcWing题库</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string s;<br><span class="hljs-type">int</span> n,t;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(string &amp;temp, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(temp[x] == <span class="hljs-string">&#x27;W&#x27;</span>) temp[x] = <span class="hljs-string">&#x27;B&#x27;</span>;<br>    <span class="hljs-keyword">else</span> temp[x] = <span class="hljs-string">&#x27;W&#x27;</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;<br>    string temp = s;<br>    vector&lt;<span class="hljs-type">int</span>&gt;res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(temp[i] != c)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">update</span>(temp,i);<br>            <span class="hljs-built_in">update</span>(temp,i+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(temp[n<span class="hljs-number">-1</span>] != c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    cout&lt;&lt;res.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!res.<span class="hljs-built_in">empty</span>())&#123;<br>        cout&lt;&lt;res.<span class="hljs-built_in">back</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        res.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        cin&gt;&gt;n;<br>        cin&gt;&gt;s;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">check</span>(<span class="hljs-string">&#x27;W&#x27;</span>) &amp;&amp; !<span class="hljs-built_in">check</span>(<span class="hljs-string">&#x27;B&#x27;</span>)) cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="费解的开关---acwing题库"><ahref="https://www.acwing.com/problem/content/97/">95. 费解的开关 -AcWing题库</a></h5><h5 id="翻硬币---acwing题库"><ahref="https://www.acwing.com/problem/content/1210/">1208. 翻硬币 -AcWing题库</a></h5><h3 id="博弈论">博弈论</h3><p><ahref="https://www.lanqiao.cn/problems/2061/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;difficulty=30&amp;tags=2022">灭鼠先锋</a></p><h3 id="前缀和">前缀和</h3><p><ahref="https://www.lanqiao.cn/problems/2109/learning/?page=2&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;difficulty=30&amp;tags=2022">统计子矩阵</a></p><p>70</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">510</span>][<span class="hljs-number">510</span>],s[<span class="hljs-number">510</span>][<span class="hljs-number">510</span>];<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            s[i][j] = s[i<span class="hljs-number">-1</span>][j] + s[i][j<span class="hljs-number">-1</span>] - s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;x++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;y&lt;=m;y++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y;j&lt;=m;j++)&#123;<br>                    <span class="hljs-type">int</span> x1 = i - x + <span class="hljs-number">1</span>;<br>                    <span class="hljs-type">int</span> y1 = j - y + <span class="hljs-number">1</span>;<br>                    <span class="hljs-type">int</span> sum = s[i][j] - s[x1<span class="hljs-number">-1</span>][j] - s[i][y1<span class="hljs-number">-1</span>] + s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>];<br>                    <span class="hljs-keyword">if</span>(sum &lt;= k) ans++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>100</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">501</span>;<br><span class="hljs-type">int</span> a[maxn][maxn];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 请在此输入您的代码</span><br><span class="hljs-type">int</span> n,m,k;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i++)<br>&#123;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br> &#123;<br>   cin &gt;&gt; a[i][j];<br>   <span class="hljs-comment">//为了后面计算方便，维护纵向前缀和</span><br>   <span class="hljs-comment">//a[i][j]表示前i行第j列之和</span><br>   a[i][j] += a[i<span class="hljs-number">-1</span>][j];<br> &#125;<br>&#125;<br><span class="hljs-comment">//遍历上边界和下边界</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<span class="hljs-comment">//遍历上边界</span><br>&#123;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ii = i; ii &lt;= n; ii++)<span class="hljs-comment">//遍历下边界</span><br> &#123;<br>   <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1</span>;<span class="hljs-comment">//滑动窗口的左右端点</span><br>   <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-comment">//区间前缀和：[l,r]区间的累计和</span><br>   <span class="hljs-keyword">for</span>(r = <span class="hljs-number">1</span>; r &lt;= m; r++)<span class="hljs-comment">//遍历右端点，根据区间和调整左端点</span><br>   &#123;<br>     sum += a[ii][r] - a[i<span class="hljs-number">-1</span>][r];<span class="hljs-comment">//加上右端点处的和</span><br>     <span class="hljs-keyword">while</span>(sum &gt; k)<span class="hljs-comment">//区间和了，左端点右移，区间变小</span><br>     &#123;<br>       sum -= a[ii][l] - a[i<span class="hljs-number">-1</span>][l];<span class="hljs-comment">//减去移出去的左端点处的和</span><br>       l++;<br>     &#125;<br>     ans += r - l + <span class="hljs-number">1</span>;<span class="hljs-comment">//方法数就是找到的区间大小累加</span><br>   &#125;<br> &#125;<br>&#125;<br>cout &lt;&lt; ans &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分应用">二分应用</h3><p><ahref="https://www.acwing.com/problem/content/description/732/">730.机器人跳跃问题 - AcWing题库</a></p><h3 id="空间换时间">空间换时间</h3><p><a href="https://www.acwing.com/problem/content/1223/">1221. 四平方和- AcWing题库</a></p><h3 id="填空">填空</h3><p><ahref="https://www.lanqiao.cn/problems/598/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tags=2022,省赛">冒泡排序次数</a></p><p><ahref="https://www.lanqiao.cn/problems/597/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tags=2022,省赛">跑步锻炼</a></p><p><ahref="https://www.lanqiao.cn/problems/1463/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tags=2022,省赛">货物摆放</a></p><p><ahref="https://www.lanqiao.cn/problems/646/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tags=2022,省赛">等差素数列</a></p><h3 id="动态规划">动态规划</h3><p><a href="https://www.acwing.com/problem/content/1214/">1212. 地宫取宝- AcWing题库</a></p><h3 id="深搜">深搜</h3><p><ahref="https://www.lanqiao.cn/problems/506/learning/?problem_list_id=1&amp;page=1&amp;sort=students_count">作物杂交- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2010</span>;<br><br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q[N];<br><span class="hljs-type">int</span> w[N],have[N],f[N];<br><span class="hljs-type">int</span> n,m,k,t;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;q[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-type">int</span> need1 = q[u][i].first;<br>    <span class="hljs-type">int</span> need2 = q[u][i].second;<br>    <span class="hljs-keyword">if</span>(!have[need1]) <span class="hljs-built_in">dfs</span>(need1);<br>    <span class="hljs-keyword">if</span>(!have[need2]) <span class="hljs-built_in">dfs</span>(need2);<br>    <span class="hljs-keyword">if</span>(have[need1] &amp;&amp; have[need2])&#123;<br>      have[u] = <span class="hljs-number">1</span>;<br>      f[u] = <span class="hljs-built_in">min</span>(f[u],<span class="hljs-built_in">max</span>(f[need1],f[need2]) + <span class="hljs-built_in">max</span>(w[need1], w[need2]));<br>      <span class="hljs-comment">// return f[u];</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> f[u];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> f);<br>  cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;t;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<br>    cin&gt;&gt;w[i];<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>    <span class="hljs-type">int</span> x;<br>    cin&gt;&gt;x;<br>    have[x] = <span class="hljs-number">1</span>;<br>    f[x] = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>    <span class="hljs-type">int</span> a,b,c;<br>    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>    q[c].<span class="hljs-built_in">push_back</span>(&#123;a,b&#125;);<br>  &#125;<br><br>  cout&lt;&lt;<span class="hljs-built_in">dfs</span>(t);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图论">图论</h3><p><a href="https://www.acwing.com/problem/content/1490/">1488. 最短距离- AcWing题库</a></p><h3 id="模拟">模拟</h3><p><a href="https://www.acwing.com/problem/content/3212/">3209. 集合竞价- AcWing题库</a></p><h3 id="暴力">暴力</h3><p><ahref="https://www.acwing.com/problem/content/description/1207/">1205.买不到的数目 - AcWing题库</a></p><p><a href="https://www.acwing.com/problem/content/1212/">1210.连号区间数 - AcWing题库</a></p>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯小知识</title>
    <link href="/2023/03/20/Algorithm/LanQiao/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/03/20/Algorithm/LanQiao/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>总结蓝桥杯常见的小考点 <span id="more"></span></p><h3 id="判断闰年">判断闰年</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(x%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;x%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span> || x%<span class="hljs-number">400</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="蛇形数组">蛇形数组</h3><p>注意算a[20,20]要满足j&gt;=20 &amp;&amp; i-j+1 &gt;=20,i要算到40多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">300</span>][<span class="hljs-number">300</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> reverse = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">50</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(reverse)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++) &#123;<br>                a[j][i - j + <span class="hljs-number">1</span>] = cnt++;<br>                cout&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;i-j+<span class="hljs-number">1</span>&lt;&lt;endl;<br>            &#125;<br>            reverse = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++) &#123;<br>                a[i - j + <span class="hljs-number">1</span>][j] = cnt++;<br>                cout&lt;&lt;i-j+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;endl;<br>            &#125;<br>            reverse = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;a[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用unordered_map">使用unordered_map</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tr1/unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tr1/unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::tr1;<br></code></pre></td></tr></table></figure><h3 id="判断两个日期之间的回文日期">判断两个日期之间的回文日期</h3><p>蓝桥杯的日期很多都是直接遍历两个int类型之间，判断int是否有效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> months[<span class="hljs-number">13</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> date)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> year = date / <span class="hljs-number">10000</span>;<br>    <span class="hljs-type">int</span> month = date % <span class="hljs-number">10000</span> / <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> day = date % <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">if</span> (!month || month &gt;= <span class="hljs-number">13</span> || !day) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (month != <span class="hljs-number">2</span> &amp;&amp; day &gt; months[month]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (month == <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-type">bool</span> leap = year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> || year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (day &gt; <span class="hljs-number">28</span> + leap) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> date1, date2;<br>    cin &gt;&gt; date1 &gt;&gt; date2;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> x = i, r = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j ++ ) r = r * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>, x /= <span class="hljs-number">10</span>;<br><br>        <span class="hljs-keyword">if</span> (r &gt;= date1 &amp;&amp; r &lt;= date2 &amp;&amp; <span class="hljs-built_in">check</span>(r)) res ++ ;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遍历ab之间所有日期">遍历AB之间所有日期</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> months[<span class="hljs-number">15</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check_year</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;x%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span> || x%<span class="hljs-number">400</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    string sx = <span class="hljs-built_in">to_string</span>(x);<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=sx.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=j)&#123;<br>        <span class="hljs-keyword">if</span>(sx[i]!=sx[j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        i++;j--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> cur)</span></span>&#123;<br>    <span class="hljs-type">int</span> year = cur / <span class="hljs-number">10000</span>;<br>    <span class="hljs-type">int</span> month = (cur / <span class="hljs-number">100</span>) % <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> day = cur % <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">if</span>(month == <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check_year</span>(year)) months[<span class="hljs-number">2</span>] = <span class="hljs-number">29</span>;<br>        <span class="hljs-keyword">else</span> months[<span class="hljs-number">2</span>] = <span class="hljs-number">28</span>;<br>    &#125; <br>    <br>    <span class="hljs-keyword">if</span>(day+<span class="hljs-number">1</span>&lt;=months[month]) cur++;<br>    <span class="hljs-keyword">else</span>&#123;<br>        day = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(month+<span class="hljs-number">1</span>&lt;=<span class="hljs-number">12</span>) cur = year * <span class="hljs-number">10000</span> + (month+<span class="hljs-number">1</span>) * <span class="hljs-number">100</span> + day;<br>        <span class="hljs-keyword">else</span>&#123;<br>            month = <span class="hljs-number">1</span>;<br>            cur = (year+<span class="hljs-number">1</span>)*<span class="hljs-number">10000</span> + month * <span class="hljs-number">100</span> + day;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&lt;=m;i=<span class="hljs-built_in">update</span>(i))&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(i)) res++;<br>    &#125;<br>    <br>    cout&lt;&lt;res;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长上升子序列">最长上升子序列</h3><p>新建一个 low 数组，low [ i]表示长度为i的LIS结尾元素的最小值。对于一个上升子序列，显然其结尾元素越小，越有利于在后面接其他的元素，也就越可能变得更长。因此，我们只需要维护low 数组，对于每一个a[ i ]，如果a[ i ] &gt; low[当前最长的LIS长度]，就把 a [ i ]接到当前最长的LIS后面，即low[++当前最长的LIS长度] = a [ i ]。 那么，怎么维护 low 数组呢？对于每一个a [ i ]，如果a [ i ]能接到 LIS 后面，就接上去；否则，就用 a [i ] 取更新 low 数组。具体方法是，在low数组中找到第一个大于等于a [ i]的元素low [ j ]，用a [ i ]去更新 low [ j ]。如果从头到尾扫一遍 low数组的话，时间复杂度仍是O(n^2)。我们注意到 low数组内部一定是单调不降的，所有我们可以二分 low数组，找出第一个大于等于a[ i ]的元素。二分一次 low数组的时间复杂度的O(lgn)，所以总的时间复杂度是O(nlogn)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span>  </span><br>  <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-type">int</span> num[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>&#125;;  <br>  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;  <br><span class="hljs-type">int</span> l=<span class="hljs-number">10</span>, g[<span class="hljs-number">100</span>], d[<span class="hljs-number">100</span>];  <br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-built_in">fill</span>(g, g+l, INF);  <br>    <span class="hljs-type">int</span> max_=<span class="hljs-number">-1</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;l; i++)  <br>    &#123;  <br>        <span class="hljs-type">int</span> j = <span class="hljs-built_in">lower_bound</span>(g, g+l, num[i]) - g;  <br>        d[i] = j+<span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span>(max_&lt;d[i])  <br>            max_=d[i];  <br>        g[j] = num[i];  <br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, max_);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125; <br><br></code></pre></td></tr></table></figure><h3 id="异或">异或</h3><p>必要异或运算性质： 归零律：a⊕a三0 结合律：a⊕b⊕c=a⊕(b⊕c)=(a⊕b)⊕c交换律：a⊕b=b⊕a 因此，a⊕b=x→a⊕b⊕x=0→a⊕x=b因此对于一个数a,与a配对的数可以直接计算得出，即为a⊕c</p>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSP 重点</title>
    <link href="/2023/03/14/Algorithm/CCF-CSP/CSP-%E9%87%8D%E7%82%B9/"/>
    <url>/2023/03/14/Algorithm/CCF-CSP/CSP-%E9%87%8D%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 重要题目 <span id="more"></span></p><h3 id="买菜---acwing题库"><ahref="https://www.acwing.com/problem/content/3266/">3263. 买菜 -AcWing题库</a></h3><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230528104827.png" style="zoom: 80%;" /></p><p>两组区间求相交的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2010</span>;<br><br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; a[N],b[N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;p,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p.second &lt; q.first || q.second &lt; p.first) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(p.second,q.second) - <span class="hljs-built_in">max</span>(p.first,q.first);<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i].first&gt;&gt;a[i].second;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;b[i].first&gt;&gt;b[i].second;<br>    &#125;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            sum += <span class="hljs-built_in">get</span>(a[i],b[j]);<br>        &#125;<br>    &#125;<br><br>    cout&lt;&lt;sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出行计划---acwing题库">[4455. 出行计划 - AcWing题库</h3><p><a href="https://www.acwing.com/problem/content/4458/"></a></p><p><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230528104748.png" style="zoom:67%;" /></p><p>很隐蔽的差分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,k;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> t,c;<br>        cin&gt;&gt;t&gt;&gt;c;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,t-k-c+<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> r = t-k;<br>        <span class="hljs-keyword">if</span>(r &gt; <span class="hljs-number">0</span>)&#123;<br>            a[l]++;<br>            a[r+<span class="hljs-number">1</span>]--;<br>        &#125;<br>    <br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++) a[i] = a[i] + a[i<span class="hljs-number">-1</span>];<br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        cout&lt;&lt;a[x]&lt;&lt;endl;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="化学方程式---acwing题库"><ahref="https://www.acwing.com/problem/content/description/3287/">3284.化学方程式 - AcWing题库</a></h3><p>String处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> unordered_map&lt;string, <span class="hljs-type">int</span>&gt; MPSI;<br><br><span class="hljs-function">MPSI <span class="hljs-title">dfs</span><span class="hljs-params">(string&amp; str, <span class="hljs-type">int</span>&amp; u)</span></span><br><span class="hljs-function"></span>&#123;<br>    MPSI res;<br>    <span class="hljs-keyword">while</span> (u &lt; str.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">if</span> (str[u] == <span class="hljs-string">&#x27;(&#x27;</span>)<br>        &#123;<br>            u ++ ;  <span class="hljs-comment">// 过滤掉 &#x27;(&#x27;</span><br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(str, u);<br>            u ++ ;  <span class="hljs-comment">// 过滤掉 &#x27;)&#x27;</span><br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>, k = u;<br>            <span class="hljs-keyword">while</span> (k &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(str[k])) k ++ ;<br>            <span class="hljs-keyword">if</span> (k &gt; u)<br>            &#123;<br>                cnt = <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(u, k - u));<br>                u = k;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: t)<br>                res[c.x] += c.y * cnt;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[u] == <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> k = u + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (k &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; str[k] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; str[k] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) k ++ ;<br>            <span class="hljs-keyword">auto</span> key = str.<span class="hljs-built_in">substr</span>(u, k - u);<br>            u = k;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (k &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(str[k])) k ++ ;<br>            <span class="hljs-keyword">if</span> (k &gt; u)<br>            &#123;<br>                cnt = <span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(u, k - u));<br>                u = k;<br>            &#125;<br>            res[key] += cnt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">MPSI <span class="hljs-title">work</span><span class="hljs-params">(string str)</span></span><br><span class="hljs-function"></span>&#123;<br>    MPSI res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; str[j] != <span class="hljs-string">&#x27;+&#x27;</span>) j ++ ;<br>        <span class="hljs-keyword">auto</span> item = str.<span class="hljs-built_in">substr</span>(i, j - i);<br>        i = j;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (k &lt; item.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(item[k])) k ++ ;<br>        <span class="hljs-keyword">if</span> (k) cnt = <span class="hljs-built_in">stoi</span>(item.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k));<br>        <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(item, k);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: t)<br>            res[c.x] += c.y * cnt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        string str;<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> k = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;=&#x27;</span>);<br>        <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">work</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k)), right = <span class="hljs-built_in">work</span>(str.<span class="hljs-built_in">substr</span>(k + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">if</span> (left == right) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Y&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;N&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/3212/">3209. 集合竞价- AcWing题库</a></p><p>模拟</p><p><ahref="https://www.acwing.com/problem/content/description/3222/">3219.模板生成系统 - AcWing题库</a></p><p>字符串处理</p><h3 id="日期模拟题">日期模拟题</h3><p>现在，给你 a,b,c 和 y1,y2，希望你输出从公元 y1 年到公元 y2年间的每年的 a月的第 b 个星期 c 的日期。已知 18501年 1 月 1日是星期二。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//日期题套路，12个月，开13个位置，第0个为占位符</span><br><span class="hljs-type">int</span> months[<span class="hljs-number">13</span>] = &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span><br>&#125;;<br><br><span class="hljs-comment">//判断某一年是否是闰年的函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">is_leap</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span> || (year % <span class="hljs-number">4</span>  == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//求某月有多少天的函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_days</span><span class="hljs-params">(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(month == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> months[month] + <span class="hljs-built_in">is_leap</span>(year); <span class="hljs-comment">//如果是2月的话返回天数和是否是闰年，如果是闰年2月份+1天</span><br>    <span class="hljs-keyword">return</span> months[month]; <span class="hljs-comment">//不是2月份则直接返回天数即可</span><br>&#125;<br><br><span class="hljs-comment">//星期一到星期日用0~6表示</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b, c, y1, y2;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; y1 &gt;&gt; y2;<br><br>    <span class="hljs-type">int</span> days = <span class="hljs-number">0</span>; <span class="hljs-comment">//表示过了多少天</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> year = <span class="hljs-number">1850</span>; year &lt;= y2; year ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> month = <span class="hljs-number">1</span>; month &lt;= <span class="hljs-number">12</span>; month ++ )<br>        &#123;<br>            <span class="hljs-keyword">if</span>(year &gt;= y1 &amp;&amp; month == a)<br>            &#123;<br>                <span class="hljs-type">int</span> w = (<span class="hljs-number">1</span> + days) % <span class="hljs-number">7</span>; <span class="hljs-comment">//先算一下这个月的1月1号是星期几,1850年1月1日是星期二，下标为1</span><br>                <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">//统计一下当前是枚举到的第几个星期c</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d = <span class="hljs-number">1</span>; d &lt;= <span class="hljs-built_in">get_days</span>(year, month); d ++ ) <span class="hljs-comment">//枚举一下这个月的所有天</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span>(w == c - <span class="hljs-number">1</span>) <span class="hljs-comment">//星期的下标从0开始，所以要-1，如星期七的下标是6</span><br>                    cnt ++ ;<span class="hljs-comment">//星期c的个数++</span><br>                    <span class="hljs-keyword">if</span>(cnt == b) <span class="hljs-comment">//如果星期c的个数等于b的话，满足条件，输出</span><br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d/%02d/%02d\n&quot;</span>, year, month, d);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    w = (w + <span class="hljs-number">1</span>) % <span class="hljs-number">7</span>; <span class="hljs-comment">//每过一天，星期需要往后错一位</span><br>                &#125;<br>                <span class="hljs-keyword">if</span>(cnt &lt; b) <span class="hljs-comment">//枚举完这个月后，如果星期c出现的次数小于b，说明没有第b个星期c，输出none</span><br>                &#123;<br>                    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;none&quot;</span>);<br>                &#125;<br>            &#125;<br>            days += <span class="hljs-built_in">get_days</span>(year, month); <span class="hljs-comment">//这个月过完之后加上这个月过的天数</span><br>        &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSP 20</title>
    <link href="/2023/03/13/Algorithm/CCF-CSP/CSP-20/"/>
    <url>/2023/03/13/Algorithm/CCF-CSP/CSP-20/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 第20届 <span id="more"></span></p><h3 id="称检测点查询"><ahref="https://www.acwing.com/problem/content/3295/">1.称检测点查询</a></h3><p>pair模板的小根堆 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,px,py;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; q;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;px&gt;&gt;py;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-type">int</span> d = (px-x)*(px-x) + (py-y)*(py-y);<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(d,i));<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>        cout&lt;&lt;q.<span class="hljs-built_in">top</span>().second&lt;&lt;endl;<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>c++重载运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,px,py;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> d;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point&amp; t) <span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">if</span>(d!=t.d) <span class="hljs-keyword">return</span> d&lt;t.d;<br>        <span class="hljs-keyword">return</span> id &lt; t.id;<br>    &#125;<br>&#125;q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (px-x)*(px-x) + (py-y)*(py-y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;px&gt;&gt;py;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        q[i] = &#123;x,y,<span class="hljs-built_in">distance</span>(x,y),i+<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(q,q+n);<br>    <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>        cout&lt;&lt;q[i].id&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="风险人群筛查"><ahref="https://www.acwing.com/problem/content/3296/">2.风险人群筛查</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,k,t,xl,yd,xr,yu;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> res[<span class="hljs-number">2</span>];<br>    cin&gt;&gt;n&gt;&gt;k&gt;&gt;t&gt;&gt;xl&gt;&gt;yd&gt;&gt;xr&gt;&gt;yu;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> max_cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;t;j++)&#123;<br>            <span class="hljs-type">int</span> x,y;<br>            cin&gt;&gt;x&gt;&gt;y;<br>            <span class="hljs-keyword">if</span>(x&gt;=xl &amp;&amp; x&lt;=xr &amp;&amp; y&gt;=yd &amp;&amp; y&lt;=yu)&#123;<br>                cnt++;<br>                <span class="hljs-keyword">if</span>(cnt &gt; max_cnt)&#123;<br>                    max_cnt = cnt;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(cnt &gt; max_cnt)&#123;<br>                    max_cnt = cnt;<br>                &#125;<br>                cnt = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(max_cnt) res[<span class="hljs-number">0</span>]++;<br>        <span class="hljs-keyword">if</span>(max_cnt&gt;=k) res[<span class="hljs-number">1</span>]++;<br>    &#125;<br>    <br>    cout&lt;&lt;res[<span class="hljs-number">0</span>]&lt;&lt;endl&lt;&lt;res[<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL,排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSP 22</title>
    <link href="/2023/03/11/Algorithm/CCF-CSP/CSP-22/"/>
    <url>/2023/03/11/Algorithm/CCF-CSP/CSP-22/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 第22届 <span id="more"></span></p><h3 id="灰度直方图"><ahref="https://www.acwing.com/problem/content/3414/">1.灰度直方图</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">256</span>;<br><br><span class="hljs-type">int</span> h[N];<br><span class="hljs-type">int</span> n,m,l;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;l;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            h[x] ++ ;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<br>        cout&lt;&lt;h[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻域均值"><ahref="https://www.acwing.com/problem/content/3415/">2.邻域均值</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">610</span>;<br><span class="hljs-type">int</span> n,l,r,t;<br><span class="hljs-type">int</span> res;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> sum[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;l,&amp;r,&amp;t);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>        &#125;·<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            sum[i][j] = sum[i<span class="hljs-number">-1</span>][j] + sum[i][j<span class="hljs-number">-1</span>] - sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-type">int</span> left,right,top,bottom;<br>            left = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,i-r);<br>            right = <span class="hljs-built_in">min</span>(n,i+r);<br>            top = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,j-r);<br>            bottom = <span class="hljs-built_in">min</span>(n,j+r);<br>            <span class="hljs-type">int</span> nums = (right-left+<span class="hljs-number">1</span>)*(bottom-top+<span class="hljs-number">1</span>);<br>            <span class="hljs-type">float</span> avg = sum[bottom][right] - sum[top<span class="hljs-number">-1</span>][right] - sum[bottom][left<span class="hljs-number">-1</span>] + sum[top<span class="hljs-number">-1</span>][left<span class="hljs-number">-1</span>];<br>            avg /= nums;<br>            <span class="hljs-keyword">if</span>(avg &lt;= t) res++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二维前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSP 23</title>
    <link href="/2023/03/11/Algorithm/CCF-CSP/CSP-23/"/>
    <url>/2023/03/11/Algorithm/CCF-CSP/CSP-23/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 202212 第23届题目 <span id="more"></span></p><h3 id="收集卡牌"><ahref="https://www.acwing.com/problem/content/4012/">4. 收集卡牌</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">17</span>,M = <span class="hljs-number">1</span>&lt;&lt;N;<span class="hljs-comment">// M代表状态数</span><br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">double</span> p[N];<br><span class="hljs-type">double</span> f[M][N*<span class="hljs-number">5</span>+<span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> state,<span class="hljs-type">int</span> coins,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">double</span>&amp; v = f[state][coins];<br>    <span class="hljs-keyword">if</span>(v&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> v;<br>    <span class="hljs-keyword">if</span>(coins &gt;= m*r) <span class="hljs-keyword">return</span> v = <span class="hljs-number">0</span>;<br>    <br>    v = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(state&gt;&gt;i&amp;<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">// 判断第i位是否为1</span><br>            v += p[i]*(<span class="hljs-built_in">dp</span>(state,coins+<span class="hljs-number">1</span>,r) + <span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            v += p[i]*(<span class="hljs-built_in">dp</span>(state | (<span class="hljs-number">1</span>&lt;&lt;i),coins,r<span class="hljs-number">-1</span>) + <span class="hljs-number">1</span>);<span class="hljs-comment">// 把第i位赋值为1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;p[i]);<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.10lf\n&quot;</span>, <span class="hljs-built_in">dp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n));<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制状态表示</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSP 201312</title>
    <link href="/2023/03/08/Algorithm/CCF-CSP/CSP-0/"/>
    <url>/2023/03/08/Algorithm/CCF-CSP/CSP-0/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 201312 第0届题目 <span id="more"></span></p><h3 id="最大的矩形"><ahref="https://www.acwing.com/problem/content/3197/">3.最大的矩形</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;h[i];<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i - l &gt;= <span class="hljs-number">0</span> &amp;&amp; h[i-l] &gt;= h[i]) l++;<br>        <span class="hljs-keyword">while</span>(i+r&lt;n&amp;&amp;h[i+r]&gt;=h[i]) r++;<br>        res = <span class="hljs-built_in">max</span>(res,h[i]*(l+r<span class="hljs-number">-1</span>));<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有趣的数"><ahref="https://www.acwing.com/problem/content/3198/">4. 有趣的数</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// c&#123;n-1&#125;&#123;k&#125;(k-1)(n-k-1)</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> c[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!j) c[i][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> c[i][j] = (c[i<span class="hljs-number">-1</span>][j] + c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) % N;<br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n<span class="hljs-number">-2</span>;i++)&#123;<br>        sum = (sum + c[n<span class="hljs-number">-1</span>][i]*(i<span class="hljs-number">-1</span>)*(n-i<span class="hljs-number">-1</span>))%N;<br>    &#125;<br>    <br>    cout&lt;&lt;sum;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划(中) 线性DP</title>
    <link href="/2023/02/25/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%AD-%E7%BA%BF%E6%80%A7DP/"/>
    <url>/2023/02/25/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%AD-%E7%BA%BF%E6%80%A7DP/</url>
    
    <content type="html"><![CDATA[<p>动态规划中的线性DP</p><span id="more"></span><h3 id="数字三角形">数字三角形</h3><h5 id="自上而下">自上而下</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">1</span>) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + a[i][j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == i) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][j]) + a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">-1e7</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        res = <span class="hljs-built_in">max</span>(res,dp[n][i]);<br>    &#125;<br><br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="自下而上">自下而上</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j],dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]) + a[i][j];<br>        &#125;<br>    &#125;<br><br>    cout&lt;&lt;dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长上升子序列">最长上升子序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(N,<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[i]&gt;a[j]) dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=n;i++) res = <span class="hljs-built_in">max</span>(res,dp[i]);<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSP 27</title>
    <link href="/2023/02/24/Algorithm/CCF-CSP/CSP-27/"/>
    <url>/2023/02/24/Algorithm/CCF-CSP/CSP-27/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 202212 第27届题目 <span id="more"></span></p><h3 id="如此编码">如此编码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N],c[N],l[N],b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    c[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        c[i] = c[i<span class="hljs-number">-1</span>]*a[i];<br>        l[i] = m%c[i];<br>        l[i] = l[i] - l[i<span class="hljs-number">-1</span>];<br>        b[i] = l[i]/c[i<span class="hljs-number">-1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="何以包邮">何以包邮</h3><h5 id="回溯暴搜">回溯暴搜</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">40</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">100000</span>];<br><span class="hljs-type">int</span> res = <span class="hljs-number">1e9</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> sum)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i==n)&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt;=m)&#123;<br>            res = <span class="hljs-built_in">min</span>(res,sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,sum);<br>    <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,sum+a[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dp">DP</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">40</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">100000</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        sum += a[i];<br>    &#125;<br><br>    <span class="hljs-type">int</span> target = sum - m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=target;j&gt;=a[i];j--)&#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-a[i]]+a[i]);<br>        &#125;<br>    &#125;<br><br>    cout&lt;&lt;sum - dp[target];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSP 28</title>
    <link href="/2023/02/24/Algorithm/CCF-CSP/CSP-28/"/>
    <url>/2023/02/24/Algorithm/CCF-CSP/CSP-28/</url>
    
    <content type="html"><![CDATA[<p>CCF CSP 202212 第28届题目 <span id="more"></span></p><h3 id="训练计划"><ahref="http://118.190.20.162/view.page?gpid=T159">2.训练计划</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N],p[N],l[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;p[i];<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">min</span><span class="hljs-params">(m+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]!=<span class="hljs-number">0</span>) min[i] = min[a[i]] + p[a[i]];<br>    &#125;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">max</span>(m+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        max[i] = n - p[i] + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> early = <span class="hljs-number">10</span> - max[i] + <span class="hljs-number">1</span> + l[i];<br>            l[a[i]] = l[a[i]]&gt;early?l[a[i]]:early;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        max[i] -= l[i];<br>        <span class="hljs-keyword">if</span>(max[i]&lt;<span class="hljs-number">0</span>) sign = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cout&lt;&lt;min[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(sign)&#123;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            cout&lt;&lt;max[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CCF CSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常用STL</title>
    <link href="/2023/02/23/Algorithm/%E5%B8%B8%E7%94%A8STL/"/>
    <url>/2023/02/23/Algorithm/%E5%B8%B8%E7%94%A8STL/</url>
    
    <content type="html"><![CDATA[<p>介绍常用的STL <span id="more"></span></p><h3 id="vector">vector</h3><p>变长数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">// 初始化</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(M,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N));<span class="hljs-comment">// 二维vector初始化</span><br>a.<span class="hljs-built_in">size</span>();<br>a.<span class="hljs-built_in">empty</span>();<br>a.<span class="hljs-built_in">front</span>();<br>a.<span class="hljs-built_in">back</span>();<br>a.<span class="hljs-built_in">push_back</span>();<br>a.<span class="hljs-built_in">pop_back</span>();<br><br>vec.<span class="hljs-built_in">erase</span>(a.<span class="hljs-built_in">begin</span>()+i); <span class="hljs-comment">// 删除</span><br></code></pre></td></tr></table></figure><h3 id="pair">pair</h3><p>二元组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br>pair&lt;<span class="hljs-type">int</span>,string&gt; a;<br>a.first; a.second;<br>a = (<span class="hljs-number">20</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>pair&lt;<span class="hljs-type">int</span>,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; b;<span class="hljs-comment">// 三元组</span><br><br><span class="hljs-comment">//按照第一个元素进行排序:</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;a[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;b)</span></span>&#123;<span class="hljs-comment">// 从大到小排序</span><br>    <span class="hljs-keyword">return</span> a.first &gt; b.first;<br>&#125;<br><span class="hljs-built_in">sort</span>(a,a+<span class="hljs-number">10</span>,cmp);<br><span class="hljs-comment">// pair模板的unordered_set</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair_hash</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function">    <span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;T1,T2&gt; <span class="hljs-type">const</span> &amp; pair)</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-type">size_t</span> h1 = <span class="hljs-built_in">hash</span>&lt;T1&gt;()(pair.first);<br>        <span class="hljs-type">size_t</span> h2 = <span class="hljs-built_in">hash</span>&lt;T2&gt;()(pair.second);<br>        <span class="hljs-keyword">return</span> h1^h2;<br>    &#125;<br>&#125;;<br><br>unordered_set&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,pair_hash&gt; pset;<br></code></pre></td></tr></table></figure><h3 id="string">string</h3><p>字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">string a = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>cout&lt;&lt; a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">// &quot;bc&quot; 代表起始下标为1，长度为2的子串</span><br>a.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;cd&quot;</span>) <span class="hljs-comment">// O(n^2)复杂度,如果没找到返回string::npos</span><br>a.<span class="hljs-built_in">replace</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// 将字符串从2开始后面2位替换为空串</span><br><span class="hljs-built_in">stoi</span>(<span class="hljs-string">&quot;123&quot;</span>)<span class="hljs-comment">// string转int</span><br><span class="hljs-built_in">stof</span>(<span class="hljs-string">&quot;1.23&quot;</span>)<span class="hljs-comment">// string转float</span><br><span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">char</span> *ptr = <span class="hljs-built_in">strstr</span>(s,<span class="hljs-string">&quot;cd&quot;</span>);<br>cout&lt;&lt; ptr - s;<span class="hljs-comment">// O(n)复杂度查找子串返回起始位置，需要用#include&lt;cstring&gt;</span><br><span class="hljs-built_in">to_string</span>(<span class="hljs-type">int</span>)<span class="hljs-comment">// int转string</span><br><br></code></pre></td></tr></table></figure><h3 id="queue">queue</h3><p>队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>();<span class="hljs-comment">// 向队尾插入</span><br>q.<span class="hljs-built_in">front</span>();<span class="hljs-comment">// 返回队头元素</span><br>q.<span class="hljs-built_in">back</span>();<span class="hljs-comment">// 返回队尾元素</span><br>q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 弹出对头元素，无返回值</span><br></code></pre></td></tr></table></figure><h3 id="priority_queue">priority_queue</h3><p>优先队列（堆）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">//默认大根堆</span><br><br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap;<span class="hljs-comment">//小根堆定义</span><br><br>q.<span class="hljs-built_in">push</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>q.<span class="hljs-built_in">top</span>();<br><br><span class="hljs-comment">// 使用pair模板</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII<br>priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;<span class="hljs-comment">// 按pair第一个元素排序</span><br>q.<span class="hljs-built_in">push</span>(&#123;d,i&#125;);<span class="hljs-comment">// 插入</span><br><br></code></pre></td></tr></table></figure><p>### deque</p><p>双端队列,效率低，慎用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;<span class="hljs-type">int</span>&gt; d;<br>d.<span class="hljs-built_in">front</span>();<br>d.<span class="hljs-built_in">back</span>();<br>d.<span class="hljs-built_in">push_back</span>();d.<span class="hljs-built_in">pop_back</span>()<br>d.<span class="hljs-built_in">push_front</span>();d.<span class="hljs-built_in">pop_front</span>();<br></code></pre></td></tr></table></figure><h3 id="setmultiset">set/multiset</h3><p>集合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>&gt; s;<br>s.<span class="hljs-built_in">insert</span>();<br>s.<span class="hljs-built_in">find</span>();<br>s.<span class="hljs-built_in">count</span>();<br>s.<span class="hljs-built_in">erase</span>();<span class="hljs-comment">// 删除所有对应的值</span><br>s.<span class="hljs-built_in">lower_bound</span>();<span class="hljs-comment">//大于等于x的最小的数</span><br>s.<span class="hljs-built_in">upper_bound</span>();<span class="hljs-comment">//大于x的最小的数</span><br></code></pre></td></tr></table></figure><h3 id="mapmultimap">map/multimap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">map &lt;string,<span class="hljs-type">int</span>&gt; m;<br>m.<span class="hljs-built_in">insert</span>();<span class="hljs-comment">// 插入的是pair</span><br>a[<span class="hljs-string">&quot;test&quot;</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 插入操作</span><br>m.<span class="hljs-built_in">find</span>();<br>cout&lt;&lt;a[<span class="hljs-string">&quot;test&quot;</span>];<span class="hljs-comment">// 时间复杂度O(logn)</span><br>m.<span class="hljs-built_in">earse</span>();<br></code></pre></td></tr></table></figure><h3id="unordered_setunordered_mapunordermap_multisetunordered_multimap">unordered_set/unordered_map/unordermap_multiset/unordered_multimap</h3><p>和上面操作类似，但是不支持lower_bound()和upper_bound()，但是增插改查时间复杂度为O(1).</p><p>两个同类型之间可以直接判等！</p><h3 id="bitset">bitset</h3><p>压位,每个只占一位。可以认为是bool数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">bitset&lt;10000&gt; s;<br>s.<span class="hljs-built_in">count</span>();<span class="hljs-comment">// 返回有几个1</span><br>s.<span class="hljs-built_in">set</span>(k,v);<span class="hljs-comment">// 将第k位变成v，v的取值[&#x27;true&#x27;,&#x27;false&#x27;]</span><br>s.<span class="hljs-built_in">set</span>();<span class="hljs-comment">// 所有值置1</span><br>s.<span class="hljs-built_in">reset</span>();<span class="hljs-comment">// 所有值置0</span><br>s.<span class="hljs-built_in">flip</span>();<span class="hljs-comment">// 等价于~，全部取反</span><br>s.<span class="hljs-built_in">flip</span>(k);<span class="hljs-comment">// 第k位取反S</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础数据结构实现(下)</title>
    <link href="/2023/02/12/Algorithm/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0(%E4%B8%8B)/"/>
    <url>/2023/02/12/Algorithm/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0(%E4%B8%8B)/</url>
    
    <content type="html"><![CDATA[<p>介绍Trie树、并查集、堆、散列表 <span id="more"></span></p><h3 id="trie树">Trie树</h3><p>用于大量字符串的存储与查找.</p><p>同时也可以存储整数的二进制表示，相关题目见<ahref="https://www.acwing.com/problem/content/145/">143. 最大异或对 -AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">100010</span>][<span class="hljs-number">26</span>];<br><span class="hljs-type">int</span> cnt[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string s)</span></span>&#123;<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(!a[cur][s[i]]) a[cur][s[i]] = ++idx;<br>        cur = a[cur][s[i]];<br>    &#125;<br>    cnt[cur] ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string s)</span></span>&#123;<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(!a[cur][s[i]]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        cur = a[cur][s[i]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[cur];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        string op, st;<br>        cin&gt;&gt;op&gt;&gt;st;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;I&quot;</span>) <span class="hljs-built_in">insert</span>(st);<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-built_in">query</span>(st)&lt;&lt;endl;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并查集">并查集</h3><p>初始有<spanclass="math inline">\(N\)</span>个独立的集合，并查集可以方便的合并集合并且查找任意两个元素是否属于同一集合。</p><p>原题链接：<a href="https://www.acwing.com/problem/content/838/">836.合并集合 - AcWing题库</a></p><p>并查集的思路为对每个集合维护一个树，并记录每个结点的父节点（根节点的父节点为自身）。合并两个元素<spanclass="math inline">\(x、y\)</span>所在的集合即令其中一个集合的根节点的父节点为另一个集合的根节点,即<spanclass="math inline">\(p(find(x)) = find(y)\)</span>.其中<spanclass="math inline">\(find()\)</span>为查找指定节点的父节点。查找两个元素是否属于同一集合即判断是否有<spanclass="math inline">\(p[x] == p[y]\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> p[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<span class="hljs-comment">// 同时完成了查找根节点与路径压缩</span><br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        a[i] = i;<br>    &#125;<br>    <span class="hljs-type">char</span> op;<br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;M&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x) != <span class="hljs-built_in">find</span>(y)) a[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>((y));<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y)) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆">堆</h3><h4 id="stl">STL</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        pq.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cout&lt;&lt;pq.<span class="hljs-built_in">top</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        pq.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="手动实现">手动实现</h4><p>维护一个二叉树，父结点总是比两个子节点大，则根节点即为最大值。所有操作的核心是向上&amp;向下整理。</p><p>数组下标从1开始，则对于结点<spanclass="math inline">\(i\)</span>,左孩子为<spanclass="math inline">\(2*i\)</span>,右孩子为<spanclass="math inline">\(2*i+1\)</span>,父节点为<spanclass="math inline">\(i/2\)</span>.注意判断父子结点是否在合法范围内。</p><h5 id="向下整理">向下整理</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> temp = x;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*x &lt;= n &amp;&amp; a[<span class="hljs-number">2</span>*x] &lt; a[x]) x = <span class="hljs-number">2</span>*x;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span> &lt;= n &amp;&amp; a[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>] &lt; a[x]) x = <span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(temp != x)&#123;<br>        <span class="hljs-built_in">swap</span>(a[x],a[temp]);<br>        <span class="hljs-built_in">down</span>(x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="向上整理">向上整理</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x/<span class="hljs-number">2</span> &amp;&amp; a[x/<span class="hljs-number">2</span>]&gt;a[x])&#123;<br>        <span class="hljs-built_in">swap</span>(a[x],a[x/<span class="hljs-number">2</span>]);<br>        <span class="hljs-built_in">up</span>(x/<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插入一个数">插入一个数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在数组尾部插入，并向上整理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    a[++cnt] = x;<br>    <span class="hljs-built_in">up</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="取出最大值">取出最大值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_max</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-built_in">swap</span>(a[<span class="hljs-number">1</span>],a[cnt--]);<br>    <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> a[cnt+<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈希表">哈希表</h3><p>只实现开放寻址法，拉链法采用头插法链表。</p><p>对于插入操作在1e5数量级的，数组应该开2e5,同时质数遇到的冲突较少，因此设置<spanclass="math inline">\(N\)</span>=2e5+3.其次设置空位标识符<spanclass="math inline">\(null\)</span>=0x3f3f3f3f.这个数大于1e9.</p><h6 id="初始化">初始化</h6><p>memset按字节赋值，因此对每个字节赋值为0x3f.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> a);<br></code></pre></td></tr></table></figure><h6 id="常见操作">常见操作</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> t = ((x%N)+N)%N;<span class="hljs-comment">// 保证结果为正数</span><br><span class="hljs-keyword">while</span>(a[t] != nulll &amp;&amp; a[t] != x)&#123;<br>    t++;<br>    <span class="hljs-keyword">if</span>(t == N) temp = <span class="hljs-number">0</span>;<span class="hljs-comment">// 循环数组</span><br>&#125;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    a[<span class="hljs-built_in">find</span>(x)] = x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a[<span class="hljs-built_in">find</span>(x)] == null) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符哈希">字符哈希</h3><p>对字符串进行哈希.</p><p>文字讲解：<ahref="https://www.acwing.com/blog/content/15289/">【新手向】字符串哈希详解 - AcWing</a></p><p><a href="https://www.acwing.com/problem/content/843/">841. 字符串哈希- AcWing题库</a></p><p>对于长度为<span class="math inline">\(n\)</span>的字符串<spanclass="math inline">\(S\)</span>,对应哈希值为<spanclass="math inline">\((\sum S_i*P^{(n-i)})*Q\)</span>.出于经验，<spanclass="math inline">\(P=131\)</span>,<spanclass="math inline">\(Q=2^{64}\)</span>. 此时采用unsigned long long作为数组可以通过自然溢出实现取模运算。</p><p>初始定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br>ULL h[N]; <span class="hljs-comment">// 存储字符串每个前缀的哈希值 </span><br>ULL p[N]; <span class="hljs-comment">// 存储展开式中的权值 ( p^0, p^1 , p^2, p^3 ... ) </span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>获得字符串的所有前缀编码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++ )&#123;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i]; <span class="hljs-comment">// 计算字符串每个 前缀 的哈希值 </span><br>    p[i] = p[i - <span class="hljs-number">1</span>] * P; <span class="hljs-comment">// 计算展开式中的各个权值 ( p^0, p^1 , p^2, p^3 ... ) </span><br> &#125;<br></code></pre></td></tr></table></figure><p>则区间[l,r]对应的字符串哈希值为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l<span class="hljs-number">-1</span>]*P[r-l+<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>比较两个字符串是否相等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>( <span class="hljs-built_in">get</span>( l1, r1 ) == <span class="hljs-built_in">get</span>( l2, r2 ) ) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>); <br><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="kmp">KMP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span><br>求模式串的Next数组：<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    ne[i] = j;<br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    <span class="hljs-keyword">if</span> (j == m)<br>    &#123;<br>        j = ne[j];<br>        <span class="hljs-comment">// 匹配成功后的逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础数据结构实现(上)</title>
    <link href="/2023/02/09/Algorithm/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/"/>
    <url>/2023/02/09/Algorithm/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<p>包含数组模拟单项链表、双向链表、栈、队列 <span id="more"></span></p><h3 id="单向链表">单向链表</h3><p><a href="https://www.acwing.com/problem/content/828/">826. 单链表 -AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> e[<span class="hljs-number">100010</span>], ne[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> head,idx;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cin&gt;&gt;n;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        string op;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;H&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            ne[idx] = head;<br>            e[idx] = x;<br>            head = idx++;<br><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;D&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>)&#123;<br>                head = ne[head];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ne[x<span class="hljs-number">-1</span>] = ne[ne[x<span class="hljs-number">-1</span>]];<br>            &#125;<br>            <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;I&quot;</span>)&#123;<br>            cin&gt;&gt;x&gt;&gt;y;<br>            e[idx] = y;<br>            ne[idx] = ne[x<span class="hljs-number">-1</span>];<br>            ne[x<span class="hljs-number">-1</span>] = idx;<br>            idx++;<br>        &#125;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head;i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        cout&lt;&lt;e[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双向链表">双向链表</h3><p><a href="https://www.acwing.com/problem/content/829/">827. 双链表 -AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> e[N], ne[N], pe[N];<br><span class="hljs-type">int</span> head,tail,idx;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_left</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    e[idx] = x;<br>    ne[idx] = head;<br>    pe[idx] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-number">-1</span>)&#123;<br>        head = tail = idx;<br>        idx++;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        pe[head] = idx;<br>        head = idx++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_right</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    e[idx] = x;<br>    pe[idx] = tail;<br>    ne[idx] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(tail==<span class="hljs-number">-1</span>)&#123;<br>        head = tail = idx;<br>        idx++;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        ne[tail] = idx;<br>        tail = idx++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    head = tail = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        string op;<br>        <span class="hljs-type">int</span> x,k;<br>        <br>        cin&gt;&gt;op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;L&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">insert_left</span>(x);<br>            <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;R&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">insert_right</span>(x);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;D&quot;</span>)&#123;<br>            cin&gt;&gt;k;<br>            <span class="hljs-keyword">if</span>(k==head) head=ne[head];<br>            <span class="hljs-keyword">if</span>(k==tail) tail=pe[tail];<br>            ne[pe[k]] = ne[k];<br>            pe[ne[k]] = pe[k];<br>            <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;IL&quot;</span>)&#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-keyword">if</span>(k==head) <span class="hljs-built_in">insert_left</span>(x);<br>            <span class="hljs-keyword">else</span>&#123;<br>                e[idx] = x;<br>                pe[idx] = pe[k];<br>                ne[idx] = k;<br>                ne[pe[k]] = idx;<br>                pe[k] = idx++;   <br>            &#125;<br>            <br>            <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;IR&quot;</span>)&#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-keyword">if</span>(k==tail) <span class="hljs-built_in">insert_right</span>(x);<br>            <span class="hljs-keyword">else</span>&#123;<br>                e[idx] = x;<br>                ne[idx] = ne[k];<br>                pe[idx] = k;<br>                pe[ne[k]] = idx;<br>                ne[k] = idx++;<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head;i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        cout&lt;&lt;e[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈">栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> top = <span class="hljs-number">-1</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    cin&gt;&gt;m;<br>    string s;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;s;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;push&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            a[++top] = x;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;pop&quot;</span>)&#123;<br>            top--;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;empty&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(top == <span class="hljs-number">-1</span>) cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;query&quot;</span>)&#123;<br>            cout&lt;&lt;a[top]&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="队列">队列</h3><p>注意数组中左边的是head，右边的是tail。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> head = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tail = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    cin&gt;&gt;m;<br>    string s;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;s;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;push&quot;</span>)&#123;<br>            cin&gt;&gt;x;<br>            a[tail++] = x;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;pop&quot;</span>)&#123;<br>            head++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;empty&quot;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head == tail) cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;query&quot;</span>)&#123;<br>            cout&lt;&lt;a[head<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单调栈">单调栈</h3><p>给定长度为N的整数数列，输出每个数左边第一个比他小的数，若不存在则输出-1</p><p>原题链接：<a href="https://www.acwing.com/problem/content/832/">830.单调栈 - AcWing题库</a></p><p>思路：常规思路为从第i个数向前遍历找到第一个更小的数。但对于a[i]与a[i-1],若a[i-1]&gt;a[i],则a[i-1]永远不可能作为i及以后数的答案，因此可以维护一个栈，若将进栈元素小于栈顶元素，则将栈顶元素出栈。最后得到的栈为值单调上升栈，第i个数的答案即为当前栈的栈顶元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n;<br>    stack&lt;<span class="hljs-type">int</span>&gt;st;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>()) st.<span class="hljs-built_in">push</span>(x),cout&lt;&lt;<span class="hljs-string">&quot;-1 &quot;</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() &gt;= x) st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>()) cout&lt;&lt;<span class="hljs-string">&quot;-1 &quot;</span>;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;st.<span class="hljs-built_in">top</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            st.<span class="hljs-built_in">push</span>(x);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口">滑动窗口</h3><p>给定长度为n的数组和窗口长度k，步长为1，求每个窗口的最大值与最小值。</p><p>原题链接：<ahref="https://www.acwing.com/problem/content/description/156/">154.滑动窗口 - AcWing题库</a></p><p>思路：常规思路为遍历窗口内所有数找出最大最小值。以最小值为例，滑动窗口思路为若a[i]&lt;a[i-1]，则a[i-1]不可能作为答案输出，因此维护一个双端均可出队的队列，若即将入队元素小于队尾元素，则将队尾元素舍去，即在队列中保证单调递增。同时为了去除离开窗口的元素，令上述队列存储元素下标，若队尾元素下标小于i-k+1则对应元素已离开窗口，舍弃即可。每个窗口的答案即为队尾元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> a[M];<br>deque&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">front</span>() &lt;= i-k) q.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>() &amp;&amp; a[q.<span class="hljs-built_in">back</span>()] &gt;= a[i]) q.<span class="hljs-built_in">pop_back</span>();<br>        q.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout&lt;&lt;a[q.<span class="hljs-built_in">front</span>()]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>    q.<span class="hljs-built_in">clear</span>();<br>    cout&lt;&lt;endl;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">front</span>() &lt;= i-k) q.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>() &amp;&amp; a[q.<span class="hljs-built_in">back</span>()] &lt;= a[i]) q.<span class="hljs-built_in">pop_back</span>();<br>        q.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout&lt;&lt;a[q.<span class="hljs-built_in">front</span>()]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法基础课题集</title>
    <link href="/2023/02/04/Algorithm/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E9%A2%98%E9%9B%86/"/>
    <url>/2023/02/04/Algorithm/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>Acwing算法基础课中不熟练题目 <span id="more"></span></p><h3 id="两个数组的目标和">两个数组的目标和</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/802/">800.数组元素的目标和 - AcWing题库</a></p><p>思路：对于双指针要找到两个指针单调的方向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],b[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,x;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) cin&gt;&gt;b[i];<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=m<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]+b[j]==x)&#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;j;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]+b[j]&gt;x) j--;<br>        <span class="hljs-keyword">else</span> i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="离散化">离散化</h3><p>原题链接：<ahref="https://www.acwing.com/problem/content/description/804/">802.区间和 - AcWing题库</a></p><p>思路：将大范围(-1e9~1e9)但是稀疏(只有1e5的数字非0)的向量进行压缩.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> a[N],s[N];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; add;<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; query;<br>vector&lt;<span class="hljs-type">int</span>&gt; all_index;<span class="hljs-comment">// 存储所有需要占据索引的操作（某位置加、两点之间的和），注意需要排序+去重</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">// 二分查找离散化前的值x在离散化后的索引</span><br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=all_index.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> mid = l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(all_index[mid]&gt;=x) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> x,c;<br>        cin&gt;&gt;x&gt;&gt;c;<br>        add.<span class="hljs-built_in">push_back</span>(&#123;x,c&#125;);<br>        all_index.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin&gt;&gt;l&gt;&gt;r;<br>        query.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>        all_index.<span class="hljs-built_in">push_back</span>(l);<br>        all_index.<span class="hljs-built_in">push_back</span>(r);<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(all_index.<span class="hljs-built_in">begin</span>(), all_index.<span class="hljs-built_in">end</span>());<br>    all_index.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(all_index.<span class="hljs-built_in">begin</span>(), all_index.<span class="hljs-built_in">end</span>()), all_index.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : add)&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(i.first);<br>        a[x] += i.second;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=all_index.<span class="hljs-built_in">size</span>();i++) s[i] = s[i<span class="hljs-number">-1</span>] + a[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : query)&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">find</span>(i.first);<br>        <span class="hljs-type">int</span> r = <span class="hljs-built_in">find</span>(i.second);<br>        cout&lt;&lt;s[r] - s[l<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="走迷宫bfs">走迷宫(BFS)</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/846/">844.走迷宫 - AcWing题库</a></p><h5 id="做法1">做法1</h5><p>个人做法,采用哈希集合存储已途径的点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> a[N][N];<br><br># unordered_set不能以pair作为模板，需要自己定义相关规则<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair_hash</span><br>&#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(pair&lt;T1, T2&gt; <span class="hljs-type">const</span> &amp;pair)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">size_t</span> h1 = <span class="hljs-built_in">hash</span>&lt;T1&gt;()(pair.first); <span class="hljs-comment">//用默认的 hash 处理 pair 中的第一个数据 X1</span><br>        <span class="hljs-type">size_t</span> h2 = <span class="hljs-built_in">hash</span>&lt;T2&gt;()(pair.second);<span class="hljs-comment">//用默认的 hash 处理 pair 中的第二个数据 X2</span><br>        <span class="hljs-keyword">return</span> h1 ^ h2;<br>    &#125;<br>&#125;;<br># 定义方式<br>unordered_set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, pair_hash&gt; map;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>    q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        ans++;<br>        <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br>            <span class="hljs-keyword">auto</span> temp = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> x = temp.first;<br>            <span class="hljs-type">int</span> y = temp.second;<br>            <span class="hljs-keyword">if</span>(x == n - <span class="hljs-number">1</span> &amp;&amp; y == m - <span class="hljs-number">1</span>) cout&lt;&lt;ans;<br>            <span class="hljs-keyword">if</span>(x+<span class="hljs-number">1</span>&lt;n &amp;&amp; !a[x+<span class="hljs-number">1</span>][y] &amp;&amp; !map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x+<span class="hljs-number">1</span>,y)))&#123;<br>                q.<span class="hljs-built_in">emplace</span>(x+<span class="hljs-number">1</span>,y);<br>                map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x+<span class="hljs-number">1</span>,y));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(x<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; !a[x<span class="hljs-number">-1</span>][y] &amp;&amp; !map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x<span class="hljs-number">-1</span>,y)))&#123;<br>                q.<span class="hljs-built_in">emplace</span>(x<span class="hljs-number">-1</span>,y);<br>                map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x<span class="hljs-number">-1</span>,y));<br><br>            &#125;<br>            <span class="hljs-keyword">if</span>(y+<span class="hljs-number">1</span>&lt;m &amp;&amp; !a[x][y+<span class="hljs-number">1</span>] &amp;&amp; !map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x,y+<span class="hljs-number">1</span>)))&#123;<br>                q.<span class="hljs-built_in">emplace</span>(x,y+<span class="hljs-number">1</span>);<br>                map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x,y+<span class="hljs-number">1</span>));<br><br>            &#125;<br>            <span class="hljs-keyword">if</span>(y<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; !a[x][y<span class="hljs-number">-1</span>] &amp;&amp; !map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x,y<span class="hljs-number">-1</span>)))&#123;<br>                q.<span class="hljs-built_in">emplace</span>(x,y<span class="hljs-number">-1</span>);<br>                map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(x,y<span class="hljs-number">-1</span>));<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化做法如下,适用于所有在二维空间进行移动的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>    q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        ans++;<br>        <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br>            <span class="hljs-keyword">auto</span> temp = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> x = temp.first;<br>            <span class="hljs-type">int</span> y = temp.second;<br>            <span class="hljs-keyword">if</span>(x == n - <span class="hljs-number">1</span> &amp;&amp; y == m - <span class="hljs-number">1</span>) cout&lt;&lt;ans;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;u&lt;<span class="hljs-number">4</span>;u++)&#123;<br>                <span class="hljs-type">int</span> xx = x+dx[u];<br>                <span class="hljs-type">int</span> yy = y+dy[u];<br>                <span class="hljs-keyword">if</span>(xx&lt;n&amp;&amp;xx&gt;=<span class="hljs-number">0</span>&amp;&amp;yy&lt;m&amp;&amp;yy&gt;=<span class="hljs-number">0</span>&amp;&amp;!a[xx][yy]&amp;&amp;!map.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(xx,yy)))&#123;<br>                    q.<span class="hljs-built_in">emplace</span>(xx,yy);<br>                    map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(xx,yy));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="做法2">做法2</h5><p>采用d数组记录到达每个点的最短距离，核心思路和做法1相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>    q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br>            <span class="hljs-keyword">auto</span> temp = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> x = temp.first;<br>            <span class="hljs-type">int</span> y = temp.second;<br>            <span class="hljs-keyword">if</span>(x == n - <span class="hljs-number">1</span> &amp;&amp; y == m - <span class="hljs-number">1</span>) cout&lt;&lt;d[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;<span class="hljs-number">4</span>;u++)&#123;<br>            <span class="hljs-type">int</span> xx = x+dx[u];<br>                <span class="hljs-type">int</span> yy = y+dy[u];<br>                <span class="hljs-keyword">if</span>(xx&lt;n&amp;&amp;xx&gt;=<span class="hljs-number">0</span>&amp;&amp;yy&lt;m&amp;&amp;yy&gt;=<span class="hljs-number">0</span>&amp;&amp;!a[xx][yy]&amp;&amp;!d[xx][yy])&#123;<br>                    q.<span class="hljs-built_in">emplace</span>(xx,yy);<br>                    d[xx][yy] = d[x][y] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列">最长公共子序列</h3><p>给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B的子序列的字符串长度最长是多少。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">char</span> a[N],b[N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;a+<span class="hljs-number">1</span>&gt;&gt;b+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>            <span class="hljs-keyword">if</span>(a[i] == b[j])&#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><p><ahref="https://www.acwing.com/activity/content/problem/content/884/">AcWing143. 最大异或对 - AcWing</a></p><p><ahref="https://www.acwing.com/activity/content/problem/content/885/">AcWing836. 合并集合 - AcWing</a></p><p><ahref="https://www.acwing.com/activity/content/problem/content/907/">AcWing844. 走迷宫 - AcWing</a></p><p><a href="https://www.acwing.com/problem/content/97/">95. 费解的开关 -AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br>vector&lt;string&gt; vs;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>    vs[i][j] = vs[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>?<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>) vs[i<span class="hljs-number">-1</span>][j] = vs[i<span class="hljs-number">-1</span>][j] == <span class="hljs-string">&#x27;0&#x27;</span>?<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>) vs[i][j<span class="hljs-number">-1</span>] = vs[i][j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;0&#x27;</span>?<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;<span class="hljs-number">5</span>) vs[i+<span class="hljs-number">1</span>][j] = vs[i+<span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;0&#x27;</span>?<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;<span class="hljs-number">5</span>) vs[i][j+<span class="hljs-number">1</span>] =  vs[i][j+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0&#x27;</span>?<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        vs.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            string s;<br>            cin&gt;&gt;s;<br>            vs.<span class="hljs-built_in">push_back</span>(s);<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1e9</span>;<br>        <br>        vector&lt;string&gt;temp = vs;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> op=<span class="hljs-number">0</span>;op&lt;<span class="hljs-number">32</span>;op++)&#123;<br>            vs = temp;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(op&gt;&gt;i&amp;<span class="hljs-number">1</span>)&#123;<br>                    cnt++;<br>                    <span class="hljs-built_in">change</span>(<span class="hljs-number">0</span>,i);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">5</span>;j++)&#123;<br>                    <span class="hljs-keyword">if</span>(vs[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                        <span class="hljs-built_in">change</span>(i+<span class="hljs-number">1</span>,j);<br>                        cnt++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-type">int</span> vaild = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(vs[<span class="hljs-number">4</span>][i] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                    vaild = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(vaild &amp;&amp; cnt&lt;=<span class="hljs-number">6</span>) res = <span class="hljs-built_in">min</span>(res,cnt);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(res==<span class="hljs-number">1e9</span>) cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;res&lt;&lt;endl;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><ahref="https://www.acwing.com/problem/content/description/732/">730.机器人跳跃问题 - AcWing题库</a></p><p>注意边界问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> max_height;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x)</span></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> temp = x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        temp = <span class="hljs-number">2</span>*temp - a[i];<br>        <span class="hljs-keyword">if</span>(temp&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(temp &gt; max_height) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )&#123;<br>        cin&gt;&gt;a[i];<br>        max_height = <span class="hljs-built_in">max</span>(max_height, a[i]);<br>    &#125;<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> l=<span class="hljs-number">0</span>,r=max_height;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    cout&lt;&lt;l;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2023/02/03/Algorithm/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <url>/2023/02/03/Algorithm/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>前缀和与差分</p><span id="more"></span><h3 id="一维前缀和">一维前缀和</h3><p>主要作用：可以快速求出大量[l,r]之间所有数的和。注意两个数组都是从1开始。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i] = b[i<span class="hljs-number">-1</span>] +a[i];<br>cout&lt;&lt;b[r] - b[l<span class="hljs-number">-1</span>];<span class="hljs-comment">// 输出[l,r]之间所有数的和</span><br></code></pre></td></tr></table></figure><h3 id="二维前缀和">二维前缀和</h3><p>作用同一维前缀和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            s[i][j] = s[i<span class="hljs-number">-1</span>][j] + s[i][j<span class="hljs-number">-1</span>] - s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];<span class="hljs-comment">// 计算前缀和</span><br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[x2][y2] - s[x1<span class="hljs-number">-1</span>][y2] - s[x2][y1<span class="hljs-number">-1</span>] + s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]);<span class="hljs-comment">// 计算矩形内所有数的和</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="一维差分">一维差分</h3><p>主要作用:对于在[l,r]区间内所有数加上c这类题目较快.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> m,n;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i] = a[i] - a[i<span class="hljs-number">-1</span>];<span class="hljs-comment">// 求差分</span><br><span class="hljs-keyword">while</span>(m--)&#123;<br>    <span class="hljs-type">int</span> l,r,c;<br>    cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>    b[r+<span class="hljs-number">1</span>] -= c;<br>    b[l] += c;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) a[i] = a[i<span class="hljs-number">-1</span>] + b[i]; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br></code></pre></td></tr></table></figure><h3 id="二维差分">二维差分</h3><p>作用同上.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> a[N][N],b[N][N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span>&#123;<span class="hljs-comment">//插入的规则,用图辅助理解</span><br>    b[x1][y1] += c;<br>    b[x1][y2+<span class="hljs-number">1</span>] -=c;<br>    b[x2+<span class="hljs-number">1</span>][y1] -=c;<br>    b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] +=c;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,q;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">insert</span>(i,j,i,j,a[i][j]);<span class="hljs-comment">//相当于对每个1*1的矩阵插入一个数</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2,c;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;<br>        <span class="hljs-built_in">insert</span>(x1,y1,x2,y2,c);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            a[i][j] = a[i<span class="hljs-number">-1</span>][j] + a[i][j<span class="hljs-number">-1</span>] - a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + b[i][j];<span class="hljs-comment">// 求前缀和</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/4458/">4455. 出行计划- AcWing题库</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高精度计算</title>
    <link href="/2023/02/03/Algorithm/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/"/>
    <url>/2023/02/03/Algorithm/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>高精度加法、减法、乘法、除法 <span id="more"></span></p><h3 id="高精度加法">高精度加法</h3><p>基本思路和列竖式相同，对于两个大数，使用string读入，在vector中倒排。对于两个vector的加法有c[i]= a[i] + b[i] +t.其中t是上一位的进位。计算完毕后，若t为1说明最高位有进位，再补上一个1即可。在输出时要记得反相输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span>(i &lt; a.<span class="hljs-built_in">size</span>() || i &lt; b.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>()) t += a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>()) t += b[i];<br>        result.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) result.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-type">int</span>&gt;aa,bb;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) aa.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//记得字符转化为对应数字要-&#x27;0&#x27;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) bb.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">add</span>(a,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>();i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        cout&lt;&lt;c[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度减法">高精度减法</h3><p>思路和高精度加法类似，以string读入，用vector倒排。对于减法，有c[i] =(a[i] - b[i] - t + 10) %10.在读数据时要注意判断a和b的大小。如果b大于a则需要先print出'-'然后再输b-a的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()!=b.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &gt; b.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-type">int</span> i=a,<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]!=b[i])&#123;<br>            <span class="hljs-keyword">return</span> a[i] &gt; b[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;result;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++)&#123;<br>        t = a[i] - t;<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>()) t = t - b[i];<br>        result.<span class="hljs-built_in">push_back</span>((t+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(result.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; result.back == <span class="hljs-number">0</span>) result.<span class="hljs-built_in">pop_back</span>();<br>   <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt;aa,bb;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) aa.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//记得字符转化为对应数字要-&#x27;0&#x27;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) bb.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">compare</span>(a,b))&#123;<br>        <span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">sub</span>(a,b);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-built_in">print</span>(c[i]);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>        <span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">sub</span>(b,a);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-built_in">print</span>(c[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="高精度乘法">高精度乘法</h3><p>对于大数A和小数b，结果的第i位可表示为c[i] =(a[i]<em>b+t)/10,其中t为第i-1位的进位。对第i+1位的进位t=(a[i]</em>b+t)%10.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>() || t;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>()) t = t + a[i]*b;<br>        result.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(result.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; result.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) result.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度除法">高精度除法</h3><p>思路可以正着做，记余数为r，则c[i] = (r*10+a[i])/b,r=r%b.为了在输入输出方面和加减乘保持一致，除法在形式上也采用倒排。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;r)</span></span>&#123;<br>    r = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt;result;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        r = r*<span class="hljs-number">10</span>+a[i];<br>        result.<span class="hljs-built_in">push_back</span>(r/b)<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(),result.<span class="hljs-built_in">end</span>());<br>   <span class="hljs-keyword">while</span>(result.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; result.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) result.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分算法</title>
    <link href="/2023/01/15/Algorithm/%E4%BA%8C%E5%88%86/"/>
    <url>/2023/01/15/Algorithm/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>整数二分、浮点数二分及例题 <span id="more"></span></p><h3 id="整数二分">整数二分</h3><p>整数二分有两种情况，取决于check()函数的逻辑。</p><p>第一种情况，假设check()函数判断的是“右侧是否满足”，则如果满足，说明mid处于右侧区间，则边界点应处于[l,mid]，因此更新r=mid；如果不满足，说明mid处于左侧区间且mid点本身并不是边界点，则边界点应处于(mid+1,r],因此更新l= mid + 1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<span class="hljs-comment">// 以整个数列为例</span><br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>    <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>&#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但考虑如下情况：若l = r - 1,此时mid = (l + r) &gt;&gt; 1 = (2l + 1)&gt;&gt; 1 =l,若此时check()返回true，执行l=mid，会导致l、r均未得到更新，程序陷入死循环，因此此时应赋值mid= (l + r + 1) &gt;&gt; 1.</p><p><strong>简便记法</strong>：出现mid - 1 的时候使用该情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例题</strong>：<ahref="https://www.acwing.com/problem/content/description/791/">789.数的范围 - AcWing题库</a></p><h3 id="浮点数二分">浮点数二分</h3><p>和整数二分类似，但无需考虑mid的取整问题。其中的eps代表精度，经验来看若题目要求保留n位小数则eps精度为n+2即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-type">double</span> l,<span class="hljs-type">double</span> r)</span></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br>    <span class="hljs-keyword">while</span>(r-l&gt;eps)&#123;<br>        <span class="hljs-type">double</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例题</strong>：<ahref="https://www.acwing.com/problem/content/792/">790. 数的三次方根 -AcWing题库</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2023/01/14/Algorithm/%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/01/14/Algorithm/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>快排、归并排序 <span id="more"></span></p><h3 id="快排">快排</h3><p>维护左右两个指针，左边指针向右走直到遇到大于x的值停下，右边指针向左走直到遇到小于x的值停下，随后两个指针指向的值进行交换。</p><p>快排是不稳定的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> x=q[l],i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i&lt;j)&#123;<br><span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i]&lt;x);<br><span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j]&gt;x);<br><span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(q[i],q[j]);<br>&#125;<br><span class="hljs-built_in">quick_sort</span>(q,l,j);<br><span class="hljs-built_in">quick_sort</span>(q,j+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure><p>先对两侧的子序列排序，再对两个有序子序列进行合并，合并思路为双指针。</p><h4 id="归并排序">归并排序</h4><p>归并排序是稳定的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">merge_sort</span>(q,l,mid);<br><span class="hljs-built_in">merge_sort</span>(q,mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;<br><span class="hljs-keyword">if</span>(q[i]&lt;q[j]) temp[k++] = q[i++];<br><span class="hljs-keyword">else</span> temp[k++] = q[j++];<br>&#125;<br><span class="hljs-keyword">while</span>(i&lt;=mid) temp[k++] = q[i++];<br><span class="hljs-keyword">while</span>(j&lt;=r) temp[k++] = q[j++];<br><span class="hljs-keyword">for</span>(i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++)&#123;<br>q[i] = temp[j];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2023/01/14/BJUT/%E6%9C%8B%E8%BE%88%E7%AD%94%E7%96%91/"/>
    <url>/2023/01/14/BJUT/%E6%9C%8B%E8%BE%88%E7%AD%94%E7%96%91/</url>
    
    <content type="html"><![CDATA[<p>朋辈讲师企业微信答疑 <span id="more"></span> 想必你清楚如何通过if-else 或者switch-case将0-9输出，主要问题在于如何将整数从高到低处理</p><p>如果直接按整数读入，会发现很难从高位到低位获得每个数字，自然很难处理</p><p>但如果是一个字符串，我们似乎就可以通过索引获得0~n的数字</p><p>如果学过c++，string自然是最好的选择，</p><p>如果只是学了c，可以通过下面的代码依次读入每个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> f[<span class="hljs-number">10</span>][<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&quot;ling&quot;</span>,<span class="hljs-string">&quot;yi&quot;</span>,<span class="hljs-string">&quot;er&quot;</span>,<span class="hljs-string">&quot;san&quot;</span>,<span class="hljs-string">&quot;si&quot;</span>,<span class="hljs-string">&quot;wu&quot;</span>,<span class="hljs-string">&quot;liu&quot;</span>,<span class="hljs-string">&quot;qi&quot;</span>,<span class="hljs-string">&quot;ba&quot;</span>,<span class="hljs-string">&quot;jiu&quot;</span>&#125;;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">do</span>&#123;<br>        c = getchar();<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fu&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,f[<span class="hljs-type">int</span>(c-<span class="hljs-string">&#x27;0&#x27;</span>)]);<span class="hljs-comment">// 注意ASCII码到实际整数的转化</span><br>        &#125;<br><br>    &#125;<span class="hljs-keyword">while</span>(c!=<span class="hljs-string">&#x27;\n&#x27;</span>);<br></code></pre></td></tr></table></figure><p>print的东西可以改为if-else或者switch-case，不再赘述了。</p><p>下面给出一个递归解决的方法~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><br><span class="hljs-type">char</span> f[<span class="hljs-number">10</span>][<span class="hljs-number">5</span>] = &#123;<span class="hljs-string">&quot;ling&quot;</span>,<span class="hljs-string">&quot;yi&quot;</span>,<span class="hljs-string">&quot;er&quot;</span>,<span class="hljs-string">&quot;san&quot;</span>,<span class="hljs-string">&quot;si&quot;</span>,<span class="hljs-string">&quot;wu&quot;</span>,<span class="hljs-string">&quot;liu&quot;</span>,<span class="hljs-string">&quot;qi&quot;</span>,<span class="hljs-string">&quot;ba&quot;</span>,<span class="hljs-string">&quot;jiu&quot;</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">high_to_low</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">10</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, f[<span class="hljs-built_in">high_to_low</span>(x/<span class="hljs-number">10</span>)]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> x%<span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fu&quot;</span>);<br>        x = -x;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,f[<span class="hljs-built_in">high_to_low</span>(x)]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>) <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));   <span class="hljs-comment">// 写法有些小问题</span><br>    <span class="hljs-type">int</span> a=<span class="hljs-built_in">rand</span>()%<span class="hljs-number">100</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//随机数字a</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a);<br>    <span class="hljs-type">int</span> d,b,n,i;<span class="hljs-comment">//输入数字b,n      // 没理解错的话n是最大的猜测次数吧，用int存储即可，n[100]代表有100个int</span><br>    d=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;b,&amp;n);    <span class="hljs-comment">// 确定题目是先读入b再读入n吗？</span><br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123; <span class="hljs-comment">// [0,n)是n个数，[0,n]是n+1个数了</span><br>        <span class="hljs-keyword">if</span>(b&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">// 每次读入b都要判断正负，原代码只判断了第一个b的正负</span><br>            <span class="hljs-keyword">if</span> (b &gt; a)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Too big\n&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b &lt; a)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Too small\n&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == a)&#123;   <span class="hljs-comment">//等真的的猜出来再判断输出什么</span><br>                <span class="hljs-keyword">if</span>(d==<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Bingo!\n&quot;</span>); <span class="hljs-comment">// 判等是两个=</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;<span class="hljs-number">1</span>&amp;&amp;d&lt;=<span class="hljs-number">3</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Lucky You!\n&quot;</span>);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d&gt;<span class="hljs-number">3</span>&amp;&amp;d&lt;=n)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Good Guess!\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果最后一次没猜对会先显示too small/big然后显示game over，</span><br>            <span class="hljs-comment">// 这个地方要按照题意，如果只需要输出game over 要把下面的if放在循环的开始</span><br>            <span class="hljs-keyword">if</span>(d&gt;=n)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Game Over\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            d++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Game Over\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10000</span>];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&lt;=m;i++)&#123;<br>        cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;       <span class="hljs-comment">// 获得i这个数的所有约数</span><br>            <span class="hljs-keyword">if</span>(i%j==<span class="hljs-number">0</span>) a[cnt++] = j;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt;j++)&#123;     <span class="hljs-comment">// 把约数都加起来</span><br>            sum += a[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum == i)&#123;       <span class="hljs-comment">// 要是加起来等于i，说明符合条件</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d = &quot;</span>,i);  <span class="hljs-comment">// 先把开头print出来</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt;j++)&#123;     <span class="hljs-comment">// 循环打印约数</span><br>                <span class="hljs-keyword">if</span>(j!=cnt<span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d + &quot;</span>,a[j]);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[j]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><span class="math display">\[d(e^{i\theta })=ie^{i\theta}d\theta=i(cos\theta+isin\theta)d\theta\]</span></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于脑功能连接矩阵的Kendall特征提取实现</title>
    <link href="/2023/01/11/DeepLearning/%E5%9F%BA%E4%BA%8E%E8%84%91%E5%8A%9F%E8%83%BD%E8%BF%9E%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84Kendall%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/01/11/DeepLearning/%E5%9F%BA%E4%BA%8E%E8%84%91%E5%8A%9F%E8%83%BD%E8%BF%9E%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84Kendall%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>基于脑功能连接矩阵的Kendall特征提取实现 <span id="more"></span>原论文如下图所示</p><div data-align="center"><img src="https://gcore.jsdelivr.net/gh/GreaterChen/PhotoBed/20230111170705.png" width="  "></div><p>基本思路为将样本分为患病组和未患病组，对于患病组的每一个样本的每一个特征，将其和未患病组的每一个样本的对应特征进行相减运算，若结果为正则记为一组concordant，若结果为负则记为一组discordant,对于每一个特征，总的concordant数记为nc,总的discordant数记为nd，随后使用abs((nc-nd)/(m*n))代表每一个特征的Kendall系数，用该系数进行排序即可。</p><p>程序最基础的代码结构如下，我们使用上Pearson矩阵上三角展开后（1，6670）的数据当作每个样本的输入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> fc <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6670</span>):<br>nc = <span class="hljs-number">0</span><br>nd = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> file_asd <span class="hljs-keyword">in</span> files_asd:<br>ref = pd.read_csv(file_asd,header=<span class="hljs-literal">False</span>)[fc]<br>        <span class="hljs-keyword">for</span> file_hc <span class="hljs-keyword">in</span> files_hc:<br>        comp = pd.read_csv(file_hc,header=<span class="hljs-literal">False</span>)[fc]<br>        <span class="hljs-keyword">if</span> ref - comp &gt; <span class="hljs-number">0</span>:<br>        nc += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>        nd += <span class="hljs-number">1</span><br>tau[fc] = <span class="hljs-built_in">abs</span>(nc - nd)/(m*n)<br></code></pre></td></tr></table></figure><p>上述代码是对原论文思路的直接实现，逻辑清晰，但是由于大量的IO以及运算，效率十分低下。因此做如下改进：</p><p>为了避免大量重复IO，将所有数据提前读入内存中,后续根据索引直接取数即可,同时为了提高这一步的读取效率，将csv文件改为pkl文件在这一步带来了上千倍的速度提升。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">all_asd_data = []<br>all_hc_data = []<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files_asd:<br>    all_asd_data.append(pd.read_pickle(file))<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files_hc:<br>    all_hc_data.append(pd.read_pickle(file))<br>all_asd_data = pd.DataFrame(np.array(all_asd_data).reshape(<span class="hljs-built_in">len</span>(all_asd_data), -<span class="hljs-number">1</span>))<br>all_hc_data = pd.DataFrame(np.array(all_hc_data).reshape(<span class="hljs-built_in">len</span>(all_hc_data), -<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>即使如此，由于原运算架构采用三层for循环，三层的循环次数分别为6670、306、368，时间复杂度太高，并行度太差，该程序需要<strong>五个多小时</strong>才能完全跑完。后续在并行度上继续改进：</p><p>首先想到对于未患病组可以不逐个计算，取出所有未患病样本的第fc列，将该array直接减去ref的值，随后统计其中大于0的个数加到nc上，小于0的个数加到nd上即可。这样的改进可以让程序在<strong>10分钟</strong>内完成全部运算。</p><p>更进一步的，我们可以不区分fc，对于全部未患病样本all_hc_data，直接减去每一个患病样本（即利用广播机制将（368，6670）减去（1，6670）），随后以列进行统计大于0的数量，得到（1，6670）的数组，直接加到nc数组上即可，nd数组同理操作。这样程序只有一层for循环，在<strong>5秒</strong>内即可完成全部运算，代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(all_asd_data)),desc=<span class="hljs-string">&quot;running&quot;</span>,file=sys.stdout):<br>    ref = <span class="hljs-built_in">list</span>(all_asd_data.iloc[i, :])<br>    bool_res = all_hc_data - ref &gt; <span class="hljs-number">0</span><br>    total_true = np.array(np.<span class="hljs-built_in">sum</span>(bool_res, axis=<span class="hljs-number">0</span>))<br>    nc += total_true<br>    nd += <span class="hljs-built_in">len</span>(all_hc_data) - total_true<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6670</span>):<br>    tau_t = (nc[i] - nd[i])/(m*n)<br>    tau = pd.DataFrame(np.insert(tau.values, <span class="hljs-built_in">len</span>(tau.index), values=[<span class="hljs-built_in">int</span>(i), <span class="hljs-built_in">abs</span>(tau_t)], axis=<span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><p>完整代码如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python">root_path = <span class="hljs-string">&quot;../../raw_data/rois_aal_pkl_pearson_static_expand/&quot;</span><br>files = os.listdir(root_path)<br>files.sort()<br><br>label_temp = pd.read_csv(<span class="hljs-string">&quot;label_674.csv&quot;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> CheckOrder(files, label_temp):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;error&quot;</span>)<br>    exit()<br>label_temp = label_temp.group_1.values<br><br>m = <span class="hljs-built_in">sum</span>(label_temp)  <span class="hljs-comment"># 患病人数</span><br>n = <span class="hljs-built_in">len</span>(label_temp) - m  <span class="hljs-comment"># 未患病人数</span><br><br>files_asd = []<br>files_hc = []<br><span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(label_temp):<br>    <span class="hljs-keyword">if</span> item == <span class="hljs-number">1</span>:<br>        files_asd.append(root_path + files[i])<br>    <span class="hljs-keyword">else</span>:<br>        files_hc.append(root_path + files[i])<br><br><span class="hljs-comment"># 预加载所有数据，避免频繁IO</span><br>all_asd_data = []<br>all_hc_data = []<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files_asd:<br>    all_asd_data.append(pd.read_pickle(file))<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files_hc:<br>    all_hc_data.append(pd.read_pickle(file))<br>all_asd_data = pd.DataFrame(np.array(all_asd_data).reshape(<span class="hljs-built_in">len</span>(all_asd_data), -<span class="hljs-number">1</span>))<br>all_hc_data = pd.DataFrame(np.array(all_hc_data).reshape(<span class="hljs-built_in">len</span>(all_hc_data), -<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(all_asd_data.shape, all_hc_data.shape)<br><br>tau = pd.DataFrame(columns=[<span class="hljs-string">&#x27;ROI&#x27;</span>, <span class="hljs-string">&#x27;tau&#x27;</span>])<br>nc = np.zeros((<span class="hljs-number">6670</span>,), dtype=<span class="hljs-built_in">int</span>)<br>nd = np.zeros((<span class="hljs-number">6670</span>,), dtype=<span class="hljs-built_in">int</span>)<br><br><span class="hljs-comment"># 利用广播机制批量运算</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(all_asd_data)),desc=<span class="hljs-string">&quot;running&quot;</span>,file=sys.stdout):<br>    ref = <span class="hljs-built_in">list</span>(all_asd_data.iloc[i, :])<br>    bool_res = all_hc_data - ref &gt; <span class="hljs-number">0</span><br>    total_true = np.array(np.<span class="hljs-built_in">sum</span>(bool_res, axis=<span class="hljs-number">0</span>))<br>    nc += total_true<br>    nd += <span class="hljs-built_in">len</span>(all_hc_data) - total_true<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6670</span>):<br>    tau_t = (nc[i] - nd[i])/(m*n)<br>    tau = pd.DataFrame(np.insert(tau.values, <span class="hljs-built_in">len</span>(tau.index), values=[<span class="hljs-built_in">int</span>(i), <span class="hljs-built_in">abs</span>(tau_t)], axis=<span class="hljs-number">0</span>))<br><br>tau.columns = [<span class="hljs-string">&#x27;ROI&#x27;</span>, <span class="hljs-string">&#x27;tau&#x27;</span>]<br>tau = tau.sort_values(by=<span class="hljs-string">&#x27;tau&#x27;</span>, ascending=<span class="hljs-literal">False</span>)<br>tau = tau.reset_index(drop=<span class="hljs-literal">True</span>)<br>tau.to_csv(<span class="hljs-string">&quot;sort.csv&quot;</span>,index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微软官方开源工具PowerToys</title>
    <link href="/2023/01/10/Tools/%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7PowerToys/"/>
    <url>/2023/01/10/Tools/%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7PowerToys/</url>
    
    <content type="html"><![CDATA[<p>具有窗口置顶、查看文件被什么进程占用、批量重命名文件、alt+space全盘检索、OCR等实用功能<span id="more"></span></p><p>Github地址：<ahref="https://github.com/microsoft/PowerToys">microsoft/PowerToys:Windows system utilities to maximize productivity (github.com)</a></p><p>所有功能见文末。下面记录一些感兴趣工具的使用方法</p><h4 id="始终置顶">始终置顶</h4><p>​ 快捷键：win+ctrl+T,固定所选的窗口，使其始终位于所有窗口的顶部</p><h4 id="文件locksmith">文件Locksmith</h4><p>​在文件资源管理器中选择一个或多个文件，右键选择<strong>使用此文件的进程</strong>即可展示出所有使用中的进程并提供了结束进程的选项。十分实用！再也不用担心因为进程占用删不掉文件夹。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBed/20230110190258.png"alt="Locksmith" /><figcaption aria-hidden="true">Locksmith</figcaption></figure><h4 id="文件资源管理器加载项">文件资源管理器加载项</h4><p>在文件资源管理器中选择视图中的<strong>预览窗格</strong>，可以在文件资源管理器右侧预览md、pdf、svg等文件格式。</p><p>感觉不如quicklook好，但内嵌在资源管理器中看起来还不错。</p><h4 id="powerrename">PowerRename</h4><p>选定多个文件右键选择PowerRename，会弹出独立窗口，可以使用正则表达式来搜索文件进行批量重命名。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBed/20230110191047.png"alt="PowerRename" /><figcaption aria-hidden="true">PowerRename</figcaption></figure><h4 id="powertoys-run">PowerToys Run</h4><p>按下alt+space进行搜索，似乎有wox团队参加，和wox功能十分类似但看起来更简洁、美观。</p><p>在设置-&gt;隐私和安全性-&gt;搜索Windows中可以选择建立索引的目录范围以及索引存放的位置。</p><p>图中提示警告是因为还没编制完索引，编制完之后便可正常实用。</p><p>但wox支持拼音首字母检索，PowerToys Run似乎并不支持。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBed/20230110191344.png" /></p><h4 id="ocr文本提取器">OCR文本提取器</h4><p>快捷键：win+shift+T</p><p>自动复制到剪切板，很方便。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/GreaterChen/PhotoBed/20230110184744.png"alt="PowerToys" /><figcaption aria-hidden="true">PowerToys</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决批处理程序中文乱码问题</title>
    <link href="/2023/01/07/Tools/%E8%A7%A3%E5%86%B3%E6%89%B9%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/01/07/Tools/%E8%A7%A3%E5%86%B3%E6%89%B9%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>通过修改cmd编码格式解决批处理程序中文乱码问题 <span id="more"></span></p><p>参考链接：<ahref="https://blog.csdn.net/qq_43553082/article/details/125902114?spm=1001.2014.3001.5501">如何修改cmd的编码格式即当前活动代码页编号（比如修改为utf-8、GBK2312）_Interfrog的博客-CSDN博客_cmd编码</a></p>]]></content>
    
    
    <categories>
      
      <category>小知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pake自动化脚本</title>
    <link href="/2023/01/07/Tools/pake%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/"/>
    <url>/2023/01/07/Tools/pake%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>基于rust打包网页应用 <span id="more"></span></p><p>本文使用开源项目工具Pake：<ahref="https://github.com/tw93/Pake">tw93/Pake: 🤱🏻 Simply make any webpage a desktop application using Rust. 🤱🏻 很简单的用 Rust打包网页生成很小的桌面 App (github.com)</a></p><p>在使用前需要先安装VS相关tool以及rust，随后使用npm安装pake包，教程参见上述链接</p><p>下表给出使用命令行安装的常用命令：</p><table><tr><th align="center">参数</th><th align="center">说明</th><th align="center">用法</th></tr><tr><td align="center">url</td><td>打包的网页链接,必须提供</td><td>pake &amp;lt url &amp;gt</td></tr><tr><td align="center">name</td><td>应用名称</td><td>--name &amp;lt value &amp;gt</td></tr><tr><td align="center">icon</td><td>应用图标，支持本地/远程文件,Windows必须为.ico,MacOS必须为.icns,Linux必须为.png</td><td>--icon &amp;lt path &amp;gt</td><p>在本人使用过程中发现必须在nodejs/node_global/node_modules/pake-cli目录下以管理员方式打开才可以使用，十分不便，因此编写批处理程序简化操作。</p><p>在bat中获取管理员权限有多种方法，代码参考链接：<ahref="https://blog.csdn.net/oShuangYue12/article/details/106055253">bat以管理员运行</a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">setlocal<br><span class="hljs-built_in">set</span> uac=~uac_permission_tmp_%random%<br>md <span class="hljs-string">&quot;%SystemRoot%\system32\%uac%&quot;</span> 2&gt;nul<br><span class="hljs-keyword">if</span> %errorlevel%==0 ( rd <span class="hljs-string">&quot;%SystemRoot%\system32\%uac%&quot;</span> &gt;nul 2&gt;nul ) <span class="hljs-keyword">else</span> (<br>    <span class="hljs-built_in">echo</span> <span class="hljs-built_in">set</span> uac = CreateObject^(<span class="hljs-string">&quot;Shell.Application&quot;</span>^)&gt;<span class="hljs-string">&quot;%temp%\%uac%.vbs&quot;</span><br>    <span class="hljs-built_in">echo</span> uac.ShellExecute <span class="hljs-string">&quot;%~s0&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;runas&quot;</span>,1 &gt;&gt;<span class="hljs-string">&quot;%temp%\%uac%.vbs&quot;</span><br>    <span class="hljs-built_in">echo</span> WScript.Quit &gt;&gt;<span class="hljs-string">&quot;%temp%\%uac%.vbs&quot;</span><br>    <span class="hljs-string">&quot;%temp%\%uac%.vbs&quot;</span> /f<br>    del /f /q <span class="hljs-string">&quot;%temp%\%uac%.vbs&quot;</span> &amp; <span class="hljs-built_in">exit</span> )<br>endlocal<br></code></pre></td></tr></table></figure> 随后给出需要的三个参数即可 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /d D:\nodejs\node_global\node_modules\pake-cli<br><span class="hljs-built_in">set</span> /p url=please input the url: <br><span class="hljs-built_in">set</span> /p title=please input the title: <br><span class="hljs-built_in">set</span> /p ico=please input the ico path: <br>pake %url% --name %title% --icon %ico%<br>pause<br></code></pre></td></tr></table></figure></p><p>由于pake-cli文件夹权限较高，未找到直接打开其中msi文件的方法，为了简化安装流程，给出打开文件夹的脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br>start explorer <span class="hljs-string">&quot;D:\nodejs\node_global\node_modules\pake-cli&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo自动化脚本</title>
    <link href="/2023/01/06/Tools/hexo%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/"/>
    <url>/2023/01/06/Tools/hexo%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>Windows一键完成新建博客、提交next更新、启动本地service<span id="more"></span></p><h4 id="新建博客">新建博客</h4><p>创建.bat文件，cd后路径改为blog根目录</p><p><span class="citation" data-cites="echo">@echo</span> off会取消后续命令的显示</p><p>pause会使命令执行完之后不关闭脚本界面，以便查看是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br> <span class="hljs-built_in">cd</span> /d D:\Blog\GreaterChen.github.io\myblog<br> call hexo new <span class="hljs-string">&quot;new post&quot;</span><br> pause<br></code></pre></td></tr></table></figure><h4 id="自动提交">自动提交</h4><p>思路同上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">cd</span> /d  D:\Blog\GreaterChen.github.io\myblog<br>call hexo clean<br>call hexo g<br>call hexo d<br>pause<br></code></pre></td></tr></table></figure><h4 id="启动本地service">启动本地service</h4><p>思路同上 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">cd</span> /d  D:\Blog\GreaterChen.github.io\myblog<br>call hexo s<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Typora下载激活</title>
    <link href="/2023/01/06/Tools/Typore%E4%B8%8B%E8%BD%BD%E6%BF%80%E6%B4%BB/"/>
    <url>/2023/01/06/Tools/Typore%E4%B8%8B%E8%BD%BD%E6%BF%80%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<p>Typora最新版本激活</p><span id="more"></span><h2 id="typora">Typora</h2><ul><li>参考网址：<ahref="https://www.cnblogs.com/hackettt/p/16335288.html">typora下载和破解（仅供学习）- hackettt - 博客园 (cnblogs.com)</a></li></ul><p>​ 评价：版本较低（1.0）</p><ul><li>参考网址：<ahref="https://www.bilibili.com/video/BV1HG4y1171i/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&amp;vd_source=1455a4be36d2913a951945519501ede2">Typora激活，任意版本，最新版也可以，巨简单_哔哩哔哩_bilibili</a></li></ul><p>​ 下载地址：https://wweb.lanzoum.com/iOTy30jxhfxi</p><p>​ 使用方法：把解压出的文件放到typora根目录即可</p><p>​ 评价：任意版本，使用方便</p>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
